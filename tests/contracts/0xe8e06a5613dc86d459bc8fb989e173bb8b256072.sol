{"Declaration.sol":{"content":"// SPDX-License-Identifier: -- ðŸ’° --\n\npragma solidity ^0.7.3;\n\nabstract contract Declaration  {\n\n    string public name = \"Feyorra\";\n    string public symbol = \"FEY\";\n\n    uint256 public decimals = 18;\n    uint256 public totalSupply = 1000000000E18;\n\n    uint256 public constant YEARLY_INTEREST = 410;\n    uint256 public constant MINIMUM_STAKE = 100E18;\n    uint256 public constant SECONDS_IN_DAY = 86400;\n    uint256 public constant MAX_STAKE_DAYS = 1825;\n\n    uint256 public immutable LAUNCH_TIME;\n\n    struct Globals {\n        uint256 stakingId;\n        uint256 currentFeyDay;\n        uint256 totalStakedAmount;\n    }\n\n    struct StakeElement {\n        address userAddress;\n        uint256 stakedAmount;\n        uint256 returnAmount;\n        uint256 interestAmount;\n        uint256 stakedAt;\n        bool isActive;\n    }\n\n    struct SnapShot {\n        uint256 totalSupply;\n        uint256 totalStakedAmount;\n    }\n\n    mapping(address =\u003e uint256) public balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowances;\n\n    mapping(uint256 =\u003e SnapShot) public snapshots;\n    mapping(uint256 =\u003e StakeElement) public stakeList;\n\n    Globals public globals;\n\n    modifier incrementId() {\n        _;\n        globals.stakingId++;\n    }\n\n    constructor() {\n        LAUNCH_TIME = block.timestamp;\n        balances[msg.sender] = totalSupply;\n    }\n}"},"Events.sol":{"content":"// SPDX-License-Identifier: -- ðŸ’° --\n\npragma solidity ^0.7.3;\n\nabstract contract Events  {\n\n    event StakeStart(\n        uint256 indexed _stakingId,\n        address _address,\n        uint256 _amount\n    );\n\n    event StakeEnd(\n        uint256 indexed _stakingId,\n        address _address,\n        uint256 _amount\n    );\n\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value\n    );\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    event ClosedGhostStake(\n        uint256 daysOld,\n        uint256 secondsOld,\n        uint256 stakeId\n    );\n\n    event SnapshotCaptured(\n        uint256 _totalSupply,\n        uint256 _totalStakedAmount,\n        uint64 _snapshotDay\n    );\n}"},"FEYToken.sol":{"content":"// SPDX-License-Identifier: -- ðŸ’° --\n\nimport \u0027./Token.sol\u0027;\n\npragma solidity ^0.7.3;\n\ncontract FEYToken is Token {\n\n    using SafeMath for uint256;\n\n    /**\n        * @notice returns the interest rate by getting the global variable\n        * YEARLY_INTEREST and subtracting the percentage passed.\n        * Lowers the default interest rate as amount staked rises towards the totalSupply.\n        * Used to record the rates for snapshots + to calculate stake interest\n        * @param _percentage any uint256 figure\n        * @return interestRate\n     */\n    function getInterestRateYearly(\n        uint256 _percentage\n    )\n        public\n        pure\n        returns (uint256 interestRate)\n    {\n        return _percentage \u003e 100\n            ? uint256(YEARLY_INTEREST).mul(uint256(10000)).div(_percentage)\n            : YEARLY_INTEREST.mul(100);\n    }\n    \n    /**\n        * @notice a no args function used to get current APY\n        * @dev _precision in getPercent is fixed to 4\n        * @return percentage -- totalStaked on a particular day out of totalSupply\n        * @return interestRateYearly -- APY based on relative size of current total stakes\n     */\n    function getYearlyInterestLatest()\n        public\n        view\n        returns (\n            uint256 percentage,\n            uint256 interestRateYearly\n        )\n    {\n        percentage = getPercent(\n            globals.totalStakedAmount,\n            totalSupply,\n            4\n        );\n\n        interestRateYearly = getInterestRateYearly(\n            percentage\n        );\n    }\n\n    /**\n        * @notice function used to get APY of a specific day\n        * @param _day integer for the target day, starting @ 0\n        * @dev _precision in getPercent is fixed to 4\n        * @return percentage -- totalStaked on a particular day out of totalSupply\n        * @return interestRateYearly -- APY based on relative size of stake\n     */\n    function getYearlyInterestHistorical(\n        uint256 _day\n    )\n        public\n        view\n        returns (\n            uint256 percentage,\n            uint256 interestRateYearly\n        )\n    {\n        SnapShot memory s = snapshots[_day];\n\n        if (s.totalSupply == 0) {\n            return getYearlyInterestLatest();\n        }\n\n        percentage = getPercent(\n            s.totalStakedAmount,\n            s.totalSupply,\n            4\n        );\n\n        interestRateYearly = getInterestRateYearly(\n            percentage\n        );\n    }\n\n    /**\n        * @notice calculates amount of interest earned per second\n        * @param _stakedAmount principal amount\n        * @param _totalStakedAmount summation of principal amount staked by everyone\n        * @param _seconds time spent earning interest on a particular day\n        * _seconds will be passed as the full SECONDS_IN_DAY for full days that we staked\n        * _seconds will be the seconds that have passed by the time getInterest is called on the last day\n        * @dev _precision in getPercent is fixed to 4\n        * @return durationInterestAmt -- totalStaked on a particular day out of totalSupply\n     */\n    function getInterest(\n        uint256 _stakedAmount,\n        uint256 _totalStakedAmount,\n        uint256 _seconds\n    )\n        public\n        view\n        returns (uint256 durationInterestAmt)\n    {\n        uint256 percentage = getPercent(\n            _totalStakedAmount,\n            totalSupply,\n            4\n        );\n\n        uint256 interestRateYearly = getInterestRateYearly(\n            percentage\n        );\n\n        uint256 yearFullAmount = _stakedAmount\n            .mul(interestRateYearly)\n            .div(100);\n\n        uint256 dailyInterestAmt = getPercent(\n            yearFullAmount,\n            31556952,\n            0\n        );\n\n        durationInterestAmt = dailyInterestAmt\n            .mul(_seconds)\n            .div(100);\n    }\n\n    /**\n         * @notice admin function to close a matured stake OBO the staker\n         * @param _stakingId ID of the stake, used as the Key from the stakeList mapping\n         * @dev can only close after all of the seconds of the last day have passed\n      */\n    function closeGhostStake(\n        uint256 _stakingId\n    )\n        external\n        onlyOwner\n    {\n        (uint256 daysOld, uint256 secondsOld) =\n\n        getStakeAge(\n            _stakingId\n        );\n\n        require(\n            daysOld == MAX_STAKE_DAYS \u0026\u0026\n            secondsOld == SECONDS_IN_DAY,\n            \u0027FEYToken: not old enough\u0027\n        );\n\n        _closeStake(\n            stakeList[_stakingId].userAddress,\n            _stakingId\n        );\n\n        emit ClosedGhostStake(\n            daysOld,\n            secondsOld,\n            _stakingId\n        );\n    }\n\n    /**\n        * @notice calculates number of days and remaining seconds on current day that a stake is open\n        * @param _stakingId ID of the stake, used as the Key from the stakeList mapping\n        * @return daysTotal -- number of complete days that the stake has been open\n        * @return secondsToday -- number of seconds the stake has been open on the current day\n     */\n    function getStakeAge(\n        uint256 _stakingId\n    )\n        public\n        view\n        returns (\n            uint256 daysTotal,\n            uint256 secondsToday\n        )\n    {\n        StakeElement memory _stakeElement = stakeList[_stakingId];\n\n        uint256 secondsTotal = getNow()\n            .sub(_stakeElement.stakedAt);\n\n        daysTotal = secondsTotal\n            .div(SECONDS_IN_DAY);\n\n        if (daysTotal \u003e MAX_STAKE_DAYS) {\n\n            daysTotal = MAX_STAKE_DAYS;\n            secondsToday = SECONDS_IN_DAY;\n\n        } else {\n            secondsToday = secondsTotal\n                .mod(SECONDS_IN_DAY);\n        }\n    }\n\n    /**\n        * @notice calculates amount of interest due to be credited to the staker based on:\n        * number of days and remaining seconds on current day that a stake is open\n        * @param _stakingId ID of the stake, used as the Key from the stakeList mapping\n        * @return stakeInterest -- total interest per second the stake was open on each day\n     */\n    function getStakeInterest(\n        uint256 _stakingId\n    )\n        public\n        view\n        returns (\n            uint256 stakeInterest\n        )\n    {\n        StakeElement memory _stakeElement = stakeList[_stakingId];\n\n        if (_stakeElement.isActive == false) {\n\n            stakeInterest = _stakeElement.interestAmount;\n\n        } else {\n\n            (\n                uint256 daysTotal,\n                uint256 secondsToday\n            ) = getStakeAge(_stakingId);\n\n            uint256 finalDay = _currentFeyDay();\n            uint256 startDay = finalDay.sub(daysTotal);\n\n            for (uint256 _day = startDay; _day \u003c finalDay; _day++) {\n                stakeInterest += getInterest(\n                    _stakeElement.stakedAmount,\n                    snapshots[_day].totalStakedAmount,\n                    SECONDS_IN_DAY\n                );\n            }\n\n            stakeInterest += getInterest(\n                _stakeElement.stakedAmount,\n                globals.totalStakedAmount,\n                secondsToday\n            );\n        }\n    }\n\n    /**\n        * @notice penalties are taken if you close a stake before the completion of the 4th day\n        * if closed before the end of the 15th day: 7.5% of staked amount is penalized\n        * if closed before the end of the 30th day: 5% of staked amount is penalized\n        * if closed before the end of the 45th day: 2.5% of staked amount is penalized\n        * @param _stakingId ID of the stake, used as the Key from the stakeList mapping\n        * @return penaltyAmount -- amount that will be debited from the stakers principal when they close their stake\n     */\n    function getStakePenalty(\n        uint256 _stakingId\n    )\n        public\n        view\n        returns (uint256 penaltyAmount)\n    {\n        StakeElement memory _stakeElement = stakeList[_stakingId];\n\n        uint256 daysDifference = getNow()\n            .sub(_stakeElement.stakedAt)\n            .div(SECONDS_IN_DAY);\n\n        if (daysDifference \u003c 15) {\n\n            penaltyAmount = percentCalculator(\n                _stakeElement.stakedAmount,\n                750\n            );\n\n        } else if (daysDifference \u003c 30) {\n\n            penaltyAmount = percentCalculator(\n                _stakeElement.stakedAmount,\n                500\n            );\n\n        } else if (daysDifference \u003c 45) {\n\n            penaltyAmount = percentCalculator(\n                _stakeElement.stakedAmount,\n                250\n            );\n        }\n    }\n\n    /**\n        * @notice calculates principal + interest - penalty (if applicable)\n        * Note: this does not calculate a return rate, only what the sum would be if the stake was closed at that moment\n        * @param _stakingId ID of the stake, used as the Key from the stakeList mapping\n        * @dev the calculated value is only in memory\n        * @return uint256 -- principal + interest - penalty\n     */\n    function estimateReturn(\n        uint256 _stakingId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        StakeElement memory _stakeElement = stakeList[_stakingId];\n\n        if (_stakeElement.isActive == false) {\n            return  _stakeElement.returnAmount;\n        }\n\n        return _stakeElement.stakedAmount\n            .add(getStakeInterest(_stakingId))\n            .sub(getStakePenalty(_stakingId));\n    }\n\n    /**\n        * @notice close a stake older than 1 full day to:\n        * 1) credit principal + interest - penalty to the balance of the staker\n        * 2) update totalStakedAmount in globals\n        * 3) take snapshot of current FEY status before the stake closes\n        * No interest is accrued unless the stake is at least on its 4th day\n        * Updates global variables to reflect the closed stake\n        * @param _stakingId ID of the stake, used as the Key from the stakeList mapping\n        * @return stakedAmount -- represents the total calculated by: principal + interest - penalty\n        * @return penaltyAmount -- amount that will be debited from the stakers principal when they close their stake\n        * @return interestAmount -- amount that will be debited from the stakers principal when they close their stake\n     */\n    function closeStake(\n        uint256 _stakingId\n    )\n        public\n        snapshotTriggerOnClose\n        returns (\n            uint256 stakedAmount,\n            uint256 penaltyAmount,\n            uint256 interestAmount\n        )\n    {\n        return _closeStake(\n            msg.sender,\n            _stakingId\n        );\n    }\n\n    function _closeStake(\n        address _staker,\n        uint256 _stakingId\n    )\n        internal\n        returns (\n            uint256 stakedAmount,\n            uint256 penaltyAmount,\n            uint256 interestAmount\n        )\n    {\n        StakeElement memory _stakeElement = stakeList[_stakingId];\n\n        uint256 daysDifference = getNow()\n            .sub(_stakeElement.stakedAt)\n            .div(SECONDS_IN_DAY);\n\n        require(\n            daysDifference \u003e= 3,\n            \u0027FEYToken: immature stake\u0027\n        );\n\n        require(\n            _stakeElement.userAddress == _staker,\n            \u0027FEYToken: wrong stake owner\u0027\n        );\n\n        require(\n            _stakeElement.isActive,\n            \u0027FEYToken: stake not active\u0027\n        );\n\n        _stakeElement.isActive = false;\n\n        stakedAmount = _stakeElement.stakedAmount;\n\n        if (daysDifference \u003e= 45) {\n            interestAmount = getStakeInterest(\n                _stakingId\n            );\n        }\n\n        penaltyAmount = getStakePenalty(\n            _stakingId\n        );\n\n        totalSupply = totalSupply\n            .add(interestAmount)\n            .sub(penaltyAmount);\n\n        _stakeElement.interestAmount = interestAmount;\n        _stakeElement.returnAmount = stakedAmount\n            .add(interestAmount)\n            .sub(penaltyAmount);\n\n        stakeList[_stakingId] = _stakeElement;\n\n        balances[_staker] =\n        balances[_staker].add(_stakeElement.returnAmount);\n\n        globals.totalStakedAmount =\n        globals.totalStakedAmount.sub(stakedAmount);\n\n        emit StakeEnd(\n            _stakingId,\n            _staker,\n            _stakeElement.returnAmount\n        );\n\n        emit Transfer(\n            address(0x0),\n            _staker,\n            _stakeElement.returnAmount\n        );\n    }\n\n    /**\n        * @notice open a stake:\n        * 1) must be greater than MINIMUM_STAKE in Declarations\n        * 2) address opening the stake must have the amount of funds that they wish to stake in their balances[0xaddress]\n        * 3) increment the global incrementId that is used to set the stakingId\n        * 3) take snapshot of current FEY status before the stake is opened\n        * Updates global variables to reflect the new stake\n        * @param _amount the amount that you want to stake, will become your principal amount\n        * @return true if no revert or error occurs\n     */\n    function openStake(\n        uint256 _amount\n    )\n        external\n        incrementId\n        snapshotTriggerOnOpen\n        returns (bool)\n    {\n        require(\n            _transferCheck(\n                msg.sender,\n                address(0x0),\n                _amount,\n                true\n            ),\n            \u0027FEYToken: _transferCheck failed\u0027\n        );\n\n        require(\n            _amount \u003e= MINIMUM_STAKE,\n            \u0027FEYToken: stake below minimum\u0027\n        );\n\n        balances[msg.sender] =\n        balances[msg.sender].sub(_amount);\n\n        stakeList[globals.stakingId] = StakeElement(\n            msg.sender,\n            _amount,\n            0,\n            0,\n            getNow(),\n            true\n        );\n\n        globals.totalStakedAmount =\n        globals.totalStakedAmount.add(_amount);\n\n        emit StakeStart(\n            globals.stakingId,\n            msg.sender,\n            _amount\n        );\n\n        emit Transfer(\n            msg.sender,\n            address(0),\n            _amount\n        );\n\n        return true;\n    }\n\n    /**\n        * @notice getter for the data of a specific stake\n        * @param _stakingId ID of the stake, used as the Key from the stakeList mapping\n        * @return _stakedAmount -- represents the total calculated by: principal + interest - penalty\n        * @return _userAddress -- address that was used to open the stake\n        * @return _returnAmount -- principal + interest - penalty\n        * @return interestAmount -- amount of interest accrued after closing the stake\n        * @return _stakedAt -- timestamp of when stake was opened\n        * @return _isActive -- boolean for if the stake is open and accruing interest\n     */\n    function getStaking(\n        uint256 _stakingId\n    )\n        external\n        view\n        returns (\n            uint256 _stakedAmount,\n            address _userAddress,\n            uint256 _returnAmount,\n            uint256 interestAmount,\n            uint256 _stakedAt,\n            bool _isActive\n        )\n    {\n        StakeElement memory _stakeElement = stakeList[_stakingId];\n\n        return (\n            _stakeElement.stakedAmount,\n            _stakeElement.userAddress,\n            _stakeElement.returnAmount,\n            _stakeElement.interestAmount,\n            _stakeElement.stakedAt,\n            _stakeElement.isActive\n        );\n    }\n}"},"Helper.sol":{"content":"// SPDX-License-Identifier: -- ðŸ’° --\n\npragma solidity ^0.7.3;\n\nimport \u0027./Timing.sol\u0027;\nimport \u0027./Ownable.sol\u0027;\nimport \u0027./Events.sol\u0027;\nimport \u0027./SafeMath.sol\u0027;\n\ncontract Helper is Ownable, Timing, Events {\n\n    using SafeMath for uint256;\n\n    /**\n    * @notice burns set amount of tokens\n    * @dev currently unused based on changing requirements\n    * @param _amount -- amount to be burned\n    * @return true if burn() succeeds\n    */\n    function burn(\n        uint256 _amount\n    )\n        external\n        onlyOwner\n        returns (bool)\n    {\n        require(\n            balances[msg.sender].sub(_amount) \u003e= 0,\n            \u0027FEYToken: exceeding balance\u0027\n        );\n\n        totalSupply =\n        totalSupply.sub(_amount);\n\n        balances[msg.sender] =\n        balances[msg.sender].sub(_amount);\n\n        emit Transfer(\n            msg.sender,\n            address(0x0),\n            _amount\n       );\n\n        return true;\n    }\n\n    /**\n    * @notice Groups common requirements in global, internal function\n    * @dev Used by Transfer(), TransferFrom(), OpenStake()\n    * @param _sender -- msg.sender of the functions listed above\n    * @param _recipient -- recipient of amount\n    * @param _amount -- amount that is transferred\n    * @param _allowBurnAddress -- boolean to allow burning tokens\n    * @return balance[] value of the input address\n    */\n    function _transferCheck(\n        address _sender,\n        address _recipient,\n        uint256 _amount,\n        bool _allowBurnAddress\n    )\n        internal\n        view\n        returns (bool)\n    {\n\n        if (_allowBurnAddress == false) {\n            require(\n                _recipient != address(0x0),\n                \u0027FEYToken: cannot send to burn address\u0027\n            );\n        }\n\n        require(\n            balances[_sender] \u003e= _amount,\n            \u0027FEYToken: exceeding balance\u0027\n        );\n\n        require(\n            balances[_recipient].add(_amount) \u003e= balances[_recipient],\n            \u0027FEYToken: overflow detected\u0027\n        );\n\n        return true;\n    }\n\n    /**\n    * @notice Used to calculate % that is staked out of the totalSupply\n    * @dev Used by getYearlyInterestLatest(), getYearlyInterestHistorical(), + twice in getInterest()\n    * @param _numerator -- numerator, typically globals.totalStakedAmount\n    * @param _denominator -- denominator, typically totalSupply\n    * @param _precision -- number of decimal points, fixed at 4\n    * @return quotient -- calculated value\n    */\n    function getPercent(\n        uint256 _numerator,\n        uint256 _denominator,\n        uint256 _precision\n    )\n        public\n        pure\n        returns(uint256 quotient)\n    {\n        uint256 numerator = _numerator * 10 ** (_precision + 1);\n        quotient = ((numerator / _denominator) + 5) / 10;\n    }\n\n    /**\n    * @notice Used to reduce value by a set percentage amount\n    * @dev Used to calculate penaltyAmount\n    * @param _value -- initial value, typically _stakeElement.stakedAmount\n    * @param _perc -- percentage reduction that will be applied\n    * @return percentageValue -- value reduced by the input percentage\n    */\n    function percentCalculator(\n        uint256 _value,\n        uint256 _perc\n    )\n        public\n        pure\n        returns (uint256 percentageValue)\n    {\n        percentageValue = _value\n            .mul(_perc)\n            .div(10000);\n    }\n\n}"},"Migrations.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.4.22 \u003c0.8.0;\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: -- ðŸ’° --\n\npragma solidity ^0.7.3;\n\ncontract Ownable {\n\n    address public owner;\n\n    event ownershipChanged(\n        address indexed _invoker,\n        address indexed _newOwner\n    );\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner,\n            \u0027Ownable: must be the owner\u0027\n        );\n        _;\n    }\n\n    function changeOwner(\n        address _newOwner\n    )\n        external\n        onlyOwner\n        returns (bool)\n    {\n        \n        require(\n            _newOwner != address(0),\n            \u0027Ownable: new owner must not be the blackhole address\u0027\n        );\n        \n        owner = _newOwner;\n\n        emit ownershipChanged(\n            msg.sender,\n            _newOwner\n        );\n\n        return true;\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: -- ðŸŽ² --\n\npragma solidity ^0.7.0;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \u0027SafeMath: addition overflow\u0027);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \u0027SafeMath: subtraction overflow\u0027);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \u0027SafeMath: multiplication overflow\u0027);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \u0027SafeMath: division by zero\u0027);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \u0027SafeMath: modulo by zero\u0027);\n        return a % b;\n    }\n}"},"Snapshot.sol":{"content":"// SPDX-License-Identifier: -- ðŸ’° --\n\npragma solidity ^0.7.3;\n\nimport \"./Helper.sol\";\n\nabstract contract Snapshot is Helper {\n\n    using SafeMath for uint;\n\n\n    /**\n    * @notice modifier to capture snapshots when a stake is opened\n    * @dev used in OpenStake() in FeyToken \n    */\n    modifier snapshotTriggerOnOpen() \n    {\n        _;\n        _dailySnapshotPoint(\n            _currentFeyDay()\n        );\n    }\n    \n    \n    /**\n    * @notice modifier to capture snapshots when a stake is closed\n    * @dev used in CloseStake() in FeyToken \n    */\n    modifier snapshotTriggerOnClose() \n    {\n        _dailySnapshotPoint(\n            _currentFeyDay()\n        );\n        _;\n    }\n\n    /**\n    * @notice Manually capture snapshot\n    */\n    function manualDailySnapshot() \n        external\n    {\n        _dailySnapshotPoint(\n            _currentFeyDay()\n        );\n    }\n\n    /**\n    * @notice takes in todays feyday + updates all missing snapshot days with todays data\n    * @param _updateDay -- current FeyDay as outputted from timing\u0027s _currentFeyDay() function\n    * Emits SnapshotCaptured event\n    */\n    function _dailySnapshotPoint(\n        uint64 _updateDay\n    )\n        private\n    {\n        for (uint256 _day = globals.currentFeyDay; _day \u003c _updateDay; _day++) {\n\n            SnapShot memory s = snapshots[_day];\n\n            s.totalSupply = totalSupply;\n            s.totalStakedAmount = globals.totalStakedAmount;\n            \n\n            snapshots[_day] = s;\n\n            globals.currentFeyDay++;\n        }\n\n        emit SnapshotCaptured(\n            totalSupply,\n            globals.totalStakedAmount,\n            _updateDay\n        );\n    }\n}"},"Timing.sol":{"content":"// SPDX-License-Identifier: -- ðŸ’° --\n\npragma solidity ^0.7.3;\n\nimport \u0027./Declaration.sol\u0027;\n\nabstract contract Timing is Declaration {\n\n    /**\n    * @notice external view function to get current FeyDay, unless called at LAUNCH_TIME, in which case it will return 0 to save gas\n    * @dev called by _currentFeyDay\n    * @return current FeyDay\n    */\n    function currentFeyDay()\n        public\n        view\n        returns (uint64)\n    {\n        return getNow() \u003e= LAUNCH_TIME\n            ? _currentFeyDay()\n            : 0;\n    }\n\n    /**\n    * @notice internal view function to calculate current FeyDay by using _feyDayFromStamp()\n    * @dev called by snapshotTrigger(), manualDailySnapshot(), + getStakeInterest()\n    * @return current FeyDay\n    */\n    function _currentFeyDay()\n        internal\n        view\n        returns (uint64)\n    {\n        return _feyDayFromStamp(getNow());\n    }\n\n    /**\n    * @notice calculates difference between passed timestamp + original LAUNCH_TIME, set when contract was deployed\n    * @dev called by _currentFeyDay\n    * @param _timestamp -- timestamp to use for difference\n    * @return number of days between timestamp param + LAUNCH_TIME \n    */\n    function _feyDayFromStamp(\n        uint256 _timestamp\n    )\n        internal\n        view\n        returns (uint64)\n    {\n        return uint64((_timestamp - LAUNCH_TIME) / SECONDS_IN_DAY);\n    }\n    \n    /**\n    * @dev called by getStakeAge(), getStakePenalty, closeStake(), openStake(), + _currentFeyDay\n    * @return current block.timestamp\n    */\n    function getNow()\n        public\n        view\n        returns (uint256)\n    {\n        return block.timestamp;\n    }\n\n}"},"Token.sol":{"content":"// SPDX-License-Identifier: -- ðŸ’° --\n\npragma solidity ^0.7.3;\n\nimport \"./Snapshot.sol\";\n\ncontract Token is Snapshot {\n\n    using SafeMath for uint256;\n\n    /**\n    * @notice Moves amount tokens from the callerâ€™s account to recipient.\n    * Returns a boolean value indicating whether the operation succeeded.\n    * @dev See {IERC20-transfer}.\n    * Emits an {Transfer} event indicating a successful transfer.\n    * @param _receiver -- recipient of amount\n    * @param _amount -- amount that is transferred\n    * @return true if transfer() succeeds\n    */\n    function transfer(\n        address _receiver,\n        uint256 _amount\n    )\n        external\n        returns (bool)\n    {\n        require(\n            _transferCheck(\n                msg.sender,\n                _receiver,\n                _amount,\n                false\n            ),\n            \u0027Token: _transferCheck failed\u0027\n        );\n\n        balances[msg.sender] =\n        balances[msg.sender].sub(_amount);\n\n        balances[_receiver] =\n        balances[_receiver].add(_amount);\n\n        emit Transfer(\n            msg.sender,\n            _receiver,\n            _amount\n        );\n\n        return true;\n    }\n\n    /**\n    * @notice Moves amount tokens from sender to recipient using the allowance mechanism.\n    * Amount is then deducted from the callerâ€™s allowance.\n    * Returns a boolean value indicating whether the operation succeeded.\n    * @dev See {IERC20-transferFrom}.\n    * Emits an {Transfer} event indicating a successful transfer.\n    * @param _owner -- address who is sending the transfer amount\n    * @param _receiver -- recipient of amount\n    * @param _amount -- amount that is transferred\n    * @return true if transferFrom() succeeds\n     */\n    function transferFrom(\n        address _owner,\n        address _receiver,\n        uint256 _amount\n    )\n        external\n        returns (bool)\n    {\n        require(\n            _transferCheck(\n                _owner,\n                _receiver,\n                _amount,\n                false\n            ),\n            \u0027Token: _transferCheck failed\u0027\n        );\n\n        require(\n            allowances[_owner][msg.sender] \u003e= _amount,\n            \u0027Token: exceeding allowance\u0027\n        );\n\n        allowances[_owner][msg.sender] =\n        allowances[_owner][msg.sender].sub(_amount);\n\n        balances[_owner] =\n        balances[_owner].sub(_amount);\n\n        balances[_receiver] =\n        balances[_receiver].add(_amount);\n\n        emit Transfer(\n            _owner,\n            _receiver,\n            _amount\n        );\n\n        return true;\n    }\n\n    /**\n    * @notice Sets amount as the allowance of spender over the callerâ€™s tokens.\n    * @dev See {IERC20-approve}.\n    * Emits an {Approval} event indicating how much was approved and whom is the spender\n    * @param _spender -- approved address\n    * @param _amount -- amount that they are approved to spend\n    * @return true if Approve() succeeds\n    */\n    function approve(\n        address _spender,\n        uint256 _amount\n    )\n        external\n        returns (bool)\n    {\n\n        allowances[msg.sender][_spender] = _amount;\n\n        emit Approval(\n            msg.sender,\n            _spender,\n            _amount\n        );\n\n        return true;\n    }\n\n    /**\n    * @notice Returns the amount of tokens owned by account.\n    * @dev See {IERC20-approve}.\n    * @param _address -- address whose balance will be returned\n    * @return balance[] value of the input address\n    */\n    function balanceOf(\n        address _address\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return balances[_address];\n    }\n\n    /**\n    * @notice Returns the remaining number of tokens that spender will be allowed to spend\n    * on behalf of owner through transferFrom. This is zero by default.\n    * This value changes when approve or transferFrom are called.\n    * @dev See {IERC20-allowance}.\n    * @param _owner -- owner address\n    * @param _spender -- address that is approved to spend tokens\n    * @return allowances[] value of the input addresses to reflect the value mapped to the _spender\u0027s address\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return allowances[_owner][_spender];\n    }\n}"}}