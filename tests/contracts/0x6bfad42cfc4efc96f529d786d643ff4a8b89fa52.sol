{{
  "language": "Solidity",
  "sources": {
    "contracts/EthCustodian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.12;\n\nimport 'rainbow-bridge/contracts/eth/nearbridge/contracts/AdminControlled.sol';\nimport 'rainbow-bridge/contracts/eth/nearbridge/contracts/Borsh.sol';\nimport 'rainbow-bridge/contracts/eth/nearprover/contracts/ProofDecoder.sol';\nimport { INearProver, ProofKeeper } from './ProofKeeper.sol';\n\ncontract EthCustodian is ProofKeeper, AdminControlled {\n\n    uint constant UNPAUSED_ALL = 0;\n    uint constant PAUSED_DEPOSIT_TO_EVM = 1 << 0;\n    uint constant PAUSED_DEPOSIT_TO_NEAR = 1 << 1;\n    uint constant PAUSED_WITHDRAW = 1 << 2;\n\n    event Deposited (\n        address indexed sender,\n        string recipient,\n        uint256 amount,\n        uint256 fee\n    );\n\n    event Withdrawn(\n        address indexed recipient,\n        uint128 amount\n    );\n\n    // Function output from burning nETH on Near side.\n    struct BurnResult {\n        uint128 amount;\n        address recipient;\n        address ethCustodian;\n    }\n\n    /// EthCustodian is linked to the EVM on NEAR side.\n    /// It also links to the prover that it uses to withdraw the tokens.\n    constructor(\n        bytes memory nearEvm,\n        INearProver prover,\n        uint64 minBlockAcceptanceHeight,\n        address _admin,\n        uint pausedFlags\n    )\n        AdminControlled(_admin, pausedFlags)\n        ProofKeeper(nearEvm, prover, minBlockAcceptanceHeight)\n        public\n    {\n    }\n\n    /// Deposits the specified amount of provided ETH (except from the relayer's fee) into the smart contract.\n    /// `ethRecipientOnNear` - the ETH address of the recipient in NEAR EVM\n    /// `fee` - the amount of fee that will be paid to the near-relayer in nETH.\n    function depositToEVM(\n        string memory ethRecipientOnNear, \n        uint256 fee\n    )\n        external\n        payable\n        pausable(PAUSED_DEPOSIT_TO_EVM)\n    {\n        require(\n            fee < msg.value,\n            'The fee cannot be bigger than the transferred amount.'\n        );\n\n        string memory separator = ':';\n        string memory protocolMessage = string(\n            abi.encodePacked(\n                string(nearProofProducerAccount_),\n                separator, ethRecipientOnNear\n            )\n        );\n\n        emit Deposited(\n            msg.sender, \n            protocolMessage, \n            msg.value, \n            fee\n        );\n    }\n\n    /// Deposits the specified amount of provided ETH (except from the relayer's fee) into the smart contract.\n    /// `nearRecipientAccountId` - the AccountID of the recipient in NEAR\n    /// `fee` - the amount of fee that will be paid to the near-relayer in nETH.\n    function depositToNear(\n        string memory nearRecipientAccountId, \n        uint256 fee\n    )\n        external\n        payable\n        pausable(PAUSED_DEPOSIT_TO_NEAR)\n    {\n        require(\n            fee < msg.value,\n            'The fee cannot be bigger than the transferred amount.'\n        );\n\n        emit Deposited(\n            msg.sender, \n            nearRecipientAccountId, \n            msg.value, \n            fee\n        );\n    }\n\n    /// Withdraws the appropriate amount of ETH which is encoded in `proofData`\n    function withdraw(\n        bytes calldata proofData, \n        uint64 proofBlockHeight\n    )\n        external\n        pausable(PAUSED_WITHDRAW)\n    {\n        ProofDecoder.ExecutionStatus memory status = _parseAndConsumeProof(proofData, proofBlockHeight);\n\n        BurnResult memory result = _decodeBurnResult(status.successValue);\n        require(\n            result.ethCustodian == address(this),\n            'Can only withdraw coins that were expected for the current contract'\n        );\n        payable(result.recipient).transfer(result.amount);\n        emit Withdrawn(\n            result.recipient,\n            result.amount\n        );\n    }\n\n    function _decodeBurnResult(bytes memory data)\n        internal\n        pure\n        returns (BurnResult memory result)\n    {\n        Borsh.Data memory borshData = Borsh.from(data);\n        result.amount = borshData.decodeU128();\n        bytes20 recipient = borshData.decodeBytes20();\n        result.recipient = address(uint160(recipient));\n        bytes20 ethCustodian = borshData.decodeBytes20();\n        result.ethCustodian = address(uint160(ethCustodian));\n    }\n}\n"
    },
    "rainbow-bridge/contracts/eth/nearbridge/contracts/AdminControlled.sol": {
      "content": "pragma solidity ^0.6;\n\ncontract AdminControlled {\n    address public admin;\n    uint public paused;\n\n    constructor(address _admin, uint flags) public {\n        admin = _admin;\n        paused = flags;\n    }\n\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n\n    modifier pausable(uint flag) {\n        require((paused & flag) == 0 || msg.sender == admin);\n        _;\n    }\n\n    function adminPause(uint flags) public onlyAdmin {\n        paused = flags;\n    }\n\n    function adminSstore(uint key, uint value) public onlyAdmin {\n        assembly {\n            sstore(key, value)\n        }\n    }\n\n    function adminSstoreWithMask(\n        uint key,\n        uint value,\n        uint mask\n    ) public onlyAdmin {\n        assembly {\n            let oldval := sload(key)\n            sstore(key, xor(and(xor(value, oldval), mask), oldval))\n        }\n    }\n\n    function adminSendEth(address payable destination, uint amount) public onlyAdmin {\n        destination.transfer(amount);\n    }\n\n    function adminReceiveEth() public payable onlyAdmin {}\n\n    function adminDelegatecall(address target, bytes memory data) public payable onlyAdmin returns (bytes memory) {\n        (bool success, bytes memory rdata) = target.delegatecall(data);\n        require(success);\n        return rdata;\n    }\n}\n"
    },
    "rainbow-bridge/contracts/eth/nearbridge/contracts/Borsh.sol": {
      "content": "pragma solidity ^0.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary Borsh {\n    using SafeMath for uint256;\n\n    struct Data {\n        uint256 offset;\n        bytes raw;\n    }\n\n    function from(bytes memory data) internal pure returns (Data memory) {\n        return Data({offset: 0, raw: data});\n    }\n\n    modifier shift(Data memory data, uint256 size) {\n        require(data.raw.length >= data.offset + size, \"Borsh: Out of range\");\n        _;\n        data.offset += size;\n    }\n\n    function finished(Data memory data) internal pure returns (bool) {\n        return data.offset == data.raw.length;\n    }\n\n    function peekKeccak256(Data memory data, uint256 length) internal pure returns (bytes32 res) {\n        return bytesKeccak256(data.raw, data.offset, length);\n    }\n\n    function bytesKeccak256(\n        bytes memory ptr,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (bytes32 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            res := keccak256(add(add(ptr, 32), offset), length)\n        }\n    }\n\n    function peekSha256(Data memory data, uint256 length) internal view returns (bytes32) {\n        return bytesSha256(data.raw, data.offset, length);\n    }\n\n    function bytesSha256(\n        bytes memory ptr,\n        uint256 offset,\n        uint256 length\n    ) internal view returns (bytes32) {\n        bytes32[1] memory result;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            pop(staticcall(gas(), 0x02, add(add(ptr, 32), offset), length, result, 32))\n        }\n        return result[0];\n    }\n\n    function decodeU8(Data memory data) internal pure shift(data, 1) returns (uint8 value) {\n        value = uint8(data.raw[data.offset]);\n    }\n\n    function decodeI8(Data memory data) internal pure shift(data, 1) returns (int8 value) {\n        value = int8(data.raw[data.offset]);\n    }\n\n    function decodeU16(Data memory data) internal pure returns (uint16 value) {\n        value = uint16(decodeU8(data));\n        value |= (uint16(decodeU8(data)) << 8);\n    }\n\n    function decodeI16(Data memory data) internal pure returns (int16 value) {\n        value = int16(decodeI8(data));\n        value |= (int16(decodeI8(data)) << 8);\n    }\n\n    function decodeU32(Data memory data) internal pure returns (uint32 value) {\n        value = uint32(decodeU16(data));\n        value |= (uint32(decodeU16(data)) << 16);\n    }\n\n    function decodeI32(Data memory data) internal pure returns (int32 value) {\n        value = int32(decodeI16(data));\n        value |= (int32(decodeI16(data)) << 16);\n    }\n\n    function decodeU64(Data memory data) internal pure returns (uint64 value) {\n        value = uint64(decodeU32(data));\n        value |= (uint64(decodeU32(data)) << 32);\n    }\n\n    function decodeI64(Data memory data) internal pure returns (int64 value) {\n        value = int64(decodeI32(data));\n        value |= (int64(decodeI32(data)) << 32);\n    }\n\n    function decodeU128(Data memory data) internal pure returns (uint128 value) {\n        value = uint128(decodeU64(data));\n        value |= (uint128(decodeU64(data)) << 64);\n    }\n\n    function decodeI128(Data memory data) internal pure returns (int128 value) {\n        value = int128(decodeI64(data));\n        value |= (int128(decodeI64(data)) << 64);\n    }\n\n    function decodeU256(Data memory data) internal pure returns (uint256 value) {\n        value = uint256(decodeU128(data));\n        value |= (uint256(decodeU128(data)) << 128);\n    }\n\n    function decodeI256(Data memory data) internal pure returns (int256 value) {\n        value = int256(decodeI128(data));\n        value |= (int256(decodeI128(data)) << 128);\n    }\n\n    function decodeBool(Data memory data) internal pure returns (bool value) {\n        value = (decodeU8(data) != 0);\n    }\n\n    function decodeBytes(Data memory data) internal pure returns (bytes memory value) {\n        value = new bytes(decodeU32(data));\n        for (uint i = 0; i < value.length; i++) {\n            value[i] = byte(decodeU8(data));\n        }\n    }\n\n    function decodeBytes32(Data memory data) internal pure shift(data, 32) returns (bytes32 value) {\n        bytes memory raw = data.raw;\n        uint256 offset = data.offset;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            value := mload(add(add(raw, 32), offset))\n        }\n    }\n\n    function decodeBytes20(Data memory data) internal pure returns (bytes20 value) {\n        for (uint i = 0; i < 20; i++) {\n            value |= bytes20(byte(decodeU8(data)) & 0xFF) >> (i * 8);\n        }\n    }\n\n    // Public key\n\n    struct SECP256K1PublicKey {\n        uint256 x;\n        uint256 y;\n    }\n\n    function decodeSECP256K1PublicKey(Borsh.Data memory data) internal pure returns (SECP256K1PublicKey memory key) {\n        key.x = decodeU256(data);\n        key.y = decodeU256(data);\n    }\n\n    struct ED25519PublicKey {\n        bytes32 xy;\n    }\n\n    function decodeED25519PublicKey(Borsh.Data memory data) internal pure returns (ED25519PublicKey memory key) {\n        key.xy = decodeBytes32(data);\n    }\n\n    // Signature\n\n    struct SECP256K1Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    function decodeSECP256K1Signature(Borsh.Data memory data) internal pure returns (SECP256K1Signature memory sig) {\n        sig.r = decodeBytes32(data);\n        sig.s = decodeBytes32(data);\n        sig.v = decodeU8(data);\n    }\n\n    struct ED25519Signature {\n        bytes32[2] rs;\n    }\n\n    function decodeED25519Signature(Borsh.Data memory data) internal pure returns (ED25519Signature memory sig) {\n        sig.rs[0] = decodeBytes32(data);\n        sig.rs[1] = decodeBytes32(data);\n    }\n}\n"
    },
    "rainbow-bridge/contracts/eth/nearprover/contracts/ProofDecoder.sol": {
      "content": "pragma solidity ^0.6;\n\nimport \"../../nearbridge/contracts/Borsh.sol\";\nimport \"../../nearbridge/contracts/NearDecoder.sol\";\n\nlibrary ProofDecoder {\n    using Borsh for Borsh.Data;\n    using ProofDecoder for Borsh.Data;\n    using NearDecoder for Borsh.Data;\n\n    struct FullOutcomeProof {\n        ExecutionOutcomeWithIdAndProof outcome_proof;\n        MerklePath outcome_root_proof; // TODO: now empty array\n        BlockHeaderLight block_header_lite;\n        MerklePath block_proof;\n    }\n\n    function decodeFullOutcomeProof(Borsh.Data memory data) internal view returns (FullOutcomeProof memory proof) {\n        proof.outcome_proof = data.decodeExecutionOutcomeWithIdAndProof();\n        proof.outcome_root_proof = data.decodeMerklePath();\n        proof.block_header_lite = data.decodeBlockHeaderLight();\n        proof.block_proof = data.decodeMerklePath();\n    }\n\n    struct BlockHeaderLight {\n        bytes32 prev_block_hash;\n        bytes32 inner_rest_hash;\n        NearDecoder.BlockHeaderInnerLite inner_lite;\n        bytes32 hash; // Computable\n    }\n\n    function decodeBlockHeaderLight(Borsh.Data memory data) internal view returns (BlockHeaderLight memory header) {\n        header.prev_block_hash = data.decodeBytes32();\n        header.inner_rest_hash = data.decodeBytes32();\n        header.inner_lite = data.decodeBlockHeaderInnerLite();\n\n        header.hash = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(header.inner_lite.hash, header.inner_rest_hash)),\n                header.prev_block_hash\n            )\n        );\n    }\n\n    struct ExecutionStatus {\n        uint8 enumIndex;\n        bool unknown;\n        bool failed;\n        bytes successValue; /// The final action succeeded and returned some value or an empty vec.\n        bytes32 successReceiptId; /// The final action of the receipt returned a promise or the signed\n        /// transaction was converted to a receipt. Contains the receipt_id of the generated receipt.\n    }\n\n    function decodeExecutionStatus(Borsh.Data memory data)\n        internal\n        pure\n        returns (ExecutionStatus memory executionStatus)\n    {\n        executionStatus.enumIndex = data.decodeU8();\n        if (executionStatus.enumIndex == 0) {\n            executionStatus.unknown = true;\n        } else if (executionStatus.enumIndex == 1) {\n            //revert(\"NearDecoder: decodeExecutionStatus failure case not implemented yet\");\n            // Can avoid revert since ExecutionStatus is latest field in all parent structures\n            executionStatus.failed = true;\n        } else if (executionStatus.enumIndex == 2) {\n            executionStatus.successValue = data.decodeBytes();\n        } else if (executionStatus.enumIndex == 3) {\n            executionStatus.successReceiptId = data.decodeBytes32();\n        } else {\n            revert(\"NearDecoder: decodeExecutionStatus index out of range\");\n        }\n    }\n\n    struct ExecutionOutcome {\n        bytes[] logs; /// Logs from this transaction or receipt.\n        bytes32[] receipt_ids; /// Receipt IDs generated by this transaction or receipt.\n        uint64 gas_burnt; /// The amount of the gas burnt by the given transaction or receipt.\n        uint128 tokens_burnt; /// The total number of the tokens burnt by the given transaction or receipt.\n        bytes executor_id; /// Hash of the transaction or receipt id that produced this outcome.\n        ExecutionStatus status; /// Execution status. Contains the result in case of successful execution.\n        bytes32[] merkelization_hashes;\n    }\n\n    function decodeExecutionOutcome(Borsh.Data memory data) internal view returns (ExecutionOutcome memory outcome) {\n        outcome.logs = new bytes[](data.decodeU32());\n        for (uint i = 0; i < outcome.logs.length; i++) {\n            outcome.logs[i] = data.decodeBytes();\n        }\n\n        uint256 start = data.offset;\n        outcome.receipt_ids = new bytes32[](data.decodeU32());\n        for (uint i = 0; i < outcome.receipt_ids.length; i++) {\n            outcome.receipt_ids[i] = data.decodeBytes32();\n        }\n        outcome.gas_burnt = data.decodeU64();\n        outcome.tokens_burnt = data.decodeU128();\n        outcome.executor_id = data.decodeBytes();\n        outcome.status = data.decodeExecutionStatus();\n        uint256 stop = data.offset;\n\n        outcome.merkelization_hashes = new bytes32[](1 + outcome.logs.length);\n        data.offset = start;\n        outcome.merkelization_hashes[0] = data.peekSha256(stop - start);\n        data.offset = stop;\n        for (uint i = 0; i < outcome.logs.length; i++) {\n            outcome.merkelization_hashes[i + 1] = sha256(outcome.logs[i]);\n        }\n    }\n\n    struct ExecutionOutcomeWithId {\n        bytes32 id; /// The transaction hash or the receipt ID.\n        ExecutionOutcome outcome;\n        bytes32 hash;\n    }\n\n    function decodeExecutionOutcomeWithId(Borsh.Data memory data)\n        internal\n        view\n        returns (ExecutionOutcomeWithId memory outcome)\n    {\n        outcome.id = data.decodeBytes32();\n        outcome.outcome = data.decodeExecutionOutcome();\n\n        uint256 len = 1 + outcome.outcome.merkelization_hashes.length;\n        outcome.hash = sha256(\n            abi.encodePacked(\n                uint8((len >> 0) & 0xFF),\n                uint8((len >> 8) & 0xFF),\n                uint8((len >> 16) & 0xFF),\n                uint8((len >> 24) & 0xFF),\n                outcome.id,\n                outcome.outcome.merkelization_hashes\n            )\n        );\n    }\n\n    struct MerklePathItem {\n        bytes32 hash;\n        uint8 direction; // 0 = left, 1 = right\n    }\n\n    function decodeMerklePathItem(Borsh.Data memory data) internal pure returns (MerklePathItem memory item) {\n        item.hash = data.decodeBytes32();\n        item.direction = data.decodeU8();\n        require(item.direction < 2, \"ProofDecoder: MerklePathItem direction should be 0 or 1\");\n    }\n\n    struct MerklePath {\n        MerklePathItem[] items;\n    }\n\n    function decodeMerklePath(Borsh.Data memory data) internal pure returns (MerklePath memory path) {\n        path.items = new MerklePathItem[](data.decodeU32());\n        for (uint i = 0; i < path.items.length; i++) {\n            path.items[i] = data.decodeMerklePathItem();\n        }\n    }\n\n    struct ExecutionOutcomeWithIdAndProof {\n        MerklePath proof;\n        bytes32 block_hash;\n        ExecutionOutcomeWithId outcome_with_id;\n    }\n\n    function decodeExecutionOutcomeWithIdAndProof(Borsh.Data memory data)\n        internal\n        view\n        returns (ExecutionOutcomeWithIdAndProof memory outcome)\n    {\n        outcome.proof = data.decodeMerklePath();\n        outcome.block_hash = data.decodeBytes32();\n        outcome.outcome_with_id = data.decodeExecutionOutcomeWithId();\n    }\n}\n"
    },
    "contracts/ProofKeeper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.12;\n\nimport 'rainbow-bridge/contracts/eth/nearprover/contracts/INearProver.sol';\nimport 'rainbow-bridge/contracts/eth/nearprover/contracts/ProofDecoder.sol';\nimport 'rainbow-bridge/contracts/eth/nearbridge/contracts/Borsh.sol';\n\ncontract ProofKeeper {\n    using Borsh for Borsh.Data;\n    using ProofDecoder for Borsh.Data;\n\n    INearProver public prover_;\n    bytes public nearProofProducerAccount_;\n\n    /// Proofs from blocks that are below the acceptance height will be rejected.\n    // If `minBlockAcceptanceHeight_` value is zero - proofs from block with any height are accepted.\n    uint64 public minBlockAcceptanceHeight_;\n\n    // OutcomeReciptId -> Used\n    mapping(bytes32 => bool) public usedEvents_;\n\n    constructor(\n        bytes memory nearProofProducerAccount,\n        INearProver prover,\n        uint64 minBlockAcceptanceHeight\n    ) \n        public \n    {\n        require(\n            nearProofProducerAccount.length > 0,\n            'Invalid Near ProofProducer address'\n        );\n        require(\n            address(prover) != address(0),\n            'Invalid Near prover address'\n        );\n\n        nearProofProducerAccount_ = nearProofProducerAccount;\n        prover_ = prover;\n        minBlockAcceptanceHeight_ = minBlockAcceptanceHeight;\n    }\n\n    /// Parses the provided proof and consumes it if it's not already used.\n    /// The consumed event cannot be reused for future calls.\n    function _parseAndConsumeProof(\n        bytes memory proofData, \n        uint64 proofBlockHeight\n    )\n        internal\n        returns(ProofDecoder.ExecutionStatus memory result)\n    {\n        require(\n            proofBlockHeight >= minBlockAcceptanceHeight_,\n            'Proof is from the ancient block'\n        );\n        require(\n            prover_.proveOutcome(proofData,proofBlockHeight),\n            'Proof should be valid'\n        );\n\n        // Unpack the proof and extract the execution outcome.\n        Borsh.Data memory borshData = Borsh.from(proofData);\n\n        ProofDecoder.FullOutcomeProof memory fullOutcomeProof = \n        borshData.decodeFullOutcomeProof();\n        \n        require(\n            borshData.finished(),\n            'Argument should be exact borsh serialization'\n        );\n\n        bytes32 receiptId = \n        fullOutcomeProof.outcome_proof.outcome_with_id.outcome.receipt_ids[0];\n\n        require(\n            !usedEvents_[receiptId],\n            'The burn event cannot be reused'\n        );\n        usedEvents_[receiptId] = true;\n\n        require(\n            keccak256(fullOutcomeProof.outcome_proof.outcome_with_id.outcome.executor_id) == \n            keccak256(nearProofProducerAccount_),\n            'Can only withdraw coins from the linked proof producer on Near blockchain'\n        );\n\n        result = fullOutcomeProof.outcome_proof.outcome_with_id.outcome.status;\n        require(\n            !result.failed, \n            'Cannot use failed execution outcome for unlocking the tokens'\n        );\n        require(\n            !result.unknown,\n            'Cannot use unknown execution outcome for unlocking the tokens'\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "rainbow-bridge/contracts/eth/nearbridge/contracts/NearDecoder.sol": {
      "content": "pragma solidity ^0.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./Borsh.sol\";\n\nlibrary NearDecoder {\n    using Borsh for Borsh.Data;\n    using NearDecoder for Borsh.Data;\n\n    struct PublicKey {\n        uint8 enumIndex;\n        Borsh.ED25519PublicKey ed25519;\n        Borsh.SECP256K1PublicKey secp256k1;\n    }\n\n    function decodePublicKey(Borsh.Data memory data) internal pure returns (PublicKey memory key) {\n        key.enumIndex = data.decodeU8();\n\n        if (key.enumIndex == 0) {\n            key.ed25519 = data.decodeED25519PublicKey();\n        } else if (key.enumIndex == 1) {\n            key.secp256k1 = data.decodeSECP256K1PublicKey();\n        } else {\n            revert(\"NearBridge: Only ED25519 and SECP256K1 public keys are supported\");\n        }\n    }\n\n    struct ValidatorStake {\n        string account_id;\n        PublicKey public_key;\n        uint128 stake;\n    }\n\n    function decodeValidatorStake(Borsh.Data memory data) internal pure returns (ValidatorStake memory validatorStake) {\n        validatorStake.account_id = string(data.decodeBytes());\n        validatorStake.public_key = data.decodePublicKey();\n        validatorStake.stake = data.decodeU128();\n    }\n\n    struct OptionalValidatorStakes {\n        bool none;\n        ValidatorStake[] validatorStakes;\n        bytes32 hash; // Additional computable element\n    }\n\n    function decodeOptionalValidatorStakes(Borsh.Data memory data)\n        internal\n        view\n        returns (OptionalValidatorStakes memory stakes)\n    {\n        stakes.none = (data.decodeU8() == 0);\n        if (!stakes.none) {\n            uint256 start = data.offset;\n\n            stakes.validatorStakes = new ValidatorStake[](data.decodeU32());\n            for (uint i = 0; i < stakes.validatorStakes.length; i++) {\n                stakes.validatorStakes[i] = data.decodeValidatorStake();\n            }\n\n            uint256 stop = data.offset;\n            data.offset = start;\n            stakes.hash = data.peekSha256(stop - start);\n            data.offset = stop;\n        }\n    }\n\n    struct Signature {\n        uint8 enumIndex;\n        Borsh.ED25519Signature ed25519;\n        Borsh.SECP256K1Signature secp256k1;\n    }\n\n    function decodeSignature(Borsh.Data memory data) internal pure returns (Signature memory sig) {\n        sig.enumIndex = data.decodeU8();\n\n        if (sig.enumIndex == 0) {\n            sig.ed25519 = data.decodeED25519Signature();\n        } else if (sig.enumIndex == 1) {\n            sig.secp256k1 = data.decodeSECP256K1Signature();\n        } else {\n            revert(\"NearBridge: Only ED25519 and SECP256K1 signatures are supported\");\n        }\n    }\n\n    struct OptionalSignature {\n        bool none;\n        Signature signature;\n    }\n\n    function decodeOptionalSignature(Borsh.Data memory data) internal pure returns (OptionalSignature memory sig) {\n        sig.none = (data.decodeU8() == 0);\n        if (!sig.none) {\n            sig.signature = data.decodeSignature();\n        }\n    }\n\n    struct LightClientBlock {\n        bytes32 prev_block_hash;\n        bytes32 next_block_inner_hash;\n        BlockHeaderInnerLite inner_lite;\n        bytes32 inner_rest_hash;\n        OptionalValidatorStakes next_bps;\n        OptionalSignature[] approvals_after_next;\n        bytes32 hash;\n        bytes32 next_hash;\n    }\n\n    struct InitialValidators {\n        ValidatorStake[] validator_stakes;\n    }\n\n    function decodeInitialValidators(Borsh.Data memory data)\n        internal\n        view\n        returns (InitialValidators memory validators)\n    {\n        validators.validator_stakes = new ValidatorStake[](data.decodeU32());\n        for (uint i = 0; i < validators.validator_stakes.length; i++) {\n            validators.validator_stakes[i] = data.decodeValidatorStake();\n        }\n    }\n\n    function decodeLightClientBlock(Borsh.Data memory data) internal view returns (LightClientBlock memory header) {\n        header.prev_block_hash = data.decodeBytes32();\n        header.next_block_inner_hash = data.decodeBytes32();\n        header.inner_lite = data.decodeBlockHeaderInnerLite();\n        header.inner_rest_hash = data.decodeBytes32();\n        header.next_bps = data.decodeOptionalValidatorStakes();\n\n        header.approvals_after_next = new OptionalSignature[](data.decodeU32());\n        for (uint i = 0; i < header.approvals_after_next.length; i++) {\n            header.approvals_after_next[i] = data.decodeOptionalSignature();\n        }\n\n        header.hash = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(header.inner_lite.hash, header.inner_rest_hash)),\n                header.prev_block_hash\n            )\n        );\n\n        header.next_hash = sha256(abi.encodePacked(header.next_block_inner_hash, header.hash));\n    }\n\n    struct BlockHeaderInnerLite {\n        uint64 height; /// Height of this block since the genesis block (height 0).\n        bytes32 epoch_id; /// Epoch start hash of this block's epoch. Used for retrieving validator information\n        bytes32 next_epoch_id;\n        bytes32 prev_state_root; /// Root hash of the state at the previous block.\n        bytes32 outcome_root; /// Root of the outcomes of transactions and receipts.\n        uint64 timestamp; /// Timestamp at which the block was built.\n        bytes32 next_bp_hash; /// Hash of the next epoch block producers set\n        bytes32 block_merkle_root;\n        bytes32 hash; // Additional computable element\n    }\n\n    function decodeBlockHeaderInnerLite(Borsh.Data memory data)\n        internal\n        view\n        returns (BlockHeaderInnerLite memory header)\n    {\n        header.hash = data.peekSha256(208);\n        header.height = data.decodeU64();\n        header.epoch_id = data.decodeBytes32();\n        header.next_epoch_id = data.decodeBytes32();\n        header.prev_state_root = data.decodeBytes32();\n        header.outcome_root = data.decodeBytes32();\n        header.timestamp = data.decodeU64();\n        header.next_bp_hash = data.decodeBytes32();\n        header.block_merkle_root = data.decodeBytes32();\n    }\n}\n"
    },
    "rainbow-bridge/contracts/eth/nearprover/contracts/INearProver.sol": {
      "content": "pragma solidity ^0.6;\n\ninterface INearProver {\n    function proveOutcome(bytes calldata proofData, uint64 blockHeight) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}