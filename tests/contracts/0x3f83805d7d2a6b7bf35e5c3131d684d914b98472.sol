{{
  "language": "Solidity",
  "sources": {
    "contracts/proxies/PendleRedeemProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\nimport \"../interfaces/IPendleRouter.sol\";\nimport \"../interfaces/IPendleForge.sol\";\nimport \"../interfaces/IPendleLiquidityMining.sol\";\nimport \"../interfaces/IPendleYieldToken.sol\";\n\ncontract PendleRedeemProxy {\n    IPendleRouter public immutable router;\n\n    constructor(address _router) {\n        require(_router != address(0), \"ZERO_ADDRESS\");\n        router = IPendleRouter(_router);\n    }\n\n    function redeem(\n        address[] calldata _xyts,\n        address[] calldata _markets,\n        address[] calldata _liqMiningContracts,\n        uint256[] calldata _expiries,\n        uint256 _liqMiningRewardsCount\n    )\n        external\n        returns (\n            uint256[] memory xytInterests,\n            uint256[] memory marketInterests,\n            uint256[] memory rewards,\n            uint256[] memory liqMiningInterests\n        )\n    {\n        xytInterests = redeemXyts(_xyts);\n        marketInterests = redeemMarkets(_markets);\n\n        (rewards, liqMiningInterests) = redeemLiqMining(\n            _liqMiningContracts,\n            _expiries,\n            _liqMiningRewardsCount\n        );\n    }\n\n    function redeemXyts(address[] calldata xyts) public returns (uint256[] memory xytInterests) {\n        xytInterests = new uint256[](xyts.length);\n        for (uint256 i = 0; i < xyts.length; i++) {\n            IPendleYieldToken xyt = IPendleYieldToken(xyts[i]);\n            bytes32 forgeId = IPendleForge(xyt.forge()).forgeId();\n            address underlyingAsset = xyt.underlyingAsset();\n            uint256 expiry = xyt.expiry();\n            xytInterests[i] = router.redeemDueInterests(\n                forgeId,\n                underlyingAsset,\n                expiry,\n                msg.sender\n            );\n        }\n    }\n\n    function redeemMarkets(address[] calldata markets)\n        public\n        returns (uint256[] memory marketInterests)\n    {\n        uint256 marketCount = markets.length;\n        marketInterests = new uint256[](marketCount);\n        for (uint256 i = 0; i < marketCount; i++) {\n            marketInterests[i] = router.redeemLpInterests(markets[i], msg.sender);\n        }\n    }\n\n    function redeemLiqMining(\n        address[] calldata liqMiningContracts,\n        uint256[] calldata expiries,\n        uint256 liqMiningRewardsCount\n    ) public returns (uint256[] memory rewards, uint256[] memory liqMiningInterests) {\n        require(liqMiningRewardsCount <= liqMiningContracts.length, \"INVALID_REWARDS_COUNT\");\n        require(expiries.length == liqMiningContracts.length, \"ARRAY_LENGTH_MISMATCH\");\n\n        rewards = new uint256[](liqMiningRewardsCount);\n        for (uint256 i = 0; i < liqMiningRewardsCount; i++) {\n            rewards[i] = IPendleLiquidityMining(liqMiningContracts[i]).redeemRewards(\n                expiries[i],\n                msg.sender\n            );\n        }\n\n        uint256 liqMiningInterestsCount = liqMiningContracts.length - liqMiningRewardsCount;\n        liqMiningInterests = new uint256[](liqMiningInterestsCount);\n        for (uint256 i = 0; i < liqMiningInterestsCount; i++) {\n            uint256 arrayIndex = i + liqMiningRewardsCount;\n            liqMiningInterests[i] = IPendleLiquidityMining(liqMiningContracts[arrayIndex])\n                .redeemLpInterests(expiries[arrayIndex], msg.sender);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IPendleRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IWETH.sol\";\nimport \"./IPendleData.sol\";\nimport \"../libraries/PendleStructs.sol\";\nimport \"./IPendleMarketFactory.sol\";\n\ninterface IPendleRouter {\n    /**\n     * @notice Emitted when a market for a future yield token and an ERC20 token is created.\n     * @param marketFactoryId Forge identifier.\n     * @param xyt The address of the tokenized future yield token as the base asset.\n     * @param token The address of an ERC20 token as the quote asset.\n     * @param market The address of the newly created market.\n     **/\n    event MarketCreated(\n        bytes32 marketFactoryId,\n        address indexed xyt,\n        address indexed token,\n        address indexed market\n    );\n\n    /**\n     * @notice Emitted when a swap happens on the market.\n     * @param trader The address of msg.sender.\n     * @param inToken The input token.\n     * @param outToken The output token.\n     * @param exactIn The exact amount being traded.\n     * @param exactOut The exact amount received.\n     * @param market The market address.\n     **/\n    event SwapEvent(\n        address indexed trader,\n        address inToken,\n        address outToken,\n        uint256 exactIn,\n        uint256 exactOut,\n        address market\n    );\n\n    /**\n     * @dev Emitted when user adds liquidity\n     * @param sender The user who added liquidity.\n     * @param token0Amount the amount of token0 (xyt) provided by user\n     * @param token1Amount the amount of token1 provided by user\n     * @param market The market address.\n     * @param exactOutLp The exact LP minted\n     */\n    event Join(\n        address indexed sender,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        address market,\n        uint256 exactOutLp\n    );\n\n    /**\n     * @dev Emitted when user removes liquidity\n     * @param sender The user who removed liquidity.\n     * @param token0Amount the amount of token0 (xyt) given to user\n     * @param token1Amount the amount of token1 given to user\n     * @param market The market address.\n     * @param exactInLp The exact Lp to remove\n     */\n    event Exit(\n        address indexed sender,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        address market,\n        uint256 exactInLp\n    );\n\n    /**\n     * @notice Gets a reference to the PendleData contract.\n     * @return Returns the data contract reference.\n     **/\n    function data() external view returns (IPendleData);\n\n    /**\n     * @notice Gets a reference of the WETH9 token contract address.\n     * @return WETH token reference.\n     **/\n    function weth() external view returns (IWETH);\n\n    /***********\n     *  FORGE  *\n     ***********/\n\n    function newYieldContracts(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (address ot, address xyt);\n\n    function redeemAfterExpiry(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (uint256 redeemedAmount);\n\n    function redeemDueInterests(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        address user\n    ) external returns (uint256 interests);\n\n    function redeemUnderlying(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToRedeem\n    ) external returns (uint256 redeemedAmount);\n\n    function renewYield(\n        bytes32 forgeId,\n        uint256 oldExpiry,\n        address underlyingAsset,\n        uint256 newExpiry,\n        uint256 renewalRate\n    )\n        external\n        returns (\n            uint256 redeemedAmount,\n            uint256 amountRenewed,\n            address ot,\n            address xyt,\n            uint256 amountTokenMinted\n        );\n\n    function tokenizeYield(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToTokenize,\n        address to\n    )\n        external\n        returns (\n            address ot,\n            address xyt,\n            uint256 amountTokenMinted\n        );\n\n    /***********\n     *  MARKET *\n     ***********/\n\n    function addMarketLiquidityDual(\n        bytes32 _marketFactoryId,\n        address _xyt,\n        address _token,\n        uint256 _desiredXytAmount,\n        uint256 _desiredTokenAmount,\n        uint256 _xytMinAmount,\n        uint256 _tokenMinAmount\n    )\n        external\n        payable\n        returns (\n            uint256 amountXytUsed,\n            uint256 amountTokenUsed,\n            uint256 lpOut\n        );\n\n    function addMarketLiquiditySingle(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        bool forXyt,\n        uint256 exactInAsset,\n        uint256 minOutLp\n    ) external payable returns (uint256 exactOutLp);\n\n    function removeMarketLiquidityDual(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        uint256 exactInLp,\n        uint256 minOutXyt,\n        uint256 minOutToken\n    ) external returns (uint256 exactOutXyt, uint256 exactOutToken);\n\n    function removeMarketLiquiditySingle(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        bool forXyt,\n        uint256 exactInLp,\n        uint256 minOutAsset\n    ) external returns (uint256 exactOutXyt, uint256 exactOutToken);\n\n    /**\n     * @notice Creates a market given a protocol ID, future yield token, and an ERC20 token.\n     * @param marketFactoryId Market Factory identifier.\n     * @param xyt Token address of the future yield token as base asset.\n     * @param token Token address of an ERC20 token as quote asset.\n     * @return market Returns the address of the newly created market.\n     **/\n    function createMarket(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token\n    ) external returns (address market);\n\n    function bootstrapMarket(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        uint256 initialXytLiquidity,\n        uint256 initialTokenLiquidity\n    ) external payable;\n\n    function swapExactIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 inTotalAmount,\n        uint256 minOutTotalAmount,\n        bytes32 marketFactoryId\n    ) external payable returns (uint256 outTotalAmount);\n\n    function swapExactOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 outTotalAmount,\n        uint256 maxInTotalAmount,\n        bytes32 marketFactoryId\n    ) external payable returns (uint256 inTotalAmount);\n\n    function redeemLpInterests(address market, address user) external returns (uint256 interests);\n}\n"
    },
    "contracts/interfaces/IPendleForge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"./IPendleRouter.sol\";\nimport \"./IPendleRewardManager.sol\";\nimport \"./IPendleYieldContractDeployer.sol\";\n\ninterface IPendleForge {\n    /**\n     * @dev Emitted when the Forge has minted the OT and XYT tokens.\n     * @param forgeId The forgeId\n     * @param underlyingAsset The address of the underlying yield token.\n     * @param expiry The expiry of the XYT token\n     * @param amountToTokenize The amount of yield bearing assets to tokenize\n     * @param amountTokenMinted The amount of OT/XYT minted\n     **/\n    event MintYieldTokens(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        uint256 amountToTokenize,\n        uint256 amountTokenMinted,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted when the Forge has created new yield token contracts.\n     * @param forgeId The forgeId\n     * @param underlyingAsset The address of the underlying asset.\n     * @param expiry The date in epoch time when the contract will expire.\n     * @param ot The address of the ownership token.\n     * @param xyt The address of the new future yield token.\n     **/\n    event NewYieldContracts(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        address ot,\n        address xyt,\n        address yieldBearingAsset\n    );\n\n    /**\n     * @dev Emitted when the Forge has redeemed the OT and XYT tokens.\n     * @param forgeId The forgeId\n     * @param underlyingAsset the address of the underlying asset\n     * @param expiry The expiry of the XYT token\n     * @param amountToRedeem The amount of OT to be redeemed.\n     * @param redeemedAmount The amount of yield token received\n     **/\n    event RedeemYieldToken(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        uint256 amountToRedeem,\n        uint256 redeemedAmount,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted when interest claim is settled\n     * @param forgeId The forgeId\n     * @param underlyingAsset the address of the underlying asset\n     * @param expiry The expiry of the XYT token\n     * @param user Interest receiver Address\n     * @param amount The amount of interest claimed\n     **/\n    event DueInterestsSettled(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        uint256 amount,\n        uint256 forgeFeeAmount,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted when forge fee is withdrawn\n     * @param forgeId The forgeId\n     * @param underlyingAsset the address of the underlying asset\n     * @param expiry The expiry of the XYT token\n     * @param amount The amount of interest claimed\n     **/\n    event ForgeFeeWithdrawn(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        uint256 amount\n    );\n\n    function setUpEmergencyMode(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address spender\n    ) external;\n\n    function newYieldContracts(address underlyingAsset, uint256 expiry)\n        external\n        returns (address ot, address xyt);\n\n    function redeemAfterExpiry(\n        address user,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (uint256 redeemedAmount);\n\n    function redeemDueInterests(\n        address user,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (uint256 interests);\n\n    function updateDueInterests(\n        address underlyingAsset,\n        uint256 expiry,\n        address user\n    ) external;\n\n    function updatePendingRewards(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) external;\n\n    function redeemUnderlying(\n        address user,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToRedeem\n    ) external returns (uint256 redeemedAmount);\n\n    function mintOtAndXyt(\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToTokenize,\n        address to\n    )\n        external\n        returns (\n            address ot,\n            address xyt,\n            uint256 amountTokenMinted\n        );\n\n    function withdrawForgeFee(address underlyingAsset, uint256 expiry) external;\n\n    function getYieldBearingToken(address underlyingAsset) external returns (address);\n\n    /**\n     * @notice Gets a reference to the PendleRouter contract.\n     * @return Returns the router contract reference.\n     **/\n    function router() external view returns (IPendleRouter);\n\n    function data() external view returns (IPendleData);\n\n    function rewardManager() external view returns (IPendleRewardManager);\n\n    function yieldContractDeployer() external view returns (IPendleYieldContractDeployer);\n\n    function rewardToken() external view returns (IERC20);\n\n    /**\n     * @notice Gets the bytes32 ID of the forge.\n     * @return Returns the forge and protocol identifier.\n     **/\n    function forgeId() external view returns (bytes32);\n\n    function dueInterests(\n        address _underlyingAsset,\n        uint256 expiry,\n        address _user\n    ) external view returns (uint256);\n\n    function yieldTokenHolders(address _underlyingAsset, uint256 _expiry)\n        external\n        view\n        returns (address yieldTokenHolder);\n}\n"
    },
    "contracts/interfaces/IPendleLiquidityMining.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\ninterface IPendleLiquidityMining {\n    event Funded(uint256[] _rewards, uint256 numberOfEpochs);\n    event RewardsToppedUp(uint256[] _epochIds, uint256[] _rewards);\n    event AllocationSettingSet(uint256[] _expiries, uint256[] _allocationNumerators);\n    event Staked(uint256 expiry, address user, uint256 amount);\n    event Withdrawn(uint256 expiry, address user, uint256 amount);\n    event PendleRewardsSettled(uint256 expiry, address user, uint256 amount);\n\n    /**\n     * @notice fund new epochs\n     */\n    function fund(uint256[] calldata rewards) external;\n\n    /**\n    @notice top up rewards for any funded future epochs (but not to create new epochs)\n    */\n    function topUpRewards(uint256[] calldata _epochIds, uint256[] calldata _rewards) external;\n\n    /**\n     * @notice Stake an exact amount of LP_expiry\n     */\n    function stake(uint256 expiry, uint256 amount) external returns (address);\n\n    /**\n     * @notice Stake an exact amount of LP_expiry, using a permit\n     */\n    function stakeWithPermit(\n        uint256 expiry,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (address);\n\n    /**\n     * @notice Withdraw an exact amount of LP_expiry\n     */\n    function withdraw(uint256 expiry, uint256 amount) external;\n\n    /**\n     * @notice Get the pending rewards for a user\n     * @return rewards Returns rewards[0] as the rewards available now, as well as rewards\n     that can be claimed for subsequent epochs (size of rewards array is numberOfEpochs)\n     */\n    function redeemRewards(uint256 expiry, address user) external returns (uint256 rewards);\n\n    /**\n     * @notice Get the pending LP interests for a staker\n     * @return dueInterests Returns the interest amount\n     */\n    function redeemLpInterests(uint256 expiry, address user)\n        external\n        returns (uint256 dueInterests);\n\n    /**\n     * @notice Let the liqMiningEmergencyHandler call to approve spender to spend tokens from liqMiningContract\n     *          and to spend tokensForLpHolder from the respective lp holders for expiries specified\n     */\n    function setUpEmergencyMode(uint256[] calldata expiries, address spender) external;\n\n    /**\n     * @notice Read the all the expiries that user has staked LP for\n     */\n    function readUserExpiries(address user) external view returns (uint256[] memory expiries);\n\n    /**\n     * @notice Read the amount of LP_expiry staked for a user\n     */\n    function getBalances(uint256 expiry, address user) external view returns (uint256);\n\n    function lpHolderForExpiry(uint256 expiry) external view returns (address);\n\n    function startTime() external view returns (uint256);\n\n    function epochDuration() external view returns (uint256);\n\n    function totalRewardsForEpoch(uint256) external view returns (uint256);\n\n    function numberOfEpochs() external view returns (uint256);\n\n    function vestingEpochs() external view returns (uint256);\n\n    function baseToken() external view returns (address);\n\n    function underlyingAsset() external view returns (address);\n\n    function underlyingYieldToken() external view returns (address);\n\n    function pendleTokenAddress() external view returns (address);\n\n    function marketFactoryId() external view returns (bytes32);\n\n    function forgeId() external view returns (bytes32);\n\n    function forge() external view returns (address);\n\n    function readAllExpiriesLength() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPendleYieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IPendleBaseToken.sol\";\nimport \"./IPendleForge.sol\";\n\ninterface IPendleYieldToken is IERC20, IPendleBaseToken {\n    /**\n     * @notice Emitted when burning OT or XYT tokens.\n     * @param user The address performing the burn.\n     * @param amount The amount to be burned.\n     **/\n    event Burn(address indexed user, uint256 amount);\n\n    /**\n     * @notice Emitted when minting OT or XYT tokens.\n     * @param user The address performing the mint.\n     * @param amount The amount to be minted.\n     **/\n    event Mint(address indexed user, uint256 amount);\n\n    /**\n     * @notice Burns OT or XYT tokens from user, reducing the total supply.\n     * @param user The address performing the burn.\n     * @param amount The amount to be burned.\n     **/\n    function burn(address user, uint256 amount) external;\n\n    /**\n     * @notice Mints new OT or XYT tokens for user, increasing the total supply.\n     * @param user The address to send the minted tokens.\n     * @param amount The amount to be minted.\n     **/\n    function mint(address user, uint256 amount) external;\n\n    /**\n     * @notice Gets the forge address of the PendleForge contract for this yield token.\n     * @return Retuns the forge address.\n     **/\n    function forge() external view returns (IPendleForge);\n\n    /**\n     * @notice Returns the address of the underlying asset.\n     * @return Returns the underlying asset address.\n     **/\n    function underlyingAsset() external view returns (address);\n\n    /**\n     * @notice Returns the address of the underlying yield token.\n     * @return Returns the underlying yield token address.\n     **/\n    function underlyingYieldToken() external view returns (address);\n\n    /**\n     * @notice let the router approve itself to spend OT/XYT/LP from any wallet\n     * @param user user to approve\n     **/\n    function approveRouter(address user) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/interfaces/IPendleData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"./IPendleRouter.sol\";\nimport \"./IPendleYieldToken.sol\";\nimport \"./IPendlePausingManager.sol\";\nimport \"./IPendleMarket.sol\";\n\ninterface IPendleData {\n    /**\n     * @notice Emitted when validity of a forge-factory pair is updated\n     * @param _forgeId the forge id\n     * @param _marketFactoryId the market factory id\n     * @param _valid valid or not\n     **/\n    event ForgeFactoryValiditySet(bytes32 _forgeId, bytes32 _marketFactoryId, bool _valid);\n\n    /**\n     * @notice Emitted when Pendle and PendleFactory addresses have been updated.\n     * @param treasury The address of the new treasury contract.\n     **/\n    event TreasurySet(address treasury);\n\n    /**\n     * @notice Emitted when LockParams is changed\n     **/\n    event LockParamsSet(uint256 lockNumerator, uint256 lockDenominator);\n\n    /**\n     * @notice Emitted when ExpiryDivisor is changed\n     **/\n    event ExpiryDivisorSet(uint256 expiryDivisor);\n\n    /**\n     * @notice Emitted when forge fee is changed\n     **/\n    event ForgeFeeSet(uint256 forgeFee);\n\n    /**\n     * @notice Emitted when interestUpdateRateDeltaForMarket is changed\n     * @param interestUpdateRateDeltaForMarket new interestUpdateRateDeltaForMarket setting\n     **/\n    event InterestUpdateRateDeltaForMarketSet(uint256 interestUpdateRateDeltaForMarket);\n\n    /**\n     * @notice Emitted when market fees are changed\n     * @param _swapFee new swapFee setting\n     * @param _protocolSwapFee new protocolSwapFee setting\n     **/\n    event MarketFeesSet(uint256 _swapFee, uint256 _protocolSwapFee);\n\n    /**\n     * @notice Emitted when the curve shift block delta is changed\n     * @param _blockDelta new block delta setting\n     **/\n    event CurveShiftBlockDeltaSet(uint256 _blockDelta);\n\n    /**\n     * @dev Emitted when new forge is added\n     * @param marketFactoryId Human Readable Market Factory ID in Bytes\n     * @param marketFactoryAddress The Market Factory Address\n     */\n    event NewMarketFactory(bytes32 indexed marketFactoryId, address indexed marketFactoryAddress);\n\n    /**\n     * @notice Set/update validity of a forge-factory pair\n     * @param _forgeId the forge id\n     * @param _marketFactoryId the market factory id\n     * @param _valid valid or not\n     **/\n    function setForgeFactoryValidity(\n        bytes32 _forgeId,\n        bytes32 _marketFactoryId,\n        bool _valid\n    ) external;\n\n    /**\n     * @notice Sets the PendleTreasury contract addresses.\n     * @param newTreasury Address of new treasury contract.\n     **/\n    function setTreasury(address newTreasury) external;\n\n    /**\n     * @notice Gets a reference to the PendleRouter contract.\n     * @return Returns the router contract reference.\n     **/\n    function router() external view returns (IPendleRouter);\n\n    /**\n     * @notice Gets a reference to the PendleRouter contract.\n     * @return Returns the router contract reference.\n     **/\n    function pausingManager() external view returns (IPendlePausingManager);\n\n    /**\n     * @notice Gets the treasury contract address where fees are being sent to.\n     * @return Address of the treasury contract.\n     **/\n    function treasury() external view returns (address);\n\n    /***********\n     *  FORGE  *\n     ***********/\n\n    /**\n     * @notice Emitted when a forge for a protocol is added.\n     * @param forgeId Forge and protocol identifier.\n     * @param forgeAddress The address of the added forge.\n     **/\n    event ForgeAdded(bytes32 indexed forgeId, address indexed forgeAddress);\n\n    /**\n     * @notice Adds a new forge for a protocol.\n     * @param forgeId Forge and protocol identifier.\n     * @param forgeAddress The address of the added forge.\n     **/\n    function addForge(bytes32 forgeId, address forgeAddress) external;\n\n    /**\n     * @notice Store new OT and XYT details.\n     * @param forgeId Forge and protocol identifier.\n     * @param ot The address of the new XYT.\n     * @param xyt The address of the new XYT.\n     * @param underlyingAsset Token address of the underlying asset.\n     * @param expiry Yield contract expiry in epoch time.\n     **/\n    function storeTokens(\n        bytes32 forgeId,\n        address ot,\n        address xyt,\n        address underlyingAsset,\n        uint256 expiry\n    ) external;\n\n    /**\n     * @notice Set a new forge fee\n     * @param _forgeFee new forge fee\n     **/\n    function setForgeFee(uint256 _forgeFee) external;\n\n    /**\n     * @notice Gets the OT and XYT tokens.\n     * @param forgeId Forge and protocol identifier.\n     * @param underlyingYieldToken Token address of the underlying yield token.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return ot The OT token references.\n     * @return xyt The XYT token references.\n     **/\n    function getPendleYieldTokens(\n        bytes32 forgeId,\n        address underlyingYieldToken,\n        uint256 expiry\n    ) external view returns (IPendleYieldToken ot, IPendleYieldToken xyt);\n\n    /**\n     * @notice Gets a forge given the identifier.\n     * @param forgeId Forge and protocol identifier.\n     * @return forgeAddress Returns the forge address.\n     **/\n    function getForgeAddress(bytes32 forgeId) external view returns (address forgeAddress);\n\n    /**\n     * @notice Checks if an XYT token is valid.\n     * @param forgeId The forgeId of the forge.\n     * @param underlyingAsset Token address of the underlying asset.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return True if valid, false otherwise.\n     **/\n    function isValidXYT(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external view returns (bool);\n\n    /**\n     * @notice Checks if an OT token is valid.\n     * @param forgeId The forgeId of the forge.\n     * @param underlyingAsset Token address of the underlying asset.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return True if valid, false otherwise.\n     **/\n    function isValidOT(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external view returns (bool);\n\n    function validForgeFactoryPair(bytes32 _forgeId, bytes32 _marketFactoryId)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Gets a reference to a specific OT.\n     * @param forgeId Forge and protocol identifier.\n     * @param underlyingYieldToken Token address of the underlying yield token.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return ot Returns the reference to an OT.\n     **/\n    function otTokens(\n        bytes32 forgeId,\n        address underlyingYieldToken,\n        uint256 expiry\n    ) external view returns (IPendleYieldToken ot);\n\n    /**\n     * @notice Gets a reference to a specific XYT.\n     * @param forgeId Forge and protocol identifier.\n     * @param underlyingAsset Token address of the underlying asset\n     * @param expiry Yield contract expiry in epoch time.\n     * @return xyt Returns the reference to an XYT.\n     **/\n    function xytTokens(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external view returns (IPendleYieldToken xyt);\n\n    /***********\n     *  MARKET *\n     ***********/\n\n    event MarketPairAdded(address indexed market, address indexed xyt, address indexed token);\n\n    function addMarketFactory(bytes32 marketFactoryId, address marketFactoryAddress) external;\n\n    function isMarket(address _addr) external view returns (bool result);\n\n    function isXyt(address _addr) external view returns (bool result);\n\n    function addMarket(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        address market\n    ) external;\n\n    function setMarketFees(uint256 _swapFee, uint256 _protocolSwapFee) external;\n\n    function setInterestUpdateRateDeltaForMarket(uint256 _interestUpdateRateDeltaForMarket)\n        external;\n\n    function setLockParams(uint256 _lockNumerator, uint256 _lockDenominator) external;\n\n    function setExpiryDivisor(uint256 _expiryDivisor) external;\n\n    function setCurveShiftBlockDelta(uint256 _blockDelta) external;\n\n    /**\n     * @notice Displays the number of markets currently existing.\n     * @return Returns markets length,\n     **/\n    function allMarketsLength() external view returns (uint256);\n\n    function forgeFee() external view returns (uint256);\n\n    function interestUpdateRateDeltaForMarket() external view returns (uint256);\n\n    function expiryDivisor() external view returns (uint256);\n\n    function lockNumerator() external view returns (uint256);\n\n    function lockDenominator() external view returns (uint256);\n\n    function swapFee() external view returns (uint256);\n\n    function protocolSwapFee() external view returns (uint256);\n\n    function curveShiftBlockDelta() external view returns (uint256);\n\n    function getMarketByIndex(uint256 index) external view returns (address market);\n\n    /**\n     * @notice Gets a market given a future yield token and an ERC20 token.\n     * @param xyt Token address of the future yield token as base asset.\n     * @param token Token address of an ERC20 token as quote asset.\n     * @return market Returns the market address.\n     **/\n    function getMarket(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token\n    ) external view returns (address market);\n\n    /**\n     * @notice Gets a market factory given the identifier.\n     * @param marketFactoryId MarketFactory identifier.\n     * @return marketFactoryAddress Returns the factory address.\n     **/\n    function getMarketFactoryAddress(bytes32 marketFactoryId)\n        external\n        view\n        returns (address marketFactoryAddress);\n\n    function getMarketFromKey(\n        address xyt,\n        address token,\n        bytes32 marketFactoryId\n    ) external view returns (address market);\n}\n"
    },
    "contracts/libraries/PendleStructs.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.7.6;\n\nstruct TokenReserve {\n    uint256 weight;\n    uint256 balance;\n}\n\nstruct PendingTransfer {\n    uint256 amount;\n    bool isOut;\n}\n"
    },
    "contracts/interfaces/IPendleMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"./IPendleRouter.sol\";\n\ninterface IPendleMarketFactory {\n    /**\n     * @notice Creates a market given a protocol ID, future yield token, and an ERC20 token.\n     * @param xyt Token address of the futuonlyCorere yield token as base asset.\n     * @param token Token address of an ERC20 token as quote asset.\n     * @return market Returns the address of the newly created market.\n     **/\n    function createMarket(address xyt, address token) external returns (address market);\n\n    /**\n     * @notice Gets a reference to the PendleRouter contract.\n     * @return Returns the router contract reference.\n     **/\n    function router() external view returns (IPendleRouter);\n\n    function marketFactoryId() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IPendlePausingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\ninterface IPendlePausingManager {\n    event AddPausingAdmin(address admin);\n    event RemovePausingAdmin(address admin);\n    event PendingForgeEmergencyHandler(address _pendingForgeHandler);\n    event PendingMarketEmergencyHandler(address _pendingMarketHandler);\n    event PendingLiqMiningEmergencyHandler(address _pendingLiqMiningHandler);\n    event ForgeEmergencyHandlerSet(address forgeEmergencyHandler);\n    event MarketEmergencyHandlerSet(address marketEmergencyHandler);\n    event LiqMiningEmergencyHandlerSet(address liqMiningEmergencyHandler);\n\n    event PausingManagerLocked();\n    event ForgeHandlerLocked();\n    event MarketHandlerLocked();\n    event LiqMiningHandlerLocked();\n\n    event SetForgePaused(bytes32 forgeId, bool settingToPaused);\n    event SetForgeAssetPaused(bytes32 forgeId, address underlyingAsset, bool settingToPaused);\n    event SetForgeAssetExpiryPaused(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        bool settingToPaused\n    );\n\n    event SetForgeLocked(bytes32 forgeId);\n    event SetForgeAssetLocked(bytes32 forgeId, address underlyingAsset);\n    event SetForgeAssetExpiryLocked(bytes32 forgeId, address underlyingAsset, uint256 expiry);\n\n    event SetMarketFactoryPaused(bytes32 marketFactoryId, bool settingToPaused);\n    event SetMarketPaused(bytes32 marketFactoryId, address market, bool settingToPaused);\n\n    event SetMarketFactoryLocked(bytes32 marketFactoryId);\n    event SetMarketLocked(bytes32 marketFactoryId, address market);\n\n    event SetLiqMiningPaused(address liqMiningContract, bool settingToPaused);\n    event SetLiqMiningLocked(address liqMiningContract);\n\n    function forgeEmergencyHandler()\n        external\n        view\n        returns (\n            address handler,\n            address pendingHandler,\n            uint256 timelockDeadline\n        );\n\n    function marketEmergencyHandler()\n        external\n        view\n        returns (\n            address handler,\n            address pendingHandler,\n            uint256 timelockDeadline\n        );\n\n    function liqMiningEmergencyHandler()\n        external\n        view\n        returns (\n            address handler,\n            address pendingHandler,\n            uint256 timelockDeadline\n        );\n\n    function permLocked() external view returns (bool);\n\n    function permForgeHandlerLocked() external view returns (bool);\n\n    function permMarketHandlerLocked() external view returns (bool);\n\n    function permLiqMiningHandlerLocked() external view returns (bool);\n\n    function isPausingAdmin(address) external view returns (bool);\n\n    function setPausingAdmin(address admin, bool isAdmin) external;\n\n    function requestForgeHandlerChange(address _pendingForgeHandler) external;\n\n    function requestMarketHandlerChange(address _pendingMarketHandler) external;\n\n    function requestLiqMiningHandlerChange(address _pendingLiqMiningHandler) external;\n\n    function applyForgeHandlerChange() external;\n\n    function applyMarketHandlerChange() external;\n\n    function applyLiqMiningHandlerChange() external;\n\n    function lockPausingManagerPermanently() external;\n\n    function lockForgeHandlerPermanently() external;\n\n    function lockMarketHandlerPermanently() external;\n\n    function lockLiqMiningHandlerPermanently() external;\n\n    function setForgePaused(bytes32 forgeId, bool paused) external;\n\n    function setForgeAssetPaused(\n        bytes32 forgeId,\n        address underlyingAsset,\n        bool paused\n    ) external;\n\n    function setForgeAssetExpiryPaused(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        bool paused\n    ) external;\n\n    function setForgeLocked(bytes32 forgeId) external;\n\n    function setForgeAssetLocked(bytes32 forgeId, address underlyingAsset) external;\n\n    function setForgeAssetExpiryLocked(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external;\n\n    function checkYieldContractStatus(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (bool _paused, bool _locked);\n\n    function setMarketFactoryPaused(bytes32 marketFactoryId, bool paused) external;\n\n    function setMarketPaused(\n        bytes32 marketFactoryId,\n        address market,\n        bool paused\n    ) external;\n\n    function setMarketFactoryLocked(bytes32 marketFactoryId) external;\n\n    function setMarketLocked(bytes32 marketFactoryId, address market) external;\n\n    function checkMarketStatus(bytes32 marketFactoryId, address market)\n        external\n        returns (bool _paused, bool _locked);\n\n    function setLiqMiningPaused(address liqMiningContract, bool settingToPaused) external;\n\n    function setLiqMiningLocked(address liqMiningContract) external;\n\n    function checkLiqMiningStatus(address liqMiningContract)\n        external\n        returns (bool _paused, bool _locked);\n}\n"
    },
    "contracts/interfaces/IPendleMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./IPendleRouter.sol\";\nimport \"./IPendleBaseToken.sol\";\nimport \"../libraries/PendleStructs.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPendleMarket is IERC20 {\n    /**\n     * @notice Emitted when reserves pool has been updated\n     * @param reserve0 The XYT reserves.\n     * @param weight0  The XYT weight\n     * @param reserve1 The generic token reserves.\n     * For the generic Token weight it can be inferred by (2^40) - weight0\n     **/\n    event Sync(uint256 reserve0, uint256 weight0, uint256 reserve1);\n\n    function setUpEmergencyMode(address spender) external;\n\n    function bootstrap(\n        address user,\n        uint256 initialXytLiquidity,\n        uint256 initialTokenLiquidity\n    ) external returns (PendingTransfer[2] memory transfers, uint256 exactOutLp);\n\n    function addMarketLiquiditySingle(\n        address user,\n        address inToken,\n        uint256 inAmount,\n        uint256 minOutLp\n    ) external returns (PendingTransfer[2] memory transfers, uint256 exactOutLp);\n\n    function addMarketLiquidityDual(\n        address user,\n        uint256 _desiredXytAmount,\n        uint256 _desiredTokenAmount,\n        uint256 _xytMinAmount,\n        uint256 _tokenMinAmount\n    ) external returns (PendingTransfer[2] memory transfers, uint256 lpOut);\n\n    function removeMarketLiquidityDual(\n        address user,\n        uint256 inLp,\n        uint256 minOutXyt,\n        uint256 minOutToken\n    ) external returns (PendingTransfer[2] memory transfers);\n\n    function removeMarketLiquiditySingle(\n        address user,\n        address outToken,\n        uint256 exactInLp,\n        uint256 minOutToken\n    ) external returns (PendingTransfer[2] memory transfers);\n\n    function swapExactIn(\n        address inToken,\n        uint256 inAmount,\n        address outToken,\n        uint256 minOutAmount\n    ) external returns (uint256 outAmount, PendingTransfer[2] memory transfers);\n\n    function swapExactOut(\n        address inToken,\n        uint256 maxInAmount,\n        address outToken,\n        uint256 outAmount\n    ) external returns (uint256 inAmount, PendingTransfer[2] memory transfers);\n\n    function redeemLpInterests(address user) external returns (uint256 interests);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256 xytBalance,\n            uint256 xytWeight,\n            uint256 tokenBalance,\n            uint256 tokenWeight,\n            uint256 currentBlock\n        );\n\n    function factoryId() external view returns (bytes32);\n\n    function token() external view returns (address);\n\n    function xyt() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IPendleBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPendleBaseToken is IERC20 {\n    /**\n     * @notice Decreases the allowance granted to spender by the caller.\n     * @param spender The address to reduce the allowance from.\n     * @param subtractedValue The amount allowance to subtract.\n     * @return Returns true if allowance has decreased, otherwise false.\n     **/\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    /**\n     * @notice The yield contract start in epoch time.\n     * @return Returns the yield start date.\n     **/\n    function start() external view returns (uint256);\n\n    /**\n     * @notice The yield contract expiry in epoch time.\n     * @return Returns the yield expiry date.\n     **/\n    function expiry() external view returns (uint256);\n\n    /**\n     * @notice Increases the allowance granted to spender by the caller.\n     * @param spender The address to increase the allowance from.\n     * @param addedValue The amount allowance to add.\n     * @return Returns true if allowance has increased, otherwise false\n     **/\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    /**\n     * @notice Returns the number of decimals the token uses.\n     * @return Returns the token's decimals.\n     **/\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Returns the name of the token.\n     * @return Returns the token's name.\n     **/\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @return Returns the token's symbol.\n     **/\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice approve using the owner's signature\n     **/\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPendleRewardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\ninterface IPendleRewardManager {\n    event UpdateFrequencySet(address[], uint256[]);\n    event SkippingRewardsSet(bool);\n\n    event DueRewardsSettled(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountOut,\n        address user\n    );\n\n    function redeemRewards(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) external returns (uint256 dueRewards);\n\n    function updatePendingRewards(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) external;\n\n    function updateParamLManual(address _underlyingAsset, uint256 _expiry) external;\n\n    function setUpdateFrequency(\n        address[] calldata underlyingAssets,\n        uint256[] calldata frequencies\n    ) external;\n\n    function setSkippingRewards(bool skippingRewards) external;\n\n    function forgeId() external returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IPendleYieldContractDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\ninterface IPendleYieldContractDeployer {\n    function forgeId() external returns (bytes32);\n\n    function forgeOwnershipToken(\n        address _underlyingAsset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _expiry\n    ) external returns (address ot);\n\n    function forgeFutureYieldToken(\n        address _underlyingAsset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _expiry\n    ) external returns (address xyt);\n\n    function deployYieldTokenHolder(address yieldToken, uint256 expiry)\n        external\n        returns (address yieldTokenHolder);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}