{{
  "language": "Solidity",
  "sources": {
    "contracts/variants/PalPoolStkAave.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\npragma abicoder v2;\n//SPDX-License-Identifier: MIT\n\nimport \"../PalPool.sol\";\nimport \"../utils/SafeMath.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../utils/IERC20.sol\";\nimport \"../tokens/AAVE/IStakedAave.sol\";\nimport {Errors} from  \"../utils/Errors.sol\";\n\n\n\n/** @title PalPoolStkAave Pool contract  */\n/// @author Paladin\ncontract PalPoolStkAave is PalPool {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    /** @dev stkAAVE token address */\n    address private immutable stkAaveAddress;\n    /** @dev AAVE token address */\n    address private immutable aaveAddress;\n    /** @dev Block number of the last reward claim */\n    uint public claimBlockNumber = 0;\n\n\n    constructor( \n        address _palToken,\n        address _controller, \n        address _underlying,\n        address _interestModule,\n        address _delegator,\n        address _palLoanToken,\n        address _aaveAddress\n    ) PalPool(\n            _palToken, \n            _controller,\n            _underlying,\n            _interestModule,\n            _delegator,\n            _palLoanToken\n        )\n    {\n        stkAaveAddress = _underlying;\n        aaveAddress = _aaveAddress;\n    }\n\n\n    /**\n    * @dev Claim AAVE tokens from the AAVE Safety Module and stake them back in the Module\n    * @return bool : Success\n    */\n    function claimFromAave() internal returns(bool) {\n        //Load contracts\n        IERC20 _aave = IERC20(aaveAddress);\n        IStakedAave _stkAave = IStakedAave(stkAaveAddress);\n\n        //Get pending rewards amount\n        uint _pendingRewards = _stkAave.getTotalRewardsBalance(address(this));\n\n        //If there is reward to claim\n        if(_pendingRewards > 0 && claimBlockNumber != block.number){\n\n            //claim the AAVE tokens\n            _stkAave.claimRewards(address(this), _pendingRewards);\n\n            //Stake the AAVE tokens to get stkAAVE tokens\n            uint _toStakeAmount = _aave.balanceOf(address(this));\n            _aave.safeApprove(stkAaveAddress, _toStakeAmount);\n            _stkAave.stake(address(this), _toStakeAmount);\n\n            //update the block number\n            claimBlockNumber = block.number;\n\n            return true;\n        }\n        return true;\n    }\n\n\n    /**\n    * @notice Deposit underlying in the Pool\n    * @dev Deposit underlying, and mints palToken for the user\n    * @param _amount Amount of underlying to deposit\n    * @return bool : amount of minted palTokens\n    */\n    function deposit(uint _amount) public override(PalPool) returns(uint){\n        require(claimFromAave());\n        return super.deposit(_amount);\n    }\n\n    /**\n    * @notice Withdraw underliyng token from the Pool\n    * @dev Transfer underlying token to the user, and burn the corresponding palToken amount\n    * @param _amount Amount of palToken to return\n    * @return uint : amount of underlying returned\n    */\n    function withdraw(uint _amount) public override(PalPool) returns(uint){\n        require(claimFromAave());\n        return super.withdraw(_amount);\n    }\n\n    /**\n    * @dev Create a Borrow, deploy a Loan Pool and delegate voting power\n    * @param _delegatee Address to delegate the voting power to\n    * @param _amount Amount of underlying to borrow\n    * @param _feeAmount Amount of fee to pay to start the loan\n    * @return uint : amount of paid fees\n    */\n    function borrow(address _delegatee, uint _amount, uint _feeAmount) public override(PalPool) returns(uint){\n        require(claimFromAave());\n        return super.borrow(_delegatee, _amount, _feeAmount);\n    }\n\n    /**\n    * @notice Transfer the new fees to the Loan, and expand the Loan\n    * @param _loan Address of the Loan\n    * @param _feeAmount New amount of fees to pay\n    * @return bool : Amount of fees paid\n    */\n    function expandBorrow(address _loan, uint _feeAmount) public override(PalPool) returns(uint){\n        require(claimFromAave());\n        return super.expandBorrow(_loan, _feeAmount);\n    }\n\n    /**\n    * @notice Close a Loan, and return the non-used fees to the Borrower.\n    * If closed before the minimum required length, penalty fees are taken to the non-used fees\n    * @dev Close a Loan, and return the non-used fees to the Borrower\n    * @param _loan Address of the Loan\n    */\n    function closeBorrow(address _loan) public override(PalPool) {\n        require(claimFromAave());\n        super.closeBorrow(_loan);\n    }\n\n    /**\n    * @notice Kill a non-healthy Loan to collect rewards\n    * @dev Kill a non-healthy Loan to collect rewards\n    * @param _loan Address of the Loan\n    */\n    function killBorrow(address _loan) public override(PalPool) {\n        require(claimFromAave());\n        super.killBorrow(_loan);\n    }\n\n\n    function changeBorrowDelegatee(address _loan, address _newDelegatee) public override(PalPool) {\n        require(claimFromAave());\n        super.changeBorrowDelegatee(_loan, _newDelegatee);\n    }\n}"
    },
    "contracts/PalPool.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\npragma abicoder v2;\n//SPDX-License-Identifier: MIT\n\nimport \"./utils/SafeMath.sol\";\nimport \"./utils/SafeERC20.sol\";\nimport \"./utils/Clones.sol\";\nimport \"./IPalPool.sol\";\nimport \"./PalPoolStorage.sol\";\nimport \"./IPalLoan.sol\";\n//import \"./PalLoan.sol\";\nimport \"./IPalToken.sol\";\nimport \"./IPaladinController.sol\";\nimport \"./IPalLoanToken.sol\";\nimport \"./interests/InterestInterface.sol\";\nimport \"./utils/IERC20.sol\";\nimport \"./utils/Admin.sol\";\nimport \"./utils/ReentrancyGuard.sol\";\nimport {Errors} from  \"./utils/Errors.sol\";\n\n\n\n/** @title PalPool contract  */\n/// @author Paladin\ncontract PalPool is IPalPool, PalPoolStorage, Admin, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n\n    modifier controllerOnly() {\n        //allows only the Controller and the admin to call the function\n        require(msg.sender == admin || msg.sender == address(controller), Errors.CALLER_NOT_CONTROLLER);\n        _;\n    }\n\n\n\n    //Functions\n\n    constructor(\n        address _palToken,\n        address _controller, \n        address _underlying,\n        address _interestModule,\n        address _delegator,\n        address _palLoanToken\n    ){\n        //Set admin\n        admin = msg.sender;\n\n        //Set inital values & modules\n        palToken = IPalToken(_palToken);\n        controller = IPaladinController(_controller);\n        underlying = IERC20(_underlying);\n        accrualBlockNumber = block.number;\n        interestModule = InterestInterface(_interestModule);\n        borrowIndex = 1e36;\n        delegator = _delegator;\n        palLoanToken = IPalLoanToken(_palLoanToken);\n    }\n\n    /**\n    * @notice Get the underlying balance for this Pool\n    * @dev Get the underlying balance of this Pool\n    * @return uint : balance of this pool in the underlying token\n    */\n    function underlyingBalance() public view returns(uint){\n        //Return the balance of this contract for the underlying asset\n        return underlying.balanceOf(address(this));\n    }\n\n    /**\n    * @notice Deposit underlying in the Pool\n    * @dev Deposit underlying, and mints palToken for the user\n    * @param _amount Amount of underlying to deposit\n    * @return bool : amount of minted palTokens\n    */\n    function deposit(uint _amount) public virtual override nonReentrant returns(uint){\n        require(_updateInterest());\n\n        //Retrieve the current exchange rate palToken:underlying\n        uint _exchRate = _exchangeRate();\n\n\n        //Find the amount to mint depending on the amount to transfer\n        uint _num = _amount.mul(mantissaScale);\n        uint _toMint = _num.div(_exchRate);\n\n        //Transfer the underlying to this contract\n        //The amount of underlying needs to be approved before\n        underlying.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //Mint the palToken\n        require(palToken.mint(msg.sender, _toMint), Errors.FAIL_MINT);\n\n        //Emit the Deposit event\n        emit Deposit(msg.sender, _amount, address(this));\n\n        //Use the controller to check if the minting was successfull\n        require(controller.depositVerify(address(this), msg.sender, _toMint), Errors.FAIL_DEPOSIT);\n\n        return _toMint;\n    }\n\n    /**\n    * @notice Withdraw underliyng token from the Pool\n    * @dev Transfer underlying token to the user, and burn the corresponding palToken amount\n    * @param _amount Amount of palToken to return\n    * @return uint : amount of underlying returned\n    */\n    function withdraw(uint _amount) public virtual override nonReentrant returns(uint){\n        require(_updateInterest());\n        require(balanceOf(msg.sender) >= _amount, Errors.INSUFFICIENT_BALANCE);\n\n        //Retrieve the current exchange rate palToken:underlying\n        uint _exchRate = _exchangeRate();\n\n        //Find the amount to return depending on the amount of palToken to burn\n        uint _num = _amount.mul(_exchRate);\n        uint _toReturn = _num.div(mantissaScale);\n\n        //Check if the pool has enough underlying to return\n        require(_toReturn <= underlyingBalance(), Errors.INSUFFICIENT_CASH);\n\n        //Burn the corresponding palToken amount\n        require(palToken.burn(msg.sender, _amount), Errors.FAIL_BURN);\n\n        //Make the underlying transfer\n        underlying.safeTransfer(msg.sender, _toReturn);\n\n        //Use the controller to check if the burning was successfull\n        require(controller.withdrawVerify(address(this), msg.sender, _toReturn), Errors.FAIL_WITHDRAW);\n\n        //Emit the Withdraw event\n        emit Withdraw(msg.sender, _amount, address(this));\n\n        return _toReturn;\n    }\n\n    /**\n    * @dev Create a Borrow, deploy a Loan Pool and delegate voting power\n    * @param _delegatee Address to delegate the voting power to\n    * @param _amount Amount of underlying to borrow\n    * @param _feeAmount Amount of fee to pay to start the loan\n    * @return uint : new PalLoanToken Id\n    */\n    function borrow(address _delegatee, uint _amount, uint _feeAmount) public virtual override nonReentrant returns(uint){\n        //Need the pool to have enough liquidity, and the interests to be up to date\n        require(_amount < underlyingBalance(), Errors.INSUFFICIENT_CASH);\n        require(_delegatee != address(0), Errors.ZERO_ADDRESS);\n        require(_amount > 0, Errors.ZERO_BORROW);\n        require(_feeAmount >= minBorrowFees(_amount), Errors.BORROW_INSUFFICIENT_FEES);\n        require(_updateInterest());\n\n        address _borrower = msg.sender;\n\n        //Update Total Borrowed\n        totalBorrowed = totalBorrowed.add(_amount);\n\n        IPalLoan _newLoan = IPalLoan(Clones.clone(delegator));\n\n        //Send the borrowed amount of underlying tokens to the Loan\n        underlying.safeTransfer(address(_newLoan), _amount);\n\n        //And transfer the fees from the Borrower to the Loan\n        underlying.safeTransferFrom(_borrower, address(_newLoan), _feeAmount);\n\n        //Start the Loan (and delegate voting power)\n        require(_newLoan.initiate(\n            address(this),\n            _borrower,\n            address(underlying),\n            _delegatee,\n            _amount,\n            _feeAmount\n        ), Errors.FAIL_LOAN_INITIATE);\n\n        //Add the new Loan to mappings\n        loans.push(address(_newLoan));\n\n        //Mint the palLoanToken linked to this new Loan\n        uint256 _newTokenId = palLoanToken.mint(_borrower, address(this), address(_newLoan));\n\n        //New Borrow struct for this Loan\n        loanToBorrow[address(_newLoan)] = Borrow(\n            _newTokenId,\n            _delegatee,\n            address(_newLoan),\n            _amount,\n            address(underlying),\n            _feeAmount,\n            0,\n            borrowIndex,\n            block.number,\n            0,\n            false,\n            false\n        );\n\n        //Check the borrow succeeded\n        require(\n            controller.borrowVerify(address(this), _borrower, _delegatee, _amount, _feeAmount, address(_newLoan)), \n            Errors.FAIL_BORROW\n        );\n\n        //Emit the NewLoan Event\n        emit NewLoan(\n            _borrower,\n            _delegatee,\n            address(underlying),\n            _amount,\n            address(this),\n            address(_newLoan),\n            _newTokenId,\n            block.number\n        );\n\n        //Return the PalLoanToken Id\n        return _newTokenId;\n    }\n\n    /**\n    * @notice Transfer the new fees to the Loan, and expand the Loan\n    * @param _loan Address of the Loan\n    * @param _feeAmount New amount of fees to pay\n    * @return bool : Amount of fees paid\n    */\n    function expandBorrow(address _loan, uint _feeAmount) public virtual override nonReentrant returns(uint){\n        //Fetch the corresponding Borrow\n        //And check that the caller is the Borrower, and the Loan is still active\n        Borrow storage _borrow = loanToBorrow[_loan];\n        require(!_borrow.closed, Errors.LOAN_CLOSED);\n        require(isLoanOwner(_loan, msg.sender), Errors.NOT_LOAN_OWNER);\n        require(_feeAmount > 0);\n        require(_updateInterest());\n        \n        //Load the Loan Pool contract & get Loan owner\n        IPalLoan _palLoan = IPalLoan(_borrow.loan);\n\n        address _loanOwner = palLoanToken.ownerOf(_borrow.tokenId);\n\n        _borrow.feesAmount = _borrow.feesAmount.add(_feeAmount);\n\n        //Transfer the new fees to the Loan\n        //If success, call the expand function of the Loan\n        underlying.safeTransferFrom(_loanOwner, _borrow.loan, _feeAmount);\n\n        require(_palLoan.expand(_feeAmount), Errors.FAIL_LOAN_EXPAND);\n\n        emit ExpandLoan(\n            _loanOwner,\n            _borrow.delegatee,\n            address(underlying),\n            address(this),\n            _borrow.feesAmount,\n            _borrow.loan,\n            _borrow.tokenId\n        );\n\n        return _feeAmount;\n    }\n\n    /**\n    * @notice Close a Loan, and return the non-used fees to the Borrower.\n    * If closed before the minimum required length, penalty fees are taken to the non-used fees\n    * @dev Close a Loan, and return the non-used fees to the Borrower\n    * @param _loan Address of the Loan\n    */\n    function closeBorrow(address _loan) public virtual override nonReentrant {\n        //Fetch the corresponding Borrow\n        //And check that the caller is the Borrower, and the Loan is still active\n        Borrow storage _borrow = loanToBorrow[_loan];\n        require(!_borrow.closed, Errors.LOAN_CLOSED);\n        require(isLoanOwner(_loan, msg.sender), Errors.NOT_LOAN_OWNER);\n        require(_updateInterest());\n\n        //Get Loan owner from the ERC721 contract\n        address _loanOwner = palLoanToken.ownerOf(_borrow.tokenId);\n\n        //Load the Loan contract\n        IPalLoan _palLoan = IPalLoan(_borrow.loan);\n\n        //Calculates the amount of fees used\n        uint _feesUsed = (_borrow.amount.mul(borrowIndex).div(_borrow.borrowIndex)).sub(_borrow.amount);\n        uint _penaltyFees = 0;\n        uint _totalFees = _feesUsed;\n\n        //If the Borrow is closed before the minimum length, calculates the penalty fees to pay\n        // -> Number of block remaining to complete the minimum length * current Borrow Rate\n        if(block.number < (_borrow.startBlock.add(minBorrowLength))){\n            uint _currentBorrowRate = interestModule.getBorrowRate(address(this), underlyingBalance(), totalBorrowed, totalReserve);\n            uint _missingBlocks = (_borrow.startBlock.add(minBorrowLength)).sub(block.number);\n            _penaltyFees = _missingBlocks.mul(_borrow.amount.mul(_currentBorrowRate)).div(mantissaScale);\n            _totalFees = _totalFees.add(_penaltyFees);\n        }\n    \n        //Security so the Borrow can be closed if there are no more fees\n        //(if the Borrow wasn't Killed yet, or the loan is closed before minimum time, and already paid fees aren't enough)\n        if(_totalFees > _borrow.feesAmount){\n            _totalFees = _borrow.feesAmount;\n        }\n\n        //Set the Borrow as closed\n        _borrow.closed = true;\n        _borrow.feesUsed = _totalFees;\n        _borrow.closeBlock = block.number;\n\n        //Remove the borrowed tokens + fees from the TotalBorrowed\n        //Add to the Reserve the reserveFactor of Penalty Fees (if there is Penalty Fees)\n        //And add the fees counted as potential Killer Fees to the Accrued Fees, since no killing was necessary\n        totalBorrowed = totalBorrowed.sub((_borrow.amount).add(_feesUsed));\n        uint _realPenaltyFees = _totalFees.sub(_feesUsed);\n        uint _killerFees = _feesUsed.mul(killerRatio).div(mantissaScale);\n        totalReserve = totalReserve.add(reserveFactor.mul(_realPenaltyFees).div(mantissaScale));\n        accruedFees = accruedFees.add(_killerFees).add(reserveFactor.mul(_realPenaltyFees).div(mantissaScale));\n        \n        //Close and destroy the loan\n        _palLoan.closeLoan(_totalFees);\n\n        //Burn the palLoanToken for this Loan\n        require(palLoanToken.burn(_borrow.tokenId), Errors.FAIL_LOAN_TOKEN_BURN);\n\n        require(controller.closeBorrowVerify(address(this), _loanOwner, _borrow.loan), Errors.FAIL_CLOSE_BORROW);\n\n        //Emit the CloseLoan Event\n        emit CloseLoan(\n            _loanOwner,\n            _borrow.delegatee,\n            address(underlying),\n            _borrow.amount,\n            address(this),\n            _totalFees,\n            _loan,\n            _borrow.tokenId,\n            false\n        );\n    }\n\n    /**\n    * @notice Kill a non-healthy Loan to collect rewards\n    * @dev Kill a non-healthy Loan to collect rewards\n    * @param _loan Address of the Loan\n    */\n    function killBorrow(address _loan) public virtual override nonReentrant {\n        address killer = msg.sender;\n        //Fetch the corresponding Borrow\n        //And check that the killer is not the Borrower, and the Loan is still active\n        Borrow storage _borrow = loanToBorrow[_loan];\n        require(!_borrow.closed, Errors.LOAN_CLOSED);\n        require(!isLoanOwner(_loan, killer), Errors.LOAN_OWNER);\n        require(_updateInterest());\n\n        //Get the owner of the Loan through the ERC721 contract\n        address _loanOwner = palLoanToken.ownerOf(_borrow.tokenId);\n\n        //Calculate the amount of fee used, and check if the Loan is killable\n        uint _feesUsed = (_borrow.amount.mul(borrowIndex).div(_borrow.borrowIndex)).sub(_borrow.amount);\n        uint _loanHealthFactor = _feesUsed.mul(uint(1e18)).div(_borrow.feesAmount);\n        require(_loanHealthFactor >= killFactor, Errors.NOT_KILLABLE);\n\n        //Load the Loan\n        IPalLoan _palLoan = IPalLoan(_borrow.loan);\n\n        //Close the Loan, and update storage variables\n        _borrow.closed = true;\n        _borrow.killed = true;\n        _borrow.feesUsed = _borrow.feesAmount;\n        _borrow.closeBlock = block.number;\n\n        //Remove the borrowed tokens + fees from the TotalBorrowed\n        //Remove the amount paid as killer fees from the Reserve, and any over accrued interest in the Reserve & AccruedFees\n        uint _overAccruedInterest = _loanHealthFactor <= mantissaScale ? 0 : _feesUsed.sub(_borrow.feesAmount);\n        uint _killerFees = (_borrow.feesAmount).mul(killerRatio).div(mantissaScale);\n        totalBorrowed = totalBorrowed.sub((_borrow.amount).add(_feesUsed));\n        totalReserve = totalReserve.sub(_killerFees).sub(_overAccruedInterest.mul(reserveFactor).div(mantissaScale));\n        accruedFees = accruedFees.sub(_overAccruedInterest.mul(reserveFactor.sub(killerRatio)).div(mantissaScale));\n\n        //Kill the Loan\n        _palLoan.killLoan(killer, killerRatio);\n\n        //Burn the palLoanToken for this Loan\n        require(palLoanToken.burn(_borrow.tokenId), Errors.FAIL_LOAN_TOKEN_BURN);\n\n        require(controller.killBorrowVerify(address(this), killer, _borrow.loan), Errors.FAIL_KILL_BORROW);\n\n        //Emit the CloseLoan Event\n        emit CloseLoan(\n            _loanOwner,\n            _borrow.delegatee,\n            address(underlying),\n            _borrow.amount,\n            address(this),\n            _borrow.feesAmount,\n            _loan,\n            _borrow.tokenId,\n            true\n        );\n    }\n\n\n\n    /**\n    * @notice Change the delegatee of a Loan, and delegate him the voting power\n    * @dev Change the delegatee in the Borrow struct and in the palLoan, then change the voting power delegation recipient\n    * @param _loan Address of the Loan\n    * @param _newDelegatee Address of the new voting power recipient\n    */\n    function changeBorrowDelegatee(address _loan, address _newDelegatee) public virtual override nonReentrant {\n        //Fetch the corresponding Borrow\n        //And check that the caller is the Borrower, and the Loan is still active\n        Borrow storage _borrow = loanToBorrow[_loan];\n        require(!_borrow.closed, Errors.LOAN_CLOSED);\n        require(_newDelegatee != address(0), Errors.ZERO_ADDRESS);\n        require(isLoanOwner(_loan, msg.sender), Errors.NOT_LOAN_OWNER);\n        require(_updateInterest());\n\n        //Load the Loan Pool contract\n        IPalLoan _palLoan = IPalLoan(_borrow.loan);\n\n        //Update storage data\n        _borrow.delegatee = _newDelegatee;\n\n        //Call the delegation logic in the palLoan to change the votong power recipient\n        require(_palLoan.changeDelegatee(_newDelegatee), Errors.FAIL_LOAN_DELEGATEE_CHANGE);\n\n        //Emit the Event\n        emit ChangeLoanDelegatee(\n            palLoanToken.ownerOf(_borrow.tokenId),\n            _newDelegatee,\n            address(underlying),\n            address(this),\n            _borrow.loan,\n            _borrow.tokenId\n        );\n\n    }\n\n\n    /**\n    * @notice Return the user's palToken balance\n    * @dev Links the PalToken balanceOf() method\n    * @param _account User address\n    * @return uint256 : user palToken balance (in wei)\n    */\n    function balanceOf(address _account) public view override returns(uint){\n        return palToken.balanceOf(_account);\n    }\n\n\n    /**\n    * @notice Return the corresponding balance of the pool underlying token depending on the user's palToken balance\n    * @param _account User address\n    * @return uint256 : corresponding balance in the underlying token (in wei)\n    */\n    function underlyingBalanceOf(address _account) external view override returns(uint){\n        uint _balance = palToken.balanceOf(_account);\n        if(_balance == 0){\n            return 0;\n        }\n        uint _exchRate = _exchangeRate();\n        uint _num = _balance.mul(_exchRate);\n        return _num.div(mantissaScale);\n    }\n\n\n    /**\n    * @notice Return true is the given address is the owner of the palLoanToken for the given palLoan\n    * @param _loanAddress Address of the Loan\n    * @param _user User address\n    * @return bool : true if owner\n    */\n    function isLoanOwner(address _loanAddress, address _user) public view override returns(bool){\n        return palLoanToken.allOwnerOf(idOfLoan(_loanAddress)) == _user;\n    }\n\n\n    /**\n    * @notice Return the token Id of the palLoanToken linked to this palLoan\n    * @param _loanAddress Address of the Loan\n    * @return uint256 : palLoanToken token Id\n    */\n    function idOfLoan(address _loanAddress) public view override returns(uint256){\n        return loanToBorrow[_loanAddress].tokenId;\n    }\n\n\n\n    /**\n    * @notice Return the list of all Loans for this Pool (closed and active)\n    * @return address[] : list of Loans\n    */\n    function getLoansPools() external view override returns(address [] memory){\n        //Return the addresses of all loans (old ones and active ones)\n        return loans;\n    }\n    \n    /**\n    * @notice Return all the Loans for a given address\n    * @param _borrower Address of the user\n    * @return address : list of Loans\n    */\n    function getLoansByBorrower(address _borrower) external view override returns(address [] memory){\n        return palLoanToken.allLoansOfForPool(_borrower, address(this));\n    }\n\n    \n    /**\n    * @notice Return the stored Borrow data for a given Loan\n    * @dev Return the Borrow data for a given Loan\n    * @param _loanAddress Address of the palLoan\n    * Composants of a Borrow struct\n    */\n    function getBorrowData(address _loanAddress) external view override returns(\n        address _borrower,\n        address _delegatee,\n        address _loan,\n        uint256 _palLoanTokenId,\n        uint _amount,\n        address _underlying,\n        uint _feesAmount,\n        uint _feesUsed,\n        uint _startBlock,\n        uint _closeBlock,\n        bool _closed,\n        bool _killed\n    ){\n        //Return the data inside a Borrow struct\n        Borrow memory _borrow = loanToBorrow[_loanAddress];\n        return (\n            //Get the Loan owner through the ERC721 contract\n            palLoanToken.allOwnerOf(_borrow.tokenId),\n            _borrow.delegatee,\n            _borrow.loan,\n            _borrow.tokenId,\n            _borrow.amount,\n            _borrow.underlying,\n            _borrow.feesAmount,\n            //Calculate amount of fees used\n            _borrow.closed ? _borrow.feesUsed : (_borrow.amount.mul(borrowIndex).div(_borrow.borrowIndex)).sub(_borrow.amount),\n            _borrow.startBlock,\n            _borrow.closeBlock,\n            _borrow.closed,\n            _borrow.killed\n        );\n\n    }\n    \n    /**\n    * @notice Get the Borrow Rate for this Pool\n    * @dev Get the Borrow Rate from the Interest Module\n    * @return uint : Borrow Rate (scale 1e18)\n    */\n    function borrowRatePerBlock() external view override returns (uint){\n        return interestModule.getBorrowRate(address(this), underlyingBalance(), totalBorrowed, totalReserve);\n    }\n    \n    /**\n    * @notice Get the Supply Rate for this Pool\n    * @dev Get the Supply Rate from the Interest Module\n    * @return uint : Supply Rate (scale 1e18)\n    */\n    function supplyRatePerBlock() external view override returns (uint){\n        return interestModule.getSupplyRate(address(this), underlyingBalance(), totalBorrowed, totalReserve, reserveFactor);\n    }\n\n    \n    /**\n    * @dev Calculates the current exchange rate\n    * @return uint : current exchange rate (scale 1e18)\n    */\n    function _exchangeRate() internal view returns (uint){\n        uint _totalSupply = palToken.totalSupply();\n        //If no palTokens where minted, use the initial exchange rate\n        if(_totalSupply == 0){\n            return initialExchangeRate;\n        }\n        else{\n            // Exchange Rate = (Cash + Borrows - Reserve) / Supply\n            uint _cash = underlyingBalance();\n            uint _availableCash = _cash.add(totalBorrowed).sub(totalReserve);\n            return _availableCash.mul(1e18).div(_totalSupply);\n        }\n    }\n\n    /**\n    * @notice Get the current exchange rate for the palToken\n    * @dev Updates interest & Calls internal function _exchangeRate\n    * @return uint : current exchange rate (scale 1e18)\n    */\n    function exchangeRateCurrent() external override returns (uint){\n        _updateInterest();\n        return _exchangeRate();\n    }\n    \n    /**\n    * @notice Get the stored exchange rate for the palToken\n    * @dev Calls internal function _exchangeRate\n    * @return uint : current exchange rate (scale 1e18)\n    */\n    function exchangeRateStored() external view override returns (uint){\n        return _exchangeRate();\n    }\n\n    /**\n    * @notice Return the minimum of fees to pay to borrow\n    * @dev Fees to pay for a Borrow (for the minimum borrow length)\n    * @return uint : minimum amount (in wei)\n    */\n    function minBorrowFees(uint _amount) public view override returns (uint){\n        require(_amount < underlyingBalance(), Errors.INSUFFICIENT_CASH);\n        //Future Borrow Rate with the amount to borrow counted as already borrowed\n        uint _borrowRate = interestModule.getBorrowRate(address(this), underlyingBalance().sub(_amount), totalBorrowed.add(_amount), totalReserve);\n        uint _minFees = minBorrowLength.mul(_amount.mul(_borrowRate)).div(mantissaScale);\n        return _minFees > 0 ? _minFees : 1;\n    }\n\n    function isKillable(address _loan) external view override returns(bool){\n        Borrow memory __borrow = loanToBorrow[_loan];\n        if(__borrow.closed){\n            return false;\n        }\n\n        //Calculate the amount of fee used, and check if the Loan is killable\n        uint _feesUsed = (__borrow.amount.mul(borrowIndex).div(__borrow.borrowIndex)).sub(__borrow.amount);\n        uint _loanHealthFactor = _feesUsed.mul(uint(1e18)).div(__borrow.feesAmount);\n        return _loanHealthFactor >= killFactor;\n    }\n\n    /**\n    * @dev Updates Inetrest and variables for this Pool\n    * @return bool : Update success\n    */\n    function _updateInterest() public returns (bool){\n        //Get the current block\n        //Check if the Pool has already been updated this block\n        uint _currentBlock = block.number;\n        if(_currentBlock == accrualBlockNumber){\n            return true;\n        }\n\n        //Get Pool variables from Storage\n        uint _cash = underlyingBalance();\n        uint _borrows = totalBorrowed;\n        uint _reserves = totalReserve;\n        uint _accruedFees = accruedFees;\n        uint _oldBorrowIndex = borrowIndex;\n\n        //Get the Borrow Rate from the Interest Module\n        uint _borrowRate = interestModule.getBorrowRate(address(this), _cash, _borrows, _reserves);\n\n        //Delta of blocks since the last update\n        uint _ellapsedBlocks = _currentBlock.sub(accrualBlockNumber);\n\n        /*\n        Interest Factor = Borrow Rate * Ellapsed Blocks\n        Accumulated Interests = Interest Factor * Borrows\n        Total Borrows = Borrows + Accumulated Interests\n        Total Reserve = Reserve + Accumulated Interests * Reserve Factor\n        Accrued Fees = Accrued Fees + Accumulated Interests * (Reserve Factor - Killer Ratio) -> (available fees should not count potential fees to send to killers)\n        Borrow Index = old Borrow Index + old Borrow Index * Interest Factor \n        */\n        uint _interestFactor = _borrowRate.mul(_ellapsedBlocks);\n        uint _accumulatedInterest = _interestFactor.mul(_borrows).div(mantissaScale);\n        uint _newBorrows = _borrows.add(_accumulatedInterest);\n        uint _newReserve = _reserves.add(reserveFactor.mul(_accumulatedInterest).div(mantissaScale));\n        uint _newAccruedFees = _accruedFees.add((reserveFactor.sub(killerRatio)).mul(_accumulatedInterest).div(mantissaScale));\n        uint _newBorrowIndex = _oldBorrowIndex.add(_interestFactor.mul(_oldBorrowIndex).div(1e18));\n\n        //Update storage\n        totalBorrowed = _newBorrows;\n        totalReserve = _newReserve;\n        accruedFees = _newAccruedFees;\n        borrowIndex = _newBorrowIndex;\n        accrualBlockNumber = _currentBlock;\n\n        return true;\n    }\n\n    \n\n\n    // Admin Functions\n\n    /**\n    * @notice Set a new Controller\n    * @dev Loads the new Controller for the Pool\n    * @param  _newController address of the new Controller\n    */\n    function setNewController(address _newController) external override controllerOnly {\n        controller = IPaladinController(_newController);\n    }\n\n    /**\n    * @notice Set a new Interest Module\n    * @dev Load a new Interest Module\n    * @param _interestModule address of the new Interest Module\n    */\n    function setNewInterestModule(address _interestModule) external override adminOnly {\n        interestModule = InterestInterface(_interestModule);\n    }\n\n    /**\n    * @notice Set a new Delegator\n    * @dev Change Delegator address\n    * @param _delegator address of the new Delegator\n    */\n    function setNewDelegator(address _delegator) external override adminOnly {\n        delegator = _delegator;\n    }\n\n\n    /**\n    * @notice Set a new Minimum Borrow Length\n    * @dev Change Minimum Borrow Length value\n    * @param _length new Minimum Borrow Length\n    */\n    function updateMinBorrowLength(uint _length) external override adminOnly {\n        require(_length > 0, Errors.INVALID_PARAMETERS);\n        minBorrowLength = _length;\n    }\n\n\n    /**\n    * @notice Update the Pool Reserve Factor & Killer Ratio\n    * @dev Change Reserve Factor value & Killer Ratio value\n    * @param _reserveFactor new % of fees to set as Reserve\n    * @param _killerRatio new Ratio of Fees to pay the killer\n    */\n    function updatePoolFactors(uint _reserveFactor, uint _killerRatio) external override adminOnly {\n        require(_reserveFactor > 0 && _killerRatio > 0 && _reserveFactor >= _killerRatio, \n            Errors.INVALID_PARAMETERS\n        );\n        reserveFactor = _reserveFactor;\n        killerRatio = _killerRatio;\n    }\n\n\n    /**\n    * @notice Add underlying in the Pool Reserve\n    * @dev Transfer underlying token from the admin to the Pool\n    * @param _amount Amount of underlying to transfer\n    */\n    function addReserve(uint _amount) external override adminOnly {\n        require(_updateInterest());\n\n        totalReserve = totalReserve.add(_amount);\n\n        //Transfer from the admin to the Pool\n        underlying.safeTransferFrom(admin, address(this), _amount);\n\n        emit AddReserve(_amount);\n    }\n\n    /**\n    * @notice Remove underlying from the Pool Reserve\n    * @dev Transfer underlying token from the Pool to the admin\n    * @param _amount Amount of underlying to transfer\n    */\n    function removeReserve(uint _amount) external override adminOnly {\n        //Check if there is enough in the reserve\n        require(_updateInterest());\n        require(_amount <= underlyingBalance() && _amount <= totalReserve, Errors.RESERVE_FUNDS_INSUFFICIENT);\n\n        totalReserve = totalReserve.sub(_amount);\n\n        //Transfer underlying to the admin\n        underlying.safeTransfer(admin, _amount);\n\n        emit RemoveReserve(_amount);\n    }\n\n    /**\n    * @notice Method to allow the Controller (or admin) to withdraw protocol fees\n    * @dev Transfer underlying token from the Pool to the controller (or admin)\n    * @param _amount Amount of underlying to transfer\n    * @param _recipient Address to receive the token\n    */\n    function withdrawFees(uint _amount, address _recipient) external override controllerOnly {\n        //Check if there is enough in the reserve\n        require(_updateInterest());\n        require(_amount<= accruedFees && _amount <= totalReserve, Errors.FEES_ACCRUED_INSUFFICIENT);\n\n        //Substract from accruedFees (to track how much fees the Controller can withdraw since last time)\n        //And also from the REserve, since the fees are part of the Reserve\n        accruedFees = accruedFees.sub(_amount);\n        totalReserve = totalReserve.sub(_amount);\n\n        //Transfer fees to the recipient\n        underlying.safeTransfer(_recipient, _amount);\n\n        emit WithdrawFees(_amount);\n    }\n\n}"
    },
    "contracts/utils/SafeMath.sol": {
      "content": "pragma solidity ^0.7.6;\n//SPDX-License-Identifier: MIT\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    "contracts/utils/IERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.7.6;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/tokens/AAVE/IStakedAave.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.7.5;\n\ninterface IStakedAave {\n  function stake(address to, uint256 amount) external;\n\n  function redeem(address to, uint256 amount) external;\n\n  function cooldown() external;\n\n  function claimRewards(address to, uint256 amount) external;\n\n  function getTotalRewardsBalance(address staker) external view returns (uint256);\n}"
    },
    "contracts/utils/Errors.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\n//SPDX-License-Identifier: MIT\n\nlibrary Errors {\n    // Admin error\n    string public constant CALLER_NOT_ADMIN = '1'; // 'The caller must be the admin'\n    string public constant CALLER_NOT_CONTROLLER = '29'; // 'The caller must be the admin or the controller'\n    string public constant CALLER_NOT_ALLOWED_POOL = '30';  // 'The caller must be a palPool listed in the controller'\n    string public constant CALLER_NOT_MINTER = '31';\n\n    // ERC20 type errors\n    string public constant FAIL_TRANSFER = '2';\n    string public constant FAIL_TRANSFER_FROM = '3';\n    string public constant BALANCE_TOO_LOW = '4';\n    string public constant ALLOWANCE_TOO_LOW = '5';\n    string public constant SELF_TRANSFER = '6';\n\n    // PalPool errors\n    string public constant INSUFFICIENT_CASH = '9';\n    string public constant INSUFFICIENT_BALANCE = '10';\n    string public constant FAIL_DEPOSIT = '11';\n    string public constant FAIL_LOAN_INITIATE = '12';\n    string public constant FAIL_BORROW = '13';\n    string public constant ZERO_BORROW = '27';\n    string public constant BORROW_INSUFFICIENT_FEES = '23';\n    string public constant LOAN_CLOSED = '14';\n    string public constant NOT_LOAN_OWNER = '15';\n    string public constant LOAN_OWNER = '16';\n    string public constant FAIL_LOAN_EXPAND = '17';\n    string public constant NOT_KILLABLE = '18';\n    string public constant RESERVE_FUNDS_INSUFFICIENT = '19';\n    string public constant FAIL_MINT = '20';\n    string public constant FAIL_BURN = '21';\n    string public constant FAIL_WITHDRAW = '24';\n    string public constant FAIL_CLOSE_BORROW = '25';\n    string public constant FAIL_KILL_BORROW = '26';\n    string public constant ZERO_ADDRESS = '22';\n    string public constant INVALID_PARAMETERS = '28'; \n    string public constant FAIL_LOAN_DELEGATEE_CHANGE = '32';\n    string public constant FAIL_LOAN_TOKEN_BURN = '33';\n    string public constant FEES_ACCRUED_INSUFFICIENT = '34';\n\n}"
    },
    "contracts/utils/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}"
    },
    "contracts/IPalPool.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\npragma abicoder v2;\n//SPDX-License-Identifier: MIT\n\n/** @title palPool Interface  */\n/// @author Paladin\ninterface IPalPool {\n\n    //Events\n    /** @notice Event when an user deposit tokens in the pool */\n    event Deposit(address user, uint amount, address palPool);\n    /** @notice Event when an user withdraw tokens from the pool */\n    event Withdraw(address user, uint amount, address palPool);\n    /** @notice Event when a loan is started */\n    event NewLoan(\n        address borrower,\n        address delegatee,\n        address underlying,\n        uint amount,\n        address palPool,\n        address loanAddress,\n        uint256 palLoanTokenId,\n        uint startBlock);\n    /** @notice Event when the fee amount in the loan is updated */\n    event ExpandLoan(\n        address borrower,\n        address delegatee,\n        address underlying,\n        address palPool,\n        uint newFeesAmount,\n        address loanAddress,\n        uint256 palLoanTokenId\n    );\n    /** @notice Event when the delegatee of the loan is updated */\n    event ChangeLoanDelegatee(\n        address borrower,\n        address newDelegatee,\n        address underlying,\n        address palPool,\n        address loanAddress,\n        uint256 palLoanTokenId\n    );\n    /** @notice Event when a loan is ended */\n    event CloseLoan(\n        address borrower,\n        address delegatee,\n        address underlying,\n        uint amount,\n        address palPool,\n        uint usedFees,\n        address loanAddress,\n        uint256 palLoanTokenId,\n        bool wasKilled\n    );\n\n    /** @notice Reserve Events */\n    event AddReserve(uint amount);\n    event RemoveReserve(uint amount);\n    event WithdrawFees(uint amount);\n\n\n    //Functions\n    function deposit(uint _amount) external returns(uint);\n    function withdraw(uint _amount) external returns(uint);\n    \n    function borrow(address _delegatee, uint _amount, uint _feeAmount) external returns(uint);\n    function expandBorrow(address _loanPool, uint _feeAmount) external returns(uint);\n    function closeBorrow(address _loanPool) external;\n    function killBorrow(address _loanPool) external;\n    function changeBorrowDelegatee(address _loanPool, address _newDelegatee) external;\n\n    function balanceOf(address _account) external view returns(uint);\n    function underlyingBalanceOf(address _account) external view returns(uint);\n\n    function isLoanOwner(address _loanAddress, address _user) external view returns(bool);\n    function idOfLoan(address _loanAddress) external view returns(uint256);\n\n    function getLoansPools() external view returns(address [] memory);\n    function getLoansByBorrower(address _borrower) external view returns(address [] memory);\n    function getBorrowData(address _loanAddress) external view returns(\n        address _borrower,\n        address _delegatee,\n        address _loanPool,\n        uint256 _palLoanTokenId,\n        uint _amount,\n        address _underlying,\n        uint _feesAmount,\n        uint _feesUsed,\n        uint _startBlock,\n        uint _closeBlock,\n        bool _closed,\n        bool _killed\n    );\n\n    function borrowRatePerBlock() external view returns (uint);\n    function supplyRatePerBlock() external view returns (uint);\n\n    function exchangeRateCurrent() external returns (uint);\n    function exchangeRateStored() external view returns (uint);\n\n    function minBorrowFees(uint _amount) external view returns (uint);\n\n    function isKillable(address _loan) external view returns(bool);\n\n    //Admin functions : \n    function setNewController(address _newController) external;\n    function setNewInterestModule(address _interestModule) external;\n    function setNewDelegator(address _delegator) external;\n\n    function updateMinBorrowLength(uint _length) external;\n    function updatePoolFactors(uint _reserveFactor, uint _killerRatio) external;\n\n    function addReserve(uint _amount) external;\n    function removeReserve(uint _amount) external;\n    function withdrawFees(uint _amount, address _recipient) external;\n\n}"
    },
    "contracts/PalPoolStorage.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\n//SPDX-License-Identifier: MIT\n\nimport \"./IPaladinController.sol\";\nimport \"./IPalLoanToken.sol\";\nimport \"./interests/InterestInterface.sol\";\nimport \"./IPalPool.sol\";\nimport \"./IPalToken.sol\";\nimport \"./utils/IERC20.sol\";\n\n/** @title palPool Storage contract  */\n/// @author Paladin\ncontract PalPoolStorage {\n\n    /** @notice Struct of a Borrow */\n    struct Borrow {\n        //id of the palLoanToken\n        uint256 tokenId;\n        //address of the delegatee\n        address delegatee;\n        //address of the Loan Pool contract holding the loan\n        address loan;\n        //amount of the loan\n        uint amount;\n        //address of the underlying for this loan\n        address underlying;\n        //amount of fees (in the underlying token) paid by the borrower\n        uint feesAmount;\n        //amount of fees (in the underlying token) already used\n        uint feesUsed;\n        //borrow index at the loan creation\n        uint borrowIndex;\n        //start block for the Borrow\n        uint startBlock;\n        //block where the Borrow was closed\n        uint closeBlock;\n        //false if the loan is active, true if loan was closed or killed\n        bool closed;\n        //false when the loan is active, true if the loan was killed\n        bool killed;\n    }\n\n    //palPool variables & Mappings\n\n    /** @notice ERC721 palLoanToken */\n    IPalLoanToken public palLoanToken;\n\n    /** @notice Underlying ERC20 token of this Pool */\n    IERC20 public underlying;\n\n    /** @notice ERC20 palToken for this Pool */\n    IPalToken public palToken;\n\n    /** @dev Boolean to prevent reentry in some functions */\n    bool internal entered = false;\n\n    /** @notice Total of the current Reserve */\n    uint public totalReserve;\n    /** @notice Total of underlying tokens \"borrowed\" (in Loan Pool contracts) */\n    uint public totalBorrowed;\n    /** @notice Total fees accrued since last withdraw */\n    /** (this amount id part of the Reserve : we should always have totalReserve >= accruedFees) */\n    uint public accruedFees;\n\n    /** @notice Minimum duration of a Borrow (in blocks) */\n    uint public minBorrowLength = 45290;\n    \n\n    /** @dev Health Factor to kill a loan */\n    uint public constant killFactor = 0.95e18;\n    /** @dev Ratio of the borrow fees to pay the killer of a loan */\n    uint public killerRatio = 0.1e18;\n\n    /** @dev Base value to mint palTokens */\n    uint internal constant initialExchangeRate = 1e18;\n    /** @notice Part of the borrows interest to set as Reserves */\n    uint public reserveFactor = 0.2e18;\n    /** @notice Last block where the interest where updated for this pool */\n    uint public accrualBlockNumber;\n    /** @notice Borrow Index : increase at each interest update to represent borrows interests increasing (scaled 1e36) */\n    uint public borrowIndex;\n\n    /** @dev Scale used to represent decimal values */\n    uint constant internal mantissaScale = 1e18;\n\n    /** @dev Mapping of Loan Pool contract address to Borrow struct */\n    mapping (address => Borrow) internal loanToBorrow;\n    /** @dev List of all loans (current & closed) */\n    address[] internal loans;\n\n\n    //Modules\n\n    /** @notice Paladin Controller contract */\n    IPaladinController public controller;\n    /** @dev Current Inetrest Module */\n    InterestInterface internal interestModule;\n\n    /** @dev Delegator for the underlying governance token */\n    address internal delegator;\n    \n}"
    },
    "contracts/IPalLoan.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\n//SPDX-License-Identifier: MIT\n\n/** @title Interface for PalLoan contract  */\n/// @author Paladin\ninterface IPalLoan {\n\n    // Variables\n    function underlying() external view returns(address);\n    function amount() external view returns(uint);\n    function borrower() external view returns(address);\n    function delegatee() external view returns(address);\n    function motherPool() external view returns(address);\n    function feesAmount() external view returns(uint);\n\n    // Functions\n    function initiate(\n        address _motherPool,\n        address _borrower,\n        address _underlying,\n        address _delegatee,\n        uint _amount,\n        uint _feesAmount\n    ) external returns(bool);\n    function expand(uint _newFeesAmount) external returns(bool);\n    function closeLoan(uint _usedAmount) external;\n    function killLoan(address _killer, uint _killerRatio) external;\n    function changeDelegatee(address _delegatee) external returns(bool);\n}"
    },
    "contracts/IPalToken.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\n//SPDX-License-Identifier: MIT\n\n\n/** @title simple PalToken Interface to be used inside the PalPool contract  */\n/// @author Paladin\ninterface IPalToken {\n\n    function mint(address _user, uint _toMint) external returns(bool);\n\n    function burn(address _user, uint _toBurn) external returns(bool);\n\n    function balanceOf(address owner) external view returns(uint);\n\n    function totalSupply() external view returns (uint256);\n\n}"
    },
    "contracts/IPaladinController.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\n//SPDX-License-Identifier: MIT\n\n/** @title Paladin Controller Interface  */\n/// @author Paladin\ninterface IPaladinController {\n    \n    //Events\n\n    /** @notice Event emitted when a new token & pool are added to the list */\n    event NewPalPool(address palPool, address palToken);\n    /** @notice Event emitted when a token & pool are removed from the list */\n    event RemovePalPool(address palPool, address palToken);\n\n\n    //Functions\n    function isPalPool(address pool) external view returns(bool);\n    function getPalTokens() external view returns(address[] memory);\n    function getPalPools() external view returns(address[] memory);\n    function setInitialPools(address[] memory palTokens, address[] memory palPools) external returns(bool);\n    function addNewPool(address palToken, address palPool) external returns(bool);\n    function removePool(address _palPool) external returns(bool);\n\n    function withdrawPossible(address palPool, uint amount) external view returns(bool);\n    function borrowPossible(address palPool, uint amount) external view returns(bool);\n\n    function depositVerify(address palPool, address dest, uint amount) external view returns(bool);\n    function withdrawVerify(address palPool, address dest, uint amount) external view returns(bool);\n    function borrowVerify(address palPool, address borrower, address delegatee, uint amount, uint feesAmount, address loanAddress) external view returns(bool);\n    function expandBorrowVerify(address palPool, address loanAddress, uint newFeesAmount) external view returns(bool);\n    function closeBorrowVerify(address palPool, address borrower, address loanAddress) external view returns(bool);\n    function killBorrowVerify(address palPool, address killer, address loanAddress) external view returns(bool);\n\n    //Admin functions\n    function setPoolsNewController(address _newController) external returns(bool);\n    function withdrawFromPool(address _pool, uint _amount, address _recipient) external returns(bool);\n\n}"
    },
    "contracts/IPalLoanToken.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\npragma abicoder v2;\n//SPDX-License-Identifier: MIT\n\nimport \"./utils/IERC721.sol\";\n\n/** @title palLoanToken Interface  */\n/// @author Paladin\ninterface IPalLoanToken is IERC721 {\n\n    //Events\n\n    /** @notice Event when a new Loan Token is minted */\n    event NewLoanToken(address palPool, address indexed owner, address indexed palLoan, uint256 indexed tokenId);\n    /** @notice Event when a Loan Token is burned */\n    event BurnLoanToken(address palPool, address indexed owner, address indexed palLoan, uint256 indexed tokenId);\n\n\n    //Functions\n    function mint(address to, address palPool, address palLoan) external returns(uint256);\n    function burn(uint256 tokenId) external returns(bool);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    function tokenOfByIndex(address owner, uint256 tokenIdex) external view returns (uint256);\n    function loanOf(uint256 tokenId) external view returns(address);\n    function poolOf(uint256 tokenId) external view returns(address);\n    function loansOf(address owner) external view returns(address[] memory);\n    function tokensOf(address owner) external view returns(uint256[] memory);\n    function loansOfForPool(address owner, address palPool) external view returns(address[] memory);\n    function allTokensOf(address owner) external view returns(uint256[] memory);\n    function allLoansOf(address owner) external view returns(address[] memory);\n    function allLoansOfForPool(address owner, address palPool) external view returns(address[] memory);\n    function allOwnerOf(uint256 tokenId) external view returns(address);\n\n    function isBurned(uint256 tokenId) external view returns(bool);\n\n    //Admin functions\n    function setNewController(address _newController) external;\n    function setNewBaseURI(string memory _newBaseURI) external;\n\n}"
    },
    "contracts/interests/InterestInterface.sol": {
      "content": "//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\n                                                     \n\npragma solidity ^0.7.6;\n//SPDX-License-Identifier: MIT\n\n/** @title Interest Module Interface  */\n/// @author Paladin\ninterface InterestInterface {\n\n    function getSupplyRate(address palPool, uint cash, uint borrows, uint reserves, uint reserveFactor) external view returns(uint);\n    function getBorrowRate(address palPool, uint cash, uint borrows, uint reserves) external view returns(uint);\n}"
    },
    "contracts/utils/Admin.sol": {
      "content": "pragma solidity ^0.7.6;\n//SPDX-License-Identifier: MIT\n\n\n/** @title Admin contract  */\n/// @author Paladin\ncontract Admin {\n\n    /** @notice (Admin) Event when the contract admin is updated */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /** @dev Admin address for this contract */\n    address payable internal admin;\n    \n    modifier adminOnly() {\n        //allows only the admin of this contract to call the function\n        require(msg.sender == admin, '1');\n        _;\n    }\n\n        /**\n    * @notice Set a new Admin\n    * @dev Changes the address for the admin parameter\n    * @param _newAdmin address of the new Controller Admin\n    */\n    function setNewAdmin(address payable _newAdmin) external adminOnly {\n        address _oldAdmin = admin;\n        admin = _newAdmin;\n\n        emit NewAdmin(_oldAdmin, _newAdmin);\n    }\n}"
    },
    "contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    "contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"
    },
    "contracts/utils/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}"
    },
    "contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 25000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}