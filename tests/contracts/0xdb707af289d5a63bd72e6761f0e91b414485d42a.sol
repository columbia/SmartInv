{{
  "language": "Solidity",
  "sources": {
    "contracts/manifold/collectible/ERC721Collectible.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./IERC721Collectible.sol\";\nimport \"./CollectibleCore.sol\";\nimport \"../../libraries/IERC721CreatorCoreVersion.sol\";\n\ncontract ERC721Collectible is CollectibleCore, IERC721Collectible {\n    struct TokenClaim {\n      uint224 instanceId;\n      uint32 mintOrder;\n    }\n\n    // NOTE: Only used for creatorContract versions < 3\n    // { contractAddress => { tokenId => TokenClaim }\n    mapping(address => mapping(uint256 => TokenClaim)) internal _tokenIdToTokenClaimMap;\n\n    // { contractAddress => { instanceId => { address => mintCount } }\n    mapping(address => mapping(uint256 => mapping(address => uint256))) internal _addressMintCount;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(AdminControl, IERC165) returns (bool) {\n        return (interfaceId == type(IERC721Collectible).interfaceId ||\n            interfaceId == type(ICreatorExtensionTokenURI).interfaceId ||\n            interfaceId == type(IERC721CreatorExtensionApproveTransfer).interfaceId ||\n            interfaceId == type(IAdminControl).interfaceId ||\n            interfaceId == type(IERC165).interfaceId);\n    }\n\n    /**\n    * See {ICollectibleCore-initializeCollectible}.\n    */\n    function initializeCollectible(\n        address creatorContractAddress,\n        uint256 instanceId,\n        InitializationParameters calldata initializationParameters\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        uint8 creatorContractVersion;\n        try IERC721CreatorCoreVersion(creatorContractAddress).VERSION() returns(uint256 version) {\n            require(version <= 255, \"Unsupported contract version\");\n            creatorContractVersion = uint8(version);\n        } catch {}\n        _initializeCollectible(creatorContractAddress, creatorContractVersion, instanceId, initializationParameters);\n  }\n\n    /**\n    * @dev See {IERC721Collectible-premint}.\n    */\n    function premint(\n        address creatorContractAddress,\n        uint256 instanceId,\n        uint16 amount\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n        require(!instance.isActive, \"Already active\");\n\n        _mint(creatorContractAddress, instanceId, msg.sender, amount);\n    }\n\n    /**\n    * @dev See {IERC721Collectible-premint}.\n    */\n    function premint(\n        address creatorContractAddress,\n        uint256 instanceId,\n        address[] calldata addresses\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n        require(!instance.isActive, \"Already active\");\n\n        for (uint256 i = 0; i < addresses.length; ) {\n            _mint(creatorContractAddress, instanceId, addresses[i], 1);\n            unchecked {\n              i++;\n            }\n        }\n    }\n\n    /**\n    * @dev See {IERC721Collectible-setTokenURIPrefix}.\n    */\n    function setTokenURIPrefix(\n        address creatorContractAddress,\n        uint256 instanceId,\n        string calldata prefix\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n        instance.baseURI = prefix;\n    }\n\n    /**\n    * @dev See {IERC721Collectible-setTransferLocked}.\n    */\n    function setTransferLocked(\n        address creatorContractAddress,\n        uint256 instanceId,\n        bool isLocked\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n        instance.isTransferLocked = isLocked;\n    }\n\n    /**\n    * @dev See {IERC721Collectible-claim}.\n    */\n    function claim(\n        address creatorContractAddress,\n        uint256 instanceId,\n        uint16 amount,\n        bytes32 message,\n        bytes calldata signature,\n        bytes32 nonce\n    ) public payable virtual override {\n        _validateClaimRestrictions(creatorContractAddress, instanceId);\n        _validateClaimRequest(creatorContractAddress, instanceId, message, signature, nonce, amount);\n        _addressMintCount[creatorContractAddress][instanceId][msg.sender] += amount;\n        require(msg.value == _getManifoldFee(amount), \"Invalid purchase amount\");\n        _mint(creatorContractAddress, instanceId, msg.sender, amount);\n    }\n\n    /**\n    * @dev See {IERC721Collection-purchase}.\n    */\n    function purchase(\n      address creatorContractAddress,\n      uint256 instanceId,\n      uint16 amount,\n      bytes32 message,\n      bytes calldata signature,\n      bytes32 nonce\n    ) public payable virtual override {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n        _validatePurchaseRestrictions(creatorContractAddress, instanceId);\n\n        bool isPresale = _isPresale(creatorContractAddress, instanceId);\n        uint256 priceWithoutFee;\n\n        // Check purchase amounts\n        require(\n            amount <= purchaseRemaining(creatorContractAddress, instanceId) &&\n                ((isPresale && instance.useDynamicPresalePurchaseLimit) ||\n                  instance.transactionLimit == 0 ||\n                  amount <= instance.transactionLimit),\n            \"Too many requested\"\n        );\n\n        if (isPresale) {\n            if (!instance.useDynamicPresalePurchaseLimit) {\n                // Make sure we are not over presalePurchaseLimit\n                if (instance.presalePurchaseLimit != 0) {\n                    uint256 mintCount = _addressMintCount[creatorContractAddress][instanceId][msg.sender];\n                    require(\n                        instance.presalePurchaseLimit > mintCount && amount <= (instance.presalePurchaseLimit - mintCount),\n                        \"Too many requested\"\n                    );\n                }\n                // Make sure we are not over purchaseLimit\n                if (instance.purchaseLimit != 0) {\n                    uint256 mintCount = _addressMintCount[creatorContractAddress][instanceId][msg.sender];\n                    require(\n                        instance.purchaseLimit > mintCount && amount <= (instance.purchaseLimit - mintCount),\n                        \"Too many requested\"\n                    );\n                  }\n              }\n            priceWithoutFee = _validatePresalePrice(amount, instance);\n            // Only track mint count if needed\n            if (!instance.useDynamicPresalePurchaseLimit && (instance.presalePurchaseLimit != 0 || instance.purchaseLimit != 0)) {\n                _addressMintCount[creatorContractAddress][instanceId][msg.sender] += amount;\n            }\n        } else {\n            // Make sure we are not over purchaseLimit\n            if (instance.purchaseLimit != 0) {\n                uint256 mintCount = _addressMintCount[creatorContractAddress][instanceId][msg.sender];\n                require(instance.purchaseLimit > mintCount && amount <= (instance.purchaseLimit - mintCount), \"Too many requested\");\n            }\n            priceWithoutFee = _validatePrice(amount, instance);\n\n            if (instance.purchaseLimit != 0) {\n                _addressMintCount[creatorContractAddress][instanceId][msg.sender] += amount;\n            }\n        }\n\n        if (isPresale && instance.useDynamicPresalePurchaseLimit) {\n           _validatePurchaseRequestWithAmount(creatorContractAddress, instanceId, message, signature, nonce, amount);\n        } else {\n            _validatePurchaseRequest(creatorContractAddress, instanceId, message, signature, nonce);\n        }\n\n        if (priceWithoutFee > 0) {\n            _forwardValue(instance.paymentReceiver, priceWithoutFee);\n        }\n\n        _mint(creatorContractAddress, instanceId, msg.sender, amount);\n    }\n\n    /**\n    * @dev returns the collection state\n    */\n    function state(address creatorContractAddress, uint256 instanceId) external view returns (CollectibleState memory) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n\n        return CollectibleState(\n            instance.isActive,\n            instance.useDynamicPresalePurchaseLimit,\n            instance.isTransferLocked,\n            instance.transactionLimit,\n            instance.purchaseMax,\n            instance.purchaseLimit,\n            instance.presalePurchaseLimit,\n            instance.purchaseCount,\n            instance.startTime,\n            instance.endTime,\n            instance.presaleInterval,\n            instance.claimStartTime,\n            instance.claimEndTime,\n            instance.purchasePrice,\n            instance.presalePurchasePrice,\n            purchaseRemaining(creatorContractAddress, instanceId),\n            instance.paymentReceiver\n        );\n    }\n\n    /**\n    * @dev See {IERC721Collectible-purchaseRemaining}.\n    */\n    function purchaseRemaining(\n        address creatorContractAddress,\n        uint256 instanceId\n    ) public view virtual override returns (uint16) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n        return instance.purchaseMax - instance.purchaseCount;\n    }\n\n    /**\n    * @dev See {ICreatorExtensionTokenURI-tokenURI}\n    */\n    function tokenURI(address creatorContractAddress, uint256 tokenId) external view override returns (string memory) {\n        TokenClaim memory tokenClaim = _tokenIdToTokenClaimMap[creatorContractAddress][tokenId];\n        uint256 mintOrder;\n        CollectibleInstance memory instance;\n        if (tokenClaim.instanceId == 0) {\n            // No claim, try to retrieve from tokenData\n            uint80 tokenData = IERC721CreatorCore(creatorContractAddress).tokenData(tokenId);\n            uint56 instanceId = uint56(tokenData >> 24);\n            require(instanceId != 0, \"Token not found\");\n            instance = _getInstance(creatorContractAddress, instanceId);\n            mintOrder = uint24(tokenData & MAX_UINT_24);\n        } else {\n            mintOrder = tokenClaim.mintOrder;\n            instance = _getInstance(creatorContractAddress, tokenClaim.instanceId);\n        }\n\n        require(bytes(instance.baseURI).length != 0, \"No base uri prefix set\");\n\n        return string(abi.encodePacked(instance.baseURI, Strings.toString(mintOrder)));\n    }\n\n    /**\n    * @dev See {IERC721CreatorExtensionApproveTransfer-setApproveTransfer}\n    */\n    function setApproveTransfer(\n      address creatorContractAddress,\n      bool enabled\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        require(\n            ERC165Checker.supportsInterface(creatorContractAddress, type(IERC721CreatorCore).interfaceId),\n            \"creator must implement IERC721CreatorCore\"\n        );\n        IERC721CreatorCore(creatorContractAddress).setApproveTransferExtension(enabled);\n    }\n\n    /**\n    * @dev See {IERC721CreatorExtensionApproveTransfer-approveTransfer}.\n    */\n    function approveTransfer(address, address from, address, uint256 tokenId) external view override returns (bool) {\n        // always allow mints\n        if (from == address(0)) {\n            return true;\n        }\n        TokenClaim memory tokenClaim = _tokenIdToTokenClaimMap[msg.sender][tokenId];\n        uint256 instanceId;\n        if (tokenClaim.instanceId == 0) {\n            // No claim, try to retrieve from tokenData\n            uint80 tokenData = IERC721CreatorCore(msg.sender).tokenData(tokenId);\n            instanceId = uint56(tokenData >> 24);\n            require(instanceId != 0, \"Token not found\");\n        } else {\n            instanceId = tokenClaim.instanceId;\n        }\n        CollectibleInstance storage instance = _getInstance(msg.sender, instanceId);\n\n        return !instance.isTransferLocked;\n    }\n\n    /**\n    * @dev override if you want to perform different mint functionality\n    */\n    function _mint(address creatorContractAddress, uint256 instanceId, address to, uint16 amount) internal virtual {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n\n        if (amount == 1) {\n            uint256 tokenId;\n            if (instance.contractVersion >= 3) {\n                uint80 tokenData = uint56(instanceId) << 24 | uint24(++instance.purchaseCount);\n                tokenId = IERC721CreatorCore(creatorContractAddress).mintExtension(to, tokenData);\n            } else {\n                ++instance.purchaseCount;\n                tokenId = IERC721CreatorCore(creatorContractAddress).mintExtension(to);\n                _tokenIdToTokenClaimMap[creatorContractAddress][tokenId] = TokenClaim(uint224(instanceId), instance.purchaseCount);\n            }\n            emit Unveil(creatorContractAddress, instanceId, instance.purchaseCount, tokenId);\n        } else {\n            uint32 tokenStart = instance.purchaseCount + 1;\n            instance.purchaseCount += amount;\n            if (instance.contractVersion >= 3) {\n                uint80[] memory tokenDatas = new uint80[](amount);\n                for (uint256 i; i < amount;) {\n                    tokenDatas[i] = uint56(instanceId) << 24 | uint24(tokenStart + i);\n                    unchecked { ++i; }\n                }\n                uint256[] memory tokenIds = IERC721CreatorCore(creatorContractAddress).mintExtensionBatch(to, tokenDatas);\n                for (uint32 i = 0; i < amount; ) {\n                    emit Unveil(creatorContractAddress, instanceId, tokenStart + i, tokenIds[i]);\n                    unchecked { ++i; }\n                }\n            } else {\n                uint256[] memory tokenIds = IERC721CreatorCore(creatorContractAddress).mintExtensionBatch(to, amount);\n                for (uint32 i = 0; i < amount; ) {\n                    emit Unveil(creatorContractAddress, instanceId, tokenStart + i, tokenIds[i]);\n                    _tokenIdToTokenClaimMap[creatorContractAddress][tokenIds[i]] = TokenClaim(uint224(instanceId), tokenStart + i);\n                    unchecked { ++i; }\n                }\n            }\n        }\n    }\n\n    /**\n    * Validate price (override for custom pricing mechanics)\n    */\n    function _validatePrice(uint16 numTokens, CollectibleInstance storage instance) internal virtual returns (uint256) {\n        uint256 priceWithoutFee = numTokens * instance.purchasePrice;\n        uint256 price = priceWithoutFee + _getManifoldFee(numTokens);\n        require(msg.value == price, \"Invalid purchase amount sent\");\n\n        return priceWithoutFee;\n    }\n\n    /**\n    * Validate price (override for custom pricing mechanics)\n    */\n    function _validatePresalePrice(uint16 numTokens, CollectibleInstance storage instance) internal virtual returns (uint256) {\n        uint256 priceWithoutFee = numTokens * instance.presalePurchasePrice;\n        uint256 price = priceWithoutFee + _getManifoldFee(numTokens);\n        require(msg.value == price, \"Invalid purchase amount sent\");\n\n        return priceWithoutFee;\n    }\n}\n"
    },
    "contracts/libraries/IERC721CreatorCoreVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721CreatorCoreVersion {\n    function VERSION() external view returns(uint256);\n}\n"
    },
    "contracts/manifold/collectible/CollectibleCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\nimport \"@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../../libraries/manifold-membership/IManifoldMembership.sol\";\n\nimport \"./ICollectibleCore.sol\";\n\n/**\n * Collection Drop Contract (Base)\n */\nabstract contract CollectibleCore is ICollectibleCore, AdminControl {\n    using ECDSA for bytes32;\n\n    uint256 public constant MINT_FEE = 690000000000000;\n    uint256 internal constant MAX_UINT_24 = 0xffffff;\n    uint256 internal constant MAX_UINT_56 = 0xffffffffffffff;\n\n    address public manifoldMembershipContract;\n\n    // { creatorContractAddress => { instanceId => nonce => t/f  } }\n    mapping(address => mapping(uint256 => mapping(bytes32 => bool))) internal _usedNonces;\n    // { creatorContractAddress => { instanceId => address  } }\n    mapping(address => mapping(uint256 => address)) private _signingAddresses;\n    // { creatorContractAddress => { instanceId => CollectibleInstance } }\n    mapping(address => mapping(uint256 => CollectibleInstance)) internal _instances;\n\n    /**\n    * @notice This extension is shared, not single-creator. So we must ensure\n    * that a claim's initializer is an admin on the creator contract\n    * @param creatorContractAddress    the address of the creator contract to check the admin against\n    */\n    modifier creatorAdminRequired(address creatorContractAddress) {\n        AdminControl creatorCoreContract = AdminControl(creatorContractAddress);\n        require(creatorCoreContract.isAdmin(msg.sender), \"Wallet is not an administrator for contract\");\n        _;\n    }\n\n    /**\n    * Initialize collectible\n    */\n    function _initializeCollectible(\n      address creatorContractAddress,\n      uint8 creatorContractVersion,\n      uint256 instanceId,\n      InitializationParameters calldata initializationParameters\n    ) internal {\n        // Max uint56 for instanceId\n        require(instanceId > 0 && instanceId <= MAX_UINT_56, \"Invalid instanceId\");\n\n        address signingAddress = _signingAddresses[creatorContractAddress][instanceId];\n        CollectibleInstance storage instance = _instances[creatorContractAddress][instanceId];\n\n        // Revert if claim at instanceId already exists\n        require(signingAddress == address(0), \"Collectible already initialized\");\n        require(initializationParameters.signingAddress != address(0), \"Invalid signing address\");\n        require(initializationParameters.paymentReceiver != address(0), \"Invalid payment address\");\n        require(initializationParameters.purchaseMax != 0, \"Invalid purchase max\");\n\n        _signingAddresses[creatorContractAddress][instanceId] = initializationParameters.signingAddress;\n        instance.contractVersion = creatorContractVersion;\n        instance.purchaseMax = initializationParameters.purchaseMax;\n        instance.purchasePrice = initializationParameters.purchasePrice;\n        instance.purchaseLimit = initializationParameters.purchaseLimit;\n        instance.transactionLimit = initializationParameters.transactionLimit;\n        instance.presalePurchasePrice = initializationParameters.presalePurchasePrice;\n        instance.presalePurchaseLimit = initializationParameters.presalePurchaseLimit;\n        instance.useDynamicPresalePurchaseLimit = initializationParameters.useDynamicPresalePurchaseLimit;\n        instance.paymentReceiver = initializationParameters.paymentReceiver;\n\n        emit CollectibleInitialized(creatorContractAddress, instanceId, msg.sender);\n    }\n\n    /**\n    * See {ICollectibleCore-withdraw}.\n    */\n    function withdraw(address payable receiver, uint256 amount) external override adminRequired {\n        (bool sent, ) = receiver.call{ value: amount }(\"\");\n        require(sent, \"Failed to transfer to receiver\");\n    }\n\n    /**\n    * See {ICollectibleCore-activate}.\n    */\n    function activate(\n      address creatorContractAddress,\n      uint256 instanceId,\n      ActivationParameters calldata activationParameters\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n        require(!instance.isActive, \"Already active\");\n        require(activationParameters.startTime > block.timestamp, \"Cannot activate in the past\");\n        require(\n          activationParameters.presaleInterval <= activationParameters.duration,\n          \"Presale Interval cannot be longer than the sale\"\n        );\n        require(\n          activationParameters.claimStartTime <= activationParameters.claimEndTime &&\n            activationParameters.claimEndTime <= activationParameters.startTime,\n          \"Invalid claim times\"\n        );\n        instance.startTime = activationParameters.startTime;\n        instance.endTime = activationParameters.startTime + activationParameters.duration;\n        instance.presaleInterval = activationParameters.presaleInterval;\n        instance.claimStartTime = activationParameters.claimStartTime;\n        instance.claimEndTime = activationParameters.claimEndTime;\n        instance.isActive = true;\n\n        emit CollectibleActivated(\n          creatorContractAddress,\n          instanceId,\n          instance.startTime,\n          instance.endTime,\n          instance.presaleInterval,\n          instance.claimStartTime,\n          instance.claimEndTime\n        );\n    }\n\n    /**\n    * See {ICollectibleCore-deactivate}.\n    */\n    function deactivate(\n      address creatorContractAddress,\n      uint256 instanceId\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n\n        instance.startTime = 0;\n        instance.endTime = 0;\n        instance.isActive = false;\n        instance.claimStartTime = 0;\n        instance.claimEndTime = 0;\n\n        emit CollectibleDeactivated(creatorContractAddress, instanceId);\n    }\n\n    /**\n    * @dev See {ICollectibleCore-getCollectible}.\n    */\n    function getCollectible(\n        address creatorContractAddress,\n        uint256 index\n    ) external view override returns (CollectibleInstance memory) {\n        return _getCollectible(creatorContractAddress, index);\n    }\n\n    /**\n    * @dev See {IERC721Collectible-setMembershipAddress}.\n    */\n    function setMembershipAddress(address addr) external override adminRequired {\n        manifoldMembershipContract = addr;\n    }\n\n    /**\n    * @dev See {ICollectibleCore-updateInitializationParameters}.\n    */\n    function updateInitializationParameters(\n        address creatorContractAddress,\n        uint256 instanceId,\n        UpdateInitializationParameters calldata initializationParameters\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n\n        require(!instance.isActive, \"Already active\");\n        instance.purchasePrice = initializationParameters.purchasePrice;\n        instance.purchaseLimit = initializationParameters.purchaseLimit;\n        instance.transactionLimit = initializationParameters.transactionLimit;\n        instance.presalePurchasePrice = initializationParameters.presalePurchasePrice;\n        instance.presalePurchaseLimit = initializationParameters.presalePurchaseLimit;\n        instance.useDynamicPresalePurchaseLimit = initializationParameters.useDynamicPresalePurchaseLimit;\n    }\n\n    /**\n    * @dev See {ICollectibleCore-updatePaymentReceiver}.\n    */\n    function updatePaymentReceiver(\n        address creatorContractAddress,\n        uint256 instanceId,\n        address payable paymentReceiver\n    ) external override creatorAdminRequired(creatorContractAddress) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n        require(paymentReceiver != address(0), \"Invalid payment address\");\n\n        instance.paymentReceiver = paymentReceiver;\n    }\n\n    /**\n    * Validate claim signature\n    */\n    function _getCollectible(\n        address creatorContractAddress,\n        uint256 instanceId\n    ) internal view returns (CollectibleInstance storage) {\n        return _instances[creatorContractAddress][instanceId];\n    }\n\n    /**\n    * Validate claim signature\n    */\n    function _validateClaimRequest(\n        address creatorContractAddress,\n        uint256 instanceId,\n        bytes32 message,\n        bytes calldata signature,\n        bytes32 nonce,\n        uint16 amount\n    ) internal virtual {\n        _validatePurchaseRequestWithAmount(creatorContractAddress, instanceId, message, signature, nonce, amount);\n    }\n\n    /**\n    * Validate claim restrictions\n    */\n    function _validateClaimRestrictions(address creatorContractAddress, uint256 instanceId) internal virtual {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n        require(instance.isActive, \"Inactive\");\n        require(block.timestamp >= instance.claimStartTime && block.timestamp <= instance.claimEndTime, \"Outside claim period.\");\n    }\n\n    /**\n    * Validate purchase signature\n    */\n    function _validatePurchaseRequest(\n        address creatorContractAddress,\n        uint256 instanceId,\n        bytes32 message,\n        bytes calldata signature,\n        bytes32 nonce\n    ) internal virtual {\n        // Verify nonce usage/re-use\n        require(!_usedNonces[creatorContractAddress][instanceId][nonce], \"Cannot replay transaction\");\n        // Verify valid message based on input variables\n        bytes32 expectedMessage = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n52\", msg.sender, nonce));\n        require(message == expectedMessage, \"Malformed message\");\n        // Verify signature was performed by the expected signing address\n        address signer = message.recover(signature);\n        address signingAddress = _signingAddresses[creatorContractAddress][instanceId];\n        require(signer == signingAddress, \"Invalid signature\");\n\n        _usedNonces[creatorContractAddress][instanceId][nonce] = true;\n    }\n\n    /**\n    * Validate purchase signature with amount\n    */\n    function _validatePurchaseRequestWithAmount(\n        address creatorContractAddress,\n        uint256 instanceId,\n        bytes32 message,\n        bytes calldata signature,\n        bytes32 nonce,\n        uint16 amount\n    ) internal virtual {\n        // Verify nonce usage/re-use\n        require(!_usedNonces[creatorContractAddress][instanceId][nonce], \"Cannot replay transaction\");\n        // Verify valid message based on input variables\n        bytes32 expectedMessage = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n54\", msg.sender, nonce, amount));\n        require(message == expectedMessage, \"Malformed message\");\n        // Verify signature was performed by the expected signing address\n        address signer = message.recover(signature);\n        address signingAddress = _signingAddresses[creatorContractAddress][instanceId];\n        require(signer == signingAddress, \"Invalid signature\");\n\n        _usedNonces[creatorContractAddress][instanceId][nonce] = true;\n    }\n\n    /**\n    * Perform purchase restriction checks. Override if more logic is needed\n    */\n    function _validatePurchaseRestrictions(address creatorContractAddress, uint256 instanceId) internal virtual {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n\n        require(instance.isActive, \"Inactive\");\n        require(block.timestamp >= instance.startTime, \"Purchasing not active\");\n    }\n\n    /**\n    * @dev See {ICollectibleCore-nonceUsed}.\n    */\n    function nonceUsed(\n        address creatorContractAddress,\n        uint256 instanceId,\n        bytes32 nonce\n    ) external view override returns (bool) {\n        return _usedNonces[creatorContractAddress][instanceId][nonce];\n    }\n\n    /**\n    * @dev Check if currently in presale\n    */\n    function _isPresale(address creatorContractAddress, uint256 instanceId) internal view returns (bool) {\n        CollectibleInstance storage instance = _getInstance(creatorContractAddress, instanceId);\n\n        return (block.timestamp > instance.startTime && block.timestamp - instance.startTime < instance.presaleInterval);\n    }\n\n    function _getInstance(\n        address creatorContractAddress,\n        uint256 instanceId\n    ) internal view returns (CollectibleInstance storage instance) {\n        instance = _instances[creatorContractAddress][instanceId];\n        require(instance.purchaseMax != 0, \"Collectible not initialized\");\n    }\n\n    /**\n    * Send funds to receiver\n    */\n    function _forwardValue(address payable receiver, uint256 amount) internal {\n        (bool sent, ) = receiver.call{ value: amount }(\"\");\n        require(sent, \"Failed to transfer to recipient\");\n    }\n\n    /**\n    * Helper to check if the sender holds an active Manifold membership\n    */\n    function _isActiveMember(address sender) internal view returns(bool) {\n        return manifoldMembershipContract != address(0) &&\n            IManifoldMembership(manifoldMembershipContract).isActiveMember(sender);\n    }\n\n    /**\n    * Helper to get the Manifold fee for the sender\n    */\n    function _getManifoldFee(uint256 numTokens) internal view returns(uint256) {\n        return _isActiveMember(msg.sender) ? 0 : (MINT_FEE * numTokens);\n    }\n}\n"
    },
    "contracts/manifold/collectible/IERC721Collectible.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@manifoldxyz/creator-core-solidity/contracts/core/IERC721CreatorCore.sol\";\nimport \"@manifoldxyz/creator-core-solidity/contracts/extensions/ERC721/IERC721CreatorExtensionApproveTransfer.sol\";\nimport \"@manifoldxyz/creator-core-solidity/contracts/extensions/ICreatorExtensionTokenURI.sol\";\n\nimport \"./ICollectibleCore.sol\";\n\n/**\n * @dev ERC721 Collection Interface\n */\ninterface IERC721Collectible is ICollectibleCore, IERC721CreatorExtensionApproveTransfer, ICreatorExtensionTokenURI {\n    event Unveil(address creatorContractAddress, uint256 instanceId, uint256 tokenMintIndex, uint256 tokenId);\n\n    /**\n    * @dev Pre-mint given amount to caller\n    * @param creatorContractAddress    the creator contract the claim will mint tokens for\n    * @param instanceId                the id of the claim in the list of creatorContractAddress' _instances\n    * @param amount                    the number of tokens to mint\n    */\n    function premint(address creatorContractAddress, uint256 instanceId, uint16 amount) external;\n\n    /**\n    * @dev Pre-mint 1 token to designated addresses\n    * @param creatorContractAddress    the creator contract the claim will mint tokens for\n    * @param instanceId                the id of the claim in the list of creatorContractAddress' _instances\n    * @param addresses                 List of addresses to premint to\n    */\n    function premint(address creatorContractAddress, uint256 instanceId, address[] calldata addresses) external;\n\n    /**\n    *  @dev set the tokenURI prefix\n    * @param creatorContractAddress    the creator contract the claim will mint tokens for\n    * @param instanceId                the id of the claim in the list of creatorContractAddress' _instances\n    * @param prefix                    the uri prefix to set\n    */\n    function setTokenURIPrefix(address creatorContractAddress, uint256 instanceId, string calldata prefix) external;\n\n    /**\n    * @dev Set whether or not token transfers are locked until end of sale.\n    * @param creatorContractAddress    the creator contract the claim will mint tokens for\n    * @param instanceId                the id of the claim in the list of creatorContractAddress' _instances\n    * @param locked Whether or not transfers are locked\n    */\n    function setTransferLocked(address creatorContractAddress, uint256 instanceId, bool locked) external;\n\n    /**\n    * @dev The `claim` function represents minting during a free claim period. A bit of an overloaded use of hte word \"claim\".\n    */\n    function claim(\n        address creatorContractAddress,\n        uint256 instanceId,\n        uint16 amount,\n        bytes32 message,\n        bytes calldata signature,\n        bytes32 nonce\n    ) external payable;\n\n    /**\n    * @dev purchase\n    */\n    function purchase(\n        address creatorContractAddress,\n        uint256 instanceId,\n        uint16 amount,\n        bytes32 message,\n        bytes calldata signature,\n        bytes32 nonce\n    ) external payable;\n\n    /**\n    * @dev returns the collection state\n    */\n    function state(address creatorContractAddress, uint256 instanceId) external view returns (CollectibleState memory);\n\n    /**\n    * @dev Get number of tokens left\n    */\n    function purchaseRemaining(address creatorContractAddress, uint256 instanceId) external view returns (uint16);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@manifoldxyz/libraries-solidity/contracts/access/AdminControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./IAdminControl.sol\";\n\nabstract contract AdminControl is Ownable, IAdminControl, ERC165 {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // Track registered admins\n    EnumerableSet.AddressSet private _admins;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IAdminControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Only allows approved admins to call the specified function\n     */\n    modifier adminRequired() {\n        require(owner() == msg.sender || _admins.contains(msg.sender), \"AdminControl: Must be owner or admin\");\n        _;\n    }   \n\n    /**\n     * @dev See {IAdminControl-getAdmins}.\n     */\n    function getAdmins() external view override returns (address[] memory admins) {\n        admins = new address[](_admins.length());\n        for (uint i = 0; i < _admins.length(); i++) {\n            admins[i] = _admins.at(i);\n        }\n        return admins;\n    }\n\n    /**\n     * @dev See {IAdminControl-approveAdmin}.\n     */\n    function approveAdmin(address admin) external override onlyOwner {\n        if (!_admins.contains(admin)) {\n            emit AdminApproved(admin, msg.sender);\n            _admins.add(admin);\n        }\n    }\n\n    /**\n     * @dev See {IAdminControl-revokeAdmin}.\n     */\n    function revokeAdmin(address admin) external override onlyOwner {\n        if (_admins.contains(admin)) {\n            emit AdminRevoked(admin, msg.sender);\n            _admins.remove(admin);\n        }\n    }\n\n    /**\n     * @dev See {IAdminControl-isAdmin}.\n     */\n    function isAdmin(address admin) public override view returns (bool) {\n        return (owner() == admin || _admins.contains(admin));\n    }\n\n}"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "contracts/manifold/collectible/ICollectibleCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/// @author: manifold.xyz\n\n/**\n * @dev CollectibleBase Interface\n */\ninterface ICollectibleCore is IERC165 {\n    struct ActivationParameters {\n        uint48 startTime;\n        uint48 duration;\n        uint48 presaleInterval;\n        uint48 claimStartTime;\n        uint48 claimEndTime;\n    }\n\n    struct InitializationParameters {\n        bool useDynamicPresalePurchaseLimit;\n        uint16 transactionLimit;\n        uint16 purchaseMax;\n        uint16 purchaseLimit;\n        uint16 presalePurchaseLimit;\n        uint256 purchasePrice;\n        uint256 presalePurchasePrice;\n        address signingAddress;\n        address payable paymentReceiver;\n    }\n\n\n    struct UpdateInitializationParameters {\n        bool useDynamicPresalePurchaseLimit;\n        uint16 transactionLimit;\n        uint16 purchaseMax;\n        uint16 purchaseLimit;\n        uint16 presalePurchaseLimit;\n        uint256 purchasePrice;\n        uint256 presalePurchasePrice;\n    }\n\n    struct CollectibleInstance {\n        bool isActive;\n        bool useDynamicPresalePurchaseLimit;\n        bool isTransferLocked;\n        uint8 contractVersion;\n        uint16 transactionLimit;\n        uint16 purchaseMax;\n        uint16 purchaseLimit;\n        uint16 presalePurchaseLimit;\n        uint16 purchaseCount;\n        uint48 startTime;\n        uint48 endTime;\n        uint48 presaleInterval;\n        uint48 claimStartTime;\n        uint48 claimEndTime;\n        uint256 purchasePrice;\n        uint256 presalePurchasePrice;\n        string baseURI;\n        address payable paymentReceiver;\n    }\n\n    struct CollectibleState {\n        bool isActive;\n        bool useDynamicPresalePurchaseLimit;\n        bool isTransferLocked;\n        uint16 transactionLimit;\n        uint16 purchaseMax;\n        uint16 purchaseLimit;\n        uint16 presalePurchaseLimit;\n        uint16 purchaseCount;\n        uint48 startTime;\n        uint48 endTime;\n        uint48 presaleInterval;\n        uint48 claimStartTime;\n        uint48 claimEndTime;\n        uint256 purchasePrice;\n        uint256 presalePurchasePrice;\n        uint256 purchaseRemaining;\n        address payable paymentReceiver;\n    }\n\n    event CollectibleInitialized(address creatorContractAddress, uint256 instanceId, address initializer);\n\n    event CollectibleActivated(\n        address creatorContractAddress,\n        uint256 instanceId,\n        uint48 startTime,\n        uint48 endTime,\n        uint48 presaleInterval,\n        uint48 claimStartTime,\n        uint48 claimEndTime\n    );\n\n    event CollectibleDeactivated(address creatorContractAddress, uint256 instanceId);\n\n    /**\n    * @notice get a burn redeem corresponding to a creator contract and index\n    * @param creatorContractAddress    the address of the creator contract\n    * @param index                     the index of the burn redeem\n    * @return CollectibleInstsance               the burn redeem object\n    */\n    function getCollectible(\n        address creatorContractAddress,\n        uint256 index\n    ) external view returns (CollectibleInstance memory);\n\n    /**\n    * @dev Check if nonce has been used\n    * @param creatorContractAddress    the creator contract address\n    * @param instanceId                the index of the claim for which we will mint\n    */\n    function nonceUsed(address creatorContractAddress, uint256 instanceId, bytes32 nonce) external view returns (bool);\n\n    /**\n    * @dev Activate the contract\n    * @param creatorContractAddress    the creator contract the claim will mint tokens for\n    * @param instanceId                the index of the claim in the list of creatorContractAddress' _claims\n    * @param activationParameters      the sale start time\n    */\n    function activate(\n        address creatorContractAddress,\n        uint256 instanceId,\n        ActivationParameters calldata activationParameters\n    ) external;\n\n    /**\n    * @dev Deactivate the contract\n    * @param creatorContractAddress    the creator contract the claim will mint tokens for\n    * @param instanceId                the index of the claim in the list of creatorContractAddress' _claims\n    */\n    function deactivate(address creatorContractAddress, uint256 instanceId) external;\n\n    /**\n    * @notice Set the Manifold Membership address\n    */\n    function setMembershipAddress(address membershipAddress) external;\n\n    /**\n    * @notice withdraw Manifold fee proceeds from the contract\n    * @param recipient                 recepient of the funds\n    * @param amount                    amount to withdraw in Wei\n    */\n    function withdraw(address payable recipient, uint256 amount) external;\n\n    /**\n    * @notice initialize a new burn redeem, emit initialize event, and return the newly created index\n    * @param creatorContractAddress    the creator contract the burn will mint redeem tokens for\n    * @param instanceId                the id of the multi-asssetclaim in the mapping of creatorContractAddress <-> instance id\n    * @param initializationParameters  initial claim parameters\n    */\n    function initializeCollectible(\n        address creatorContractAddress,\n        uint256 instanceId,\n        InitializationParameters calldata initializationParameters\n    ) external;\n\n    /**\n    * Updates a handful of sale parameters\n    * @param creatorContractAddress    the creator contract the burn will mint redeem tokens for\n    * @param instanceId                the id of the multi-asssetclaim in the mapping of creatorContractAddress <-> instance id\n    * @param initializationParameters  initial claim parameters\n    */\n    function updateInitializationParameters(\n        address creatorContractAddress,\n        uint256 instanceId,\n        UpdateInitializationParameters calldata initializationParameters\n    ) external;\n\n    /**\n    * Updates payment receiver\n    * @param creatorContractAddress    the creator contract the burn will mint redeem tokens for\n    * @param instanceId                the id of the multi-asssetclaim in the mapping of creatorContractAddress <-> instance id\n    * @param paymentReceiver           the new address that will receive payments\n    */\n    function updatePaymentReceiver(\n        address creatorContractAddress,\n        uint256 instanceId,\n        address payable paymentReceiver\n    ) external;\n}\n"
    },
    "@manifoldxyz/creator-core-solidity/contracts/extensions/ICreatorExtensionTokenURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Implement this if you want your extension to have overloadable URI's\n */\ninterface ICreatorExtensionTokenURI is IERC165 {\n\n    /**\n     * Get the uri for a given creator/tokenId\n     */\n    function tokenURI(address creator, uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@manifoldxyz/creator-core-solidity/contracts/extensions/ERC721/IERC721CreatorExtensionApproveTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * Implement this if you want your extension to approve a transfer\n */\ninterface IERC721CreatorExtensionApproveTransfer is IERC165 {\n\n    /**\n     * @dev Set whether or not the creator will check the extension for approval of token transfer\n     */\n    function setApproveTransfer(address creator, bool enabled) external;\n\n    /**\n     * @dev Called by creator contract to approve a transfer\n     */\n    function approveTransfer(address operator, address from, address to, uint256 tokenId) external returns (bool);\n}\n"
    },
    "@manifoldxyz/creator-core-solidity/contracts/core/IERC721CreatorCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"./ICreatorCore.sol\";\n\n/**\n * @dev Core ERC721 creator interface\n */\ninterface IERC721CreatorCore is ICreatorCore {\n\n    /**\n     * @dev mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBase(address to) external returns (uint256);\n\n    /**\n     * @dev mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBase(address to, string calldata uri) external returns (uint256);\n\n    /**\n     * @dev batch mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBaseBatch(address to, uint16 count) external returns (uint256[] memory);\n\n    /**\n     * @dev batch mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBaseBatch(address to, string[] calldata uris) external returns (uint256[] memory);\n\n    /**\n     * @dev mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtension(address to) external returns (uint256);\n\n    /**\n     * @dev mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtension(address to, string calldata uri) external returns (uint256);\n\n    /**\n     * @dev mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtension(address to, uint80 data) external returns (uint256);\n\n    /**\n     * @dev batch mint a token. Can only be called by a registered extension.\n     * Returns tokenIds minted\n     */\n    function mintExtensionBatch(address to, uint16 count) external returns (uint256[] memory);\n\n    /**\n     * @dev batch mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtensionBatch(address to, string[] calldata uris) external returns (uint256[] memory);\n\n    /**\n     * @dev batch mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtensionBatch(address to, uint80[] calldata data) external returns (uint256[] memory);\n\n    /**\n     * @dev burn a token. Can only be called by token owner or approved address.\n     * On burn, calls back to the registered extension's onBurn method\n     */\n    function burn(uint256 tokenId) external;\n\n    /**\n     * @dev get token data\n     */\n    function tokenData(uint256 tokenId) external view returns (uint80);\n\n}"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/libraries/manifold-membership/IManifoldMembership.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\n/**\n * Manifold Membership interface\n */\ninterface IManifoldMembership {\n   function isActiveMember(address sender) external view returns (bool);\n}"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@manifoldxyz/libraries-solidity/contracts/access/IAdminControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for admin control\n */\ninterface IAdminControl is IERC165 {\n\n    event AdminApproved(address indexed account, address indexed sender);\n    event AdminRevoked(address indexed account, address indexed sender);\n\n    /**\n     * @dev gets address of all admins\n     */\n    function getAdmins() external view returns (address[] memory);\n\n    /**\n     * @dev add an admin.  Can only be called by contract owner.\n     */\n    function approveAdmin(address admin) external;\n\n    /**\n     * @dev remove an admin.  Can only be called by contract owner.\n     */\n    function revokeAdmin(address admin) external;\n\n    /**\n     * @dev checks whether or not given address is an admin\n     * Returns True if they are\n     */\n    function isAdmin(address admin) external view returns (bool);\n\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@manifoldxyz/creator-core-solidity/contracts/core/ICreatorCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Core creator interface\n */\ninterface ICreatorCore is IERC165 {\n\n    event ExtensionRegistered(address indexed extension, address indexed sender);\n    event ExtensionUnregistered(address indexed extension, address indexed sender);\n    event ExtensionBlacklisted(address indexed extension, address indexed sender);\n    event MintPermissionsUpdated(address indexed extension, address indexed permissions, address indexed sender);\n    event RoyaltiesUpdated(uint256 indexed tokenId, address payable[] receivers, uint256[] basisPoints);\n    event DefaultRoyaltiesUpdated(address payable[] receivers, uint256[] basisPoints);\n    event ApproveTransferUpdated(address extension);\n    event ExtensionRoyaltiesUpdated(address indexed extension, address payable[] receivers, uint256[] basisPoints);\n    event ExtensionApproveTransferUpdated(address indexed extension, bool enabled);\n\n    /**\n     * @dev gets address of all extensions\n     */\n    function getExtensions() external view returns (address[] memory);\n\n    /**\n     * @dev add an extension.  Can only be called by contract owner or admin.\n     * extension address must point to a contract implementing ICreatorExtension.\n     * Returns True if newly added, False if already added.\n     */\n    function registerExtension(address extension, string calldata baseURI) external;\n\n    /**\n     * @dev add an extension.  Can only be called by contract owner or admin.\n     * extension address must point to a contract implementing ICreatorExtension.\n     * Returns True if newly added, False if already added.\n     */\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external;\n\n    /**\n     * @dev add an extension.  Can only be called by contract owner or admin.\n     * Returns True if removed, False if already removed.\n     */\n    function unregisterExtension(address extension) external;\n\n    /**\n     * @dev blacklist an extension.  Can only be called by contract owner or admin.\n     * This function will destroy all ability to reference the metadata of any tokens created\n     * by the specified extension. It will also unregister the extension if needed.\n     * Returns True if removed, False if already removed.\n     */\n    function blacklistExtension(address extension) external;\n\n    /**\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\n     */\n    function setBaseTokenURIExtension(string calldata uri) external;\n\n    /**\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\n     * For tokens with no uri configured, tokenURI will return \"uri+tokenId\"\n     */\n    function setBaseTokenURIExtension(string calldata uri, bool identical) external;\n\n    /**\n     * @dev set the common prefix of an extension.  Can only be called by extension.\n     * If configured, and a token has a uri set, tokenURI will return \"prefixURI+tokenURI\"\n     * Useful if you want to use ipfs/arweave\n     */\n    function setTokenURIPrefixExtension(string calldata prefix) external;\n\n    /**\n     * @dev set the tokenURI of a token extension.  Can only be called by extension that minted token.\n     */\n    function setTokenURIExtension(uint256 tokenId, string calldata uri) external;\n\n    /**\n     * @dev set the tokenURI of a token extension for multiple tokens.  Can only be called by extension that minted token.\n     */\n    function setTokenURIExtension(uint256[] memory tokenId, string[] calldata uri) external;\n\n    /**\n     * @dev set the baseTokenURI for tokens with no extension.  Can only be called by owner/admin.\n     * For tokens with no uri configured, tokenURI will return \"uri+tokenId\"\n     */\n    function setBaseTokenURI(string calldata uri) external;\n\n    /**\n     * @dev set the common prefix for tokens with no extension.  Can only be called by owner/admin.\n     * If configured, and a token has a uri set, tokenURI will return \"prefixURI+tokenURI\"\n     * Useful if you want to use ipfs/arweave\n     */\n    function setTokenURIPrefix(string calldata prefix) external;\n\n    /**\n     * @dev set the tokenURI of a token with no extension.  Can only be called by owner/admin.\n     */\n    function setTokenURI(uint256 tokenId, string calldata uri) external;\n\n    /**\n     * @dev set the tokenURI of multiple tokens with no extension.  Can only be called by owner/admin.\n     */\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external;\n\n    /**\n     * @dev set a permissions contract for an extension.  Used to control minting.\n     */\n    function setMintPermissions(address extension, address permissions) external;\n\n    /**\n     * @dev Configure so transfers of tokens created by the caller (must be extension) gets approval\n     * from the extension before transferring\n     */\n    function setApproveTransferExtension(bool enabled) external;\n\n    /**\n     * @dev get the extension of a given token\n     */\n    function tokenExtension(uint256 tokenId) external view returns (address);\n\n    /**\n     * @dev Set default royalties\n     */\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external;\n\n    /**\n     * @dev Set royalties of a token\n     */\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\n\n    /**\n     * @dev Set royalties of an extension\n     */\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\n\n    /**\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\n     */\n    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n    \n    // Royalty support for various other standards\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\n    function getFeeBps(uint256 tokenId) external view returns (uint[] memory);\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\n\n    /**\n     * @dev Set the default approve transfer contract location.\n     */\n    function setApproveTransfer(address extension) external; \n\n    /**\n     * @dev Get the default approve transfer contract location.\n     */\n    function getApproveTransfer() external view returns (address);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}