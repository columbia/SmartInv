{{
  "language": "Solidity",
  "sources": {
    "contracts/auction/AuctionHouse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./Staged.sol\";\nimport \"./AuctionHouseMath.sol\";\n\nimport \"./interfaces/IAuctionHouse.sol\";\n\nimport \"../funds/interfaces/basket/IBasketReader.sol\";\nimport \"../oracle/interfaces/ITwap.sol\";\nimport \"../policy/interfaces/IMonetaryPolicy.sol\";\nimport \"../tokens/interfaces/ISupplyControlledERC20.sol\";\n\nimport \"../lib/BasisMath.sol\";\nimport \"../lib/BlockNumber.sol\";\nimport \"../lib/Recoverable.sol\";\nimport \"../external-lib/SafeDecimalMath.sol\";\nimport \"../tokens/SafeSupplyControlledERC20.sol\";\n\n/**\n * @title Float Protocol Auction House\n * @notice The contract used to sell or buy FLOAT\n * @dev This contract does not store any assets, except for protocol fees, hence\n * it implements an asset recovery functionality (Recoverable).\n */\ncontract AuctionHouse is\n  IAuctionHouse,\n  BlockNumber,\n  AuctionHouseMath,\n  AccessControl,\n  Staged,\n  Recoverable\n{\n  using SafeMath for uint256;\n  using SafeDecimalMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ISupplyControlledERC20;\n  using SafeSupplyControlledERC20 for ISupplyControlledERC20;\n  using BasisMath for uint256;\n\n  /* ========== CONSTANTS ========== */\n  bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n\n  IERC20 internal immutable weth;\n  ISupplyControlledERC20 internal immutable bank;\n  ISupplyControlledERC20 internal immutable float;\n  IBasketReader internal immutable basket;\n\n  /* ========== STATE VARIABLES ========== */\n  // Monetary Policy Contract that decides the target price\n  IMonetaryPolicy internal monetaryPolicy;\n  // Provides the BANK-ETH Time Weighted Average Price (TWAP) [e27]\n  ITwap internal bankEthOracle;\n  // Provides the FLOAT-ETH Time Weighted Average Price (TWAP) [e27]\n  ITwap internal floatEthOracle;\n\n  /// @inheritdoc IAuctionHouseState\n  uint16 public override buffer = 10_00; // 10% default\n\n  /// @inheritdoc IAuctionHouseState\n  uint16 public override protocolFee = 5_00; // 5% / 500 bps\n\n  /// @inheritdoc IAuctionHouseState\n  uint32 public override allowanceCap = 10_00; // 10% / 1000 bps\n\n  /// @inheritdoc IAuctionHouseVariables\n  uint64 public override round;\n\n  /**\n   * @notice Allows for monetary policy updates to be enabled and disabled.\n   */\n  bool public shouldUpdatePolicy = true;\n\n  /**\n   * Note that we choose to freeze all price values at the start of an auction.\n   * These values are stale _by design_. The burden of price checking\n   * is moved to the arbitrager, already vital for them to make a profit.\n   * We don't mind these values being out of date, as we start the auctions from a position generously in favour of the protocol (assuming our target price is correct). If these market values are stale, then profit opportunity will start earlier / later, and hence close out a mispriced auction early.\n   * We also start the auctions at `buffer`% of the price.\n   */\n\n  /// @inheritdoc IAuctionHouseVariables\n  mapping(uint64 => Auction) public override auctions;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    // Dependencies\n    address _weth,\n    address _bank,\n    address _float,\n    address _basket,\n    address _monetaryPolicy,\n    address _gov,\n    address _bankEthOracle,\n    address _floatEthOracle,\n    // Parameters\n    uint16 _auctionDuration,\n    uint32 _auctionCooldown,\n    uint256 _firstAuctionBlock\n  ) Staged(_auctionDuration, _auctionCooldown, _firstAuctionBlock) {\n    // Tokens\n    weth = IERC20(_weth);\n    bank = ISupplyControlledERC20(_bank);\n    float = ISupplyControlledERC20(_float);\n\n    // Basket\n    basket = IBasketReader(_basket);\n\n    // Monetary Policy\n    monetaryPolicy = IMonetaryPolicy(_monetaryPolicy);\n    floatEthOracle = ITwap(_floatEthOracle);\n    bankEthOracle = ITwap(_bankEthOracle);\n\n    emit ModifyParameters(\"monetaryPolicy\", _monetaryPolicy);\n    emit ModifyParameters(\"floatEthOracle\", _floatEthOracle);\n    emit ModifyParameters(\"bankEthOracle\", _bankEthOracle);\n\n    emit ModifyParameters(\"auctionDuration\", _auctionDuration);\n    emit ModifyParameters(\"auctionCooldown\", _auctionCooldown);\n    emit ModifyParameters(\"lastAuctionBlock\", lastAuctionBlock);\n    emit ModifyParameters(\"buffer\", buffer);\n    emit ModifyParameters(\"protocolFee\", protocolFee);\n    emit ModifyParameters(\"allowanceCap\", allowanceCap);\n\n    // Roles\n    _setupRole(DEFAULT_ADMIN_ROLE, _gov);\n    _setupRole(GOVERNANCE_ROLE, _gov);\n    _setupRole(RECOVER_ROLE, _gov);\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier onlyGovernance {\n    require(\n      hasRole(GOVERNANCE_ROLE, _msgSender()),\n      \"AuctionHouse/GovernanceRole\"\n    );\n    _;\n  }\n\n  modifier inExpansion {\n    require(\n      latestAuction().stabilisationCase == Cases.Up ||\n        latestAuction().stabilisationCase == Cases.Restock,\n      \"AuctionHouse/NotInExpansion\"\n    );\n    _;\n  }\n\n  modifier inContraction {\n    require(\n      latestAuction().stabilisationCase == Cases.Confidence ||\n        latestAuction().stabilisationCase == Cases.Down,\n      \"AuctionHouse/NotInContraction\"\n    );\n    _;\n  }\n\n  /* ========== VIEWS ========== */\n\n  /// @inheritdoc IAuctionHouseDerivedState\n  function price()\n    public\n    view\n    override(IAuctionHouseDerivedState)\n    returns (uint256 wethPrice, uint256 bankPrice)\n  {\n    Auction memory _latestAuction = latestAuction();\n    uint256 _step = step();\n\n    wethPrice = lerp(\n      _latestAuction.startWethPrice,\n      _latestAuction.endWethPrice,\n      _step,\n      auctionDuration\n    );\n    bankPrice = lerp(\n      _latestAuction.startBankPrice,\n      _latestAuction.endBankPrice,\n      _step,\n      auctionDuration\n    );\n    return (wethPrice, bankPrice);\n  }\n\n  /// @inheritdoc IAuctionHouseDerivedState\n  function step()\n    public\n    view\n    override(IAuctionHouseDerivedState)\n    atStage(Stages.AuctionActive)\n    returns (uint256)\n  {\n    // .sub is unnecessary here - block number >= lastAuctionBlock.\n    return _blockNumber() - lastAuctionBlock;\n  }\n\n  function _startPrice(\n    bool expansion,\n    Cases stabilisationCase,\n    uint256 targetFloatInEth,\n    uint256 marketFloatInEth,\n    uint256 bankInEth,\n    uint256 basketFactor\n  ) internal view returns (uint256 wethStart, uint256 bankStart) {\n    uint256 bufferedMarketPrice =\n      _bufferedMarketPrice(expansion, marketFloatInEth);\n\n    if (stabilisationCase == Cases.Up) {\n      uint256 bankProportion =\n        bufferedMarketPrice.sub(targetFloatInEth).divideDecimalRoundPrecise(\n          bankInEth\n        );\n\n      return (targetFloatInEth, bankProportion);\n    }\n\n    if (\n      stabilisationCase == Cases.Restock ||\n      stabilisationCase == Cases.Confidence\n    ) {\n      return (bufferedMarketPrice, 0);\n    }\n\n    assert(stabilisationCase == Cases.Down);\n    assert(basketFactor < SafeDecimalMath.PRECISE_UNIT);\n    uint256 invertedBasketFactor =\n      SafeDecimalMath.PRECISE_UNIT.sub(basketFactor);\n\n    uint256 basketFactorAdjustedEth =\n      bufferedMarketPrice.multiplyDecimalRoundPrecise(basketFactor);\n\n    // Note that the PRECISE_UNIT factors itself out\n    uint256 basketFactorAdjustedBank =\n      bufferedMarketPrice.mul(invertedBasketFactor).div(bankInEth);\n    return (basketFactorAdjustedEth, basketFactorAdjustedBank);\n  }\n\n  function _endPrice(\n    Cases stabilisationCase,\n    uint256 targetFloatInEth,\n    uint256 bankInEth,\n    uint256 basketFactor\n  ) internal pure returns (uint256 wethEnd, uint256 bankEnd) {\n    if (stabilisationCase == Cases.Down) {\n      assert(basketFactor < SafeDecimalMath.PRECISE_UNIT);\n      uint256 invertedBasketFactor =\n        SafeDecimalMath.PRECISE_UNIT.sub(basketFactor);\n\n      uint256 basketFactorAdjustedEth =\n        targetFloatInEth.multiplyDecimalRoundPrecise(basketFactor);\n\n      // Note that the PRECISE_UNIT factors itself out.\n      uint256 basketFactorAdjustedBank =\n        targetFloatInEth.mul(invertedBasketFactor).div(bankInEth);\n      return (basketFactorAdjustedEth, basketFactorAdjustedBank);\n    }\n\n    return (targetFloatInEth, 0);\n  }\n\n  /// @inheritdoc IAuctionHouseDerivedState\n  function latestAuction()\n    public\n    view\n    override(IAuctionHouseDerivedState)\n    returns (Auction memory)\n  {\n    return auctions[round];\n  }\n\n  /// @dev Returns a buffered [e27] market price, note that buffer is still [e18], so can use divideDecimal.\n  function _bufferedMarketPrice(bool expansion, uint256 marketPrice)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 factor =\n      expansion\n        ? BasisMath.FULL_PERCENT.add(buffer)\n        : BasisMath.FULL_PERCENT.sub(buffer);\n    return marketPrice.percentageOf(factor);\n  }\n\n  /// @dev Calculates the current case based on if we're expanding and basket factor.\n  function _currentCase(bool expansion, uint256 basketFactor)\n    internal\n    pure\n    returns (Cases)\n  {\n    bool underlyingDemand = basketFactor >= SafeDecimalMath.PRECISE_UNIT;\n\n    if (expansion) {\n      return underlyingDemand ? Cases.Up : Cases.Restock;\n    }\n\n    return underlyingDemand ? Cases.Confidence : Cases.Down;\n  }\n\n  /* |||||||||| AuctionPending |||||||||| */\n\n  // solhint-disable function-max-lines\n  /// @inheritdoc IAuctionHouseActions\n  function start()\n    external\n    override(IAuctionHouseActions)\n    timedTransition\n    atStage(Stages.AuctionPending)\n    returns (uint64 newRound)\n  {\n    // Check we have up to date oracles, this also ensures we don't have\n    // auctions too close together (reverts based upon timeElapsed < periodSize).\n    bankEthOracle.update(address(bank), address(weth));\n    floatEthOracle.update(address(float), address(weth));\n\n    // [e27]\n    uint256 frozenBankInEth =\n      bankEthOracle.consult(\n        address(bank),\n        SafeDecimalMath.PRECISE_UNIT,\n        address(weth)\n      );\n    // [e27]\n    uint256 frozenFloatInEth =\n      floatEthOracle.consult(\n        address(float),\n        SafeDecimalMath.PRECISE_UNIT,\n        address(weth)\n      );\n\n    // Update Monetary Policy with previous auction results\n    if (round != 0 && shouldUpdatePolicy) {\n      uint256 oldTargetPriceInEth = monetaryPolicy.consult();\n      uint256 oldBasketFactor = basket.getBasketFactor(oldTargetPriceInEth);\n\n      monetaryPolicy.updateGivenAuctionResults(\n        round,\n        lastAuctionBlock,\n        frozenFloatInEth,\n        oldBasketFactor\n      );\n    }\n\n    // Round only increments by one on start, given auction period of restriction of 150 blocks\n    // this means we'd need 2**64 / 150 blocks or ~3.7 lifetimes of the universe to overflow.\n    // Likely, we'd have upgraded the contract by this point.\n    round++;\n\n    // Calculate target price [e27]\n    uint256 frozenTargetPriceInEth = monetaryPolicy.consult();\n\n    // STC: Pull out to ValidateOracles\n    require(frozenTargetPriceInEth != 0, \"AuctionHouse/TargetSenseCheck\");\n    require(frozenBankInEth != 0, \"AuctionHouse/BankSenseCheck\");\n    require(frozenFloatInEth != 0, \"AuctionHouse/FloatSenseCheck\");\n    uint256 basketFactor = basket.getBasketFactor(frozenTargetPriceInEth);\n\n    bool expansion = frozenFloatInEth >= frozenTargetPriceInEth;\n    Cases stabilisationCase = _currentCase(expansion, basketFactor);\n\n    // Calculate Auction Price points\n    (uint256 wethStart, uint256 bankStart) =\n      _startPrice(\n        expansion,\n        stabilisationCase,\n        frozenTargetPriceInEth,\n        frozenFloatInEth,\n        frozenBankInEth,\n        basketFactor\n      );\n\n    (uint256 wethEnd, uint256 bankEnd) =\n      _endPrice(\n        stabilisationCase,\n        frozenTargetPriceInEth,\n        frozenBankInEth,\n        basketFactor\n      );\n\n    // Calculate Allowance\n    uint256 allowance =\n      AuctionHouseMath.allowance(\n        expansion,\n        allowanceCap,\n        float.totalSupply(),\n        frozenFloatInEth,\n        frozenTargetPriceInEth\n      );\n\n    require(allowance != 0, \"AuctionHouse/NoAllowance\");\n\n    auctions[round].stabilisationCase = stabilisationCase;\n    auctions[round].targetFloatInEth = frozenTargetPriceInEth;\n    auctions[round].marketFloatInEth = frozenFloatInEth;\n    auctions[round].bankInEth = frozenBankInEth;\n\n    auctions[round].basketFactor = basketFactor;\n    auctions[round].allowance = allowance;\n\n    auctions[round].startWethPrice = wethStart;\n    auctions[round].startBankPrice = bankStart;\n    auctions[round].endWethPrice = wethEnd;\n    auctions[round].endBankPrice = bankEnd;\n\n    lastAuctionBlock = _blockNumber();\n    _setStage(Stages.AuctionActive);\n\n    emit NewAuction(round, allowance, frozenTargetPriceInEth, lastAuctionBlock);\n\n    return round;\n  }\n\n  // solhint-enable function-max-lines\n\n  /* |||||||||| AuctionActive |||||||||| */\n\n  function _updateDelta(uint256 floatDelta) internal {\n    Auction memory _currentAuction = latestAuction();\n\n    require(\n      floatDelta <= _currentAuction.allowance.sub(_currentAuction.delta),\n      \"AuctionHouse/WithinAllowedDelta\"\n    );\n\n    auctions[round].delta = _currentAuction.delta.add(floatDelta);\n  }\n\n  /* |||||||||| AuctionActive:inExpansion |||||||||| */\n\n  /// @inheritdoc IAuctionHouseActions\n  function buy(\n    uint256 wethInMax,\n    uint256 bankInMax,\n    uint256 floatOutMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    override(IAuctionHouseActions)\n    timedTransition\n    atStage(Stages.AuctionActive)\n    inExpansion\n    returns (\n      uint256 usedWethIn,\n      uint256 usedBankIn,\n      uint256 usedFloatOut\n    )\n  {\n    // solhint-disable-next-line not-rely-on-time\n    require(block.timestamp <= deadline, \"AuctionHouse/TransactionTooOld\");\n\n    (uint256 wethPrice, uint256 bankPrice) = price();\n\n    usedFloatOut = Math.min(\n      wethInMax.divideDecimalRoundPrecise(wethPrice),\n      bankPrice == 0\n        ? type(uint256).max\n        : bankInMax.divideDecimalRoundPrecise(bankPrice)\n    );\n\n    require(usedFloatOut != 0, \"AuctionHouse/ZeroFloatBought\");\n    require(usedFloatOut >= floatOutMin, \"AuctionHouse/RequestedTooMuch\");\n\n    usedWethIn = wethPrice.multiplyDecimalRoundPrecise(usedFloatOut);\n    usedBankIn = bankPrice.multiplyDecimalRoundPrecise(usedFloatOut);\n\n    require(wethInMax >= usedWethIn, \"AuctionHouse/MinimumWeth\");\n    require(bankInMax >= usedBankIn, \"AuctionHouse/MinimumBank\");\n\n    _updateDelta(usedFloatOut);\n\n    emit Buy(round, _msgSender(), usedWethIn, usedBankIn, usedFloatOut);\n\n    _interactBuy(usedWethIn, usedBankIn, usedFloatOut, to);\n\n    return (usedWethIn, usedBankIn, usedFloatOut);\n  }\n\n  function _interactBuy(\n    uint256 usedWethIn,\n    uint256 usedBankIn,\n    uint256 usedFloatOut,\n    address to\n  ) internal {\n    weth.safeTransferFrom(_msgSender(), address(basket), usedWethIn);\n\n    if (usedBankIn != 0) {\n      (uint256 bankToSave, uint256 bankToBurn) =\n        usedBankIn.splitBy(protocolFee);\n\n      bank.safeTransferFrom(_msgSender(), address(this), bankToSave);\n      bank.safeBurnFrom(_msgSender(), bankToBurn);\n    }\n\n    float.safeMint(to, usedFloatOut);\n  }\n\n  /* |||||||||| AuctionActive:inContraction |||||||||| */\n\n  /// @inheritdoc IAuctionHouseActions\n  function sell(\n    uint256 floatIn,\n    uint256 wethOutMin,\n    uint256 bankOutMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    override(IAuctionHouseActions)\n    timedTransition\n    atStage(Stages.AuctionActive)\n    inContraction\n    returns (\n      uint256 usedfloatIn,\n      uint256 usedWethOut,\n      uint256 usedBankOut\n    )\n  {\n    // solhint-disable-next-line not-rely-on-time\n    require(block.timestamp <= deadline, \"AuctionHouse/TransactionTooOld\");\n    require(floatIn != 0, \"AuctionHouse/ZeroFloatSold\");\n\n    (uint256 wethPrice, uint256 bankPrice) = price();\n\n    usedWethOut = wethPrice.multiplyDecimalRoundPrecise(floatIn);\n    usedBankOut = bankPrice.multiplyDecimalRoundPrecise(floatIn);\n\n    require(wethOutMin <= usedWethOut, \"AuctionHouse/ExpectedTooMuchWeth\");\n    require(bankOutMin <= usedBankOut, \"AuctionHouse/ExpectedTooMuchBank\");\n\n    _updateDelta(floatIn);\n\n    emit Sell(round, _msgSender(), floatIn, usedWethOut, usedBankOut);\n\n    _interactSell(floatIn, usedWethOut, usedBankOut, to);\n\n    return (floatIn, usedWethOut, usedBankOut);\n  }\n\n  function _interactSell(\n    uint256 floatIn,\n    uint256 usedWethOut,\n    uint256 usedBankOut,\n    address to\n  ) internal {\n    float.safeBurnFrom(_msgSender(), floatIn);\n\n    if (usedWethOut != 0) {\n      weth.safeTransferFrom(address(basket), to, usedWethOut);\n    }\n\n    if (usedBankOut != 0) {\n      // STC: Maximum mint checks relative to allowance\n      bank.safeMint(to, usedBankOut);\n    }\n  }\n\n  /* |||||||||| AuctionCooldown, AuctionPending, AuctionActive |||||||||| */\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /* ----- onlyGovernance ----- */\n\n  /// @inheritdoc IAuctionHouseGovernedActions\n  function modifyParameters(bytes32 parameter, uint256 data)\n    external\n    override(IAuctionHouseGovernedActions)\n    onlyGovernance\n  {\n    if (parameter == \"auctionDuration\") {\n      require(data <= type(uint16).max, \"AuctionHouse/ModADMax\");\n      require(data != 0, \"AuctionHouse/ModADZero\");\n      auctionDuration = uint16(data);\n    } else if (parameter == \"auctionCooldown\") {\n      require(data <= type(uint32).max, \"AuctionHouse/ModCMax\");\n      auctionCooldown = uint32(data);\n    } else if (parameter == \"buffer\") {\n      // 0% <= buffer <= 1000%\n      require(data <= 10 * BasisMath.FULL_PERCENT, \"AuctionHouse/ModBMax\");\n      buffer = uint16(data);\n    } else if (parameter == \"protocolFee\") {\n      // 0% <= protocolFee <= 100%\n      require(data <= BasisMath.FULL_PERCENT, \"AuctionHouse/ModPFMax\");\n      protocolFee = uint16(data);\n    } else if (parameter == \"allowanceCap\") {\n      // 0% < allowanceCap <= N ~ 1_000%\n      require(data <= type(uint32).max, \"AuctionHouse/ModACMax\");\n      require(data != 0, \"AuctionHouse/ModACMin\");\n      allowanceCap = uint32(data);\n    } else if (parameter == \"shouldUpdatePolicy\") {\n      require(data == 1 || data == 0, \"AuctionHouse/ModUP\");\n      shouldUpdatePolicy = data == 1;\n    } else if (parameter == \"lastAuctionBlock\") {\n      // We wouldn't want to disable auctions for more than ~4.3 weeks\n      // A longer period should result in a \"burnt\" auction house and redeploy.\n      require(data <= block.number + 2e5, \"AuctionHouse/ModLABMax\");\n      require(data != 0, \"AuctionHouse/ModLABMin\");\n      // Can be used to pause auctions if set in the future.\n      lastAuctionBlock = data;\n    } else revert(\"AuctionHouse/InvalidParameter\");\n\n    emit ModifyParameters(parameter, data);\n  }\n\n  /// @inheritdoc IAuctionHouseGovernedActions\n  function modifyParameters(bytes32 parameter, address data)\n    external\n    override(IAuctionHouseGovernedActions)\n    onlyGovernance\n  {\n    if (parameter == \"monetaryPolicy\") {\n      // STC: Sense check\n      monetaryPolicy = IMonetaryPolicy(data);\n    } else if (parameter == \"bankEthOracle\") {\n      // STC: Sense check\n      bankEthOracle = ITwap(data);\n    } else if (parameter == \"floatEthOracle\") {\n      // STC: Sense check\n      floatEthOracle = ITwap(data);\n    } else revert(\"AuctionHouse/InvalidParameter\");\n\n    emit ModifyParameters(parameter, data);\n  }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/auction/Staged.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../lib/BlockNumber.sol\";\n\ncontract Staged is BlockNumber {\n  /**\n   * @dev The current auction stage.\n   * - AuctionCooling - We cannot start an auction due to Cooling Period.\n   * - AuctionPending - We can start an auction at any time.\n   * - AuctionActive - Auction is ongoing.\n   */\n  enum Stages {AuctionCooling, AuctionPending, AuctionActive}\n\n  /* ========== STATE VARIABLES ========== */\n\n  /**\n   * @dev The cooling period between each auction in blocks.\n   */\n  uint32 internal auctionCooldown;\n\n  /**\n   * @dev The length of the auction in blocks.\n   */\n  uint16 internal auctionDuration;\n\n  /**\n   * @notice The current stage\n   */\n  Stages public stage;\n\n  /**\n   * @notice Block number when the last auction started.\n   */\n  uint256 public lastAuctionBlock;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    uint16 _auctionDuration,\n    uint32 _auctionCooldown,\n    uint256 _firstAuctionBlock\n  ) {\n    require(\n      _firstAuctionBlock >= _auctionDuration + _auctionCooldown,\n      \"Staged/InvalidAuctionStart\"\n    );\n\n    auctionDuration = _auctionDuration;\n    auctionCooldown = _auctionCooldown;\n    lastAuctionBlock = _firstAuctionBlock - _auctionDuration - _auctionCooldown;\n    stage = Stages.AuctionCooling;\n  }\n\n  /* ============ Events ============ */\n\n  event StageChanged(uint8 _prevStage, uint8 _newStage);\n\n  /* ========== MODIFIERS ========== */\n\n  modifier atStage(Stages _stage) {\n    require(stage == _stage, \"Staged/InvalidStage\");\n    _;\n  }\n\n  /**\n   * @dev Modify the stages as necessary on call.\n   */\n  modifier timedTransition() {\n    uint256 _blockNumber = _blockNumber();\n\n    if (\n      stage == Stages.AuctionActive &&\n      _blockNumber > lastAuctionBlock + auctionDuration\n    ) {\n      stage = Stages.AuctionCooling;\n      emit StageChanged(uint8(Stages.AuctionActive), uint8(stage));\n    }\n    // Note that this can cascade so AuctionActive -> AuctionPending in one update, when auctionCooldown = 0.\n    if (\n      stage == Stages.AuctionCooling &&\n      _blockNumber > lastAuctionBlock + auctionDuration + auctionCooldown\n    ) {\n      stage = Stages.AuctionPending;\n      emit StageChanged(uint8(Stages.AuctionCooling), uint8(stage));\n    }\n\n    _;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @notice Updates the stage, even if a function with timedTransition modifier has not yet been called\n   * @return Returns current auction stage\n   */\n  function updateStage() external timedTransition returns (Stages) {\n    return stage;\n  }\n\n  /**\n   * @dev Set the stage manually.\n   */\n  function _setStage(Stages _stage) internal {\n    Stages priorStage = stage;\n    stage = _stage;\n    emit StageChanged(uint8(priorStage), uint8(_stage));\n  }\n}\n"
    },
    "contracts/auction/AuctionHouseMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"../lib/BasisMath.sol\";\nimport \"../external-lib/SafeDecimalMath.sol\";\n\ncontract AuctionHouseMath {\n  using SafeMath for uint256;\n  using SafeDecimalMath for uint256;\n  using BasisMath for uint256;\n\n  /**\n   * @notice Calculate the maximum allowance for this action to do a price correction\n   * This is normally an over-estimate as it assumes all Float is circulating\n   * and the market cap is constant through supply changes.\n   */\n  function allowance(\n    bool expansion,\n    uint256 capBasisPoint,\n    uint256 floatSupply,\n    uint256 marketFloatPrice,\n    uint256 targetFloatPrice\n  ) internal pure returns (uint256) {\n    uint256 targetSupply =\n      marketFloatPrice.mul(floatSupply).div(targetFloatPrice);\n    uint256 allowanceForAdjustment =\n      expansion ? targetSupply.sub(floatSupply) : floatSupply.sub(targetSupply);\n\n    // Cap Allowance per auction; e.g. with 10% of total supply => ~20% price move.\n    uint256 allowanceByCap = floatSupply.percentageOf(capBasisPoint);\n\n    return Math.min(allowanceForAdjustment, allowanceByCap);\n  }\n\n  /**\n   * @notice Linear interpolation: start + (end - start) * (step/duration)\n   * @dev For 150 steps, duration = 149, start / end can be in any format\n   * as long as <= 10 ** 49.\n   * @param start The starting value\n   * @param end The ending value\n   * @param step Number of blocks into interpolation\n   * @param duration Total range\n   */\n  function lerp(\n    uint256 start,\n    uint256 end,\n    uint256 step,\n    uint256 duration\n  ) internal pure returns (uint256 result) {\n    require(duration != 0, \"AuctionHouseMath/ZeroDuration\");\n    require(step <= duration, \"AuctionHouseMath/InvalidStep\");\n\n    // Max value <= 2^256 / 10^27 of which 10^49 is.\n    require(start <= 10**49, \"AuctionHouseMath/StartTooLarge\");\n    require(end <= 10**49, \"AuctionHouseMath/EndTooLarge\");\n\n    // 0 <= t <= PRECISE_UNIT\n    uint256 t = step.divideDecimalRoundPrecise(duration);\n\n    // result = start + (end - start) * t\n    //        = end * t + start - start * t\n    return\n      result = end.multiplyDecimalRoundPrecise(t).add(start).sub(\n        start.multiplyDecimalRoundPrecise(t)\n      );\n  }\n}\n"
    },
    "contracts/auction/interfaces/IAuctionHouse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./ah/IAuctionHouseState.sol\";\nimport \"./ah/IAuctionHouseVariables.sol\";\nimport \"./ah/IAuctionHouseDerivedState.sol\";\nimport \"./ah/IAuctionHouseActions.sol\";\nimport \"./ah/IAuctionHouseGovernedActions.sol\";\nimport \"./ah/IAuctionHouseEvents.sol\";\n\n/**\n * @title The interface for a Float Protocol Auction House\n * @notice The Auction House enables the sale and buy of FLOAT tokens from the\n * market in order to stabilise price.\n * @dev The Auction House interface is broken up into many smaller pieces\n */\ninterface IAuctionHouse is\n  IAuctionHouseState,\n  IAuctionHouseVariables,\n  IAuctionHouseDerivedState,\n  IAuctionHouseActions,\n  IAuctionHouseGovernedActions,\n  IAuctionHouseEvents\n{\n\n}\n"
    },
    "contracts/funds/interfaces/basket/IBasketReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\ninterface IBasketReader {\n  /**\n   * @notice Underlying token that is kept in this Basket\n   */\n  function underlying() external view returns (address);\n\n  /**\n   * @notice Given a target price, what is the basket factor\n   * @param targetPriceInUnderlying the current target price to calculate the\n   * basket factor for in the units of the underlying token.\n   */\n  function getBasketFactor(uint256 targetPriceInUnderlying)\n    external\n    view\n    returns (uint256 basketFactor);\n}\n"
    },
    "contracts/oracle/interfaces/ITwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\ninterface ITwap {\n  /**\n   * @notice Returns the amount out corresponding to the amount in for a given token using the moving average over time range [`block.timestamp` - [`windowSize`, `windowSize - periodSize * 2`], `block.timestamp`].\n   * E.g. with a windowSize = 24hrs, periodSize = 6hrs.\n   * [24hrs ago to 12hrs ago, now]\n   * @dev Update must have been called for the bucket corresponding to the timestamp `now - windowSize`\n   * @param tokenIn the address of the token we are offering\n   * @param amountIn the quantity of tokens we are pricing\n   * @param tokenOut the address of the token we want\n   * @return amountOut the `tokenOut` amount corresponding to the `amountIn` for `tokenIn` over the time range\n   */\n  function consult(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut\n  ) external view returns (uint256 amountOut);\n\n  /**\n   * @notice Checks if a particular pair can be updated\n   * @param tokenA Token A of pair (any order)\n   * @param tokenB Token B of pair (any order)\n   * @return If an update call will succeed\n   */\n  function updateable(address tokenA, address tokenB)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @notice Update the cumulative price for the observation at the current timestamp. Each observation is updated at most once per epoch period.\n   * @param tokenA the first token to create pair from\n   * @param tokenB the second token to create pair from\n   * @return if the observation was updated or not.\n   */\n  function update(address tokenA, address tokenB) external returns (bool);\n}\n"
    },
    "contracts/policy/interfaces/IMonetaryPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\ninterface IMonetaryPolicy {\n  /**\n   * @notice Consult the monetary policy for the target price in eth\n   */\n  function consult() external view returns (uint256 targetPriceInEth);\n\n  /**\n   * @notice Update the Target price given the auction results.\n   * @dev 0 values are used to indicate missing data.\n   */\n  function updateGivenAuctionResults(\n    uint256 round,\n    uint256 lastAuctionBlock,\n    uint256 floatMarketPrice,\n    uint256 basketFactor\n  ) external returns (uint256 targetPriceInEth);\n}\n"
    },
    "contracts/tokens/interfaces/ISupplyControlledERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISupplyControlledERC20 is IERC20 {\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   * Requirements:\n   * - the caller must have the `MINTER_ROLE`.\n   */\n  function mint(address to, uint256 amount) external;\n\n  /**\n   * @dev Destroys `amount` tokens from the caller.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burn(uint256 amount) external;\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "contracts/lib/BasisMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n/**\n * @title Basis Mathematics\n * @notice Provides helpers to perform percentage calculations\n * @dev Percentages are [e2] i.e. with 2 decimals precision / basis point.\n */\nlibrary BasisMath {\n  uint256 internal constant FULL_PERCENT = 1e4; // 100.00% / 1000 bp\n  uint256 internal constant HALF_ONCE_SCALED = FULL_PERCENT / 2;\n\n  /**\n   * @dev Percentage pct, round 0.5+ up.\n   * @param self The value to take a percentage pct\n   * @param percentage The percentage to be calculated [e2]\n   * @return pct self * percentage\n   */\n  function percentageOf(uint256 self, uint256 percentage)\n    internal\n    pure\n    returns (uint256 pct)\n  {\n    if (self == 0 || percentage == 0) {\n      pct = 0;\n    } else {\n      require(\n        self <= (type(uint256).max - HALF_ONCE_SCALED) / percentage,\n        \"BasisMath/Overflow\"\n      );\n\n      pct = (self * percentage + HALF_ONCE_SCALED) / FULL_PERCENT;\n    }\n  }\n\n  /**\n   * @dev Split value into percentage, round 0.5+ up.\n   * @param self The value to split\n   * @param percentage The percentage to be calculated [e2]\n   * @return pct The percentage of the value\n   * @return rem Anything leftover from the value\n   */\n  function splitBy(uint256 self, uint256 percentage)\n    internal\n    pure\n    returns (uint256 pct, uint256 rem)\n  {\n    require(percentage <= FULL_PERCENT, \"BasisMath/ExcessPercentage\");\n    pct = percentageOf(self, percentage);\n    rem = self - pct;\n  }\n}\n"
    },
    "contracts/lib/BlockNumber.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n/// @title Function for getting block number\n/// @dev Base contract that is overridden for tests\nabstract contract BlockNumber {\n  /// @dev Method that exists purely to be overridden for tests\n  /// @return The current block number\n  function _blockNumber() internal view virtual returns (uint256) {\n    return block.number;\n  }\n}\n"
    },
    "contracts/lib/Recoverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Recoverable feature\n * @dev should _only_ be used with contracts that should not store assets,\n * but instead interacted with value so there is potential to lose assets.\n */\nabstract contract Recoverable is AccessControl {\n  using SafeERC20 for IERC20;\n  using Address for address payable;\n\n  /* ========== CONSTANTS ========== */\n  bytes32 public constant RECOVER_ROLE = keccak256(\"RECOVER_ROLE\");\n\n  /* ============ Events ============ */\n\n  event Recovered(address onBehalfOf, address tokenAddress, uint256 amount);\n\n  /* ========== MODIFIERS ========== */\n\n  modifier isRecoverer {\n    require(hasRole(RECOVER_ROLE, _msgSender()), \"Recoverable/RecoverRole\");\n    _;\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n  /* ----- RECOVER_ROLE ----- */\n\n  /**\n   * @notice Provide accidental token retrieval.\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\n   */\n  function recoverERC20(\n    address to,\n    address tokenAddress,\n    uint256 tokenAmount\n  ) external isRecoverer {\n    emit Recovered(to, tokenAddress, tokenAmount);\n\n    IERC20(tokenAddress).safeTransfer(to, tokenAmount);\n  }\n\n  /**\n   * @notice Provide accidental ETH retrieval.\n   */\n  function recoverETH(address to) external isRecoverer {\n    uint256 contractBalance = address(this).balance;\n\n    emit Recovered(to, address(0), contractBalance);\n\n    payable(to).sendValue(contractBalance);\n  }\n}\n"
    },
    "contracts/external-lib/SafeDecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n  using SafeMath for uint256;\n\n  /* Number of decimal places in the representations. */\n  uint8 public constant decimals = 18;\n  uint8 public constant highPrecisionDecimals = 27;\n\n  /* The number representing 1.0. */\n  uint256 public constant UNIT = 10**uint256(decimals);\n\n  /* The number representing 1.0 for higher fidelity numbers. */\n  uint256 public constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);\n  uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR =\n    10**uint256(highPrecisionDecimals - decimals);\n\n  /**\n   * @return Provides an interface to UNIT.\n   */\n  function unit() external pure returns (uint256) {\n    return UNIT;\n  }\n\n  /**\n   * @return Provides an interface to PRECISE_UNIT.\n   */\n  function preciseUnit() external pure returns (uint256) {\n    return PRECISE_UNIT;\n  }\n\n  /**\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\n   * decimals.\n   *\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\n   * so that product must be less than 2**256. As this is an integer division,\n   * the internal division always rounds down. This helps save on gas. Rounding\n   * is more expensive on gas.\n   */\n  function multiplyDecimal(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    return x.mul(y) / UNIT;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of the specified precision unit.\n   *\n   * @dev The operands should be in the form of a the specified unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function _multiplyDecimalRound(\n    uint256 x,\n    uint256 y,\n    uint256 precisionUnit\n  ) private pure returns (uint256) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a precise unit.\n   *\n   * @dev The operands should be in the precise unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRoundPrecise(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a standard unit.\n   *\n   * @dev The operands should be in the standard unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRound(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _multiplyDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is a high\n   * precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\n   * this is an integer division, the result is always rounded down.\n   * This helps save on gas. Rounding is more expensive on gas.\n   */\n  function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n    /* Reintroduce the UNIT factor that will be divided out by y. */\n    return x.mul(UNIT).div(y);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * decimal in the precision unit specified in the parameter.\n   *\n   * @dev y is divided after the product of x and the specified precision unit\n   * is evaluated, so the product of x and the specified precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function _divideDecimalRound(\n    uint256 x,\n    uint256 y,\n    uint256 precisionUnit\n  ) private pure returns (uint256) {\n    uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n    if (resultTimesTen % 10 >= 5) {\n      resultTimesTen += 10;\n    }\n\n    return resultTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * standard precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and the standard precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRound(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _divideDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * high precision decimal.\n   *\n   * @dev y is divided after the product of x and the high precision unit\n   * is evaluated, so the product of x and the high precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRoundPrecise(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @dev Convert a standard decimal representation to a high precision one.\n   */\n  function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {\n    return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n  }\n\n  /**\n   * @dev Convert a high precision decimal to a standard decimal representation.\n   */\n  function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {\n    uint256 quotientTimesTen =\n      i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n}\n"
    },
    "contracts/tokens/SafeSupplyControlledERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\nimport \"../tokens/interfaces/ISupplyControlledERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title SafeSupplyControlledERC20\n * @dev Wrappers around Supply Controlled ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n */\nlibrary SafeSupplyControlledERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeBurnFrom(\n    ISupplyControlledERC20 token,\n    address from,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.burnFrom.selector, from, value)\n    );\n  }\n\n  function safeMint(\n    ISupplyControlledERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.mint.selector, to, value)\n    );\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata =\n      address(token).functionCall(\n        data,\n        \"SafeSupplyControlled/LowlevelCallFailed\"\n      );\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeSupplyControlled/ERC20Failed\"\n      );\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/// @title Auction House state that can change by governance.\n/// @notice These methods provide vision on specific state that could be used in wrapper contracts.\ninterface IAuctionHouseState {\n  /**\n   * @notice The buffer around the starting price to handle mispriced / stale oracles.\n   * @dev Basis point\n   * Starts at 10% / 1e3 so market price is buffered by 110% or 90%\n   */\n  function buffer() external view returns (uint16);\n\n  /**\n   * @notice The fee taken by the protocol.\n   * @dev Basis point\n   */\n  function protocolFee() external view returns (uint16);\n\n  /**\n   * @notice The cap based on total FLOAT supply to change in a single auction. E.g. 10% cap => absolute max of 10% of total supply can be minted / burned\n   * @dev Basis point\n   */\n  function allowanceCap() external view returns (uint32);\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseVariables.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./ICases.sol\";\n\n/// @title Auction House state that can change\n/// @notice These methods compose the auctions state, and will change per action.\ninterface IAuctionHouseVariables is ICases {\n  /**\n   * @notice The number of auctions since inception.\n   */\n  function round() external view returns (uint64);\n\n  /**\n   * @notice Returns data about a specific auction.\n   * @param roundNumber The round number for the auction array to fetch\n   * @return stabilisationCase The Auction struct including case\n   */\n  function auctions(uint64 roundNumber)\n    external\n    view\n    returns (\n      Cases stabilisationCase,\n      uint256 targetFloatInEth,\n      uint256 marketFloatInEth,\n      uint256 bankInEth,\n      uint256 startWethPrice,\n      uint256 startBankPrice,\n      uint256 endWethPrice,\n      uint256 endBankPrice,\n      uint256 basketFactor,\n      uint256 delta,\n      uint256 allowance\n    );\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseDerivedState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./IAuction.sol\";\n\n/// @title Auction House state that can change\n/// @notice These methods are derived from the IAuctionHouseState.\ninterface IAuctionHouseDerivedState is IAuction {\n  /**\n   * @notice The price (that the Protocol with expect on expansion, and give on Contraction) for 1 FLOAT\n   * @dev Under cases, this value is used differently:\n   * - Contraction, Protocol buys FLOAT for pair.\n   * - Expansion, Protocol sells FLOAT for pair.\n   * @return wethPrice [e27] Expected price in wETH.\n   * @return bankPrice [e27] Expected price in BANK.\n   */\n  function price() external view returns (uint256 wethPrice, uint256 bankPrice);\n\n  /**\n   * @notice The current step through the auction.\n   * @dev block numbers since auction start (0 indexed)\n   */\n  function step() external view returns (uint256);\n\n  /**\n   * @notice Latest Auction alias\n   */\n  function latestAuction() external view returns (Auction memory);\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\n/// @title Open Auction House actions\n/// @notice Contains all actions that can be called by anyone\ninterface IAuctionHouseActions {\n  /**\n   * @notice Starts an auction\n   * @dev This will:\n   * - update the oracles\n   * - calculate the target price\n   * - check stabilisation case\n   * - create allowance.\n   * - Set start / end prices of the auction\n   */\n  function start() external returns (uint64 newRound);\n\n  /**\n   * @notice Buy for an amount of <WETH, BANK> for as much FLOAT tokens as possible.\n   * @dev Expansion, Protocol sells FLOAT for pair.\n    As the price descends there should be no opportunity for slippage causing failure\n    `msg.sender` should already have given the auction allowance for at least `wethIn` and `bankIn`.\n   * `wethInMax` / `bankInMax` < 2**256 / 10**18, assumption is that totalSupply\n   * doesn't exceed type(uint128).max\n   * @param wethInMax The max amount of WETH to send (takes maximum from given ratio).\n   * @param bankInMax The max amount of BANK to send (takes maximum from given ratio).\n   * @param floatOutMin The minimum amount of FLOAT that must be received for this transaction not to revert.\n   * @param to Recipient of the FLOAT.\n   * @param deadline Unix timestamp after which the transaction will revert.\n   */\n  function buy(\n    uint256 wethInMax,\n    uint256 bankInMax,\n    uint256 floatOutMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 usedWethIn,\n      uint256 usedBankIn,\n      uint256 usedFloatOut\n    );\n\n  /**\n   * @notice Sell an amount of FLOAT for the given reward tokens.\n   * @dev Contraction, Protocol buys FLOAT for pair. `msg.sender` should already have given the auction allowance for at least `floatIn`.\n   * @param floatIn The amount of FLOAT to sell.\n   * @param wethOutMin The minimum amount of WETH that can be received before the transaction reverts.\n   * @param bankOutMin The minimum amount of BANK that can be received before the tranasction reverts.\n   * @param to Recipient of <WETH, BANK>.\n   * @param deadline Unix timestamp after which the transaction will revert.\n   */\n  function sell(\n    uint256 floatIn,\n    uint256 wethOutMin,\n    uint256 bankOutMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 usedfloatIn,\n      uint256 usedWethOut,\n      uint256 usedBankOut\n    );\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseGovernedActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\n/// @title Auction House actions that require certain level of privilege\n/// @notice Contains Auction House methods that may only be called by controller\ninterface IAuctionHouseGovernedActions {\n  /**\n   * @notice Modify a uint256 parameter\n   * @param parameter The parameter name to modify\n   * @param data New value for the parameter\n   */\n  function modifyParameters(bytes32 parameter, uint256 data) external;\n\n  /**\n   * @notice Modify an address parameter\n   * @param parameter The parameter name to modify\n   * @param data New address for the parameter\n   */\n  function modifyParameters(bytes32 parameter, address data) external;\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\n/// @title Events emitted by the auction house\n/// @notice Contains all events emitted by the auction house\ninterface IAuctionHouseEvents {\n  event NewAuction(\n    uint256 indexed round,\n    uint256 allowance,\n    uint256 targetFloatInEth,\n    uint256 startBlock\n  );\n  event Buy(\n    uint256 indexed round,\n    address indexed buyer,\n    uint256 wethIn,\n    uint256 bankIn,\n    uint256 floatOut\n  );\n  event Sell(\n    uint256 indexed round,\n    address indexed seller,\n    uint256 floatIn,\n    uint256 wethOut,\n    uint256 bankOut\n  );\n  event ModifyParameters(bytes32 parameter, uint256 data);\n  event ModifyParameters(bytes32 parameter, address data);\n}\n"
    },
    "contracts/auction/interfaces/ah/ICases.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\ninterface ICases {\n  /**\n   * @dev The Stabilisation Cases\n   * Up (Expansion) - Estimated market price >= target price & Basket Factor >= 1.\n   * Restock (Expansion) - Estimated market price >= target price & Basket Factor < 1.\n   * Confidence (Contraction) - Estimated market price < target price & Basket Factor >= 1.\n   * Down (Contraction) - Estimated market price < target price & Basket Factor < 1.\n   */\n  enum Cases {Up, Restock, Confidence, Down}\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./ICases.sol\";\n\ninterface IAuction is ICases {\n  /**\n   * The current Stabilisation Case\n   * Auction's target price.\n   * Auction's floatInEth price.\n   * Auction's bankInEth price.\n   * Auction's basket factor.\n   * Auction's used float delta.\n   * Auction's allowed float delta (how much FLOAT can be created or burned).\n   */\n  struct Auction {\n    Cases stabilisationCase;\n    uint256 targetFloatInEth;\n    uint256 marketFloatInEth;\n    uint256 bankInEth;\n    uint256 startWethPrice;\n    uint256 startBankPrice;\n    uint256 endWethPrice;\n    uint256 endBankPrice;\n    uint256 basketFactor;\n    uint256 delta;\n    uint256 allowance;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}