{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/core/MiningCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\ncontract Context {\n\n\n    constructor () { }\n\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\ninterface MiningMachine is IERC721 {\n    function machines(uint256 tokenId) external view returns(uint model, uint load,uint exploit);\n    function burn(uint256 tokenId) external;\n    function mint(address to,uint _power) external;\n}\n\n\ninterface MiningPool{\n\n    function users(address userAddress) external view returns(uint256 id,uint256 investment,uint256 freezeTime);\n\n    function balanceOf(address userAddress) external view returns (address[2] memory,uint256[2] memory balances);\n\n    function duration() external view returns (uint256);\n\n    function deposit(uint256[2] calldata amounts) external returns(bool);\n\n    function allot(address userAddress,uint256[2] calldata amounts) external returns(bool);\n\n    function lock(address holder, address locker, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\n\n    function lockStatus(address userAddress) external view returns(bool);\n\n    function asset(address userAddress) external view returns(uint256);\n}\n\ninterface IUniswapPair {\n\n    function setFeeOwner(address _feeOwner) external;\n}\n\ninterface IUniswapFactory {\n\n    function getPair(address token0,address token1) external returns(address);\n}\n\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\nabstract contract ERC721TokenReceiver is IERC721Receiver{\n\n     function onERC721Received(address operator, address from, uint256 tokenId,  bytes calldata data) external override returns(bytes4) {\n        mining(msg.sender,operator,from,tokenId,data);\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function mining(address msgSender, address operator, address from, uint256 tokenId, bytes calldata data) internal virtual;\n}\n\ncontract WhiteList is Ownable {\n\n    function getWhiteListStatus(address _maker) external view returns (bool) {\n        return isWhiteListed[_maker];\n    }\n\n    mapping (address => bool) public isWhiteListed;\n\n    function addWhiteList (address _user) public onlyOwner {\n        isWhiteListed[_user] = true;\n        emit AddedWhiteList(_user);\n    }\n\n    function removeWhiteList (address _clearedUser) public onlyOwner {\n        isWhiteListed[_clearedUser] = false;\n        emit RemovedWhiteList(_clearedUser);\n    }\n\n    event AddedWhiteList(address indexed _user);\n\n    event RemovedWhiteList(address indexed _user);\n\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function nonces(address account) external view returns (uint256);\n\n    function approve(address spender, uint value) external returns (bool);\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry, uint256 amount, uint8 v, bytes32 r, bytes32 s) external;\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ncontract Config{\n\n    uint256 public constant ONE_DAY = 1 days;\n\n    uint256[10] public  RANKING_AWARD_PERCENT = [10,5,3,1,1,1,1,1,1,1];\n\n    uint256 public constant LAST_STRAW_PERCNET = 5;\n\n    uint256[2] public  OUT_RATE = [1,1];\n\n}\n\n\ncontract MiningCore is Config, WhiteList, ERC721TokenReceiver {\n\n    using SafeMath for uint256;\n\n    constructor(MiningPool _pool,MiningMachine _machine,address payable _developer) {\n        pool = _pool;\n        machine = _machine;\n        developer = _developer;\n    }\n\n    MiningPool public pool;\n\n    uint256 public ORE_AMOUNT = 1500000000;\n\n    struct Record{\n        //提现状态\n        bool drawStatus;\n        //挖矿总量\n        uint256 digGross;\n        //最后一击\n        bool lastStraw;\n\n    }\n\n    struct Pair {\n        uint256[2] amounts;\n        //挖矿总量\n        uint256 complete;\n        //实际挖矿量\n        uint256 actual;\n\n        uint256 oracleAmount;\n\n        address lastStraw;\n    }\n\n\n    address payable developer;\n\n    uint256 public version;\n\n    MiningMachine public machine;\n\n    mapping(uint256=>mapping(address=>Record)) public records;\n\n    //Record of each mining period\n    mapping(uint256=>Pair) public history;\n\n    //Daily output\n    mapping(uint256=>uint256) public dailyOutput;\n\n    mapping(uint256=> address[10]) public rank;\n\n    event ObtainCar(address indexed userAddress,uint256 indexed _version,uint256 amount );\n\n    event Mining(address indexed userAddress,uint256 indexed _version,uint256 , uint256 amount);\n\n    event WithdrawAward(address indexed userAddress,uint256 indexed _version,uint256[2] amounts);\n\n    event UpdateRank(address indexed operator);\n\n    event DeveloperFee(uint256 fee1,uint256 fee2);\n\n    event SetCarIndex(uint256 sn,uint256 id,uint256 fertility,uint256 carry);\n\n    event LastStraw(address indexed userAddress,uint256 _version,uint256,uint256,uint256);\n\n\n    //----------------------test--------------------------------------------\n//    function takeOf(IERC20 token) public onlyOwner {\n//        uint balance = token.balanceOf(address(this));\n//        token.transfer(developer, balance);\n//    }\n\n    function setFeeOwner(address _feeOwner,address factory) external  onlyOwner {\n        (address[2] memory tokens,) = pool.balanceOf(address(0));\n        address pair = IUniswapFactory(factory).getPair(tokens[0],tokens[1]);\n        IUniswapPair(pair).setFeeOwner(_feeOwner);\n    }\n\n\n    function setOracle(uint256 _ORE_AMOUNT) public onlyOwner {\n        ORE_AMOUNT = _ORE_AMOUNT;\n    }\n\n\n    function mining(address msgSender, address operator, address from, uint256 tokenId, bytes calldata) internal override virtual{\n        require(address(machine)==msgSender,\"not allowed\");\n        if(Address.isContract(operator)){\n            require(isWhiteListed[operator],\"not in whiteList\");\n        }\n        if(from!=address(0)){\n            burn(from,tokenId);\n        }\n    }\n\n\n    function obtainCar(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) public {\n        require(!pool.lockStatus(msg.sender),\"Have been received\");\n        pool.lock(msg.sender,address(this),nonce,expiry,allowed,v,r,s);\n        uint256 asset = pool.asset(msg.sender);\n        machine.mint(msg.sender,asset);\n    }\n\n    function withdrawAward(uint256 _version) public {\n\n       require(!records[_version][msg.sender].drawStatus,\"have withdrawal\");\n\t   require(_version<version,\"Event not over\");\n\n       (uint256[2] memory amounts) =  getVersionAward(_version,msg.sender);\n\n       records[_version][msg.sender].drawStatus = true;\n\n       pool.allot(msg.sender,amounts);\n\n       emit WithdrawAward(msg.sender,_version,amounts);\n\n    }\n\n\n    function getVersionAward(uint256 _version,address userAddress) public view returns(uint256[2] memory amounts){\n        Pair memory pair = history[_version];\n        return getPredictAward(_version,userAddress,pair);\n    }\n\n    function getPredictAward(uint256 _version,address userAddress,Pair memory pair) internal view returns(uint256[2] memory amounts){\n        Record storage record = records[_version][userAddress];\n\n        uint256 ranking = getRanking(userAddress,_version);\n\n        for(uint8 i = 0;i<2;i++){\n            uint256 baseAmount = pair.amounts[i].mul(70).div(100);\n            uint256 awardAmount = pair.amounts[i].mul(30).div(100);\n\n            amounts[i] = amounts[i].add(baseAmount.mul(record.digGross).div(pair.oracleAmount==0?ORE_AMOUNT:pair.oracleAmount));\n\n            if(ranking<10){\n                amounts[i] = amounts[i].add(awardAmount.mul(RANKING_AWARD_PERCENT[ranking]).div(30));\n            }\n\n            if(record.lastStraw){\n                amounts[i] = amounts[i].add(awardAmount.mul(LAST_STRAW_PERCNET).div(30));\n            }\n        }\n    }\n\n    function getGlobalStats(uint256 _version) external view returns (uint256[5] memory stats,address lastStrawUser) {\n\n        Pair memory pair = history[_version];\n        if(_version==version){\n            (,uint256[2] memory balances) = pool.balanceOf(address(this));\n            pair.amounts = balances;\n        }\n\n        stats[0] = pair.amounts[0];\n        stats[1] = pair.amounts[1];\n        stats[2] = pair.complete;\n        stats[3] = pair.actual;\n        stats[4] = (pool.duration()+1)*ONE_DAY;\n        lastStrawUser = pair.lastStraw;\n\n    }\n\n\n    function crown(uint256 _version) external view returns (address[10] memory ranking,uint256[10] memory digGross){\n        ranking = sortRank(_version);\n        for(uint8 i =0;i<ranking.length;i++){\n            digGross[i] = getDigGross(ranking[i],_version);\n        }\n    }\n\n\n    function getPersonalStats(uint256 _version,address userAddress) external view returns (uint256[7] memory stats,bool[3] memory stats2){\n        Record storage record = records[_version][userAddress];\n\n        (uint256 id,uint256 investment,uint256 freezeTime) = pool.users(userAddress);\n        stats[0] = investment;\n        stats[1] = record.digGross;\n\n        Pair memory pair = history[_version];\n\n        if(_version==version){\n            (,uint256[2] memory balances) = pool.balanceOf(address(this));\n            pair.amounts = balances;\n        }\n\n        uint256[2] memory amounts = getPredictAward(_version,userAddress,pair);\n\n        stats[2] = amounts[1];\n        stats[3] = amounts[0];\n        stats[4] = id;\n        stats[5] = freezeTime;\n        stats[6] = getRanking(userAddress,_version)+1;\n\n        stats2[0] = record.drawStatus;\n        stats2[1] = record.lastStraw;\n        stats2[2] = pool.lockStatus(userAddress);\n\n\n     }\n\n    function burn(address _from,uint256 tokenId) internal returns(uint256){\n        Pair storage pair = history[version];\n\n        Record storage record = records[version][_from];\n\n        (, uint load,uint exploit) = machine.machines(tokenId);\n        uint256 output;\n        if(exploit>load){\n            output = load;\n        }else{\n            output = exploit;\n        }\n\n        uint256 miningQuantity = pair.complete.add(exploit);\n\n        if(pair.complete.add(output)>ORE_AMOUNT){\n            output = ORE_AMOUNT>pair.complete?ORE_AMOUNT-pair.complete:0;\n        }\n\n        record.digGross = record.digGross.add(output);\n        pair.complete = pair.complete.add(exploit);\n        pair.actual = pair.actual.add(output);\n        updateRank(_from);\n\n        if(miningQuantity>=ORE_AMOUNT){\n            emit LastStraw(_from,version,exploit,load,output);\n            lastStraw(_from,pair);\n        }\n        machine.burn(tokenId);\n\n        emit Mining(_from,version,tokenId,output);\n        return output;\n    }\n\n    function getRanking(address userAddress,uint256 _version) public view returns(uint256){\n        address[10] memory rankingList = sortRank(_version);\n        uint256 ranking = 10;\n        for(uint8 i =0;i<rankingList.length;i++){\n            if(userAddress == rankingList[i]){\n                ranking = i;\n                break;\n            }\n        }\n        return ranking;\n    }\n\n    function pickUp(address[10] memory rankingList,address userAddress) internal view returns (uint256 sn,uint256 minDig){\n\n        minDig = getDigGross(rankingList[0]);\n        for(uint8 i =0;i<rankingList.length;i++){\n            if(rankingList[i]==userAddress){\n                return (rankingList.length,0);\n            }\n            if(getDigGross(rankingList[i])<minDig){\n                minDig = getDigGross(rankingList[i]);\n                sn = i;\n            }\n        }\n\n        return (sn,minDig);\n    }\n\n    function updateRank(address userAddress) internal {\n        address[10] memory rankingList = rank[version];\n\n        (uint256 sn,uint256 minDig) = pickUp(rankingList,userAddress);\n        if(sn!=rankingList.length){\n            if(minDig< getDigGross(userAddress)){\n                rankingList[sn] = userAddress;\n            }\n            rank[version] = rankingList;\n            emit UpdateRank(userAddress);\n        }\n    }\n\n    function sortRank(uint256 _version) public view returns(address[10] memory ranking){\n        ranking = rank[_version];\n\n        address tmp;\n        for(uint8 i = 1;i<10;i++){\n            for(uint8 j = 0;j<10-i;j++){\n                if(getDigGross(ranking[j],_version)<getDigGross(ranking[j+1],_version)){\n                    tmp = ranking[j];\n                    ranking[j] = ranking[j+1];\n                    ranking[j+1] = tmp;\n                }\n            }\n        }\n        return ranking;\n    }\n\n    function getDigGross(address userAddress) internal view returns(uint256){\n        return getDigGross(userAddress,version);\n    }\n\n    function getDigGross(address userAddress,uint256 _version) internal view returns(uint256){\n        return records[_version][userAddress].digGross;\n    }\n\n    function lastStraw(address userAddress,Pair storage pair) internal{\n\n        (address[2] memory tokens,uint256[2] memory amounts) = pool.balanceOf(address(this));\n\n        for(uint8 i;i<amounts.length;i++){\n            TransferHelper.safeApprove(tokens[i],address(pool),amounts[i]);\n        }\n        pool.deposit(amounts);\n        pair.amounts = amounts;\n\n        pair.lastStraw = userAddress;\n        pair.oracleAmount = ORE_AMOUNT;\n        records[version][userAddress].lastStraw = true;\n\n        developerFee(pair);\n\n        version++;\n\n    }\n\n     //项目方收款\n    function developerFee(Pair storage pair) internal{\n\n        uint256[2] memory amounts;\n        address[10] memory rankingList = rank[version];\n        uint count;\n        for(uint i = 0;i<rankingList.length;i++) {\n            if(rankingList[i]==address(0)) {\n                count++;\n            }\n        }\n\n        uint unused;\n        for(uint j = 0;j<count;j++){\n            if(j<10) unused+=RANKING_AWARD_PERCENT[9-j];\n        }\n\n        for(uint256 i = 0;i<amounts.length;i++){\n            uint waste = pair.amounts[i].mul(70).mul(pair.oracleAmount.sub(pair.actual)).div(ORE_AMOUNT).div(100);\n            uint rest = pair.amounts[i].mul(unused).div(100);\n            amounts[i] = waste+rest;\n        }\n\n        pool.allot(developer,amounts);\n\n        emit DeveloperFee(amounts[0],amounts[1]);\n    }\n\n\n}\n\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call{value:amount}(new bytes(0));\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n\n        return c;\n    }\n\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  }
}}