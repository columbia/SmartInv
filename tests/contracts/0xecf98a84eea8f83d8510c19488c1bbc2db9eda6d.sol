{"FactRegistry.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"IQueryableFactRegistry.sol\";\n\ncontract FactRegistry is IQueryableFactRegistry {\n    // Mapping: fact hash -\u003e true.\n    mapping(bytes32 =\u003e bool) private verifiedFact;\n\n    // Indicates whether the Fact Registry has at least one fact registered.\n    bool anyFactRegistered;\n\n    /*\n      Checks if a fact has been verified.\n    */\n    function isValid(bytes32 fact) external view override returns (bool) {\n        return _factCheck(fact);\n    }\n\n    /*\n      This is an internal method to check if the fact is already registered.\n      In current implementation of FactRegistry it\u0027s identical to isValid().\n      But the check is against the local fact registry,\n      So for a derived referral fact registry, it\u0027s not the same.\n    */\n    function _factCheck(bytes32 fact) internal view returns (bool) {\n        return verifiedFact[fact];\n    }\n\n    function registerFact(bytes32 factHash) internal {\n        // This function stores the fact hash in the mapping.\n        verifiedFact[factHash] = true;\n\n        // Mark first time off.\n        if (!anyFactRegistered) {\n            anyFactRegistered = true;\n        }\n    }\n\n    /*\n      Indicates whether at least one fact was registered.\n    */\n    function hasRegisteredFact() external view override returns (bool) {\n        return anyFactRegistered;\n    }\n}\n"},"FriLayer.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"MerkleVerifier.sol\";\nimport \"PrimeFieldElement0.sol\";\n\n/*\n  The main component of FRI is the FRI step which takes\n  the i-th layer evaluations on a coset c*\u003cg\u003e and produces a single evaluation in layer i+1.\n\n  To this end we have a friCtx that holds the following data:\n  evaluations:    holds the evaluations on the coset we are currently working on.\n  group:          holds the group \u003cg\u003e in bit reversed order.\n  halfInvGroup:   holds the group \u003cg^-1\u003e/\u003c-1\u003e in bit reversed order.\n                  (We only need half of the inverse group)\n\n  Note that due to the bit reversed order, a prefix of size 2^k of either group\n  or halfInvGroup has the same structure (but for a smaller group).\n*/\ncontract FriLayer is MerkleVerifier, PrimeFieldElement0 {\n    event LogGas(string name, uint256 val);\n\n    uint256 internal constant FRI_MAX_FRI_STEP = 4;\n    uint256 internal constant MAX_COSET_SIZE = 2**FRI_MAX_FRI_STEP;\n    // Generator of the group of size MAX_COSET_SIZE: GENERATOR_VAL**((PRIME - 1)/MAX_COSET_SIZE).\n    uint256 internal constant FRI_GROUP_GEN =\n        0x5ec467b88826aba4537602d514425f3b0bdf467bbf302458337c45f6021e539;\n\n    uint256 internal constant FRI_GROUP_SIZE = 0x20 * MAX_COSET_SIZE;\n    uint256 internal constant FRI_CTX_TO_COSET_EVALUATIONS_OFFSET = 0;\n    uint256 internal constant FRI_CTX_TO_FRI_GROUP_OFFSET = FRI_GROUP_SIZE;\n    uint256 internal constant FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET =\n        FRI_CTX_TO_FRI_GROUP_OFFSET + FRI_GROUP_SIZE;\n\n    uint256 internal constant FRI_CTX_SIZE =\n        FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET + (FRI_GROUP_SIZE / 2);\n\n    function nextLayerElementFromTwoPreviousLayerElements(\n        uint256 fX,\n        uint256 fMinusX,\n        uint256 evalPoint,\n        uint256 xInv\n    ) internal pure returns (uint256 res) {\n        // Folding formula:\n        // f(x)  = g(x^2) + xh(x^2)\n        // f(-x) = g((-x)^2) - xh((-x)^2) = g(x^2) - xh(x^2)\n        // =\u003e\n        // 2g(x^2) = f(x) + f(-x)\n        // 2h(x^2) = (f(x) - f(-x))/x\n        // =\u003e The 2*interpolation at evalPoint is:\n        // 2*(g(x^2) + evalPoint*h(x^2)) = f(x) + f(-x) + evalPoint*(f(x) - f(-x))*xInv.\n        //\n        // Note that multiplying by 2 doesn\u0027t affect the degree,\n        // so we can just agree to do that on both the prover and verifier.\n        assembly {\n            // PRIME is PrimeFieldElement0.K_MODULUS.\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            // Note that whenever we call add(), the result is always less than 2*PRIME,\n            // so there are no overflows.\n            res := addmod(\n                add(fX, fMinusX),\n                mulmod(\n                    mulmod(evalPoint, xInv, PRIME),\n                    add(\n                        fX,\n                        // -fMinusX\n                        sub(PRIME, fMinusX)\n                    ),\n                    PRIME\n                ),\n                PRIME\n            )\n        }\n    }\n\n    /*\n      Reads 4 elements, and applies 2 + 1 FRI transformations to obtain a single element.\n\n      FRI layer n:                              f0 f1  f2 f3\n      -----------------------------------------  \\ / -- \\ / -----------\n      FRI layer n+1:                              f0    f2\n      -------------------------------------------- \\ ---/ -------------\n      FRI layer n+2:                                 f0\n\n      The basic FRI transformation is described in nextLayerElementFromTwoPreviousLayerElements().\n    */\n    function do2FriSteps(\n        uint256 friHalfInvGroupPtr,\n        uint256 evaluationsOnCosetPtr,\n        uint256 cosetOffset_,\n        uint256 friEvalPoint\n    ) internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {\n        assembly {\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)\n\n            let f0 := mload(evaluationsOnCosetPtr)\n            {\n                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))\n\n                // f0 \u003c 3P ( = 1 + 1 + 1).\n                f0 := add(\n                    add(f0, f1),\n                    mulmod(\n                        friEvalPointDivByX,\n                        add(\n                            f0,\n                            // -fMinusX\n                            sub(PRIME, f1)\n                        ),\n                        PRIME\n                    )\n                )\n            }\n\n            let f2 := mload(add(evaluationsOnCosetPtr, 0x40))\n            {\n                let f3 := mload(add(evaluationsOnCosetPtr, 0x60))\n                f2 := addmod(\n                    add(f2, f3),\n                    mulmod(\n                        add(\n                            f2,\n                            // -fMinusX\n                            sub(PRIME, f3)\n                        ),\n                        mulmod(mload(add(friHalfInvGroupPtr, 0x20)), friEvalPointDivByX, PRIME),\n                        PRIME\n                    ),\n                    PRIME\n                )\n            }\n\n            {\n                let newXInv := mulmod(cosetOffset_, cosetOffset_, PRIME)\n                nextXInv := mulmod(newXInv, newXInv, PRIME)\n            }\n\n            // f0 + f2 \u003c 4P ( = 3 + 1).\n            nextLayerValue := addmod(\n                add(f0, f2),\n                mulmod(\n                    mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME),\n                    add(\n                        f0,\n                        // -fMinusX\n                        sub(PRIME, f2)\n                    ),\n                    PRIME\n                ),\n                PRIME\n            )\n        }\n    }\n\n    /*\n      Reads 8 elements, and applies 4 + 2 + 1 FRI transformation to obtain a single element.\n\n      See do2FriSteps for more detailed explanation.\n    */\n    function do3FriSteps(\n        uint256 friHalfInvGroupPtr,\n        uint256 evaluationsOnCosetPtr,\n        uint256 cosetOffset_,\n        uint256 friEvalPoint\n    ) internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {\n        assembly {\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            let MPRIME := 0x8000000000000110000000000000000000000000000000000000000000000010\n            let f0 := mload(evaluationsOnCosetPtr)\n\n            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)\n            let friEvalPointDivByXSquared := mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME)\n            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))\n\n            {\n                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))\n\n                // f0 \u003c 3P ( = 1 + 1 + 1).\n                f0 := add(\n                    add(f0, f1),\n                    mulmod(\n                        friEvalPointDivByX,\n                        add(\n                            f0,\n                            // -fMinusX\n                            sub(PRIME, f1)\n                        ),\n                        PRIME\n                    )\n                )\n            }\n            {\n                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))\n                {\n                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))\n\n                    // f2 \u003c 3P ( = 1 + 1 + 1).\n                    f2 := add(\n                        add(f2, f3),\n                        mulmod(\n                            add(\n                                f2,\n                                // -fMinusX\n                                sub(PRIME, f3)\n                            ),\n                            mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),\n                            PRIME\n                        )\n                    )\n                }\n\n                // f0 \u003c 7P ( = 3 + 3 + 1).\n                f0 := add(\n                    add(f0, f2),\n                    mulmod(\n                        friEvalPointDivByXSquared,\n                        add(\n                            f0,\n                            // -fMinusX\n                            sub(MPRIME, f2)\n                        ),\n                        PRIME\n                    )\n                )\n            }\n            {\n                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))\n                {\n                    let friEvalPointDivByX2 := mulmod(\n                        friEvalPointDivByX,\n                        mload(add(friHalfInvGroupPtr, 0x40)),\n                        PRIME\n                    )\n                    {\n                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))\n\n                        // f4 \u003c 3P ( = 1 + 1 + 1).\n                        f4 := add(\n                            add(f4, f5),\n                            mulmod(\n                                friEvalPointDivByX2,\n                                add(\n                                    f4,\n                                    // -fMinusX\n                                    sub(PRIME, f5)\n                                ),\n                                PRIME\n                            )\n                        )\n                    }\n\n                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))\n                    {\n                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))\n\n                        // f6 \u003c 3P ( = 1 + 1 + 1).\n                        f6 := add(\n                            add(f6, f7),\n                            mulmod(\n                                add(\n                                    f6,\n                                    // -fMinusX\n                                    sub(PRIME, f7)\n                                ),\n                                // friEvalPointDivByX2 * imaginaryUnit ==\n                                // friEvalPointDivByX * mload(add(friHalfInvGroupPtr, 0x60)).\n                                mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),\n                                PRIME\n                            )\n                        )\n                    }\n\n                    // f4 \u003c 7P ( = 3 + 3 + 1).\n                    f4 := add(\n                        add(f4, f6),\n                        mulmod(\n                            mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),\n                            add(\n                                f4,\n                                // -fMinusX\n                                sub(MPRIME, f6)\n                            ),\n                            PRIME\n                        )\n                    )\n                }\n\n                // f0, f4 \u003c 7P -\u003e f0 + f4 \u003c 14P \u0026\u0026 9P \u003c f0 + (MPRIME - f4) \u003c 23P.\n                nextLayerValue := addmod(\n                    add(f0, f4),\n                    mulmod(\n                        mulmod(friEvalPointDivByXSquared, friEvalPointDivByXSquared, PRIME),\n                        add(\n                            f0,\n                            // -fMinusX\n                            sub(MPRIME, f4)\n                        ),\n                        PRIME\n                    ),\n                    PRIME\n                )\n            }\n\n            {\n                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)\n                let xInv4 := mulmod(xInv2, xInv2, PRIME)\n                nextXInv := mulmod(xInv4, xInv4, PRIME)\n            }\n        }\n    }\n\n    /*\n      This function reads 16 elements, and applies 8 + 4 + 2 + 1 fri transformation\n      to obtain a single element.\n\n      See do2FriSteps for more detailed explanation.\n    */\n    function do4FriSteps(\n        uint256 friHalfInvGroupPtr,\n        uint256 evaluationsOnCosetPtr,\n        uint256 cosetOffset_,\n        uint256 friEvalPoint\n    ) internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {\n        assembly {\n            let friEvalPointDivByXTessed\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            let MPRIME := 0x8000000000000110000000000000000000000000000000000000000000000010\n            let f0 := mload(evaluationsOnCosetPtr)\n\n            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)\n            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))\n\n            {\n                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))\n\n                // f0 \u003c 3P ( = 1 + 1 + 1).\n                f0 := add(\n                    add(f0, f1),\n                    mulmod(\n                        friEvalPointDivByX,\n                        add(\n                            f0,\n                            // -fMinusX\n                            sub(PRIME, f1)\n                        ),\n                        PRIME\n                    )\n                )\n            }\n            {\n                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))\n                {\n                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))\n\n                    // f2 \u003c 3P ( = 1 + 1 + 1).\n                    f2 := add(\n                        add(f2, f3),\n                        mulmod(\n                            add(\n                                f2,\n                                // -fMinusX\n                                sub(PRIME, f3)\n                            ),\n                            mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),\n                            PRIME\n                        )\n                    )\n                }\n                {\n                    let friEvalPointDivByXSquared := mulmod(\n                        friEvalPointDivByX,\n                        friEvalPointDivByX,\n                        PRIME\n                    )\n                    friEvalPointDivByXTessed := mulmod(\n                        friEvalPointDivByXSquared,\n                        friEvalPointDivByXSquared,\n                        PRIME\n                    )\n\n                    // f0 \u003c 7P ( = 3 + 3 + 1).\n                    f0 := add(\n                        add(f0, f2),\n                        mulmod(\n                            friEvalPointDivByXSquared,\n                            add(\n                                f0,\n                                // -fMinusX\n                                sub(MPRIME, f2)\n                            ),\n                            PRIME\n                        )\n                    )\n                }\n            }\n            {\n                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))\n                {\n                    let friEvalPointDivByX2 := mulmod(\n                        friEvalPointDivByX,\n                        mload(add(friHalfInvGroupPtr, 0x40)),\n                        PRIME\n                    )\n                    {\n                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))\n\n                        // f4 \u003c 3P ( = 1 + 1 + 1).\n                        f4 := add(\n                            add(f4, f5),\n                            mulmod(\n                                friEvalPointDivByX2,\n                                add(\n                                    f4,\n                                    // -fMinusX\n                                    sub(PRIME, f5)\n                                ),\n                                PRIME\n                            )\n                        )\n                    }\n\n                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))\n                    {\n                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))\n\n                        // f6 \u003c 3P ( = 1 + 1 + 1).\n                        f6 := add(\n                            add(f6, f7),\n                            mulmod(\n                                add(\n                                    f6,\n                                    // -fMinusX\n                                    sub(PRIME, f7)\n                                ),\n                                // friEvalPointDivByX2 * imaginaryUnit ==\n                                // friEvalPointDivByX * mload(add(friHalfInvGroupPtr, 0x60)).\n                                mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),\n                                PRIME\n                            )\n                        )\n                    }\n\n                    // f4 \u003c 7P ( = 3 + 3 + 1).\n                    f4 := add(\n                        add(f4, f6),\n                        mulmod(\n                            mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),\n                            add(\n                                f4,\n                                // -fMinusX\n                                sub(MPRIME, f6)\n                            ),\n                            PRIME\n                        )\n                    )\n                }\n\n                // f0 \u003c 15P ( = 7 + 7 + 1).\n                f0 := add(\n                    add(f0, f4),\n                    mulmod(\n                        friEvalPointDivByXTessed,\n                        add(\n                            f0,\n                            // -fMinusX\n                            sub(MPRIME, f4)\n                        ),\n                        PRIME\n                    )\n                )\n            }\n            {\n                let f8 := mload(add(evaluationsOnCosetPtr, 0x100))\n                {\n                    let friEvalPointDivByX4 := mulmod(\n                        friEvalPointDivByX,\n                        mload(add(friHalfInvGroupPtr, 0x80)),\n                        PRIME\n                    )\n                    {\n                        let f9 := mload(add(evaluationsOnCosetPtr, 0x120))\n\n                        // f8 \u003c 3P ( = 1 + 1 + 1).\n                        f8 := add(\n                            add(f8, f9),\n                            mulmod(\n                                friEvalPointDivByX4,\n                                add(\n                                    f8,\n                                    // -fMinusX\n                                    sub(PRIME, f9)\n                                ),\n                                PRIME\n                            )\n                        )\n                    }\n\n                    let f10 := mload(add(evaluationsOnCosetPtr, 0x140))\n                    {\n                        let f11 := mload(add(evaluationsOnCosetPtr, 0x160))\n                        // f10 \u003c 3P ( = 1 + 1 + 1).\n                        f10 := add(\n                            add(f10, f11),\n                            mulmod(\n                                add(\n                                    f10,\n                                    // -fMinusX\n                                    sub(PRIME, f11)\n                                ),\n                                // friEvalPointDivByX4 * imaginaryUnit ==\n                                // friEvalPointDivByX * mload(add(friHalfInvGroupPtr, 0xa0)).\n                                mulmod(friEvalPointDivByX4, imaginaryUnit, PRIME),\n                                PRIME\n                            )\n                        )\n                    }\n\n                    // f8 \u003c 7P ( = 3 + 3 + 1).\n                    f8 := add(\n                        add(f8, f10),\n                        mulmod(\n                            mulmod(friEvalPointDivByX4, friEvalPointDivByX4, PRIME),\n                            add(\n                                f8,\n                                // -fMinusX\n                                sub(MPRIME, f10)\n                            ),\n                            PRIME\n                        )\n                    )\n                }\n                {\n                    let f12 := mload(add(evaluationsOnCosetPtr, 0x180))\n                    {\n                        let friEvalPointDivByX6 := mulmod(\n                            friEvalPointDivByX,\n                            mload(add(friHalfInvGroupPtr, 0xc0)),\n                            PRIME\n                        )\n                        {\n                            let f13 := mload(add(evaluationsOnCosetPtr, 0x1a0))\n\n                            // f12 \u003c 3P ( = 1 + 1 + 1).\n                            f12 := add(\n                                add(f12, f13),\n                                mulmod(\n                                    friEvalPointDivByX6,\n                                    add(\n                                        f12,\n                                        // -fMinusX\n                                        sub(PRIME, f13)\n                                    ),\n                                    PRIME\n                                )\n                            )\n                        }\n\n                        let f14 := mload(add(evaluationsOnCosetPtr, 0x1c0))\n                        {\n                            let f15 := mload(add(evaluationsOnCosetPtr, 0x1e0))\n\n                            // f14 \u003c 3P ( = 1 + 1 + 1).\n                            f14 := add(\n                                add(f14, f15),\n                                mulmod(\n                                    add(\n                                        f14,\n                                        // -fMinusX\n                                        sub(PRIME, f15)\n                                    ),\n                                    // friEvalPointDivByX6 * imaginaryUnit ==\n                                    // friEvalPointDivByX * mload(add(friHalfInvGroupPtr, 0xe0)).\n                                    mulmod(friEvalPointDivByX6, imaginaryUnit, PRIME),\n                                    PRIME\n                                )\n                            )\n                        }\n\n                        // f12 \u003c 7P ( = 3 + 3 + 1).\n                        f12 := add(\n                            add(f12, f14),\n                            mulmod(\n                                mulmod(friEvalPointDivByX6, friEvalPointDivByX6, PRIME),\n                                add(\n                                    f12,\n                                    // -fMinusX\n                                    sub(MPRIME, f14)\n                                ),\n                                PRIME\n                            )\n                        )\n                    }\n\n                    // f8 \u003c 15P ( = 7 + 7 + 1).\n                    f8 := add(\n                        add(f8, f12),\n                        mulmod(\n                            mulmod(friEvalPointDivByXTessed, imaginaryUnit, PRIME),\n                            add(\n                                f8,\n                                // -fMinusX\n                                sub(MPRIME, f12)\n                            ),\n                            PRIME\n                        )\n                    )\n                }\n\n                // f0, f8 \u003c 15P -\u003e f0 + f8 \u003c 30P \u0026\u0026 16P \u003c f0 + (MPRIME - f8) \u003c 31P.\n                nextLayerValue := addmod(\n                    add(f0, f8),\n                    mulmod(\n                        mulmod(friEvalPointDivByXTessed, friEvalPointDivByXTessed, PRIME),\n                        add(\n                            f0,\n                            // -fMinusX\n                            sub(MPRIME, f8)\n                        ),\n                        PRIME\n                    ),\n                    PRIME\n                )\n            }\n\n            {\n                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)\n                let xInv4 := mulmod(xInv2, xInv2, PRIME)\n                let xInv8 := mulmod(xInv4, xInv4, PRIME)\n                nextXInv := mulmod(xInv8, xInv8, PRIME)\n            }\n        }\n    }\n\n    /*\n      Gathers the \"cosetSize\" elements that belong to the same coset\n      as the item at the top of the FRI queue and stores them in ctx[MM_FRI_STEP_VALUES:].\n\n      Returns\n        friQueueHead - friQueueHead_ + 0x60  * (# elements that were taken from the queue).\n        cosetIdx - the start index of the coset that was gathered.\n        cosetOffset_ - the xInv field element that corresponds to cosetIdx.\n    */\n    function gatherCosetInputs(\n        uint256 channelPtr,\n        uint256 friCtx,\n        uint256 friQueueHead_,\n        uint256 cosetSize\n    )\n        internal\n        pure\n        returns (\n            uint256 friQueueHead,\n            uint256 cosetIdx,\n            uint256 cosetOffset_\n        )\n    {\n        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;\n        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;\n\n        friQueueHead = friQueueHead_;\n        assembly {\n            let queueItemIdx := mload(friQueueHead)\n            // The coset index is represented by the most significant bits of the queue item index.\n            cosetIdx := and(queueItemIdx, not(sub(cosetSize, 1)))\n            let nextCosetIdx := add(cosetIdx, cosetSize)\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n\n            // Get the algebraic coset offset:\n            // I.e. given c*g^(-k) compute c, where\n            //      g is the generator of the coset group.\n            //      k is bitReverse(offsetWithinCoset, log2(cosetSize)).\n            //\n            // To do this we multiply the algebraic coset offset at the top of the queue (c*g^(-k))\n            // by the group element that corresponds to the index inside the coset (g^k).\n            cosetOffset_ := mulmod(\n                // (c*g^(-k))=\n                mload(add(friQueueHead, 0x40)),\n                // (g^k)=\n                mload(\n                    add(\n                        friGroupPtr,\n                        mul(\n                            // offsetWithinCoset=\n                            sub(queueItemIdx, cosetIdx),\n                            0x20\n                        )\n                    )\n                ),\n                PRIME\n            )\n\n            let proofPtr := mload(channelPtr)\n\n            for {\n                let index := cosetIdx\n            } lt(index, nextCosetIdx) {\n                index := add(index, 1)\n            } {\n                // Inline channel operation:\n                // Assume we are going to read the next element from the proof.\n                // If this is not the case add(proofPtr, 0x20) will be reverted.\n                let fieldElementPtr := proofPtr\n                proofPtr := add(proofPtr, 0x20)\n\n                // Load the next index from the queue and check if it is our sibling.\n                if eq(index, queueItemIdx) {\n                    // Take element from the queue rather than from the proof\n                    // and convert it back to Montgomery form for Merkle verification.\n                    fieldElementPtr := add(friQueueHead, 0x20)\n\n                    // Revert the read from proof.\n                    proofPtr := sub(proofPtr, 0x20)\n\n                    // Reading the next index here is safe due to the\n                    // delimiter after the queries.\n                    friQueueHead := add(friQueueHead, 0x60)\n                    queueItemIdx := mload(friQueueHead)\n                }\n\n                // Note that we apply the modulo operation to convert the field elements we read\n                // from the proof to canonical representation (in the range [0, PRIME - 1]).\n                mstore(evaluationsOnCosetPtr, mod(mload(fieldElementPtr), PRIME))\n                evaluationsOnCosetPtr := add(evaluationsOnCosetPtr, 0x20)\n            }\n\n            mstore(channelPtr, proofPtr)\n        }\n    }\n\n    /*\n      Returns the bit reversal of num assuming it has the given number of bits.\n      For example, if we have numberOfBits = 6 and num = (0b)1101 == (0b)001101,\n      the function will return (0b)101100.\n    */\n    function bitReverse(uint256 num, uint256 numberOfBits)\n        internal\n        pure\n        returns (uint256 numReversed)\n    {\n        assert((numberOfBits == 256) || (num \u003c 2**numberOfBits));\n        uint256 n = num;\n        uint256 r = 0;\n        for (uint256 k = 0; k \u003c numberOfBits; k++) {\n            r = (r * 2) | (n % 2);\n            n = n / 2;\n        }\n        return r;\n    }\n\n    /*\n      Initializes the FRI group and half inv group in the FRI context.\n    */\n    function initFriGroups(uint256 friCtx) internal view {\n        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;\n        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;\n\n        // FRI_GROUP_GEN is the coset generator.\n        // Raising it to the (MAX_COSET_SIZE - 1) power gives us the inverse.\n        uint256 genFriGroup = FRI_GROUP_GEN;\n\n        uint256 genFriGroupInv = fpow(genFriGroup, (MAX_COSET_SIZE - 1));\n\n        uint256 lastVal = ONE_VAL;\n        uint256 lastValInv = ONE_VAL;\n        uint256 prime = PrimeFieldElement0.K_MODULUS;\n        assembly {\n            // ctx[mmHalfFriInvGroup + 0] = ONE_VAL;\n            mstore(friHalfInvGroupPtr, lastValInv)\n            // ctx[mmFriGroup + 0] = ONE_VAL;\n            mstore(friGroupPtr, lastVal)\n            // ctx[mmFriGroup + 1] = fsub(0, ONE_VAL);\n            mstore(add(friGroupPtr, 0x20), sub(prime, lastVal))\n        }\n\n        // To compute [1, -1 (== g^n/2), g^n/4, -g^n/4, ...]\n        // we compute half the elements and derive the rest using negation.\n        uint256 halfCosetSize = MAX_COSET_SIZE / 2;\n        for (uint256 i = 1; i \u003c halfCosetSize; i++) {\n            lastVal = fmul(lastVal, genFriGroup);\n            lastValInv = fmul(lastValInv, genFriGroupInv);\n            uint256 idx = bitReverse(i, FRI_MAX_FRI_STEP - 1);\n\n            assembly {\n                // ctx[mmHalfFriInvGroup + idx] = lastValInv;\n                mstore(add(friHalfInvGroupPtr, mul(idx, 0x20)), lastValInv)\n                // ctx[mmFriGroup + 2*idx] = lastVal;\n                mstore(add(friGroupPtr, mul(idx, 0x40)), lastVal)\n                // ctx[mmFriGroup + 2*idx + 1] = fsub(0, lastVal);\n                mstore(add(friGroupPtr, add(mul(idx, 0x40), 0x20)), sub(prime, lastVal))\n            }\n        }\n    }\n\n    /*\n      Operates on the coset of size friFoldedCosetSize that start at index.\n\n      It produces 3 outputs:\n        1. The field elements that result from doing FRI reductions on the coset.\n        2. The pointInv elements for the location that corresponds to the first output.\n        3. The root of a Merkle tree for the input layer.\n\n      The input is read either from the queue or from the proof depending on data availability.\n      Since the function reads from the queue it returns an updated head pointer.\n    */\n    function doFriSteps(\n        uint256 friCtx,\n        uint256 friQueueTail,\n        uint256 cosetOffset_,\n        uint256 friEvalPoint,\n        uint256 friCosetSize,\n        uint256 index,\n        uint256 merkleQueuePtr\n    ) internal pure {\n        uint256 friValue;\n\n        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;\n        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;\n\n        // Compare to expected FRI step sizes in order of likelihood, step size 3 being most common.\n        if (friCosetSize == 8) {\n            (friValue, cosetOffset_) = do3FriSteps(\n                friHalfInvGroupPtr,\n                evaluationsOnCosetPtr,\n                cosetOffset_,\n                friEvalPoint\n            );\n        } else if (friCosetSize == 4) {\n            (friValue, cosetOffset_) = do2FriSteps(\n                friHalfInvGroupPtr,\n                evaluationsOnCosetPtr,\n                cosetOffset_,\n                friEvalPoint\n            );\n        } else if (friCosetSize == 16) {\n            (friValue, cosetOffset_) = do4FriSteps(\n                friHalfInvGroupPtr,\n                evaluationsOnCosetPtr,\n                cosetOffset_,\n                friEvalPoint\n            );\n        } else {\n            require(false, \"Only step sizes of 2, 3 or 4 are supported.\");\n        }\n\n        uint256 lhashMask = getHashMask();\n        assembly {\n            let indexInNextStep := div(index, friCosetSize)\n            mstore(merkleQueuePtr, indexInNextStep)\n            mstore(\n                add(merkleQueuePtr, 0x20),\n                and(lhashMask, keccak256(evaluationsOnCosetPtr, mul(0x20, friCosetSize)))\n            )\n\n            mstore(friQueueTail, indexInNextStep)\n            mstore(add(friQueueTail, 0x20), friValue)\n            mstore(add(friQueueTail, 0x40), cosetOffset_)\n        }\n    }\n\n    /*\n      Computes the FRI step with eta = log2(friCosetSize) for all the live queries.\n      The input and output data is given in array of triplets:\n          (query index, FRI value, FRI inversed point)\n      in the address friQueuePtr (which is \u0026ctx[mmFriQueue:]).\n\n      The function returns the number of live queries remaining after computing the FRI step.\n\n      The number of live queries decreases whenever multiple query points in the same\n      coset are reduced to a single query in the next FRI layer.\n\n      As the function computes the next layer it also collects that data from\n      the previous layer for Merkle verification.\n    */\n    function computeNextLayer(\n        uint256 channelPtr,\n        uint256 friQueuePtr,\n        uint256 merkleQueuePtr,\n        uint256 nQueries,\n        uint256 friEvalPoint,\n        uint256 friCosetSize,\n        uint256 friCtx\n    ) internal pure returns (uint256 nLiveQueries) {\n        uint256 merkleQueueTail = merkleQueuePtr;\n        uint256 friQueueHead = friQueuePtr;\n        uint256 friQueueTail = friQueuePtr;\n        uint256 friQueueEnd = friQueueHead + (0x60 * nQueries);\n\n        do {\n            uint256 cosetOffset;\n            uint256 index;\n            (friQueueHead, index, cosetOffset) = gatherCosetInputs(\n                channelPtr,\n                friCtx,\n                friQueueHead,\n                friCosetSize\n            );\n\n            doFriSteps(\n                friCtx,\n                friQueueTail,\n                cosetOffset,\n                friEvalPoint,\n                friCosetSize,\n                index,\n                merkleQueueTail\n            );\n\n            merkleQueueTail += 0x40;\n            friQueueTail += 0x60;\n        } while (friQueueHead \u003c friQueueEnd);\n        return (friQueueTail - friQueuePtr) / 0x60;\n    }\n}\n"},"FriStatementContract.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"FactRegistry.sol\";\nimport \"FriLayer.sol\";\n\ncontract FriStatementContract is FriLayer, FactRegistry {\n    /*\n      Compute a single FRI layer of size friStepSize at evaluationPoint starting from input\n      friQueue, and the extra witnesses in the \"proof\" channel. Also check that the input and\n      witnesses belong to a Merkle tree with root expectedRoot, again using witnesses from \"proof\".\n      After verification, register the FRI fact hash, which is:\n      keccak256(\n          evaluationPoint,\n          friStepSize,\n          keccak256(friQueue_input),\n          keccak256(friQueue_output),  // The FRI queue after proccessing the FRI layer\n          expectedRoot\n      )\n\n      Note that this function is used as external, but declared public to avoid copying the arrays.\n    */\n    function verifyFRI(\n        uint256[] memory proof,\n        uint256[] memory friQueue,\n        uint256 evaluationPoint,\n        uint256 friStepSize,\n        uint256 expectedRoot\n    ) public {\n        require(friStepSize \u003c= FRI_MAX_FRI_STEP, \"FRI step size too large\");\n        /*\n          The friQueue should have of 3*nQueries + 1 elements, beginning with nQueries triplets\n          of the form (query_index, FRI_value, FRI_inverse_point), and ending with a single buffer\n          cell set to 0, which is accessed and read during the computation of the FRI layer.\n        */\n        require(\n            friQueue.length % 3 == 1,\n            \"FRI Queue must be composed of triplets plus one delimiter cell\"\n        );\n        require(friQueue.length \u003e= 4, \"No query to process\");\n\n        uint256 mmFriCtxSize = FRI_CTX_SIZE;\n        uint256 nQueries = friQueue.length / 3; // NOLINT: divide-before-multiply.\n        friQueue[3 * nQueries] = 0;\n        uint256 merkleQueuePtr;\n        uint256 friQueuePtr;\n        uint256 channelPtr;\n        uint256 friCtx;\n        uint256 dataToHash;\n\n        // Verify evaluation point within valid range.\n        require(evaluationPoint \u003c K_MODULUS, \"INVALID_EVAL_POINT\");\n\n        // Queries need to be in the range [2**height .. 2**(height+1)-1] strictly incrementing.\n        // i.e. we need to check that Qi+1 \u003e Qi for each i,\n        // but regarding the height range - it\u0027s sufficient to check that\n        // (Q1 ^ Qn) \u003c Q1 Which affirms that all queries are within the same logarithmic step.\n\n        // Verify FRI values and inverses are within valid range.\n        // and verify that queries are strictly incrementing.\n        uint256 prevQuery = 0; // If we pass height, change to: prevQuery = 1 \u003c\u003c height - 1;\n        for (uint256 i = 0; i \u003c nQueries; i++) {\n            require(friQueue[3 * i] \u003e prevQuery, \"INVALID_QUERY_VALUE\");\n            require(friQueue[3 * i + 1] \u003c K_MODULUS, \"INVALID_FRI_VALUE\");\n            require(friQueue[3 * i + 2] \u003c K_MODULUS, \"INVALID_FRI_INVERSE_POINT\");\n            prevQuery = friQueue[3 * i];\n        }\n\n        // Verify all queries are on the same logarithmic step.\n        // NOLINTNEXTLINE: divide-before-multiply.\n        require((friQueue[0] ^ friQueue[3 * nQueries - 3]) \u003c friQueue[0], \"INVALID_QUERIES_RANGE\");\n\n        // Allocate memory queues: channelPtr, merkleQueue, friCtx, dataToHash.\n        assembly {\n            friQueuePtr := add(friQueue, 0x20)\n            channelPtr := mload(0x40) // Free pointer location.\n            mstore(channelPtr, add(proof, 0x20))\n            merkleQueuePtr := add(channelPtr, 0x20)\n            friCtx := add(merkleQueuePtr, mul(0x40, nQueries))\n            dataToHash := add(friCtx, mmFriCtxSize)\n            mstore(0x40, add(dataToHash, 0xa0)) // Advance free pointer.\n\n            mstore(dataToHash, evaluationPoint)\n            mstore(add(dataToHash, 0x20), friStepSize)\n            mstore(add(dataToHash, 0x80), expectedRoot)\n\n            // Hash FRI inputs and add to dataToHash.\n            mstore(add(dataToHash, 0x40), keccak256(friQueuePtr, mul(0x60, nQueries)))\n        }\n\n        initFriGroups(friCtx);\n\n        nQueries = computeNextLayer(\n            channelPtr,\n            friQueuePtr,\n            merkleQueuePtr,\n            nQueries,\n            evaluationPoint,\n            2**friStepSize, /* friCosetSize = 2**friStepSize */\n            friCtx\n        );\n\n        verifyMerkle(channelPtr, merkleQueuePtr, bytes32(expectedRoot), nQueries);\n\n        bytes32 factHash;\n        assembly {\n            // Hash FRI outputs and add to dataToHash.\n            mstore(add(dataToHash, 0x60), keccak256(friQueuePtr, mul(0x60, nQueries)))\n            factHash := keccak256(dataToHash, 0xa0)\n        }\n\n        registerFact(factHash);\n    }\n}\n"},"IFactRegistry.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\n/*\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\n  business logic of the contract flow.\n\n  A fact registry holds a hash table of verified \"facts\" which are represented by a hash of claims\n  that the registry hash check and found valid. This table may be queried by accessing the\n  isValid() function of the registry with a given hash.\n\n  In addition, each fact registry exposes a registry specific function for submitting new claims\n  together with their proofs. The information submitted varies from one registry to the other\n  depending of the type of fact requiring verification.\n\n  For further reading on the Fact Registry design pattern see this\n  `StarkWare blog post \u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\u003e`_.\n*/\ninterface IFactRegistry {\n    /*\n      Returns true if the given fact was previously registered in the contract.\n    */\n    function isValid(bytes32 fact) external view returns (bool);\n}\n"},"IMerkleVerifier.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nabstract contract IMerkleVerifier {\n    uint256 internal constant MAX_N_MERKLE_VERIFIER_QUERIES = 128;\n\n    function verifyMerkle(\n        uint256 channelPtr,\n        uint256 queuePtr,\n        bytes32 root,\n        uint256 n\n    ) internal view virtual returns (bytes32 hash);\n}\n"},"IQueryableFactRegistry.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"IFactRegistry.sol\";\n\n/*\n  Extends the IFactRegistry interface with a query method that indicates\n  whether the fact registry has successfully registered any fact or is still empty of such facts.\n*/\ninterface IQueryableFactRegistry is IFactRegistry {\n    /*\n      Returns true if at least one fact has been registered.\n    */\n    function hasRegisteredFact() external view returns (bool);\n}\n"},"MerkleVerifier.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"IMerkleVerifier.sol\";\n\ncontract MerkleVerifier is IMerkleVerifier {\n    function getHashMask() internal pure returns (uint256) {\n        // Default implementation.\n        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;\n    }\n\n    /*\n      Verifies a Merkle tree decommitment for n leaves in a Merkle tree with N leaves.\n\n      The inputs data sits in the queue at queuePtr.\n      Each slot in the queue contains a 32 bytes leaf index and a 32 byte leaf value.\n      The indices need to be in the range [N..2*N-1] and strictly incrementing.\n      Decommitments are read from the channel in the ctx.\n\n      The input data is destroyed during verification.\n    */\n    function verifyMerkle(\n        uint256 channelPtr,\n        uint256 queuePtr,\n        bytes32 root,\n        uint256 n\n    ) internal view virtual override returns (bytes32 hash) {\n        uint256 lhashMask = getHashMask();\n        require(n \u003c= MAX_N_MERKLE_VERIFIER_QUERIES, \"TOO_MANY_MERKLE_QUERIES\");\n\n        assembly {\n            // queuePtr + i * 0x40 gives the i\u0027th index in the queue.\n            // hashesPtr + i * 0x40 gives the i\u0027th hash in the queue.\n            let hashesPtr := add(queuePtr, 0x20)\n            let queueSize := mul(n, 0x40)\n            let slotSize := 0x40\n\n            // The items are in slots [0, n-1].\n            let rdIdx := 0\n            let wrIdx := 0 // = n % n.\n\n            // Iterate the queue until we hit the root.\n            let index := mload(add(rdIdx, queuePtr))\n            let proofPtr := mload(channelPtr)\n\n            // while(index \u003e 1).\n            for {\n\n            } gt(index, 1) {\n\n            } {\n                let siblingIndex := xor(index, 1)\n                // sibblingOffset := 0x20 * lsb(siblingIndex).\n                let sibblingOffset := mulmod(siblingIndex, 0x20, 0x40)\n\n                // Store the hash corresponding to index in the correct slot.\n                // 0 if index is even and 0x20 if index is odd.\n                // The hash of the sibling will be written to the other slot.\n                mstore(xor(0x20, sibblingOffset), mload(add(rdIdx, hashesPtr)))\n                rdIdx := addmod(rdIdx, slotSize, queueSize)\n\n                // Inline channel operation:\n                // Assume we are going to read a new hash from the proof.\n                // If this is not the case add(proofPtr, 0x20) will be reverted.\n                let newHashPtr := proofPtr\n                proofPtr := add(proofPtr, 0x20)\n\n                // Push index/2 into the queue, before reading the next index.\n                // The order is important, as otherwise we may try to read from an empty queue (in\n                // the case where we are working on one item).\n                // wrIdx will be updated after writing the relevant hash to the queue.\n                mstore(add(wrIdx, queuePtr), div(index, 2))\n\n                // Load the next index from the queue and check if it is our sibling.\n                index := mload(add(rdIdx, queuePtr))\n                if eq(index, siblingIndex) {\n                    // Take sibling from queue rather than from proof.\n                    newHashPtr := add(rdIdx, hashesPtr)\n                    // Revert reading from proof.\n                    proofPtr := sub(proofPtr, 0x20)\n                    rdIdx := addmod(rdIdx, slotSize, queueSize)\n\n                    // Index was consumed, read the next one.\n                    // Note that the queue can\u0027t be empty at this point.\n                    // The index of the parent of the current node was already pushed into the\n                    // queue, and the parent is never the sibling.\n                    index := mload(add(rdIdx, queuePtr))\n                }\n\n                mstore(sibblingOffset, mload(newHashPtr))\n\n                // Push the new hash to the end of the queue.\n                mstore(add(wrIdx, hashesPtr), and(lhashMask, keccak256(0x00, 0x40)))\n                wrIdx := addmod(wrIdx, slotSize, queueSize)\n            }\n            hash := mload(add(rdIdx, hashesPtr))\n\n            // Update the proof pointer in the context.\n            mstore(channelPtr, proofPtr)\n        }\n        require(hash == root, \"INVALID_MERKLE_PROOF\");\n    }\n}\n"},"PrimeFieldElement0.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\ncontract PrimeFieldElement0 {\n    uint256 internal constant K_MODULUS =\n        0x800000000000011000000000000000000000000000000000000000000000001;\n    uint256 internal constant K_MONTGOMERY_R =\n        0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1;\n    uint256 internal constant K_MONTGOMERY_R_INV =\n        0x40000000000001100000000000012100000000000000000000000000000000;\n    uint256 internal constant GENERATOR_VAL = 3;\n    uint256 internal constant ONE_VAL = 1;\n    uint256 internal constant GEN1024_VAL =\n        0x659d83946a03edd72406af6711825f5653d9e35dc125289a206c054ec89c4f1;\n\n    function fromMontgomery(uint256 val) internal pure returns (uint256 res) {\n        // uint256 res = fmul(val, kMontgomeryRInv);\n        assembly {\n            res := mulmod(\n                val,\n                0x40000000000001100000000000012100000000000000000000000000000000,\n                0x800000000000011000000000000000000000000000000000000000000000001\n            )\n        }\n        return res;\n    }\n\n    function fromMontgomeryBytes(bytes32 bs) internal pure returns (uint256) {\n        // Assuming bs is a 256bit bytes object, in Montgomery form, it is read into a field\n        // element.\n        uint256 res = uint256(bs);\n        return fromMontgomery(res);\n    }\n\n    function toMontgomeryInt(uint256 val) internal pure returns (uint256 res) {\n        //uint256 res = fmul(val, kMontgomeryR);\n        assembly {\n            res := mulmod(\n                val,\n                0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1,\n                0x800000000000011000000000000000000000000000000000000000000000001\n            )\n        }\n        return res;\n    }\n\n    function fmul(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        //uint256 res = mulmod(a, b, kModulus);\n        assembly {\n            res := mulmod(a, b, 0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fadd(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, b, kModulus);\n        assembly {\n            res := addmod(a, b, 0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fsub(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, kModulus - b, kModulus);\n        assembly {\n            res := addmod(\n                a,\n                sub(0x800000000000011000000000000000000000000000000000000000000000001, b),\n                0x800000000000011000000000000000000000000000000000000000000000001\n            )\n        }\n        return res;\n    }\n\n    function fpow(uint256 val, uint256 exp) internal view returns (uint256) {\n        return expmod(val, exp, K_MODULUS);\n    }\n\n    function expmod(\n        uint256 base,\n        uint256 exponent,\n        uint256 modulus\n    ) internal view returns (uint256 res) {\n        assembly {\n            let p := mload(0x40)\n            mstore(p, 0x20) // Length of Base.\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\n            mstore(add(p, 0x60), base) // Base.\n            mstore(add(p, 0x80), exponent) // Exponent.\n            mstore(add(p, 0xa0), modulus) // Modulus.\n            // Call modexp precompile.\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n            res := mload(p)\n        }\n    }\n\n    function inverse(uint256 val) internal view returns (uint256) {\n        return expmod(val, K_MODULUS - 2, K_MODULUS);\n    }\n}\n"}}