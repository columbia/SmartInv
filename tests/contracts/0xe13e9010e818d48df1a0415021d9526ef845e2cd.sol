{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "pragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/UniswapTrader.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.8;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n    @title The Uniswap-enabled base contract for Vanilla.\n*/\ncontract UniswapTrader {\n    using SafeMath for uint256;\n\n    string private constant _ERROR_SLIPPAGE_LIMIT_EXCEEDED = \"a1\";\n    string private constant _INVALID_UNISWAP_PAIR = \"a2\";\n\n    address internal immutable _uniswapFactoryAddr;\n    address internal immutable _wethAddr;\n\n    // internally tracked reserves for price manipulation protection for each token (Uniswap uses uint112 so uint128 is plenty)\n    mapping(address => uint128) public wethReserves;\n\n    /**\n        @notice Deploys the contract and initializes Uniswap contract references and internal WETH-reserve for safe tokens.\n        @dev using UniswapRouter to ensure that Vanilla uses the same WETH contract\n        @param routerAddress The address of UniswapRouter contract\n        @param limit The initial reserve value for tokens in the safelist\n        @param safeList The list of \"safe\" tokens to trade\n     */\n    constructor(\n        address routerAddress,\n        uint128 limit,\n        address[] memory safeList\n    ) public {\n        // fetch addresses via router to guarantee correctness\n        IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);\n        address wethAddr = router.WETH();\n        IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\n        for (uint256 i = 0; i < safeList.length; i++) {\n            address token = safeList[i];\n            // verify that WETH-token pair exists in Uniswap\n            // (order isn't significant, UniswapV2Factory.createPair populates the mapping in reverse direction too)\n            address pair = factory.getPair(token, wethAddr);\n            require(pair != address(0), _INVALID_UNISWAP_PAIR);\n\n            // we initialize the fixed list of rewardedTokens with the reserveLimit-value that they'll match the invariant\n            // \"every rewardedToken will have wethReserves[rewardedToken] > 0\"\n            // (this way we don't need to store separate lists for both wethReserve-tracking and tokens eligible for the rewards)\n            wethReserves[token] = limit;\n        }\n        _wethAddr = wethAddr;\n        _uniswapFactoryAddr = address(factory);\n    }\n\n    /**\n        @notice Checks if the given ERC-20 token will be eligible for rewards (i.e. a safelisted token)\n        @param token The ERC-20 token address\n     */\n    function isTokenRewarded(address token) public view returns (bool) {\n        return wethReserves[token] > 0;\n    }\n\n    function _pairInfo(\n        address factory,\n        address token,\n        address weth\n    ) internal pure returns (address pair, bool tokenFirst) {\n        // as order of tokens is important in Uniswap pairs, we record this information here and pass it on to caller\n        // for gas optimization\n        tokenFirst = token < weth;\n\n        // adapted from UniswapV2Library.sol, calculates the CREATE2 address for a pair without making any external calls to factory contract\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        factory,\n                        keccak256(\n                            tokenFirst\n                                ? abi.encodePacked(token, weth)\n                                : abi.encodePacked(weth, token)\n                        ),\n                        hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\"\n                    )\n                )\n            )\n        );\n    }\n\n    function _amountToSwap(\n        uint256 tokensIn,\n        uint256 reservesIn,\n        uint256 reservesOut\n    ) internal pure returns (uint256 tokensOut) {\n        uint256 inMinusFee = tokensIn.mul(997); // in * (100% - 0.3%)\n        tokensOut = reservesOut.mul(inMinusFee).div(\n            reservesIn.mul(1000).add(inMinusFee)\n        );\n    }\n\n    function _updateReservesOnBuy(address token, uint112 wethReserve)\n        private\n        returns (uint128 reserve)\n    {\n        // when buying, update internal reserve only if Uniswap reserve is greater\n        reserve = wethReserves[token];\n        if (reserve == 0) {\n            // trading a non-safelisted token, so do not update internal reserves\n            return reserve;\n        }\n        if (wethReserve > reserve) {\n            wethReserves[token] = wethReserve;\n            reserve = wethReserve;\n        }\n    }\n\n    function _buyInUniswap(\n        address token_,\n        uint256 eth,\n        uint256 amount_,\n        address tokenOwner_\n    ) internal returns (uint256 numToken, uint128 reserve) {\n        (address pairAddress, bool tokenFirst) =\n            _pairInfo(_uniswapFactoryAddr, token_, _wethAddr);\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n\n        address tokenCustody = address(this);\n        uint256 balance = IERC20(token_).balanceOf(tokenCustody);\n        IERC20(_wethAddr).transferFrom(tokenOwner_, pairAddress, eth);\n        if (tokenFirst) {\n            (uint112 tokenReserve, uint112 wethReserve, ) = pair.getReserves();\n            pair.swap(\n                _amountToSwap(eth, wethReserve, tokenReserve),\n                uint256(0),\n                tokenCustody,\n                new bytes(0)\n            );\n            reserve = _updateReservesOnBuy(token_, wethReserve);\n        } else {\n            (uint112 wethReserve, uint112 tokenReserve, ) = pair.getReserves();\n            pair.swap(\n                uint256(0),\n                _amountToSwap(eth, wethReserve, tokenReserve),\n                tokenCustody,\n                new bytes(0)\n            );\n            reserve = _updateReservesOnBuy(token_, wethReserve);\n        }\n        // finally check how the custody balance has changed after swap\n        numToken = IERC20(token_).balanceOf(tokenCustody) - balance;\n        // revert if the price diff between trade-time and execution-time was too large\n        require(numToken >= amount_, _ERROR_SLIPPAGE_LIMIT_EXCEEDED);\n    }\n\n    function _updateReservesOnSell(address token, uint112 wethReserve)\n        private\n        returns (uint128 reserve)\n    {\n        // when selling, update internal reserve only if the Uniswap reserve is smaller\n        reserve = wethReserves[token];\n        if (reserve == 0) {\n            // trading a non-safelisted token, so do not update internal reserves\n            return reserve;\n        }\n        if (wethReserve < reserve) {\n            wethReserves[token] = wethReserve;\n            reserve = wethReserve;\n        }\n    }\n\n    function _sellInUniswap(\n        address token_,\n        uint256 amount_,\n        uint256 eth_,\n        address tokenReceiver_\n    ) internal returns (uint256 numEth, uint128 reserve) {\n        (address pairAddress, bool tokenFirst) =\n            _pairInfo(_uniswapFactoryAddr, token_, _wethAddr);\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n        uint256 balance = IERC20(_wethAddr).balanceOf(tokenReceiver_);\n\n        // Use TransferHelper because we have no idea here how token.transfer() has been implemented\n        TransferHelper.safeTransfer(token_, pairAddress, amount_);\n        if (tokenFirst) {\n            (uint112 tokenReserve, uint112 wethReserve, ) = pair.getReserves();\n            pair.swap(\n                uint256(0),\n                _amountToSwap(amount_, tokenReserve, wethReserve),\n                tokenReceiver_,\n                new bytes(0)\n            );\n            reserve = _updateReservesOnSell(token_, wethReserve);\n        } else {\n            (uint112 wethReserve, uint112 tokenReserve, ) = pair.getReserves();\n            pair.swap(\n                _amountToSwap(amount_, tokenReserve, wethReserve),\n                uint256(0),\n                tokenReceiver_,\n                new bytes(0)\n            );\n            reserve = _updateReservesOnSell(token_, wethReserve);\n        }\n        // finally check how the receivers balance has changed after swap\n        numEth = IERC20(_wethAddr).balanceOf(tokenReceiver_) - balance;\n        // revert if the price diff between trade-time and execution-time was too large\n        require(numEth >= eth_, _ERROR_SLIPPAGE_LIMIT_EXCEEDED);\n    }\n}\n"
    },
    "contracts/VanillaGovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n @title Governance Token for Vanilla Finance.\n */\ncontract VanillaGovernanceToken is ERC20(\"Vanilla\", \"VNL\") {\n    string private constant _ERROR_ACCESS_DENIED = \"c1\";\n    address private immutable _owner;\n\n    /**\n        @notice Deploys the token and sets the caller as an owner.\n     */\n    constructor() public {\n        _owner = msg.sender;\n        // set the decimals explicitly to 12, for (theoretical maximum of) VNL reward of a 1ETH of profit\n        // should be displayed as 1000000VNL (18-6 = 12 decimals).\n        _setupDecimals(12);\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, _ERROR_ACCESS_DENIED);\n        _;\n    }\n\n    /**\n        @notice Mints the tokens. Used only by the VanillaRouter-contract.\n\n        @param to The recipient address of the minted tokens\n        @param tradeReward The amount of tokens to be minted\n     */\n    function mint(address to, uint256 tradeReward) external onlyOwner {\n        _mint(to, tradeReward);\n    }\n}\n"
    },
    "contracts/VanillaRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./VanillaGovernanceToken.sol\";\nimport \"./UniswapTrader.sol\";\n\n/// @dev Needed functions from the WETH contract originally deployed in https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n\n/**\n    @title The main entrypoint for Vanilla\n*/\ncontract VanillaRouter is UniswapTrader {\n    string private constant _ERROR_TRADE_EXPIRED = \"b1\";\n    string private constant _ERROR_TRANSFER_FAILED = \"b2\";\n    string private constant _ERROR_TOO_MANY_TRADES_PER_BLOCK = \"b3\";\n    string private constant _ERROR_NO_TOKEN_OWNERSHIP = \"b4\";\n    string private constant _ERROR_RESERVELIMIT_TOO_LOW = \"b5\";\n    string private constant _ERROR_NO_SAFE_TOKENS = \"b6\";\n\n    uint256 public immutable epoch;\n    VanillaGovernanceToken public immutable vnlContract;\n    uint128 public immutable reserveLimit;\n\n    using SafeMath for uint256;\n\n    // data for calculating volume-weighted average prices, average purchasing block, and limiting trades per block\n    struct PriceData {\n        uint256 ethSum;\n        uint256 tokenSum;\n        uint256 weightedBlockSum;\n        uint256 latestBlock;\n    }\n\n    // Price data, indexed as [owner][token]\n    mapping(address => mapping(address => PriceData)) public tokenPriceData;\n\n    /**\n       @dev Emitted when tokens are sold.\n       @param seller The owner of tokens.\n       @param token The address of the sold token.\n       @param amount Number of sold tokens.\n       @param eth The received ether from the trade.\n       @param profit The calculated profit from the trade.\n       @param reward The amount of VanillaGovernanceToken reward tokens transferred to seller.\n       @param reserve The internally tracker Uniswap WETH reserve before trade.\n     */\n    event TokensSold(\n        address indexed seller,\n        address indexed token,\n        uint256 amount,\n        uint256 eth,\n        uint256 profit,\n        uint256 reward,\n        uint256 reserve\n    );\n\n    /**\n       @dev Emitted when tokens are bought.\n       @param buyer The new owner of tokens.\n       @param token The address of the purchased token.\n       @param eth The amount of ether spent in the trade.\n       @param amount Number of purchased tokens.\n       @param reserve The internally tracker Uniswap WETH reserve before trade.\n     */\n    event TokensPurchased(\n        address indexed buyer,\n        address indexed token,\n        uint256 eth,\n        uint256 amount,\n        uint256 reserve\n    );\n\n    /**\n        @notice Deploys the contract and the VanillaGovernanceToken contract.\n        @dev initializes the token contract for safe reference and sets the epoch for reward calculations\n        @param uniswapRouter The address of UniswapRouter contract\n        @param limit The minimum WETH reserve for a token to be eligible in profit mining\n        @param safeList The list of ERC-20 addresses that are considered \"safe\", and will be eligible for rewards\n    */\n    constructor(\n        address uniswapRouter,\n        uint128 limit,\n        address[] memory safeList\n    ) public UniswapTrader(uniswapRouter, limit, safeList) {\n        vnlContract = new VanillaGovernanceToken();\n        epoch = block.number;\n        require(limit > 0, _ERROR_RESERVELIMIT_TOO_LOW);\n        require(safeList.length > 0, _ERROR_NO_SAFE_TOKENS);\n        reserveLimit = limit;\n    }\n\n    modifier beforeDeadline(uint256 deadline) {\n        require(deadline >= block.timestamp, _ERROR_TRADE_EXPIRED);\n        _;\n    }\n\n    /**\n        @notice Buys the tokens with Ether. Use the external pricefeed for pricing.\n        @dev Buys the `numToken` tokens for all the msg.value Ether, before `blockTimeDeadline`\n\n        @param token The address of ERC20 token to be bought\n        @param numToken The amount of ERC20 tokens to be bought\n        @param blockTimeDeadline The block timestamp when this buy-transaction expires\n     */\n    function depositAndBuy(\n        address token,\n        uint256 numToken,\n        uint256 blockTimeDeadline\n    ) external payable beforeDeadline(blockTimeDeadline) {\n        IWETH weth = IWETH(_wethAddr);\n        uint256 numEth = msg.value;\n        weth.deposit{value: numEth}();\n\n        // execute swap using WETH-balance of this contract\n        _executeBuy(msg.sender, address(this), token, numEth, numToken);\n    }\n\n    /**\n        @notice Buys the tokens with WETH. Use the external pricefeed for pricing.\n        @dev Buys the `numToken` tokens for all the msg.value Ether, before `blockTimeDeadline`\n\n        @param token The address of ERC20 token to be bought\n        @param numEth The amount of WETH to spend. Needs to be pre-approved for the VanillaRouter.\n        @param numToken The amount of ERC20 tokens to be bought\n        @param blockTimeDeadline The block timestamp when this buy-transaction expires\n     */\n    function buy(\n        address token,\n        uint256 numEth,\n        uint256 numToken,\n        uint256 blockTimeDeadline\n    ) external beforeDeadline(blockTimeDeadline) {\n        // execute swap using WETH-balance of the caller\n        _executeBuy(msg.sender, msg.sender, token, numEth, numToken);\n    }\n\n    function _executeBuy(\n        address owner,\n        address currentWETHHolder,\n        address token,\n        uint256 numEthSold,\n        uint256 numToken\n    ) internal {\n        // verify the one-trade-per-block-per-token rule and protect against reentrancy\n        PriceData storage prices = tokenPriceData[owner][token];\n        require(\n            block.number > prices.latestBlock,\n            _ERROR_TOO_MANY_TRADES_PER_BLOCK\n        );\n        prices.latestBlock = block.number;\n\n        // do the swap and update price data\n        (uint256 tokens, uint256 newReserve) =\n            _buyInUniswap(token, numEthSold, numToken, currentWETHHolder);\n        prices.ethSum = prices.ethSum.add(numEthSold);\n        prices.tokenSum = prices.tokenSum.add(tokens);\n        prices.weightedBlockSum = prices.weightedBlockSum.add(\n            block.number.mul(tokens)\n        );\n        emit TokensPurchased(msg.sender, token, numEthSold, tokens, newReserve);\n    }\n\n    /**\n        @dev Receives the ether only from WETH contract during withdraw()\n     */\n    receive() external payable {\n        // make sure that router accepts ETH only from WETH contract\n        assert(msg.sender == _wethAddr);\n    }\n\n    /**\n        @notice Sells the tokens the caller owns. Use the external pricefeed for pricing.\n        @dev Sells the `numToken` tokens msg.sender owns, for `numEth` ether, before `blockTimeDeadline`\n\n        @param token The address of ERC20 token to be sold\n        @param numToken The amount of ERC20 tokens to be sold\n        @param numEthLimit The minimum amount of ether to be received for exchange (the limit order)\n        @param blockTimeDeadline The block timestamp when this sell-transaction expires\n     */\n    function sell(\n        address token,\n        uint256 numToken,\n        uint256 numEthLimit,\n        uint256 blockTimeDeadline\n    ) external beforeDeadline(blockTimeDeadline) {\n        // execute the swap by transferring WETH directly to caller\n        _executeSell(msg.sender, msg.sender, token, numToken, numEthLimit);\n    }\n\n    /**\n        @notice Sells the tokens the caller owns. Use the external pricefeed for pricing.\n        @dev Sells the `numToken` tokens msg.sender owns, for `numEth` ether, before `blockTimeDeadline`\n\n        @param token The address of ERC20 token to be sold\n        @param numToken The amount of ERC20 tokens to be sold\n        @param numEthLimit The minimum amount of ether to be received for exchange (the limit order)\n        @param blockTimeDeadline The block timestamp when this sell-transaction expires\n     */\n    function sellAndWithdraw(\n        address token,\n        uint256 numToken,\n        uint256 numEthLimit,\n        uint256 blockTimeDeadline\n    ) external beforeDeadline(blockTimeDeadline) {\n        // execute the swap by transferring WETH to this contract first\n        uint256 numEth =\n            _executeSell(\n                msg.sender,\n                address(this),\n                token,\n                numToken,\n                numEthLimit\n            );\n\n        IWETH iweth = IWETH(_wethAddr);\n        iweth.withdraw(numEth);\n\n        (bool etherTransferSuccessful, ) =\n            msg.sender.call{value: numEth}(new bytes(0));\n        require(etherTransferSuccessful, _ERROR_TRANSFER_FAILED);\n    }\n\n    function _executeSell(\n        address owner,\n        address recipient,\n        address token,\n        uint256 numTokensSold,\n        uint256 numEthLimit\n    ) internal returns (uint256) {\n        // verify the one-trade-per-block-per-token rule and protect against reentrancy\n        PriceData storage prices = tokenPriceData[owner][token];\n        require(\n            block.number > prices.latestBlock,\n            _ERROR_TOO_MANY_TRADES_PER_BLOCK\n        );\n        prices.latestBlock = block.number;\n\n        // do the swap, calculate the profit and update price data\n        (uint256 numEth, uint128 reserve) =\n            _sellInUniswap(token, numTokensSold, numEthLimit, recipient);\n\n        uint256 profitablePrice =\n            numTokensSold.mul(prices.ethSum).div(prices.tokenSum);\n        uint256 avgBlock = prices.weightedBlockSum.div(prices.tokenSum);\n        uint256 newTokenSum = prices.tokenSum.sub(numTokensSold);\n        uint256 profit =\n            numEth > profitablePrice ? numEth.sub(profitablePrice) : 0;\n\n        prices.ethSum = _proportionOf(\n            prices.ethSum,\n            newTokenSum,\n            prices.tokenSum\n        );\n        prices.weightedBlockSum = _proportionOf(\n            prices.weightedBlockSum,\n            newTokenSum,\n            prices.tokenSum\n        );\n        prices.tokenSum = newTokenSum;\n\n        uint256 reward = 0;\n        if (isTokenRewarded(token)) {\n            // calculate the reward, and mint tokens\n            reward = _calculateReward(\n                epoch,\n                avgBlock,\n                block.number,\n                profit,\n                reserve,\n                reserveLimit\n            );\n            if (reward > 0) {\n                vnlContract.mint(msg.sender, reward);\n            }\n        }\n\n        emit TokensSold(\n            msg.sender,\n            token,\n            numTokensSold,\n            numEth,\n            profit,\n            reward,\n            reserve\n        );\n        return numEth;\n    }\n\n    /**\n        @notice Estimates the reward.\n        @dev Estimates the reward for given `owner` when selling `numTokensSold``token`s for `numEth` Ether. Also returns the individual components of the reward formula.\n        @return profitablePrice The expected amount of Ether for this trade. Profit of this trade can be calculated with `numEth`-`profitablePrice`.\n        @return avgBlock The volume-weighted average block for the `owner` and `token`\n        @return htrs The Holding/Trading Ratio, Squared- estimate for this trade, percentage value range in fixed point range 0-100.0000.\n        @return vpc The Value-Protection Coefficient- estimate for this trade, percentage value range in fixed point range 0-100.0000.\n        @return reward The token reward estimate for this trade.\n     */\n    function estimateReward(\n        address owner,\n        address token,\n        uint256 numEth,\n        uint256 numTokensSold\n    )\n        external\n        view\n        returns (\n            uint256 profitablePrice,\n            uint256 avgBlock,\n            uint256 htrs,\n            uint256 vpc,\n            uint256 reward\n        )\n    {\n        PriceData storage prices = tokenPriceData[owner][token];\n        require(prices.tokenSum > 0, _ERROR_NO_TOKEN_OWNERSHIP);\n        profitablePrice = numTokensSold.mul(prices.ethSum).div(prices.tokenSum);\n        avgBlock = prices.weightedBlockSum.div(prices.tokenSum);\n        if (numEth > profitablePrice) {\n            uint256 profit = numEth.sub(profitablePrice);\n            uint128 wethReserve = wethReserves[token];\n            htrs = _estimateHTRS(avgBlock);\n            vpc = _estimateVPC(profit, wethReserve);\n            reward = _calculateReward(\n                epoch,\n                avgBlock,\n                block.number,\n                profit,\n                wethReserve,\n                reserveLimit\n            );\n        } else {\n            htrs = 0;\n            vpc = 0;\n            reward = 0;\n        }\n    }\n\n    function _estimateHTRS(uint256 avgBlock) internal view returns (uint256) {\n        // H     = \"Holding/Trading Ratio, Squared\" (HTRS)\n        //       = ((Bmax-Bavg)/(Bmax-Bmin))\n        //       = (((Bmax-Bmin)-(Bavg-Bmin))/(Bmax-Bmin))\n        //       = (Bhold/Btrade) (= 0 if Bmax = Bavg, NaN if Bmax = Bmin)\n        if (avgBlock == block.number || block.number == epoch) return 0;\n\n        uint256 bhold = block.number - avgBlock;\n        uint256 btrade = block.number - epoch;\n\n        return bhold.mul(bhold).mul(1_000_000).div(btrade.mul(btrade));\n    }\n\n    function _estimateVPC(uint256 profit, uint256 reserve)\n        internal\n        view\n        returns (uint256)\n    {\n        // VPC = 1-max((P + L)/W, 1) (= 0 if P+L > W)\n        //     = (W - P - L ) / W\n        if (profit + reserveLimit > reserve) return 0;\n\n        return (reserve - profit - reserveLimit).mul(1_000_000).div(reserve);\n    }\n\n    function _calculateReward(\n        uint256 epoch_,\n        uint256 avgBlock,\n        uint256 currentBlock,\n        uint256 profit,\n        uint128 wethReserve,\n        uint128 reserveLimit_\n    ) internal pure returns (uint256) {\n        /*\n        Reward formula:\n            P     = absolute profit in Ether = `profit`\n            Bmax  = block.number when trade is happening = `block.number`\n            Bavg  = volume-weighted average block.number of purchase = `avgBlock`\n            Bmin  = \"epoch\", the block.number when contract was deployed = `epoch_`\n            Bhold = Bmax-Bavg = number of blocks the trade has been held (instead of traded)\n            Btrade= Bmax-Bmin = max possible trading time in blocks\n            H     = \"Holding/Trading Ratio, Squared\" (HTRS)\n                  = ((Bmax-Bavg)/(Bmax-Bmin))\n                  = (((Bmax-Bmin)-(Bavg-Bmin))/(Bmax-Bmin))\n                  = (Bhold/Btrade) (= 0 if Bmax = Bavg, NaN if Bmax = Bmin)\n            L     = WETH reserve limit for any traded token = `_reserveLimit`\n            W     = internally tracked WETH reserve size for when selling a token = `wethReserve`\n            V     = value protection coefficient\n                  = 1-min((P + L)/W, 1) (= 0 if P+L > W)\n            R     = minted rewards\n                  = P*V*H\n                  = if   (P = 0 || P + L > W || Bmax = Bavg || BMax = Bmin)\n                         0\n                    else P * (1-(P + L)/W) * (Bhold/Btrade)\n                       = (P * (W - P - L) * Bhold) / W / Btrade\n        */\n\n        if (profit == 0) return 0;\n        if (profit + reserveLimit_ > wethReserve) return 0;\n        if (currentBlock == avgBlock) return 0;\n        if (currentBlock == epoch_) return 0;\n\n        // these cannot underflow thanks to previous checks\n        uint256 rpl = wethReserve - profit - reserveLimit_;\n        uint256 bhold = currentBlock - avgBlock;\n        uint256 btrade = currentBlock - epoch_;\n\n        uint256 nominator = profit.mul(rpl).mul(bhold.mul(bhold));\n        // no division by zero possible, both wethReserve and btrade are always > 0\n        return nominator / wethReserve / (btrade.mul(btrade));\n    }\n\n    function _proportionOf(\n        uint256 total,\n        uint256 numerator,\n        uint256 denominator\n    ) internal pure returns (uint256) {\n        // percentage = (numerator/denominator)\n        // proportion = total * percentage\n        return total.mul(numerator).div(denominator);\n    }\n}\n"
    }
  }
}}