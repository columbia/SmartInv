{{
  "language": "Solidity",
  "sources": {
    "contracts/Satoshiverse.sol": {
      "content": "//SPDX-License-Identifier: GNU General Public License v3.0\n\n          \n  //                      ******,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,**,,,,,,,,,,,,,,,,,,,,,,,,,,,,************                                          \n  //                    *******,,,,,*,,,,*,*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#,/****/**//*//**#****                                        \n  //                  ************* *,,*,*,/,,,..............,,,,,,,,,,,,,,,,,,,,*/(,/****(/,(*//////*****                                         \n  //                ******,,,,*,,,**,,,,*./,,,. ............,,,,,,,,,,,,,,,,,,***/,******/(,(//*/*////*/###,                                          \n  //               **,,,,,,,,,,,**,,,*, ,,,,,.  ..........,,,,,,,,,,,,,,,,,***,(,******/(,#//**/*///////,###,                                          \n  //              **,,,,,,,,,*,*,**,,,*,,  ,/**,...*......,,,,,,,,,,,,*,,**//#/,*//******(*(///////////((((##.                                          \n  //            *****,,,,,,,,,,,,*,**,,,,,,,,,,. ..*/,,,,**************/*/(*,,,/**/*******//,/*///*///////((##,                                          \n  //          ******,,,,,,,,,,,,*,*,,,,,,,.,,,,.....,,,,**.,/,**.,,******,**************//*,////////////(((###%,                                          \n  //        ********,*,,,,,,,*,,*,*,,,,,,,,,.....,,,.  ...,,/,**.,/,,******,,,,**********/**/**///**////(((###%%,                                          \n  //       ********,*,,,,,,,,*,*,/*,*,,,,,..  .,,.....,,,,,*/.*/.,/**,,,,,,************///**,///*//////((((####%%(                                          \n  //      **/********,**,,,,,*,,,,,,,,,.,,,,,,,....,,,,...,*(,/*.,/,,*****,,,*******,***//,,/***///////((######%%#/,                                          \n  //      **********,,**,,,****,,,,,*,,,,,,,,....,,**,,,****(,**,,(***,********,,****////(,(*///////////(((#####%%%,                                          \n  //     ************,,***,,,****,,,,***,,...,,,,,,....,,*/**(,/*,,(//***,,,***********///(,/**/////(////(########%%                                          \n  //    ,///********,,,***,,,*****,,*,,******,,,,,****,,,,**/,/**,/,,,*********////******(,(//((////*//((########%%&,                                          \n  //    *//*********,,,,*****,,,*******,*********,********/(,/*,,(//****////***,,,**//(/(,(((///*//((((#######%%%%%**                                          \n  //    //*/************,,*****///*/*//****,,,*****,,,,***,//,/**,/*///***,,,**//((////*((*////((((((((((#######%%%%(,                                          \n  //    *,(******************,**(/(/*****//**,,,,**********(,/****/****////////****//(((#/(((((((///(((((######%%#%%,,                                          \n  //    /***/*/*/*//(((############%(##((((///////***/**(,#.,/*/,/(*///(///////((##%%%%&%&%&&&&&&&&&&&&&&&%%%###%#%%%*                                          \n  //   *&/**//*/((###%&&#%%%%%%%%%%%#(((((((((###/(#%,,,,//*******/**,,*/((#&%%#%#######%&&&&&&&&&&&&@&&&&&&%%%%%##&@(,                                          \n  //   &&&(*///((((#%%%(#*******///*//////(#%####(%,(******,******////((#%%%%%%%%%(////////////////(&&&&@&&&&%%%%#&&&@/,                                          \n  //   %&,#%/**(((/#/#/*(*%***************/////#%%#(((/*,,**********///(%%%%%&%#////////////////////@%%%&@&&%&&%%#%&%#&,                                          \n  //   (,*&&**(##,********,#/***************/////%(/******************#%%%%%////////////////****(//%%%%%%%##&&%%%&&##&#,                                          \n  //   //*/&&#,/,,(*//********,/#*,,,,,,,,**/#%//*//****,,,,,,,****//(%#%%%%&&@%(/////***,*/&/*/((((((#%%&%#%%#@@@&#%&#*                                          \n  //   #*#,(&/,,,,,**,*%,//*********************/******,,**********//(##%%%#%%%%%%*********///(//#%#(&/((/#####%@##@#&#*                                          \n  //   #%**,#/,,,,,,,,,,*,,,,*##(***,,/,*((,.,*,*******,,,,,****,,,,*(###%%%%#%,*/((/****(*/#%#***///////((((#%%%###@%#,                                          \n  //   *%*(#&/*,,,,,,,,,,,,,,,,,,,,..    .,*,,*********************//###%%%////*/*,****,*************////((((##%@%%%%##,                                          \n  //   *(,(#**,,,,,,,,,,,,,,,,,,...   .,(,.*,,*****/***,,,,,,,,***//####%*,****/,*/*,,,,,,*,*******////((((##%#&&#%%%//                                          \n  //   (//(*******,,,,,,,,,,,,,,,,......,/,*,,,,,,********,*********/##%%//*,,,*,*//*,,,,,,*******////(((###%%%%%%&%%%#                                          \n  //    ((#*/*********,,,,,,,,,,,,,,,,,,./,,,**,****//**,,,,,,,*,,,*(#%%%///////*,****,,,,,,,,,,,,,,,,,,###%%%%%%&#%%%(                                          \n  //    ((((#*#*********,,,,,,,,,,,,,,,,,*,,******///******,,,*/***/##%%(/****//(%/,,,,,,,,,,,,,,,,***##%%%%%%%&%&%%%%/                                          \n  //     ((((((/*#***************,,,,,,***#*//**(//(///**,,****,****(#%%////(/(((,,,,,,*************##%%%%%%&%&%&%%%%(                                          \n  //     ((((((((#*(////**********************,(/*/(//***,,,***,*/**#%%%((#/%(*/,**************###%%%%%%%%&%&&&&%%%%#                                          \n  //       (((((((((*(%%(**///*********************//(//****,***,****##%%#%******************#%%%%&&%%&@&&&&&&&&%%%%                                          \n  //        ((((((((#(/#//((**(%(***************,*****#//*////(//(((#/%#%%(****************###%#@&%%%&&%&&&&&&&&%%%                                          \n  //         (((((((#(#%//////////************,,,,****(//%#(/***/(#&&@%%&%***************%#%%%&%%&&%%&&&&&&&&&%%%%%                                          \n  //         (((((((((((#(///////#/*****%/*****,,,***(#/(#%&&%%%%%%&&@&&&&&(***********#@%#%%%%&%%%&&&&&&&&&&&&&%%                                          \n  //          (%(((((((((/(////*((******#&#/****#*,,,********(%(%%%%%%%%%%*//#*******&&@%%%%%&&&%&&&&&&&&&&&&&&%&                                          \n  //           ##%(((((#(/%%*////********@&%&&&&&&&&&&&(&*********//%&&&&&&&@@@@&&@@%%%%%%%%%%%%&@@&&&&&&&%&%%%%                                          \n  //            /#*%//%&&%%/////**********/@@@@@@@@@@@@@&/,,,,,,,**%@@@@@@@@@@@@@@&%%%%%%%%%%%%%&%&&@@&%&&#&%%%                                          \n  //            ///////(%/#/////********,#/**,,,,,,,,,,,,,,,,,,,,,*******/////%%%%&&%%%%%%%%%%%&&&&&@&%%%%%%%%                                          \n  //             /*/*///////#//*************,,,,,,,,,,*///******///(((#((/////((((#%%%%%%%%%%%%%%%&&%%%%%%%%%                                          \n  //              //******/(//**********#*******(&&&&&&&&&&&&&&&&&&&&&&@@@@&&%##%%%%&%%%%%%%%%%%&%%%%%%%%%&*                                          \n  //              *(/******///**/%#(****%*&&&&%******,,. .,***********/////(%%&&@@@&&%%%&&@@%%%&%%%%%%%%%&(                                          \n  //               (,(*******((/*****************,,,,,,,,,,,,,,,,,********/(######%#%%%%%%%%%&&&%%%%%%%&#%                                          \n  //                ((,#*/***********************/////////****/////((#%%&&&%%%####%##%%%%%%%%%%%%%%%%&%&&                                          \n  //                //((/*(*///********************///((##%%&&&&&&&&&&%%%####(#((##%%%%%%%%%%%%%%%&#&&&&*                                          \n  //                 ,((//#*/*#******************////////////((#(#((#%#&%####((#%%%%%%%%%%%%%%&%%%&&%&&*                                          \n  //                   ((((((*(/,(*********************************//////((((#(######%%%%%%&#%%%&&&&&%                                          \n  //                    ##(((#*((#,#***********************/,***(***/////////(((((##%%%%%&%&&%%&&&&&                                          \n  //                      ##((#/#(((,#**************(/,,*,/,//((/,#**,/%(////(((((%#%%%%%&&&%%&&&&&                                          \n  //                       ((((((((((//(,#*/*###/,,,/#,%(,#&&&&&#&&@*(*(#%//*/%%&&(#%&#&%&&&&%&&&&                                          \n  //                         ((()))))(/(////,,*##/,*/(((,(%%@*,,,**&@*%((/(((#(%&&#((&%&%%%&&&&                                         \n  //                            (()))))))(///((/(/**(/*(#,,#@*//***/*(##(@/(/((/(#&#&&%&%%%&&&                                          \n  //                               ()()()(()#(((/*(((*@*&,/(@@#(****//((@@@/%(#%&#%#&%%&&&()                                         \n  //                                 ())))#####%(&/&,@@@@@(%/,/(####*(&(@@@@@@&&&&&&&())                                       \n  //                                      &&(%*%@@@@@#(%%%#**#%%&%@@@@@@@()()()()()())                                         \n  //                                         ()()()&^()()@@@@@@@@@@@@@@@&*&()()())()                                          \n  //                                                \n  //                                               \n  //\n\n/*\n*Welcome to the Satoshiverse! The Satoshiverse is an epic comic NFT collaboration between Apollo NFT Studios, Jose Delbo, and YOU, the NFT community. \n*It tells the story of our hero, Satoshi The Creator and his quest to save the world from the Defenders of Fiat and the many other foes who lie ahead.\n*/ \npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/ILegionnaire.sol\";\nimport \"./utils/Operatorable.sol\";\nimport \"./helpers/NumberHelper.sol\";\n\n\n /**\n    * Satoshiverse Legionnaire Avatar NFT Contract V1 \n    * Provided by Satoshiverse LLC\n    * Authored by brnaldomesi a Senior Solidity Developer @ Herasoft\n    */\ncontract Satoshiverse is VRFConsumerBase, Operatorable, ReentrancyGuard {\n  ILegionnaire public legionnaire;\n\n  // Payable Address for the Initial Sale\n  address payable public svEthAddr = payable(0x981268bF660454e24DBEa9020D57C2504a538C57);\n  \n  uint16 _claimSV = 190;\n  uint16 _purchaseSV = 3301;\n\n  uint256 SV_MAX = 10000;\n  \n  uint256 _activeDateTime; \n  uint256 INTERVAL = 3600;\n  uint256 randNonce;\n  \n  // Chainlink\n  uint256 randomNess;\n  uint256 internal fee;\n  bytes32 internal keyHash;\n  \n  bool revealState;\n\n  bool public claimState = true;\n  bool public purchaseState = true;\n\n  bytes32 requestId;\n\n  string[] public leftoverUris;\n\n  mapping(address => mapping(string => uint8)) public tokensCount;\n\n  // Only through Day 4 Mints\n  mapping(address => uint8) public purchasedSoFar;\n  \n\n  // Set Initial Addresses and Variables Upon Deployment\n  constructor(\n    address _operator,\n    address _uriSetter,\n    address _legionnaire,\n    address _vrfCoordinator,\n    address _link,\n    bytes32 _keyHash,\n    uint256 _fee\n  ) \n    VRFConsumerBase(_vrfCoordinator, _link)\n  {\n    keyHash = _keyHash;\n    fee = _fee;\n\n    legionnaire = ILegionnaire(_legionnaire);\n\n    addOperator(_operator);\n    addURISetter(_uriSetter);\n  }\n\n// Change the Payment Adddress if Necessary\n  function setPaymentAddress(address _svEthAddr) external onlyOwner {\n    svEthAddr = payable(_svEthAddr);\n  }\n\n // Operator Account Sets the Contract with a List of Presale Holders Addresses\n // Snapshot was taken 12pm EST Monday November 22, 2021\n  function seedPresaleWhiteList(address[] calldata users, string calldata tokenType, uint8[] calldata counts) external onlyOperator {\n    require(users.length == counts.length, \"Mismatched presale addresses and counts\");\n\n    for(uint256 i = 0; i < users.length; i++) {\n      tokensCount[users[i]][tokenType] += counts[i];\n    }\n  }\n\n// Operator can toggle the claim mechanism as On / Off\n  function toggleClaim() external onlyOperator {\n    claimState = !claimState;\n  }\n// Operator can toggle the purchasing mechanism as On / Off for the Sale of Legionnaires\n  function togglePurchase() external onlyOperator {\n    purchaseState = !purchaseState;\n  }\n\n// Returns a Random Legionnaire from the set of Random Legionniares \n  function popRandomTokenURI() internal returns(string memory) {\n    // leftOverUris === unpurchased / unclaimed Legionnaires \n    uint256 randomIndex = getRandomIndex(leftoverUris.length);\n    string memory tokenURI = leftoverUris[randomIndex];\n    leftoverUris[randomIndex] = leftoverUris[leftoverUris.length - 1];\n    leftoverUris.pop();\n    return tokenURI;\n  }\n\n  // A secure function for Claiming Legionnaires on a specific window of time dependant on the presale token the user has. \n  function claim(uint256 claimedCount) external nonReentrant {\n    require(claimState, \"Claim is disabled\");\n    require(block.timestamp >= _activeDateTime, \"Presale not start yet\");\n    \n    uint8 genesisTokenCount = tokensCount[msg.sender]['genesis'];\n    uint8 platinumTokenCount = tokensCount[msg.sender]['platinum'];\n    uint8 goldTokenCount = tokensCount[msg.sender]['gold'];\n    uint8 silverTokenCount = tokensCount[msg.sender]['silver'];\n\n    uint256 passedDays = NumberHelper.daysSince(_activeDateTime, INTERVAL);\n\n    uint256 totalCount = genesisTokenCount;\n    if (passedDays >= 1) {\n        totalCount += platinumTokenCount;\n    }\n    if (passedDays >= 2) {\n        totalCount += goldTokenCount;\n    }\n    if (passedDays >= 3) {\n        totalCount += silverTokenCount;\n    }\n\n    uint256 minCount = NumberHelper.min(totalCount, claimedCount);\n    require(_claimSV + minCount <= 3301, \"No legionnaires left for presale\");\n\n    uint256 i = 0;\n    uint256 tokenId;\n    string memory tokenURI;\n\n    while(i < minCount) {\n      if(genesisTokenCount > 0) {\n        genesisTokenCount--;\n      } else if (passedDays >= 1 && platinumTokenCount > 0) {\n        platinumTokenCount--;\n      } else if (passedDays >= 2 && goldTokenCount > 0) {\n        goldTokenCount--;\n      } else if (passedDays >= 3 && silverTokenCount > 0) {\n        silverTokenCount--;\n      }\n\n      if(revealState) {\n        tokenURI = popRandomTokenURI();\n      }\n\n      tokenId = _claimSV;\n      _claimSV++;\n      \n      legionnaire.safeMint(msg.sender, tokenId);\n      if(!revealState) {\n        legionnaire.setTokenURI(tokenId, \"placeholder\");\n      } else {\n        legionnaire.setTokenURI(tokenId, tokenURI);\n      }\n      i++;\n    }\n\n    tokensCount[msg.sender]['genesis'] = genesisTokenCount;\n    tokensCount[msg.sender]['platinum'] = platinumTokenCount;\n    tokensCount[msg.sender]['gold'] = goldTokenCount;\n    tokensCount[msg.sender]['silver'] = silverTokenCount;\n  }\n\n  \n// A secure function to purchase a Legionnaire \n  function purchase(uint256 count) external payable nonReentrant {\n    require(purchaseState, \"Purchase is disabled\");\n    require(block.timestamp >= _activeDateTime, \"Sale not start yet\");\n    uint256 passedDays = NumberHelper.daysSince(_activeDateTime, INTERVAL);\n    require(passedDays > 3, \"Public sale not start yet\");\n    require(msg.value >= count * .1 ether, \"Not enough ether\");\n    \n    uint256 limit; \n    if(passedDays < 5) {\n      limit = purchasedSoFar[msg.sender];\n      require(count + limit > 0 && count + limit < 3, \"Not allowed to purchase that amount\");\n      purchasedSoFar[msg.sender] += uint8(count);\n     // on Day 5 you can only purchase up to 10 / transaction \n    } else if (passedDays < 6) {\n      require(count < 11, \"Up to 10 only\");\n    }\n\n    limit = count;\n    require(_purchaseSV + limit <= SV_MAX + 1, \"No legionnaires left for public sale\");\n\n    uint256 tokenId;\n    string memory tokenURI;\n\n\n    for (uint256 i = 0; i < limit; i++) {\n      if(revealState) {\n        tokenURI = popRandomTokenURI();\n      }\n\n      tokenId = _purchaseSV;\n      _purchaseSV++;\n    \n      legionnaire.safeMint(msg.sender, tokenId);\n      if(!revealState) {\n        legionnaire.setTokenURI(tokenId, \"placeholder\");\n      } else {\n        legionnaire.setTokenURI(tokenId, tokenURI);\n      }\n    }\n\n    (bool sent, ) = svEthAddr.call{ value: limit * .1 ether }(\"\");\n    require(sent, \"Failed to send Ether\");\n\n    if(msg.value > count * .1 ether) {\n      (sent, ) = payable(msg.sender).call{ value: msg.value - limit * .1 ether }(\"\");\n      require(sent, \"Failed to send change back to user\");\n    }\n  }\n\n// Operator can set the start time in UNIX stamp for the claim and sale period \n  function setActiveDateTime(uint256 activeDateTime) external onlyOperator {\n    _activeDateTime = activeDateTime;\n  }\n\n\n// Operator pushes the set of remaining unclaimed legionnaires going into self-reveal phase\n  function pushLeftOverUris(string[] memory leftoverUris_) external onlyOperator {\n    require(!revealState, \"Self-Reveal already begun\");\n\n    for(uint256 i = 0; i < leftoverUris_.length; i++) {\n      leftoverUris.push(leftoverUris_[i]);\n    }\n  }\n\n  // Returns the left over URIs array length\n  function getLeftOverUrisLength() public view returns(uint256) {\n    return leftoverUris.length;\n  }\n\n/*\n*\n* A function for the Operator to start the period of time for the user to reveal the URI upon mint\n*\n*/  \n  function beginSelfRevealPeriod() external onlyOperator {\n    revealState = true;\n  }\n   \n   // A Random Index between zero and range leveraging VRF \n  \n  function getRandomIndex(uint256 range) internal returns(uint256) {\n    randNonce++;\n    return uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, randNonce, randomNess))) % range;\n  }\n\n// Operator can batch mint and trasnfer remaining Legionnaires to a secure address\n\n  function safeBatchMintAndTransfer(address holder, bool isSetUri, uint16 batchSize) external onlyOperator {\n    require(revealState, \"Have to begin Self-Reveal\");\n    require(_purchaseSV + batchSize <= SV_MAX + 1, \"No legionnaires left for public sale\");\n\n    for(uint256 i = _purchaseSV; i < _purchaseSV + batchSize; i++) {\n      legionnaire.safeMint(holder, i);\n      if(isSetUri) {\n        legionnaire.setTokenURI(i, \"placeholder\");\n      }\n    }\n\n    _purchaseSV = uint16(_purchaseSV + batchSize);\n  }\n\n // URISetter will call this to randomly pair URIs with NFT Metadata to tokens.\n  function pairLegionnairesWithUris(uint16[] memory _tokenIds, string[] memory _tokenURIs) external onlyURISetter {\n    require(_tokenIds.length == _tokenURIs.length, \"Mismatched ids and URIs\");\n    require(_tokenIds.length > 0, \"Empty parameters\");\n\n    while(_tokenIds.length > 0) {\n      uint256 length = _tokenIds.length;\n      uint256 randomIndex = getRandomIndex(length);\n      legionnaire.setTokenURI(_tokenIds[length - 1], _tokenURIs[randomIndex]);\n      _tokenURIs[randomIndex] = _tokenURIs[length - 1];\n      delete _tokenIds[length - 1];\n      delete _tokenURIs[length - 1];\n\n      assembly { mstore(_tokenIds, sub(mload(_tokenIds), 1)) }\n      assembly { mstore(_tokenURIs, sub(mload(_tokenURIs), 1)) }\n    }\n  }\n\n // Function saves the random nonce from VRF into the contract \n  function fulfillRandomness(bytes32 _requestId, uint256 _randomness) internal override {\n    if(requestId == _requestId) {\n      randomNess = _randomness;\n    }\n  }\n\n // Owner can decrease the total supply not ever exceeding 10,000 Legionnaires\n  function setMaxLimit(uint256 maxLimit) external onlyOwner {\n    require(maxLimit < 10001, \"Exceed max limit 10000\");\n    SV_MAX = maxLimit;\n  }\n\n // Operator Calls to VRF for a random nonce\n  function requestRandomToVRF() external onlyOperator {\n    require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK\");\n    requestId = requestRandomness(keyHash, fee);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(\n    bytes32 requestId,\n    uint256 randomness\n  )\n    internal\n    virtual;\n\n  /**\n   * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n  uint256 constant private USER_SEED_PLACEHOLDER = 0;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(\n    bytes32 _keyHash,\n    uint256 _fee\n  )\n    internal\n    returns (\n      bytes32 requestId\n    )\n  {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash] + 1;\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface immutable internal LINK;\n  address immutable private vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  constructor(\n    address _vrfCoordinator,\n    address _link\n  ) {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(\n    bytes32 requestId,\n    uint256 randomness\n  )\n    external\n  {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/ILegionnaire.sol": {
      "content": "//SPDX-License-Identifier: GNU General Public License v3.0\npragma solidity ^0.8.0;\n\n// Interface for Legionnaire token\ninterface ILegionnaire {\n  \n  function safeMint(address to, uint256 tokenId) external;\n\n  function setTokenURI(uint256 tokenId, string memory _tokenURI) external;\n}\n"
    },
    "contracts/utils/Operatorable.sol": {
      "content": "//SPDX-License-Identifier: GNU General Public License v3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract Operatorable is Ownable, AccessControl {\n  bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n  bytes32 public constant URI_SETTER_ROLE = keccak256(\"URI_SETTER_ROLE\");\n\n  /**\n    * @dev Restricted to members of the `operator` role.\n    */\n  modifier onlyOperator() {\n    require(hasRole(OPERATOR_ROLE, msg.sender), \"Operatorable: CALLER_NO_OPERATOR_ROLE\");\n    _;\n  }\n\n  modifier onlyURISetter() {\n    require(hasRole(URI_SETTER_ROLE, msg.sender), \"Settable: CALLER_NO_URI_SETTER_ROLE\");\n    _;\n  }\n\n  constructor() {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(OPERATOR_ROLE, msg.sender);\n    _setupRole(URI_SETTER_ROLE, msg.sender);\n  }\n\n  /**\n    * @dev Add an `_account` to the `operator` role.\n    */\n  function addOperator(address _account) public onlyOwner {\n    grantRole(OPERATOR_ROLE, _account);\n  }\n\n  /**\n    * @dev Remove an `_account` from the `operator` role.\n    */\n  function removeOperator(address _account) public onlyOwner {\n    revokeRole(OPERATOR_ROLE, _account);\n  }\n\n  function addURISetter(address _account) public onlyOwner {\n    grantRole(URI_SETTER_ROLE, _account);\n  }\n\n  function removeURISetter(address _account) public onlyOwner {\n    revokeRole(URI_SETTER_ROLE, _account);\n  }\n\n  /**\n    * @dev Check if an _account is operator.\n    */\n  function isOperator(address _account) public view returns (bool) {\n    return hasRole(OPERATOR_ROLE, _account);\n  }\n\n  /**\n    * @dev Check if an _account is operator.\n    */\n  function isURISetter(address _account) public view returns (bool) {\n    return hasRole(URI_SETTER_ROLE, _account);\n  }\n}\n"
    },
    "contracts/helpers/NumberHelper.sol": {
      "content": "//SPDX-License-Identifier: GNU General Public License v3.0\npragma solidity ^0.8.0;\n\nlibrary NumberHelper {\n  function min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function daysSince(uint256 _activeDateTime, uint256 _interval) internal view returns (uint256) {\n    unchecked {\n      uint256 passedTime = (block.timestamp - _activeDateTime) / _interval;\n      if( passedTime < 24) {\n        return 1;\n      } else if( passedTime < 48 ) {\n        return 2;\n      } else if( passedTime < 72 ) {\n        return 3;\n      } else if( passedTime < 96 ) {\n        return 4;\n      } else if( passedTime < 120 ) {\n        return 5;\n      } else if( passedTime < 144 ) {\n        return 6;\n      } else if( passedTime < 168 ) {\n        return 7;\n      } else {\n        return 8;\n      }\n    }\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n\n  function allowance(\n    address owner,\n    address spender\n  )\n    external\n    view\n    returns (\n      uint256 remaining\n    );\n\n  function approve(\n    address spender,\n    uint256 value\n  )\n    external\n    returns (\n      bool success\n    );\n\n  function balanceOf(\n    address owner\n  )\n    external\n    view\n    returns (\n      uint256 balance\n    );\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8 decimalPlaces\n    );\n\n  function decreaseApproval(\n    address spender,\n    uint256 addedValue\n  )\n    external\n    returns (\n      bool success\n    );\n\n  function increaseApproval(\n    address spender,\n    uint256 subtractedValue\n  ) external;\n\n  function name()\n    external\n    view\n    returns (\n      string memory tokenName\n    );\n\n  function symbol()\n    external\n    view\n    returns (\n      string memory tokenSymbol\n    );\n\n  function totalSupply()\n    external\n    view\n    returns (\n      uint256 totalTokensIssued\n    );\n\n  function transfer(\n    address to,\n    uint256 value\n  )\n    external\n    returns (\n      bool success\n    );\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  )\n    external\n    returns (\n      bool success\n    );\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    external\n    returns (\n      bool success\n    );\n\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  )\n    internal\n    pure\n    returns (\n      uint256\n    )\n  {\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(\n    bytes32 _keyHash,\n    uint256 _vRFInputSeed\n  )\n    internal\n    pure\n    returns (\n      bytes32\n    )\n  {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}