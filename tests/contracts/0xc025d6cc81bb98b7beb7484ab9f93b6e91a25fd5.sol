{"CashBack.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./Modifiers.sol\";\n\ncontract CashBack is Modifiers {\n    using SafeMath for uint;\n\n    function cashBackAmount(address _painter) public view returns (uint cashBackInWei) {\n        // last cashBack Calculation Round for Painter\n        uint round = cashBackCalculationRound[_painter];\n\n        uint calcCashBack = cashBackCalculated[_painter];\n        uint curCashBackPerPaint = maxCashBackPerPaintForRound[round].sub(cashBackPerPaintForRound[round][_painter]);\n        uint curCashBack = curCashBackPerPaint.mul(userPaintsForRound[round][_painter]);\n\n        cashBackInWei = calcCashBack.add(curCashBack);\n    }\n\n    function withdrawCashBack() external isLiveGame() {\n        address withdrawer = msg.sender;\n        uint curCashBack = cashBackAmount(withdrawer);\n        require(curCashBack \u003e 0, \"Cashback can not be 0\");\n\n        // last cashBack Calculation Round for Withdrawer\n        uint round = cashBackCalculationRound[withdrawer];\n\n        // update states\n        cashBackCalculated[withdrawer] = 0;\n        cashBackPerPaintForRound[round][withdrawer] = maxCashBackPerPaintForRound[round];\n\n        // transfer cashback\n        withdrawer.transfer(curCashBack);\n        emit CashBackWithdrawn(currentRound, withdrawer, curCashBack);\n    }\n\n    function _distributeCashBack(uint _value) internal {\n        uint curRound = currentRound;  // gas consumption optimization\n        address painter = msg.sender;\n\n        uint totalPaints = totalPaintsForRound[curRound];\n        uint curCashBackPerPaint = _value.div(totalPaints);\n        uint updCashBackPerPaint = maxCashBackPerPaintForRound[curRound].add(curCashBackPerPaint);\n\n        // update maxCashBackPerPaintForRound state\n        maxCashBackPerPaintForRound[curRound] = updCashBackPerPaint;\n\n        // update already earned cashback in this or prev rounds\n        cashBackCalculated[painter] = cashBackAmount(painter);\n\n        // update cashBackCalculationRound state\n        if (cashBackCalculationRound[painter] \u003c curRound) {\n            cashBackCalculationRound[painter] = curRound;\n            // add current round cashback\n            cashBackCalculated[painter] = cashBackAmount(painter);\n        }\n\n        // update cashBackPerPaintForRound state\n        cashBackPerPaintForRound[curRound][painter] = updCashBackPerPaint;\n\n        // update totalCashBackForRound state\n        totalCashBackForRound[curRound] = totalCashBackForRound[curRound].add(_value);\n    }\n}"},"DividendsDistributor.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Modifiers.sol\";\n\ncontract DividendsDistributor is Modifiers {\n\n    function withdrawFoundersComission() external onlyAdmin() returns (bool) {\n        _withdrawDividensHelper(founders);\n        return true;\n    }\n\n    function withdrawDividends() external returns (bool) {\n        _withdrawDividensHelper(msg.sender);\n        return true;\n    }\n\n    function _withdrawDividensHelper(address _beneficiary) private {\n        uint balance = pendingWithdrawals[_beneficiary];\n        require(balance \u003e 0, \"Dividends withdrawal balance is zero.\");\n\n        // set state\n        pendingWithdrawals[_beneficiary] = 0;\n\n        // withdrawal dividends\n        _beneficiary.transfer(balance);\n        emit DividendsWithdrawn(_beneficiary, balance);\n    }\n}"},"ERC1538Delegate.sol":{"content":"pragma solidity 0.4.24;\nimport \"./IERC1538.sol\";\nimport \"./ERC1538QueryDelegates.sol\";\n\n/******************************************************************************\\\n* Implementation of ERC1538.\n* Function signatures are stored in an array so functions can be queried.\n/******************************************************************************/\n\ncontract ERC1538Delegate is IERC1538, ERC1538QueryDelegates {\n\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external onlyOwner {\n        // pos is first used to check the size of the delegate contract.\n        // After that pos is the current memory location of _functionSignatures.\n        // It is used to move through the characters of _functionSignatures\n        uint256 pos;\n        if(_delegate != address(0)) {\n            assembly {\n                pos := extcodesize(_delegate)\n            }\n            require(pos \u003e 0, \"_delegate address is not a contract and is not address(0)\");\n        }\n        // creates a bytes vesion of _functionSignatures\n        bytes memory signatures = bytes(_functionSignatures);\n        // stores the position in memory where _functionSignatures ends.\n        uint256 signaturesEnd;\n        // stores the starting position of a function signature in _functionSignatures\n        uint256 start;\n        assembly {\n            pos := add(signatures,32)\n            start := pos\n            signaturesEnd := add(pos,mload(signatures))\n        }\n        // the function id of the current function signature\n        bytes4 funcId;\n        // the delegate address that is being replaced or address(0) if removing functions\n        address oldDelegate;\n        // the length of the current function signature in _functionSignatures\n        uint256 num;\n        // the current character in _functionSignatures\n        uint256 char;\n        // the position of the current function signature in the funcSignatures array\n        uint256 index;\n        // the last position in the funcSignatures array\n        uint256 lastIndex;\n        // parse the _functionSignatures string and handle each function\n        for (; pos \u003c signaturesEnd; pos++) {\n            assembly {char := byte(0,mload(pos))}\n            // 0x29 == )\n            if (char == 0x29) {\n                pos++;\n                num = (pos - start);\n                start = pos;\n                assembly {\n                    mstore(signatures,num)\n                }\n                funcId = bytes4(keccak256(signatures));\n                oldDelegate = delegates[funcId];\n                if(_delegate == address(0)) {\n                    index = funcSignatureToIndex[signatures];\n                    require(index != 0, \"Function does not exist.\");\n                    index--;\n                    lastIndex = funcSignatures.length - 1;\n                    if (index != lastIndex) {\n                        funcSignatures[index] = funcSignatures[lastIndex];\n                        funcSignatureToIndex[funcSignatures[lastIndex]] = index + 1;\n                    }\n                    funcSignatures.length--;\n                    delete funcSignatureToIndex[signatures];\n                    delete delegates[funcId];\n                    emit FunctionUpdate(funcId, oldDelegate, address(0), string(signatures));\n                }\n                else if (funcSignatureToIndex[signatures] == 0) {\n                    require(oldDelegate == address(0), \"Funcion id clash.\");\n                    delegates[funcId] = _delegate;\n                    funcSignatures.push(signatures);\n                    funcSignatureToIndex[signatures] = funcSignatures.length;\n                    emit FunctionUpdate(funcId, address(0), _delegate, string(signatures));\n                }\n                else if (delegates[funcId] != _delegate) {\n                    delegates[funcId] = _delegate;\n                    emit FunctionUpdate(funcId, oldDelegate, _delegate, string(signatures));\n\n                }\n                assembly {signatures := add(signatures,num)}\n            }\n        }\n        emit CommitMessage(commitMessage);\n    }\n}"},"ERC1538QueryDelegates.sol":{"content":"pragma solidity 0.4.24;\n/******************************************************************************\\\n* \n* Contains functions for retrieving function signatures and delegate contract\n* addresses.\n/******************************************************************************/\n\nimport \"./StorageV0.sol\";\nimport \"./IERC1538Query.sol\";\n\ncontract ERC1538QueryDelegates is IERC1538Query, StorageV0 {\n\n    function totalFunctions() external view returns(uint256) {\n        return funcSignatures.length;\n    }\n\n    function functionByIndex(uint256 _index) external view returns(string memory functionSignature, bytes4 functionId, address delegate) {\n        require(_index \u003c funcSignatures.length, \"functionSignatures index does not exist.\");\n        bytes memory signature = funcSignatures[_index];\n        functionId = bytes4(keccak256(signature));\n        delegate = delegates[functionId];\n        return (string(signature), functionId, delegate);\n    }\n\n    function functionExists(string _functionSignature) external view returns(bool) {\n        return funcSignatureToIndex[bytes(_functionSignature)] != 0;\n    }\n\n    function functionSignatures() external view returns(string) {\n        uint256 signaturesLength;\n        bytes memory signatures;\n        bytes memory signature;\n        uint256 functionIndex;\n        uint256 charPos;\n        uint256 funcSignaturesNum = funcSignatures.length;\n        bytes[] memory memoryFuncSignatures = new bytes[](funcSignaturesNum);\n        for(; functionIndex \u003c funcSignaturesNum; functionIndex++) {\n            signature = funcSignatures[functionIndex];\n            signaturesLength += signature.length;\n            memoryFuncSignatures[functionIndex] = signature;\n        }\n        signatures = new bytes(signaturesLength);\n        functionIndex = 0;\n        for(; functionIndex \u003c funcSignaturesNum; functionIndex++) {\n            signature = memoryFuncSignatures[functionIndex];\n            for(uint256 i = 0; i \u003c signature.length; i++) {\n                signatures[charPos] = signature[i];\n                charPos++;\n            }\n        }\n        return string(signatures);\n    }\n\n    function delegateFunctionSignatures(address _delegate) external view returns(string) {\n        uint256 funcSignaturesNum = funcSignatures.length;\n        bytes[] memory delegateSignatures = new bytes[](funcSignaturesNum);\n        uint256 delegateSignaturesPos;\n        uint256 signaturesLength;\n        bytes memory signatures;\n        bytes memory signature;\n        uint256 functionIndex;\n        uint256 charPos;\n        for(; functionIndex \u003c funcSignaturesNum; functionIndex++) {\n            signature = funcSignatures[functionIndex];\n            if(_delegate == delegates[bytes4(keccak256(signature))]) {\n                signaturesLength += signature.length;\n                delegateSignatures[delegateSignaturesPos] = signature;\n                delegateSignaturesPos++;\n            }\n\n        }\n        signatures = new bytes(signaturesLength);\n        functionIndex = 0;\n        for(; functionIndex \u003c delegateSignatures.length; functionIndex++) {\n            signature = delegateSignatures[functionIndex];\n            if(signature.length == 0) {\n                break;\n            }\n            for(uint256 i = 0; i \u003c signature.length; i++) {\n                signatures[charPos] = signature[i];\n                charPos++;\n            }\n        }\n        return string(signatures);\n    }\n\n    function delegateAddress(string _functionSignature) external view returns(address) {\n        require(funcSignatureToIndex[bytes(_functionSignature)] != 0, \"Function signature not found.\");\n        return delegates[bytes4(keccak256(bytes(_functionSignature)))];\n    }\n\n    function functionById(bytes4 _functionId) external view returns(string signature, address delegate) {\n        for(uint256 i = 0; i \u003c funcSignatures.length; i++) {\n            if(_functionId == bytes4(keccak256(funcSignatures[i]))) {\n                return (string(funcSignatures[i]), delegates[_functionId]);\n            }\n        }\n        revert(\"functionId not found\");\n    }\n\n    function delegateAddresses() external view returns(address[]) {\n        uint256 funcSignaturesNum = funcSignatures.length;\n        address[] memory delegatesBucket = new address[](funcSignaturesNum);\n        uint256 numDelegates;\n        uint256 functionIndex;\n        bool foundDelegate;\n        address delegate;\n        for(; functionIndex \u003c funcSignaturesNum; functionIndex++) {\n            delegate = delegates[bytes4(keccak256(funcSignatures[functionIndex]))];\n            for(uint256 i = 0; i \u003c numDelegates; i++) {\n                if(delegate == delegatesBucket[i]) {\n                    foundDelegate = true;\n                    break;\n                }\n            }\n            if(foundDelegate == false) {\n                delegatesBucket[numDelegates] = delegate;\n                numDelegates++;\n            }\n            else {\n                foundDelegate = false;\n            }\n        }\n        address[] memory delegates_ = new address[](numDelegates);\n        functionIndex = 0;\n        for(; functionIndex \u003c numDelegates; functionIndex++) {\n            delegates_[functionIndex] = delegatesBucket[functionIndex];\n        }\n        return delegates_;\n    }\n}"},"Game.sol":{"content":"pragma solidity 0.4.24;\nimport \"./PaintsPool.sol\";\nimport \"./PaintDiscount.sol\";\nimport \"./CashBack.sol\";\nimport \"./Utils.sol\";\n\ncontract Game is PaintDiscount, PaintsPool, CashBack {\n    using SafeMath for uint;\n\n    // set new value of priceLimitPaints\n    function setPriceLimitPaints(uint _paintsNumber) external onlyAdmin() {\n        priceLimitPaints = _paintsNumber;\n    }\n\n    // function estimating call price for given color\n    function estimateCallPrice(uint[] _pixels, uint _color) public view returns (uint totalCallPrice) {\n        uint moneySpent = moneySpentByUser[msg.sender];\n        bool hasDiscount = hasPaintDiscount[msg.sender];\n        uint discount = usersPaintDiscount[msg.sender];\n\n        // next paint number\n        uint curPaintNum = totalPaintsForRound[currentRound] + 1;\n\n        // external call – add extra paints\n        if (!isPaintCall) {\n            curPaintNum += priceLimitPaints;\n        }\n\n        uint curPrice = _getPaintPrice(curPaintNum);  // price for next painting without discount\n        uint price = curPrice;  // price for next painting\n\n        for (uint i = 0; i \u003c _pixels.length; i++) {\n            if (hasDiscount) {\n                price = curPrice.mul(100 - discount).div(100); // discount call price\n            }\n\n            totalCallPrice += price;\n            moneySpent += price;\n\n            if (moneySpent \u003e= 1 ether) {\n                hasDiscount = true;\n                discount = moneySpent / 1 ether;\n\n                if (moneySpent \u003e= 10 ether) {\n                    discount = 10;\n                }\n            }\n        }\n\n    }\n\n    function drawTimeBank() public {\n        uint curRound = currentRound;\n        uint lastPaintTime = lastPaintTimeForRound[curRound];\n        require ((now - lastPaintTime) \u003e 20 minutes \u0026\u0026 lastPaintTime \u003e 0, \"20 minutes have not passed yet.\");\n\n        address winner = lastPainterForRound[curRound];\n        uint curTbIter = tbIteration;\n        uint prize = timeBankForRound[curRound].mul(90).div(100);  // 90% of time bank goes to winner;\n\n        winnerOfRound[curRound] = winner;  // set winner of round\n        winnerBankForRound[curRound] = 1;  // timebank(1) was drawn for this round\n        timeBankForRound[curRound + 1] = timeBankForRound[curRound].div(10);  // 10% of time bank goes to next round\n        timeBankForRound[curRound] = prize;\n\n        colorBankForRound[curRound + 1] = colorBankForRound[curRound];  // color bank goes to next round\n        colorBankForRound[curRound] = 0;\n\n        // change global state - new game\n        currentRound = curRound.add(1);\n        tbIteration = curTbIter.add(1);\n        _resetPaintsPool();\n\n        // transfer time bank to winner\n        winner.transfer(prize);\n        emit TimeBankWithdrawn(curRound, curTbIter, winner, prize);\n    }\n\n    function paint(uint[] _pixels, uint _color, string _refLink) external payable isRegistered(_refLink) isLiveGame() {\n        require (_pixels.length \u003e= 1 \u0026\u0026 _pixels.length \u003c= 15, \"The number of pixels should be from 1 to 15 pixels\");\n        require(_color \u003e 0 \u0026\u0026 _color \u003c= totalColorsNumber, \"The color with such id does not exist.\");\n\n        // drawTimeBank call and exit if 20 minutes passed since last paint\n        if ((now - lastPaintTimeForRound[currentRound]) \u003e 20 minutes \u0026\u0026\n            lastPaintTimeForRound[currentRound] \u003e 0) {\n\n            drawTimeBank();\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        // call estimateCallPrice from paint function\n        isPaintCall = true;\n        uint callPrice = estimateCallPrice(_pixels, _color);\n        isPaintCall = false;\n\n        require(msg.value \u003e= callPrice, \"Wrong call price – insufficient funds\");\n\n        // Add remaining money\n        if (msg.value - callPrice \u003e 0) {\n            uint remainingMoney = msg.value - callPrice;\n            // Update cashback amount for msg.sender\n            cashBackCalculated[msg.sender] = cashBackCalculated[msg.sender].add(remainingMoney);\n        }\n\n        // distribute money to banks, cashBack and dividends\n        if (totalPaintsForRound[currentRound] == 0) {\n            // need for first cashback distribution to first painter\n            totalPaintsForRound[currentRound] = _pixels.length;\n            userPaintsForRound[currentRound][msg.sender] = _pixels.length;\n            _setBanks(_color, _refLink, callPrice);\n        } else {\n            // for other cases – distribute cashback to prev painters\n            _setBanks(_color, _refLink, callPrice);\n            totalPaintsForRound[currentRound] = totalPaintsForRound[currentRound].add(_pixels.length);\n            userPaintsForRound[currentRound][msg.sender] = userPaintsForRound[currentRound][msg.sender].add(_pixels.length);\n        }\n\n        colorToTotalPaintsForCBIteration[cbIteration][_color] = colorToTotalPaintsForCBIteration[cbIteration][_color].add(_pixels.length);\n\n        //paint pixels\n        for (uint i = 0; i \u003c _pixels.length; i++) {\n            _paint(_pixels[i], _color);\n        }\n\n        // save user spended money for this color\n        _setMoneySpentByUserForColor(_color);\n\n        _setUsersPaintDiscountForColor(_color);\n\n        if (paintsCounterForColor[_color] == 0) {\n            paintGenToEndTimeForColor[_color][currentPaintGenForColor[_color] - 1] = now;\n        }\n\n        paintsCounter++; //counter for all users paints\n        paintsCounterForColor[_color]++; //counter for given color\n        counterToPainter[paintsCounter] = msg.sender; //counter for given user\n        counterToPainterForColor[_color][paintsCounterForColor[_color]] = msg.sender;\n\n        if (isUserCountedForRound[currentRound][msg.sender] == false) {\n            usersCounterForRound[currentRound] = usersCounterForRound[currentRound].add(1);\n            isUserCountedForRound[currentRound][msg.sender] = true;\n        }\n\n        // check the winning in color bank\n        if (winnerBankForRound[currentRound] == 2) {\n            _drawColorBank();\n        }\n    }\n\n    function _paint(uint _pixel, uint _color) internal {\n        //set paints amount in a pool and price for paint\n        _fillPaintsPool(_color);\n\n        require(msg.sender == tx.origin, \"Can not be a contract\");\n        require(_pixel \u003e 0 \u0026\u0026 _pixel \u003c= totalPixelsNumber, \"The pixel with such id does not exist.\");\n\n        uint oldColor = pixelToColorForRound[currentRound][_pixel];\n\n        pixelToColorForRound[currentRound][_pixel] = _color; // save old color for pixel\n        pixelToOldColorForRound[currentRound][_pixel] = oldColor; // set new color for pixel\n\n        lastPaintTimeForRound[currentRound] = now;\n        lastPainterForRound[currentRound] = msg.sender;\n\n        // decrease number of old color pixels\n        if (colorToPaintedPixelsAmountForRound[currentRound][oldColor] \u003e 0) {\n            colorToPaintedPixelsAmountForRound[currentRound][oldColor] = colorToPaintedPixelsAmountForRound[currentRound][oldColor].sub(1);\n        }\n\n        // increase number of new color pixels\n        colorToPaintedPixelsAmountForRound[currentRound][_color] = colorToPaintedPixelsAmountForRound[currentRound][_color].add(1);\n\n        pixelToPaintTimeForRound[currentRound][_pixel] = now;\n\n        lastPaintTimeOfUser[msg.sender] = now;\n        lastPaintTimeOfUserForColor[_color][msg.sender] = now;\n\n        // decrease paints pool by 1\n        paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] = paintGenToAmountForColor[_color][currentPaintGenForColor[_color]].sub(1);\n\n        lastPaintedPixelForRound[currentRound] = _pixel;\n        lastPlayedRound[msg.sender] = currentRound;\n\n        emit Paint(_pixel, _color, msg.sender, currentRound, now);\n\n        // check wherether all pixels are the same color\n        if (colorToPaintedPixelsAmountForRound[currentRound][_color] == totalPixelsNumber) {\n            winnerColorForRound[currentRound] = _color;\n            winnerOfRound[currentRound] = lastPainterForRound[currentRound];\n\n            // color bank is 2\n            winnerBankForRound[currentRound] = 2;\n\n            // 10% of colorbank goes to next round\n            colorBankForRound[currentRound + 1] = colorBankForRound[currentRound].div(10);\n\n            // 90% of colorbank for winner\n            colorBankForRound[currentRound] = colorBankForRound[currentRound].mul(90).div(100);\n\n            //timebank goes to next round\n            timeBankForRound[currentRound + 1] = timeBankForRound[currentRound];\n            timeBankForRound[currentRound] = 0;\n        }\n    }\n\n    function _setBanks(uint _color, string _refLink, uint _callPrice) private {\n        bytes32 refLink32 = Utils.toBytes16(_refLink);\n\n        uint valueToTimeBank = _callPrice.mul(40).div(100);  // 40% to TimeBank\n        uint valueToColorBank = _callPrice.div(10);  // 10% to ColorBank\n        uint valueToLuckyPot = _callPrice.div(20);  // 5% to LuckyPot\n        uint valueGameFee = _callPrice.div(20);  // 5% Game Fee to Founders\n        uint valueRef = _callPrice.div(20);  // 5% to Referrer\n        uint valueCashBack = _callPrice.mul(35).div(100);  // 35% CashBack (+ valueRef without Referrer)\n\n        // reflink provided\n        if (refLinkExists[refLink32]) {\n            pendingWithdrawals[refLinkToUser[refLink32]] = pendingWithdrawals[refLinkToUser[refLink32]].add(valueRef);\n            _distributeCashBack(valueCashBack);  // CashBack with Refferer\n        } else {\n            _distributeCashBack(valueCashBack + valueRef);  // CashBack without Refferer\n        }\n\n        // set bank states\n        timeBankForRound[currentRound] = timeBankForRound[currentRound].add(valueToTimeBank);\n        colorBankForRound[currentRound] = colorBankForRound[currentRound].add(valueToColorBank);\n        colorBankToColorForRound[currentRound][_color] = colorBankToColorForRound[currentRound][_color].add(valueToColorBank);\n        luckyPotBank = luckyPotBank.add(valueToLuckyPot);\n        pendingWithdrawals[founders] = pendingWithdrawals[founders].add(valueGameFee);\n    }\n\n    function _drawColorBank() private {\n        uint curRound = currentRound;\n        uint curCbIter = cbIteration;\n        address winner = winnerOfRound[curRound];\n        uint prize = colorBankForRound[curRound];\n\n        // change global state - new game\n        currentRound = curRound.add(1);\n        cbIteration = curCbIter.add(1);\n        _resetPaintsPool();\n\n        // transfer color bank to winner\n        winner.transfer(prize);\n        emit ColorBankWithdrawn(curRound, curCbIter, winner, prize);\n    }\n\n    function _resetPaintsPool() private {\n        uint firstPaintGenForColor = 1;\n\n        for (uint i = 1; i \u003c= totalColorsNumber; i++){\n            callPriceForColor[i] = 0.005 ether;\n            nextCallPriceForColor[i] = callPriceForColor[i];\n            currentPaintGenForColor[i] = firstPaintGenForColor;\n\n            paintGenToAmountForColor[i][firstPaintGenForColor] = maxPaintsInPool;\n            paintGenStartedForColor[i][firstPaintGenForColor] = true;\n            paintGenToStartTimeForColor[i][firstPaintGenForColor] = now;\n        }\n    }\n\n    modifier isRegistered(string _refLink) {\n\n        if (isRegisteredUser[msg.sender] != true) {\n            bytes32 refLink32 = Utils.toBytes16(_refLink);\n\n            if (refLinkExists[refLink32]) {\n                address referrer = refLinkToUser[refLink32];\n                referrerToReferrals[referrer].push(msg.sender);\n                referralToReferrer[msg.sender] = referrer;\n                hasReferrer[msg.sender] = true;\n            }\n            uniqueUsersCount = uniqueUsersCount.add(1);\n            newUserToCounter[msg.sender] = uniqueUsersCount;\n            registrationTimeForUser[msg.sender] = now;\n            isRegisteredUser[msg.sender] = true;\n        }\n        _;\n    }\n\n    function _getPaintPrice(uint _number) private pure returns (uint) {\n        uint paintPrice = uint((int(_sqrt(_number * 22222222 + 308641358025)) - 7777777)*1e18 / 12345678 + 0.589996*1e18);\n        uint temp = 1e13;  // for round - 10^-5\n        return ((paintPrice + temp - 1) / temp) * temp;\n    }\n\n    // gives square root of given x.\n    function _sqrt(uint x) private pure returns (uint y) {\n        uint z = (x + 1) / 2;\n        y = x;\n        while (z \u003c y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}"},"GameStateController.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Roles.sol\";\nimport \"./Modifiers.sol\";\n\ncontract GameStateController is Modifiers {\n\n    function pauseGame() external onlyAdmin() {\n        require (isGamePaused == false, \"Game is already paused\");\n        isGamePaused = true;\n    }\n\n    function resumeGame() external onlyAdmin() {\n        require (isGamePaused == true, \"Game is already live\");\n        isGamePaused = false;\n    }\n\n    function withdrawEther() external onlyAdmin() returns (bool) {\n        require (isGamePaused == true, \"Can withdraw when game is live\");\n        uint balance = address(this).balance;\n        uint colorBank = colorBankForRound[currentRound];\n        uint timeBank = timeBankForRound[currentRound];\n        owner().transfer(balance);\n        colorBankForRound[currentRound]= 0;\n        timeBankForRound[currentRound]= 0;\n        emit EtherWithdrawn(balance, colorBank, timeBank, now);\n        return true;\n    }\n    \n}\n"},"Helpers.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Modifiers.sol\";\n\ncontract Helpers is Modifiers {\n\n    function getUsername(address _painter) external view returns(string username) {\n        username = addressToUsername[_painter];\n    }\n\n    function isUsernameExists(string _username) external view returns(bool) {\n        return usernameExists[_username];\n    }\n\n    // username lenght 1-16 symbols\n    function createUsername(string _username) external isValidUsername(_username) {\n        require(!usernameExists[_username], \"This username already exists, try different one.\");\n        require(bytes(addressToUsername[msg.sender]).length == 0, \"You have already created your username.\");\n\n        addressToUsername[msg.sender] = _username;\n        usernameExists[_username] = true;\n\n        emit UsernameCreated(msg.sender, _username);\n    }\n\n    function getPixelColor(uint _pixel) external view returns (uint) {\n        return pixelToColorForRound[currentRound][_pixel];\n    }\n\n    //function adding new color to the game after minting\n    function addNewColor() external onlyAdmin() {\n        totalColorsNumber++; \n        currentPaintGenForColor[totalColorsNumber] = 1;\n        callPriceForColor[totalColorsNumber] = 0.01 ether;\n        nextCallPriceForColor[totalColorsNumber] = callPriceForColor[totalColorsNumber];\n        paintGenToAmountForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber]] = maxPaintsInPool;\n        paintGenStartedForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber]] = true;\n        paintGenToEndTimeForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber] - 1] = now;\n        paintGenToStartTimeForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber]] = now;\n    }\n\n}"},"IColor.sol":{"content":"pragma solidity 0.4.24;\n\ninterface Color {\n    function totalSupply() external view returns (uint);\n    function ownerOf(uint _tokenId) external view returns (address);\n}\n\n"},"IERC1538.sol":{"content":"pragma solidity 0.4.24;\n\ninterface IERC1538 {\n    event CommitMessage(string message);\n    event FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external;\n}"},"IERC1538Query.sol":{"content":"pragma solidity 0.4.24;\n\ninterface IERC1538Query {\n    function totalFunctions() external view returns(uint256);\n    function functionByIndex(uint256 _index) external view returns(string memory functionSignature, bytes4 functionId, address delegate);\n    function functionExists(string _functionSignature) external view returns(bool);\n    function functionSignatures() external view returns(string);\n    function delegateFunctionSignatures(address _delegate) external view returns(string);\n    function delegateAddress(string _functionSignature) external view returns(address);\n    function functionById(bytes4 _functionId) external view returns(string signature, address delegate);\n    function delegateAddresses() external view returns(address[]);\n}"},"Initializer.sol":{"content":"pragma solidity 0.4.24;\nimport \"./StorageV1.sol\";\n\ncontract Initializer is StorageV1 {\n\n    //constructor\n    function _initializer() internal {\n        totalColorsNumber = 8;\n        totalPixelsNumber = 49;\n\n        isAdmin[msg.sender] = true;\n        maxPaintsInPool = totalPixelsNumber;\n        currentRound = 1;\n        cbIteration = 1;\n        tbIteration = 1;\n\n        priceLimitPaints = 100;\n\n        for (uint i = 1; i \u003c= totalColorsNumber; i++) {\n            currentPaintGenForColor[i] = 1;\n            callPriceForColor[i] = 0.005 ether;\n            nextCallPriceForColor[i] = callPriceForColor[i];\n            paintGenToAmountForColor[i][currentPaintGenForColor[i]] = maxPaintsInPool;\n            paintGenStartedForColor[i][currentPaintGenForColor[i]] = true;\n            \n            paintGenToStartTimeForColor[i][currentPaintGenForColor[i]] = now;\n        }\n        \n    }\n}\n"},"IPixel.sol":{"content":"pragma solidity 0.4.24;\n\ninterface Pixel {\n    function totalSupply() external view returns (uint);\n    function ownerOf(uint _tokenId) external view returns (address);\n}\n\n"},"LuckyPot.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./Modifiers.sol\";\n\ncontract LuckyPot is Modifiers {\n    using SafeMath for uint;\n\n    function increaseLuckyPot() external payable {\n        require(msg.value != 0, \"msg.value is 0\");\n        luckyPotBank = luckyPotBank.add(msg.value);\n    }\n\n    function drawLuckyPot(address _user, uint _bankPercent, uint _pixelId) external onlyAdmin() {\n        require(luckyPotBank \u003e 0, \"luckyPotBank is empty\");\n        require(_bankPercent \u003e 0 \u0026\u0026 _bankPercent \u003c= 100, \"Invalid percent\");\n        require(_pixelId \u003e 0 \u0026\u0026 _pixelId \u003c= totalPixelsNumber, \"The pixel with such id does not exist.\");\n\n        uint luckyPotBankAmountForWinner = luckyPotBank.mul(_bankPercent).div(100);\n\n        // change luckyPotBank state\n        luckyPotBank = luckyPotBank.sub(luckyPotBankAmountForWinner);\n        luckyPotBankWinner[_user] = true;\n\n        // transfer luckypot\n        _user.transfer(luckyPotBankAmountForWinner);\n        emit LuckyPotDrawn(_pixelId, _user, luckyPotBankAmountForWinner);\n    }\n}"},"Migrations.sol":{"content":"pragma solidity ^0.4.23;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"},"Modifiers.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./StorageV1.sol\";\n\ncontract Modifiers is StorageV1 {\n    using SafeMath for uint;\n\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender] == true, \"You don\u0027t have admin rights.\");\n        _;\n    }\n\n    modifier isLiveGame() {\n        require(isGamePaused == false, \"Game is paused.\");\n        _;\n    }\n\n    // should be 4-8 symbols\n    modifier isValidRefLink(string _str) {\n        require(bytes(_str).length \u003e= 4, \"Ref link should be of length [4,8]\");\n        require(bytes(_str).length \u003c= 8, \"Ref link should be of length [4,8]\");\n        _;\n    }\n\n    // should be 1-16 symbols\n    modifier isValidUsername(string _str) {\n        require(bytes(_str).length \u003e= 1, \"Name should be of length [1,16]\");\n        require(bytes(_str).length \u003c= 16, \"Name should be of length [1,16]\");\n        _;\n    }\n\n}"},"Ownable.sol":{"content":"pragma solidity 0.4.24;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() internal {\n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @return the address of the owner.\n   */\n  function owner() public view returns(address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner());\n    _;\n  }\n\n  /**\n   * @return true if `msg.sender` is the owner of the contract.\n   */\n  function isOwner() public view returns(bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"},"PaintDiscount.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./StorageV1.sol\";\n\ncontract PaintDiscount is StorageV1 {\n    using SafeMath for uint;\n\n    // saving discount for user\n    function _setUsersPaintDiscountForColor(uint _color) internal {\n\n        //each 1 eth = 1% discount\n        usersPaintDiscount[msg.sender] = moneySpentByUser[msg.sender] / 1 ether; // for all colors\n        usersPaintDiscountForColor[_color][msg.sender] = moneySpentByUserForColor[_color][msg.sender] / 1 ether; // for current color\n\n        //max discount 10% for all colors\n        if (moneySpentByUser[msg.sender] \u003e= 10 ether) {\n            usersPaintDiscount[msg.sender] = 10;\n        }\n\n        //max discount 10% for current color\n        if (moneySpentByUserForColor[_color][msg.sender] \u003e= 10 ether) {\n            usersPaintDiscountForColor[_color][msg.sender] = 10;\n        }\n    }\n\n    //  Money spent by user buying this color\n    function _setMoneySpentByUserForColor(uint _color) internal {\n\n        moneySpentByUser[msg.sender] += msg.value; // for all colors\n        moneySpentByUserForColor[_color][msg.sender] += msg.value; // for current color\n\n        // for all colors\n        if (moneySpentByUser[msg.sender] \u003e= 1 ether) {\n            hasPaintDiscount[msg.sender] = true;\n        }\n\n        // for current color\n        if (moneySpentByUserForColor[_color][msg.sender] \u003e= 1 ether) {\n            hasPaintDiscountForColor[_color][msg.sender] = true;\n        }\n    }\n}"},"PaintsPool.sol":{"content":"pragma solidity ^0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./StorageV1.sol\";\n\ncontract PaintsPool is StorageV1 {\n    using SafeMath for uint;\n\n    //update paint price\n    function _updateCallPrice(uint _color) private {\n        \n        //increase call price for 5%(for frontend)\n        nextCallPriceForColor[_color] = callPriceForColor[_color].mul(105).div(100);\n        \n        \n        emit CallPriceUpdated(callPriceForColor[_color]);\n    }\n     \n    \n    \n    function _fillPaintsPool(uint _color) internal {\n\n        \n        uint nextPaintGen = currentPaintGenForColor[_color].add(1);\n        //each 5 min we produce new paint generation\n        if (now - paintGenToEndTimeForColor[_color][currentPaintGenForColor[_color] - 1] \u003e= 5 minutes) { \n            \n            \n            uint paintsRemain = paintGenToAmountForColor[_color][currentPaintGenForColor[_color]]; \n            \n            //if 5 min passed and new gen not yet started     \n            if (paintGenStartedForColor[_color][nextPaintGen] == false) {\n                \n                //we create new gen with amount of paints remaining \n                paintGenToAmountForColor[_color][nextPaintGen] = maxPaintsInPool.sub(paintsRemain); \n                \n                \n                paintGenToStartTimeForColor[_color][nextPaintGen] = now; \n\n                paintGenStartedForColor[_color][nextPaintGen] = true;\n            }\n            \n            if (paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] == 1) {\n                \n                \n                _updateCallPrice(_color);\n                \n                //current gen paiints ends now \n                paintGenToEndTimeForColor[_color][currentPaintGenForColor[_color]] = now;\n            }\n               \n            \n            if (paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] == 0) {\n                \n               \n                callPriceForColor[_color] = nextCallPriceForColor[_color];\n\n                if (paintGenToAmountForColor[_color][nextPaintGen] == 0) {\n                    paintGenToAmountForColor[_color][nextPaintGen] = maxPaintsInPool;\n                }\n                //now we use next gen paints\n                currentPaintGenForColor[_color] = nextPaintGen;\n            }\n        }\n        ///if 5 min not yet passed\n        else {\n\n            if (paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] == 0) {\n               \n                paintGenToAmountForColor[_color][nextPaintGen] = maxPaintsInPool;\n                //we use next paint gen\n                currentPaintGenForColor[_color] = nextPaintGen;\n            }\n\n        }\n    }\n}"},"Referral.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./Modifiers.sol\";\nimport \"./Utils.sol\";\n\ncontract Referral is Modifiers {\n    using SafeMath for uint;\n\n    // ref link lenght 4-8 symbols\n    function createRefLink(string _refLink) external isValidRefLink(_refLink) {\n        require(!hasRefLink[msg.sender], \"You have already generated your ref link.\");\n        bytes32 refLink32 = Utils.toBytes16(_refLink);\n        require(!refLinkExists[refLink32], \"This referral link already exists, try different one.\");\n        hasRefLink[msg.sender] = true;\n        userToRefLink[msg.sender] = _refLink;\n        refLinkExists[refLink32] = true;\n        refLinkToUser[refLink32] = msg.sender;\n    }\n\n    function getReferralsForUser(address _user) external view returns (address[]) {\n        return referrerToReferrals[_user];\n    }\n\n    function getReferralData(address _user) external view returns (uint registrationTime, uint moneySpent) {\n        registrationTime = registrationTimeForUser[_user];\n        moneySpent = moneySpentByUser[_user];\n    }\n}"},"Roles.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Modifiers.sol\";\n\ncontract Roles is Modifiers {\n    \n    function addAdmin(address _new) external onlyOwner() {\n        isAdmin[_new] = true;\n    }\n    \n    function removeAdmin(address _admin) external onlyOwner() {\n        isAdmin[_admin] = false;\n    }\n\n    function renounceAdmin() external onlyAdmin() {\n        isAdmin[msg.sender] = false;\n    }\n\n}"},"Router.sol":{"content":"pragma solidity 0.4.24;\npragma experimental \"v0.5.0\";\nimport \"./Initializer.sol\";\n\ncontract Router is Initializer {\n    \n    event CommitMessage(string message);\n    event FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\n\n    constructor(address _erc1538Delegate) public  {\n\n        //Adding ERC1538 updateContract function\n        bytes memory signature = \"updateContract(address,string,string)\";\n        bytes4 funcId = bytes4(keccak256(signature));\n        delegates[funcId] = _erc1538Delegate;\n        funcSignatures.push(signature);\n        funcSignatureToIndex[signature] = funcSignatures.length;\n        emit FunctionUpdate(funcId, address(0), _erc1538Delegate, string(signature));\n        emit CommitMessage(\"Added ERC1538 updateContract function at contract creation\");\n    \n        _initializer();\n    }\n\n    function() external payable {\n        address delegate = delegates[msg.sig];\n        require(delegate != address(0), \"Function does not exist.\");\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize)\n            let result := delegatecall(gas, delegate, ptr, calldatasize, 0, 0)\n            let size := returndatasize\n            returndatacopy(ptr, 0, size)\n            switch result\n            case 0 {revert(ptr, size)}\n            default {return (ptr, size)}\n        }\n    }\n}"},"SafeMath.sol":{"content":"pragma solidity 0.4.24;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}"},"StorageV0.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Ownable.sol\";\n\ncontract StorageV0 is Ownable {\n\n    // maps functions to the delegate contracts that execute the functions\n    // funcId =\u003e delegate contract\n    mapping(bytes4 =\u003e address) internal delegates;\n\n    // array of function signatures supported by the contract\n    bytes[] internal funcSignatures;\n\n    // maps each function signature to its position in the funcSignatures array.\n    // signature =\u003e index+1\n    mapping(bytes =\u003e uint256) internal funcSignatureToIndex;\n\n}"},"StorageV1.sol":{"content":"pragma solidity 0.4.24;\nimport \"./StorageV0.sol\";\nimport \"./IColor.sol\";\nimport \"./IPixel.sol\";\n\ncontract StorageV1 is StorageV0 {\n\n    //pixel color(round=\u003e pixel=\u003e color)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public pixelToColorForRound;\n\n    //old pixel color(round=\u003e pixel=\u003e color)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public pixelToOldColorForRound;\n\n    // (round =\u003e color =\u003e pixel amount)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public colorToPaintedPixelsAmountForRound;\n\n    //color bank for round (round =\u003e color bank)\n    mapping (uint =\u003e uint) public colorBankForRound;\n\n    //color bank for  color for round (round =\u003e color =\u003e color bank)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public colorBankToColorForRound;\n\n    //time bank for round (round =\u003e time bank)\n    mapping (uint =\u003e uint) public timeBankForRound;\n\n    // (round =\u003e timestamp)\n    mapping (uint =\u003e uint) public lastPaintTimeForRound;\n\n    // (round =\u003e adress)\n    mapping (uint =\u003e address) public lastPainterForRound;\n\n    // (round =\u003e pixel)\n    mapping (uint =\u003e uint) public lastPaintedPixelForRound;\n\n    // (round =\u003e color)\n    mapping (uint =\u003e uint) public winnerColorForRound;\n\n    // (round =\u003e color =\u003e paints amount)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public colorToTotalPaintsForCBIteration;\n\n    // (round =\u003e adress)\n    mapping (uint =\u003e address) public winnerOfRound;\n\n    //bank drawn in round (round =\u003e drawn bank) (1 = time bank, 2 = color bank)\n    mapping (uint =\u003e uint) public winnerBankForRound;\n\n    // (round =\u003e pixel =\u003e timestamp)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public pixelToPaintTimeForRound;\n\n\n    // number of paints for paint price limit\n    uint public priceLimitPaints;\n\n    // is paint function call – for paint price limit logic\n    bool public isPaintCall;\n\n\n    // (round =\u003e paints number)\n    mapping (uint =\u003e uint) public totalPaintsForRound;\n\n    // (round =\u003e address =\u003e paints number)\n    mapping (uint =\u003e mapping (address =\u003e uint)) public userPaintsForRound;\n\n\n    // total cashback for round (round =\u003e total cashback)\n    mapping (uint =\u003e uint) public totalCashBackForRound;\n\n    // max cashback since the beginning of the round (round =\u003e cashback per paint)\n    mapping (uint =\u003e uint) public maxCashBackPerPaintForRound;\n\n    // cashback per painter for round in time of painter\u0027s last paint (round =\u003e painter\u0027s address =\u003e cashback per paint)\n    mapping (uint =\u003e mapping (address =\u003e uint)) public cashBackPerPaintForRound;\n\n    // unwithdrawn cashback + remaining money from paints (address =\u003e cashback per painter)\n    mapping (address =\u003e uint) public cashBackCalculated;\n\n    // last cashback calculation round in cashBackCalculated (address =\u003e round)\n    mapping (address =\u003e uint) public cashBackCalculationRound;\n\n\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public paintGenToAmountForColor;\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public paintGenToStartTimeForColor;\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public paintGenToEndTimeForColor;\n    mapping (uint =\u003e mapping (uint =\u003e bool)) public paintGenStartedForColor;\n    mapping (uint =\u003e uint) public currentPaintGenForColor;\n    mapping (uint =\u003e uint) public callPriceForColor;\n    mapping (uint =\u003e uint) public nextCallPriceForColor;\n\n\n    mapping (uint =\u003e mapping (address =\u003e uint)) public moneySpentByUserForColor;\n    mapping (address =\u003e uint) public moneySpentByUser;\n\n\n    mapping (uint =\u003e mapping (address =\u003e bool)) public hasPaintDiscountForColor;\n    mapping (address =\u003e bool) public hasPaintDiscount;\n    mapping (uint =\u003e mapping (address =\u003e uint)) public usersPaintDiscountForColor;  //in percent\n    mapping (address =\u003e uint) public usersPaintDiscount;  //in percent\n\n\n\n    mapping (address =\u003e uint) public registrationTimeForUser;\n    mapping (address =\u003e bool) public isRegisteredUser;\n\n\n    mapping (address =\u003e bool) public hasRefLink;\n    mapping (address =\u003e address) public referralToReferrer;\n    mapping (address =\u003e address[]) public referrerToReferrals;\n    mapping (address =\u003e bool) public hasReferrer;\n    mapping (address =\u003e string) public userToRefLink;\n    mapping (bytes32 =\u003e address) public refLinkToUser;\n    mapping (bytes32 =\u003e bool) public refLinkExists;\n    mapping (address =\u003e uint) public newUserToCounter;\n\n\n    mapping (address =\u003e string) public addressToUsername;\n    mapping (string =\u003e bool) internal usernameExists;  // not public – string accessor\n\n\n    mapping(address =\u003e bool)  public luckyPotBankWinner;\n    uint public luckyPotBank;\n\n\n    uint public uniqueUsersCount;\n\n    uint public maxPaintsInPool;\n\n    uint public currentRound;\n\n    //time bank iteration\n    uint public tbIteration;\n\n   //color bank iteration\n    uint public cbIteration;\n\n\n    uint public paintsCounter;\n    mapping (uint =\u003e uint) public paintsCounterForColor;\n\n\n    // (counter =\u003e user)\n    mapping (uint =\u003e address) public counterToPainter;\n\n    // (color =\u003e counter =\u003e user)\n    mapping (uint =\u003e mapping (uint =\u003e address)) public counterToPainterForColor;\n\n    mapping (address =\u003e uint) public lastPlayedRound;\n\n\n    // For dividends distribution\n    mapping (address =\u003e uint) public pendingWithdrawals;\n\n    // (adress =\u003e time)\n    mapping (address =\u003e uint) public addressToLastWithdrawalTime;\n\n\n    address public founders = 0xe04f921cf3d6c882C0FAa79d0810a50B1101e2D4;\n\n\n    bool public isGamePaused;\n\n    mapping(address =\u003e bool) public isAdmin;\n\n    Color public colorInstance;\n    Pixel public pixelInstance;\n\n    uint public totalColorsNumber; // 8\n    uint public totalPixelsNumber; //225 in V1\n\n\n    mapping (address =\u003e uint) public lastPaintTimeOfUser;\n    mapping (uint =\u003e mapping (address =\u003e uint)) public lastPaintTimeOfUserForColor;\n\n\n    mapping (uint =\u003e uint) public usersCounterForRound;\n    mapping (uint =\u003e mapping (address =\u003e bool)) public isUserCountedForRound;\n\n\n    // ***** Events *****\n\n    event ColorBankWithdrawn(uint indexed round, uint indexed cbIteration, address indexed winnerOfRound, uint prize);\n    event TimeBankWithdrawn(uint indexed round, uint indexed tbIteration, address indexed winnerOfRound, uint prize);\n    event Paint(uint indexed pixelId, uint colorId, address indexed painter, uint indexed round, uint timestamp);\n    event CallPriceUpdated(uint indexed newCallPrice);\n    event EtherWithdrawn(uint balance, uint colorBank, uint timeBank, uint timestamp);\n    event LuckyPotDrawn(uint pixelId, address indexed winnerOfLuckyPot, uint prize);\n    event CashBackWithdrawn(uint indexed round, address indexed withdrawer, uint cashback);\n    event DividendsWithdrawn(address indexed withdrawer, uint withdrawalAmount);\n    event UsernameCreated(address indexed user, string username);\n}"},"Utils.sol":{"content":"pragma solidity 0.4.24;\n\nlibrary Utils {\n    \n    // convert a string less than 32 characters long to bytes32\n    function toBytes16(string _string) pure internal returns (bytes16) {\n        // make sure that the string isn\u0027t too long for this function\n        // will work but will cut off the any characters past the 32nd character\n        bytes16 _stringBytes;\n        string memory str = _string;\n    \n        // simplest way to convert 32 character long string\n        assembly {\n          // load the memory pointer of string with an offset of 32\n          // 32 passes over non-core data parts of string such as length of text\n          _stringBytes := mload(add(str, 32))\n        }\n        return _stringBytes;\n    }\n\n    \n    \n}"},"Wrapper.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Modifiers.sol\";\n\n/**\n** Wrapper for Router Contract to interact with all the functions\u0027 signatures\n**/\n\ncontract Wrapper is Modifiers {\n\n    //DividendsDistributor.sol\n    function withdrawDividends() external returns (bool) {}\n    function withdrawFoundersComission() external returns (bool) {}\n\n    //LuckyPot\n    function increaseLuckyPot() external payable {}\n    function drawLuckyPot(address _user, uint _bankPercent, uint _pixelId) external {}\n\n    //GameStateController.sol\n    function pauseGame() external {}\n    function resumeGame() external {}\n    function withdrawEther() external returns (bool) {}\n\n    //Referral.sol\n    function createRefLink(string _refLink) external {}\n    function getReferralsForUser(address _user) external view returns (address[]) {}\n    function getReferralData(address _user) external view returns (uint registrationTime, uint moneySpent) {}\n\n    //Roles.sol\n    function addAdmin(address _new) external {}\n    function removeAdmin(address _admin) external {}\n    function renounceAdmin() external {}\n\n    //Game.sol\n    function setPriceLimitPaints(uint _paintsNumber) external {}\n    function estimateCallPrice(uint[] _pixels, uint _color) public view returns (uint totalCallPrice) {}\n    function paint(uint[] _pixels, uint _color, string _refLink) external payable {}\n    function drawTimeBank() public {}\n    function cashBackAmount(address _painter) public view returns(uint cashBackInWei) {}\n    function withdrawCashBack() external {}\n\n    //ERC1538.sol\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external {}\n\n    //GameMock.sol\n    function mock() external {}\n    function mock2() external {}\n    function mock3(uint _winnerColor) external {}\n    function mockMaxPaintsInPool() external {}\n\n    //Helpers.sol\n    function getUsername(address _painter) external view returns(string username) {}\n    function isUsernameExists(string _username) external view returns(bool) {}\n    function createUsername(string _username) external {}\n    function getPixelColor(uint _pixel) external view returns (uint) {}\n    function addNewColor() external {}\n\n}"}}