{{
  "language": "Solidity",
  "sources": {
    "contracts/core/PendleRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/MathLib.sol\";\nimport \"../interfaces/IPendleRouter.sol\";\nimport \"../interfaces/IPendleData.sol\";\nimport \"../interfaces/IPendleForge.sol\";\nimport \"../interfaces/IPendleMarketFactory.sol\";\nimport \"../interfaces/IPendleMarket.sol\";\nimport \"../periphery/PermissionsV2.sol\";\nimport \"../periphery/WithdrawableV2.sol\";\nimport \"../periphery/PendleRouterNonReentrant.sol\";\n\n/**\n@dev OVERALL NOTE:\n* The router will not hold any funds, instead it will just help sending funds to other contracts & users\n* addLiquidity/removeLiquidity/swap all supports auto wrap of ETH\n    - There will be no markets of XYT-ETH, only markets of XYT-WETH\n    - If users want to send in / receive ETH, just pass the ETH_ADDRESS to the corresponding field,\n    the router will automatically wrap/unwrap WETH and interact with markets\n    - principle of ETH wrap implementation: always use the token with the \"original\" prefix for transfer,\n    and use the non-original token (_xyt, _token...) in all other cases\n* Markets will not transfer any XYT/baseToken, but instead make requests to Router through the transfer array\n    and the Router will transfer them\n*/\ncontract PendleRouter is IPendleRouter, WithdrawableV2, PendleRouterNonReentrant {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using Math for uint256;\n\n    IWETH public immutable override weth;\n    IPendleData public immutable override data;\n    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    // if someone's allowance for the router is below this amount,\n    // we will approve the router again (to spend from their account)\n    // if we already call .approveRouter for the a token, we shouldn't need to approve again\n    uint256 private constant REASONABLE_ALLOWANCE_AMOUNT = type(uint256).max / 2;\n\n    constructor(\n        address _governanceManager,\n        IWETH _weth,\n        IPendleData _data\n    ) PermissionsV2(_governanceManager) PendleRouterNonReentrant() {\n        weth = _weth;\n        data = _data;\n    }\n\n    /**\n     * @dev Accepts ETH via fallback from the WETH contract.\n     **/\n    receive() external payable {\n        require(msg.sender == address(weth), \"ETH_NOT_FROM_WETH\");\n    }\n\n    /**\n     * @notice Create a new pair of OT + XYT tokens to represent the\n     *   principal and interest for an underlying asset, until an expiry\n     Conditions:\n     * _expiry must be divisible for expiryDivisor() so that there are not too many yieldContracts\n     * Any _underlyingAsset can be passed in, since there is no way to validate them\n     * Have Reentrancy protection\n     **/\n    function newYieldContracts(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) external override nonReentrant returns (address ot, address xyt) {\n        require(_underlyingAsset != address(0), \"ZERO_ADDRESS\");\n        require(_expiry > block.timestamp, \"INVALID_EXPIRY\");\n        require(_expiry % data.expiryDivisor() == 0, \"INVALID_EXPIRY\");\n        IPendleForge forge = IPendleForge(data.getForgeAddress(_forgeId));\n        require(address(forge) != address(0), \"FORGE_NOT_EXISTS\");\n\n        ot = address(data.otTokens(_forgeId, _underlyingAsset, _expiry));\n        xyt = address(data.xytTokens(_forgeId, _underlyingAsset, _expiry));\n        require(ot == address(0) && xyt == address(0), \"DUPLICATE_YIELD_CONTRACT\");\n\n        (ot, xyt) = forge.newYieldContracts(_underlyingAsset, _expiry);\n    }\n\n    /**\n     * @notice After an expiry, redeem OT tokens to get back the underlyingYieldToken\n     *         and also any interests\n     * @notice This function acts as a proxy to the actual function\n     * @dev The interest from \"the last global action before expiry\" until the expiry\n     *      is given to the OT holders. This is to simplify accounting. An assumption\n     *      is that the last global action before expiry will be close to the expiry\n     * @dev all validity checks are in the internal function\n    Conditions:\n     * Have Reentrancy protection\n     **/\n    function redeemAfterExpiry(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry\n    ) public override nonReentrant returns (uint256 redeemedAmount) {\n        require(data.isValidXYT(_forgeId, _underlyingAsset, _expiry), \"INVALID_YT\");\n        require(_expiry < block.timestamp, \"MUST_BE_AFTER_EXPIRY\");\n\n        // guaranteed to be a valid forge by the isValidXYT check\n        IPendleForge forge = IPendleForge(data.getForgeAddress(_forgeId));\n\n        redeemedAmount = forge.redeemAfterExpiry(msg.sender, _underlyingAsset, _expiry);\n    }\n\n    /**\n     * @notice redeem the dueInterests from XYTs\n     * @dev all validity checks are in the internal function\n     Conditions:\n     * Have Reentrancy protection\n     **/\n    function redeemDueInterests(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) external override nonReentrant returns (uint256 interests) {\n        require(data.isValidXYT(_forgeId, _underlyingAsset, _expiry), \"INVALID_YT\");\n        require(_user != address(0), \"ZERO_ADDRESS\");\n        IPendleForge forge = IPendleForge(data.getForgeAddress(_forgeId));\n        interests = forge.redeemDueInterests(_user, _underlyingAsset, _expiry);\n    }\n\n    /**\n     * @notice Before the expiry, a user can redeem the same amount of OT+XYT to get back\n     *       the underlying yield token\n     Conditions:\n     * Have Reentrancy protection\n     **/\n    function redeemUnderlying(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 _amountToRedeem\n    ) external override nonReentrant returns (uint256 redeemedAmount) {\n        require(data.isValidXYT(_forgeId, _underlyingAsset, _expiry), \"INVALID_YT\");\n        require(block.timestamp < _expiry, \"YIELD_CONTRACT_EXPIRED\");\n        require(_amountToRedeem != 0, \"ZERO_AMOUNT\");\n\n        // guaranteed to be a valid forge by the isValidXYT check\n        IPendleForge forge = IPendleForge(data.getForgeAddress(_forgeId));\n\n        redeemedAmount = forge.redeemUnderlying(\n            msg.sender,\n            _underlyingAsset,\n            _expiry,\n            _amountToRedeem\n        );\n    }\n\n    /**\n     * @notice Use to renewYield. Basically a proxy to call redeemAfterExpiry & tokenizeYield\n     * @param _renewalRate a Fixed Point number, shows how much of the total redeemedAmount is renewed.\n        We allowed _renewalRate > RONE in case the user wants to increase his position\n     Conditions:\n     * No Reentrancy protection because it will just act as a proxy for 2 calls\n     **/\n    function renewYield(\n        bytes32 _forgeId,\n        uint256 _oldExpiry,\n        address _underlyingAsset,\n        uint256 _newExpiry,\n        uint256 _renewalRate\n    )\n        external\n        override\n        returns (\n            uint256 redeemedAmount,\n            uint256 amountRenewed,\n            address ot,\n            address xyt,\n            uint256 amountTokenMinted\n        )\n    {\n        require(0 < _renewalRate, \"INVALID_RENEWAL_RATE\");\n        redeemedAmount = redeemAfterExpiry(_forgeId, _underlyingAsset, _oldExpiry);\n        amountRenewed = redeemedAmount.rmul(_renewalRate);\n        (ot, xyt, amountTokenMinted) = tokenizeYield(\n            _forgeId,\n            _underlyingAsset,\n            _newExpiry,\n            amountRenewed,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice tokenize yield tokens to get OT+XYT. We allows tokenizing for others too\n     * @dev each forge is for a yield protocol (for example: Aave, Compound)\n    Conditions:\n     * Have Reentrancy protection\n     * Can only tokenize to a not-yet-expired XYT\n     **/\n    function tokenizeYield(\n        bytes32 _forgeId,\n        address _underlyingAsset,\n        uint256 _expiry,\n        uint256 _amountToTokenize,\n        address _to\n    )\n        public\n        override\n        nonReentrant\n        returns (\n            address ot,\n            address xyt,\n            uint256 amountTokenMinted\n        )\n    {\n        require(data.isValidXYT(_forgeId, _underlyingAsset, _expiry), \"INVALID_YT\");\n        require(block.timestamp < _expiry, \"YIELD_CONTRACT_EXPIRED\");\n        require(_to != address(0), \"ZERO_ADDRESS\");\n        require(_amountToTokenize != 0, \"ZERO_AMOUNT\");\n\n        // guaranteed to be a valid forge by the isValidXYT check\n        IPendleForge forge = IPendleForge(data.getForgeAddress(_forgeId));\n\n        // In this getYieldBearingToken call, the forge will check if there is\n        // any yieldToken that matches the underlyingAsset. For more details please\n        // check the getYieldBearingToken in forge\n        IERC20 yieldToken = IERC20(forge.getYieldBearingToken(_underlyingAsset));\n\n        // pull tokens in\n        yieldToken.safeTransferFrom(\n            msg.sender,\n            forge.yieldTokenHolders(_underlyingAsset, _expiry),\n            _amountToTokenize\n        );\n\n        // mint OT&XYT for users\n        (ot, xyt, amountTokenMinted) = forge.mintOtAndXyt(\n            _underlyingAsset,\n            _expiry,\n            _amountToTokenize,\n            _to\n        );\n    }\n\n    /**\n     * @notice add market liquidity by both xyt and baseToken\n     Conditions:\n     * Have Reentrancy protection\n     */\n    function addMarketLiquidityDual(\n        bytes32 _marketFactoryId,\n        address _xyt,\n        address _token,\n        uint256 _desiredXytAmount,\n        uint256 _desiredTokenAmount,\n        uint256 _xytMinAmount,\n        uint256 _tokenMinAmount\n    )\n        public\n        payable\n        override\n        nonReentrant\n        returns (\n            uint256 amountXytUsed,\n            uint256 amountTokenUsed,\n            uint256 lpOut\n        )\n    {\n        require(\n            _desiredXytAmount != 0 && _desiredXytAmount >= _xytMinAmount,\n            \"INVALID_YT_AMOUNTS\"\n        );\n        require(\n            _desiredTokenAmount != 0 && _desiredTokenAmount >= _tokenMinAmount,\n            \"INVALID_TOKEN_AMOUNTS\"\n        );\n\n        address originalToken = _token;\n        _token = _isETH(_token) ? address(weth) : _token;\n\n        IPendleMarket market = IPendleMarket(data.getMarket(_marketFactoryId, _xyt, _token));\n        require(address(market) != address(0), \"MARKET_NOT_FOUND\");\n\n        // note that LP minting will be done in the market\n        PendingTransfer[2] memory transfers;\n        (transfers, lpOut) = market.addMarketLiquidityDual(\n            msg.sender,\n            _desiredXytAmount,\n            _desiredTokenAmount,\n            _xytMinAmount,\n            _tokenMinAmount\n        );\n        _settlePendingTransfers(transfers, _xyt, originalToken, address(market));\n\n        amountXytUsed = transfers[0].amount;\n        amountTokenUsed = transfers[1].amount;\n        emit Join(msg.sender, amountXytUsed, amountTokenUsed, address(market), lpOut);\n    }\n\n    /**\n     * @notice add market liquidity by xyt or base token\n     * @dev no checks on _minOutLp\n     * @param _forXyt whether the user wants to addLiquidity by _xyt or _token\n     Conditions:\n     * Have Reentrancy protection\n     */\n    function addMarketLiquiditySingle(\n        bytes32 _marketFactoryId,\n        address _xyt,\n        address _token,\n        bool _forXyt,\n        uint256 _exactIn,\n        uint256 _minOutLp\n    ) external payable override nonReentrant returns (uint256 exactOutLp) {\n        require(_exactIn != 0, \"ZERO_AMOUNTS\");\n\n        address originalToken = _token;\n        _token = _isETH(_token) ? address(weth) : _token;\n\n        IPendleMarket market = IPendleMarket(data.getMarket(_marketFactoryId, _xyt, _token));\n        require(address(market) != address(0), \"MARKET_NOT_FOUND\");\n\n        address assetToTransferIn = _forXyt ? _xyt : originalToken;\n        address assetForMarket = _forXyt ? _xyt : _token;\n\n        // note that LP minting will be done in the market\n        PendingTransfer[2] memory transfers;\n        (transfers, exactOutLp) = market.addMarketLiquiditySingle(\n            msg.sender,\n            assetForMarket,\n            _exactIn,\n            _minOutLp\n        );\n\n        if (_forXyt) {\n            emit Join(msg.sender, _exactIn, 0, address(market), exactOutLp);\n        } else {\n            emit Join(msg.sender, 0, _exactIn, address(market), exactOutLp);\n        }\n        // We only need settle the transfering in of the assetToTransferIn\n        _settleTokenTransfer(assetToTransferIn, transfers[0], address(market));\n    }\n\n    /**\n     * @notice remove market liquidity by xyt and base tokens\n     * @dev no checks on _minOutXyt, _minOutToken\n     Conditions:\n     * Have Reentrancy protection\n     */\n    function removeMarketLiquidityDual(\n        bytes32 _marketFactoryId,\n        address _xyt,\n        address _token,\n        uint256 _exactInLp,\n        uint256 _minOutXyt,\n        uint256 _minOutToken\n    ) external override nonReentrant returns (uint256 exactOutXyt, uint256 exactOutToken) {\n        require(_exactInLp != 0, \"ZERO_LP_IN\");\n\n        address originalToken = _token;\n        _token = _isETH(_token) ? address(weth) : _token;\n\n        IPendleMarket market = IPendleMarket(data.getMarket(_marketFactoryId, _xyt, _token));\n        require(address(market) != address(0), \"MARKET_NOT_FOUND\");\n\n        // note that LP burning will be done in the market\n        PendingTransfer[2] memory transfers =\n            market.removeMarketLiquidityDual(msg.sender, _exactInLp, _minOutXyt, _minOutToken);\n\n        _settlePendingTransfers(transfers, _xyt, originalToken, address(market));\n        exactOutXyt = transfers[0].amount;\n        exactOutToken = transfers[1].amount;\n        emit Exit(msg.sender, exactOutXyt, exactOutToken, address(market), _exactInLp);\n    }\n\n    /**\n     * @notice remove market liquidity by xyt or base tokens\n     * @dev no checks on  _minOutAsset\n     * @param _forXyt whether the user wants to addLiquidity by _xyt or _token\n     Conditions:\n     * Have Reentrancy protection\n     */\n    function removeMarketLiquiditySingle(\n        bytes32 _marketFactoryId,\n        address _xyt,\n        address _token,\n        bool _forXyt,\n        uint256 _exactInLp,\n        uint256 _minOutAsset\n    ) external override nonReentrant returns (uint256 exactOutXyt, uint256 exactOutToken) {\n        require(_exactInLp != 0, \"ZERO_LP_IN\");\n\n        address originalToken = _token;\n        _token = _isETH(_token) ? address(weth) : _token;\n\n        IPendleMarket market = IPendleMarket(data.getMarket(_marketFactoryId, _xyt, _token));\n        require(address(market) != address(0), \"MARKET_NOT_FOUND\");\n\n        address assetForMarket = _forXyt ? _xyt : _token;\n\n        // note that LP burning will be done in the market\n        PendingTransfer[2] memory transfers =\n            market.removeMarketLiquiditySingle(\n                msg.sender,\n                assetForMarket,\n                _exactInLp,\n                _minOutAsset\n            );\n\n        address assetToTransferOut = _forXyt ? _xyt : originalToken;\n        _settleTokenTransfer(assetToTransferOut, transfers[0], address(market));\n\n        if (_forXyt) {\n            emit Exit(msg.sender, transfers[0].amount, 0, address(market), _exactInLp);\n            return (transfers[0].amount, 0);\n        } else {\n            emit Exit(msg.sender, 0, transfers[0].amount, address(market), _exactInLp);\n            return (0, transfers[0].amount);\n        }\n    }\n\n    /**\n     * @notice create a new market for a pair of xyt & token\n     * @dev A market can be uniquely identified by the triplet(_marketFactoryId,_xyt,_token)\n     Conditions:\n     * Have Reentrancy protection\n     */\n    function createMarket(\n        bytes32 _marketFactoryId,\n        address _xyt,\n        address _token\n    ) external override nonReentrant returns (address market) {\n        require(_xyt != address(0), \"ZERO_ADDRESS\");\n        require(_token != address(0), \"ZERO_ADDRESS\");\n        require(data.isXyt(_xyt), \"INVALID_YT\");\n        require(!data.isXyt(_token), \"YT_QUOTE_PAIR_FORBIDDEN\");\n        require(data.getMarket(_marketFactoryId, _xyt, _token) == address(0), \"EXISTED_MARKET\");\n\n        IPendleMarketFactory factory =\n            IPendleMarketFactory(data.getMarketFactoryAddress(_marketFactoryId));\n        require(address(factory) != address(0), \"ZERO_ADDRESS\");\n\n        bytes32 forgeId = IPendleForge(IPendleYieldToken(_xyt).forge()).forgeId();\n        require(data.validForgeFactoryPair(forgeId, _marketFactoryId), \"INVALID_FORGE_FACTORY\");\n\n        market = factory.createMarket(_xyt, _token);\n\n        emit MarketCreated(_marketFactoryId, _xyt, _token, market);\n    }\n\n    /**\n     * @notice bootstrap a market (aka the first one to add liquidity)\n     Conditions:\n     * Have Reentrancy protection\n     */\n    function bootstrapMarket(\n        bytes32 _marketFactoryId,\n        address _xyt,\n        address _token,\n        uint256 _initialXytLiquidity,\n        uint256 _initialTokenLiquidity\n    ) external payable override nonReentrant {\n        require(_initialXytLiquidity > 0, \"INVALID_YT_AMOUNT\");\n        require(_initialTokenLiquidity > 0, \"INVALID_TOKEN_AMOUNT\");\n\n        address originalToken = _token;\n        _token = _isETH(_token) ? address(weth) : _token;\n\n        IPendleMarket market = IPendleMarket(data.getMarket(_marketFactoryId, _xyt, _token));\n        require(address(market) != address(0), \"MARKET_NOT_FOUND\");\n\n        PendingTransfer[2] memory transfers;\n        uint256 exactOutLp;\n        (transfers, exactOutLp) = market.bootstrap(\n            msg.sender,\n            _initialXytLiquidity,\n            _initialTokenLiquidity\n        );\n\n        _settlePendingTransfers(transfers, _xyt, originalToken, address(market));\n        emit Join(\n            msg.sender,\n            _initialXytLiquidity,\n            _initialTokenLiquidity,\n            address(market),\n            exactOutLp\n        );\n    }\n\n    /**\n     * @notice trade by swap exact amount of token into market\n     * @dev no checks on _minOutAmount\n     Conditions:\n     * Have Reentrancy protection\n     */\n    function swapExactIn(\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _inAmount,\n        uint256 _minOutAmount,\n        bytes32 _marketFactoryId\n    ) external payable override nonReentrant returns (uint256 outSwapAmount) {\n        require(_inAmount != 0, \"ZERO_IN_AMOUNT\");\n\n        address originalTokenIn = _tokenIn;\n        address originalTokenOut = _tokenOut;\n        _tokenIn = _isETH(_tokenIn) ? address(weth) : _tokenIn;\n        _tokenOut = _isETH(_tokenOut) ? address(weth) : _tokenOut;\n\n        IPendleMarket market =\n            IPendleMarket(data.getMarketFromKey(_tokenIn, _tokenOut, _marketFactoryId));\n        require(address(market) != address(0), \"MARKET_NOT_FOUND\");\n\n        PendingTransfer[2] memory transfers;\n        (outSwapAmount, transfers) = market.swapExactIn(\n            _tokenIn,\n            _inAmount,\n            _tokenOut,\n            _minOutAmount\n        );\n\n        _settlePendingTransfers(transfers, originalTokenIn, originalTokenOut, address(market));\n\n        emit SwapEvent(msg.sender, _tokenIn, _tokenOut, _inAmount, outSwapAmount, address(market));\n    }\n\n    /**\n     * @notice trade by swap exact amount of token out of market\n     * @dev no checks on _maxInAmount\n     Conditions:\n     * Have Reentrancy protection\n     */\n    function swapExactOut(\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _outAmount,\n        uint256 _maxInAmount,\n        bytes32 _marketFactoryId\n    ) external payable override nonReentrant returns (uint256 inSwapAmount) {\n        require(_outAmount != 0, \"ZERO_OUT_AMOUNT\");\n\n        address originalTokenIn = _tokenIn;\n        address originalTokenOut = _tokenOut;\n        _tokenIn = _isETH(_tokenIn) ? address(weth) : _tokenIn;\n        _tokenOut = _isETH(_tokenOut) ? address(weth) : _tokenOut;\n\n        IPendleMarket market =\n            IPendleMarket(data.getMarketFromKey(_tokenIn, _tokenOut, _marketFactoryId));\n        require(address(market) != address(0), \"MARKET_NOT_FOUND\");\n\n        PendingTransfer[2] memory transfers;\n        (inSwapAmount, transfers) = market.swapExactOut(\n            _tokenIn,\n            _maxInAmount,\n            _tokenOut,\n            _outAmount\n        );\n\n        _settlePendingTransfers(transfers, originalTokenIn, originalTokenOut, address(market));\n\n        emit SwapEvent(msg.sender, _tokenIn, _tokenOut, inSwapAmount, _outAmount, address(market));\n    }\n\n    /**\n     * @notice For Lp holders to claim Lp interests\n    Conditions:\n     * Have Reentrancy protection\n     */\n    function redeemLpInterests(address market, address user)\n        external\n        override\n        nonReentrant\n        returns (uint256 interests)\n    {\n        require(data.isMarket(market), \"INVALID_MARKET\");\n        require(user != address(0), \"ZERO_ADDRESS\");\n        interests = IPendleMarket(market).redeemLpInterests(user);\n    }\n\n    function _getData() internal view override returns (IPendleData) {\n        return data;\n    }\n\n    function _isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n\n    /**\n     * @notice This function takes in the standard array PendingTransfer[2] that represents\n     *        any pending transfers of tokens to be done between a market and msg.sender\n     * @dev transfers[0] and transfers[1] always represent the tokens that are traded\n     *    The convention is that:\n     *      - if its a function with xyt and baseToken, transfers[0] is always xyt\n     *      - if its a function with tokenIn and tokenOut, transfers[0] is always tokenOut\n     */\n    function _settlePendingTransfers(\n        PendingTransfer[2] memory transfers,\n        address firstToken,\n        address secondToken,\n        address market\n    ) internal {\n        _settleTokenTransfer(firstToken, transfers[0], market);\n        _settleTokenTransfer(secondToken, transfers[1], market);\n    }\n\n    /**\n     * @notice This function settles a PendingTransfer, where the token could be ETH_ADDRESS\n     *        a PendingTransfer is always between a market and msg.sender\n     */\n    function _settleTokenTransfer(\n        address token,\n        PendingTransfer memory transfer,\n        address market\n    ) internal {\n        if (transfer.amount == 0) {\n            return;\n        }\n        if (transfer.isOut) {\n            if (_isETH(token)) {\n                weth.transferFrom(market, address(this), transfer.amount);\n                weth.withdraw(transfer.amount);\n                (bool success, ) = msg.sender.call{value: transfer.amount}(\"\");\n                require(success, \"TRANSFER_FAILED\");\n            } else {\n                IERC20(token).safeTransferFrom(market, msg.sender, transfer.amount);\n            }\n        } else {\n            if (_isETH(token)) {\n                require(msg.value >= transfer.amount, \"INSUFFICENT_ETH_AMOUNT\");\n                // we only need transfer.amount, so we return the excess\n                uint256 excess = msg.value.sub(transfer.amount);\n                if (excess != 0) {\n                    (bool success, ) = msg.sender.call{value: excess}(\"\");\n                    require(success, \"TRANSFER_FAILED\");\n                }\n\n                weth.deposit{value: transfer.amount}();\n                weth.transfer(market, transfer.amount);\n            } else {\n                // its a transfer in of token. If its an XYT\n                // we will auto approve the router to spend from the user account;\n                if (data.isXyt(token)) {\n                    _checkApproveRouter(token);\n                }\n                IERC20(token).safeTransferFrom(msg.sender, market, transfer.amount);\n            }\n        }\n    }\n\n    // Check if an user has approved the router to spend the amount\n    // if not, approve the router to spend the token from the user account\n    function _checkApproveRouter(address token) internal {\n        uint256 allowance = IPendleBaseToken(token).allowance(msg.sender, address(this));\n        if (allowance >= REASONABLE_ALLOWANCE_AMOUNT) return;\n        IPendleYieldToken(token).approveRouter(msg.sender);\n    }\n\n    // There shouldn't be any fund in here\n    // hence governance is allowed to withdraw anything from here.\n    function _allowedToWithdraw(address) internal pure override returns (bool allowed) {\n        allowed = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/MathLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary Math {\n    using SafeMath for uint256;\n\n    uint256 internal constant BIG_NUMBER = (uint256(1) << uint256(200));\n    uint256 internal constant PRECISION_BITS = 40;\n    uint256 internal constant RONE = uint256(1) << PRECISION_BITS;\n    uint256 internal constant PI = (314 * RONE) / 10**2;\n    uint256 internal constant PI_PLUSONE = (414 * RONE) / 10**2;\n    uint256 internal constant PRECISION_POW = 1e2;\n\n    function checkMultOverflow(uint256 _x, uint256 _y) internal pure returns (bool) {\n        if (_y == 0) return false;\n        return (((_x * _y) / _y) != _x);\n    }\n\n    /**\n    @notice find the integer part of log2(p/q)\n        => find largest x s.t p >= q * 2^x\n        => find largest x s.t 2^x <= p / q\n     */\n    function log2Int(uint256 _p, uint256 _q) internal pure returns (uint256) {\n        uint256 res = 0;\n        uint256 remain = _p / _q;\n        while (remain > 0) {\n            res++;\n            remain /= 2;\n        }\n        return res - 1;\n    }\n\n    /**\n    @notice log2 for a number that it in [1,2)\n    @dev _x is FP, return a FP\n    @dev function is from Kyber. Long modified the condition to be (_x >= one) && (_x < two)\n    to avoid the case where x = 2 may lead to incorrect result\n     */\n    function log2ForSmallNumber(uint256 _x) internal pure returns (uint256) {\n        uint256 res = 0;\n        uint256 one = (uint256(1) << PRECISION_BITS);\n        uint256 two = 2 * one;\n        uint256 addition = one;\n\n        require((_x >= one) && (_x < two), \"MATH_ERROR\");\n        require(PRECISION_BITS < 125, \"MATH_ERROR\");\n\n        for (uint256 i = PRECISION_BITS; i > 0; i--) {\n            _x = (_x * _x) / one;\n            addition = addition / 2;\n            if (_x >= two) {\n                _x = _x / 2;\n                res += addition;\n            }\n        }\n\n        return res;\n    }\n\n    /**\n    @notice log2 of (p/q). returns result in FP form\n    @dev function is from Kyber.\n    @dev _p & _q is FP, return a FP\n     */\n    function logBase2(uint256 _p, uint256 _q) internal pure returns (uint256) {\n        uint256 n = 0;\n\n        if (_p > _q) {\n            n = log2Int(_p, _q);\n        }\n\n        require(n * RONE <= BIG_NUMBER, \"MATH_ERROR\");\n        require(!checkMultOverflow(_p, RONE), \"MATH_ERROR\");\n        require(!checkMultOverflow(n, RONE), \"MATH_ERROR\");\n        require(!checkMultOverflow(uint256(1) << n, _q), \"MATH_ERROR\");\n\n        uint256 y = (_p * RONE) / (_q * (uint256(1) << n));\n        uint256 log2Small = log2ForSmallNumber(y);\n\n        assert(log2Small <= BIG_NUMBER);\n\n        return n * RONE + log2Small;\n    }\n\n    /**\n    @notice calculate ln(p/q). returned result >= 0\n    @dev function is from Kyber.\n    @dev _p & _q is FP, return a FP\n    */\n    function ln(uint256 p, uint256 q) internal pure returns (uint256) {\n        uint256 ln2Numerator = 6931471805599453094172;\n        uint256 ln2Denomerator = 10000000000000000000000;\n\n        uint256 log2x = logBase2(p, q);\n\n        require(!checkMultOverflow(ln2Numerator, log2x), \"MATH_ERROR\");\n\n        return (ln2Numerator * log2x) / ln2Denomerator;\n    }\n\n    /**\n    @notice extract the fractional part of a FP\n    @dev value is a FP, return a FP\n     */\n    function fpart(uint256 value) internal pure returns (uint256) {\n        return value % RONE;\n    }\n\n    /**\n    @notice convert a FP to an Int\n    @dev value is a FP, return an Int\n     */\n    function toInt(uint256 value) internal pure returns (uint256) {\n        return value / RONE;\n    }\n\n    /**\n    @notice convert an Int to a FP\n    @dev value is an Int, return a FP\n     */\n    function toFP(uint256 value) internal pure returns (uint256) {\n        return value * RONE;\n    }\n\n    /**\n    @notice return e^exp in FP form\n    @dev estimation by formula at http://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap04/exp.html\n        the function is based on exp function of:\n        https://github.com/NovakDistributed/macroverse/blob/master/contracts/RealMath.sol\n    @dev the function is expected to converge quite fast, after about 20 iteration\n    @dev exp is a FP, return a FP\n     */\n    function rpowe(uint256 exp) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 curTerm = RONE;\n\n        for (uint256 n = 0; ; n++) {\n            res += curTerm;\n            curTerm = rmul(curTerm, rdiv(exp, toFP(n + 1)));\n            if (curTerm == 0) {\n                break;\n            }\n            if (n == 500) {\n                /*\n                testing shows that in the most extreme case, it will take 430 turns to converge.\n                however, it's expected that the numbers will not exceed 2^120 in normal situation\n                the most extreme case is rpow((1<<256)-1,(1<<40)-1) (equal to rpow((2^256-1)/2^40,0.99..9))\n                */\n                revert(\"RPOWE_SLOW_CONVERGE\");\n            }\n        }\n\n        return res;\n    }\n\n    /**\n    @notice calculate base^exp with base and exp being FP int\n    @dev to improve accuracy, base^exp = base^(int(exp)+frac(exp))\n                                       = base^int(exp) * base^frac\n    @dev base & exp are FP, return a FP\n     */\n    function rpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        if (exp == 0) {\n            // Anything to the 0 is 1\n            return RONE;\n        }\n        if (base == 0) {\n            // 0 to anything except 0 is 0\n            return 0;\n        }\n\n        uint256 frac = fpart(exp); // get the fractional part\n        uint256 whole = exp - frac;\n\n        uint256 wholePow = rpowi(base, toInt(whole)); // whole is a FP, convert to Int\n        uint256 fracPow;\n\n        // instead of calculating base ^ frac, we will calculate e ^ (frac*ln(base))\n        if (base < RONE) {\n            /* since the base is smaller than 1.0, ln(base) < 0.\n            Since 1 / (e^(frac*ln(1/base))) = e ^ (frac*ln(base)),\n            we will calculate 1 / (e^(frac*ln(1/base))) instead.\n            */\n            uint256 newExp = rmul(frac, ln(rdiv(RONE, base), RONE));\n            fracPow = rdiv(RONE, rpowe(newExp));\n        } else {\n            /* base is greater than 1, calculate normally */\n            uint256 newExp = rmul(frac, ln(base, RONE));\n            fracPow = rpowe(newExp);\n        }\n        return rmul(wholePow, fracPow);\n    }\n\n    /**\n    @notice return base^exp with base in FP form and exp in Int\n    @dev this function use a technique called: exponentiating by squaring\n        complexity O(log(q))\n    @dev function is from Kyber.\n    @dev base is a FP, exp is an Int, return a FP\n     */\n    function rpowi(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 res = exp % 2 != 0 ? base : RONE;\n\n        for (exp /= 2; exp != 0; exp /= 2) {\n            base = rmul(base, base);\n\n            if (exp % 2 != 0) {\n                res = rmul(res, base);\n            }\n        }\n        return res;\n    }\n\n    /**\n    @dev y is an Int, returns an Int\n    @dev babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    @dev from Uniswap\n     */\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    /**\n    @notice divide 2 FP, return a FP\n    @dev function is from Balancer.\n    @dev x & y are FP, return a FP\n     */\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (y / 2).add(x.mul(RONE)).div(y);\n    }\n\n    /**\n    @notice multiply 2 FP, return a FP\n    @dev function is from Balancer.\n    @dev x & y are FP, return a FP\n     */\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (RONE / 2).add(x.mul(y)).div(RONE);\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a - b : 0;\n    }\n}\n"
    },
    "contracts/interfaces/IPendleRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IWETH.sol\";\nimport \"./IPendleData.sol\";\nimport \"../libraries/PendleStructs.sol\";\nimport \"./IPendleMarketFactory.sol\";\n\ninterface IPendleRouter {\n    /**\n     * @notice Emitted when a market for a future yield token and an ERC20 token is created.\n     * @param marketFactoryId Forge identifier.\n     * @param xyt The address of the tokenized future yield token as the base asset.\n     * @param token The address of an ERC20 token as the quote asset.\n     * @param market The address of the newly created market.\n     **/\n    event MarketCreated(\n        bytes32 marketFactoryId,\n        address indexed xyt,\n        address indexed token,\n        address indexed market\n    );\n\n    /**\n     * @notice Emitted when a swap happens on the market.\n     * @param trader The address of msg.sender.\n     * @param inToken The input token.\n     * @param outToken The output token.\n     * @param exactIn The exact amount being traded.\n     * @param exactOut The exact amount received.\n     * @param market The market address.\n     **/\n    event SwapEvent(\n        address indexed trader,\n        address inToken,\n        address outToken,\n        uint256 exactIn,\n        uint256 exactOut,\n        address market\n    );\n\n    /**\n     * @dev Emitted when user adds liquidity\n     * @param sender The user who added liquidity.\n     * @param token0Amount the amount of token0 (xyt) provided by user\n     * @param token1Amount the amount of token1 provided by user\n     * @param market The market address.\n     * @param exactOutLp The exact LP minted\n     */\n    event Join(\n        address indexed sender,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        address market,\n        uint256 exactOutLp\n    );\n\n    /**\n     * @dev Emitted when user removes liquidity\n     * @param sender The user who removed liquidity.\n     * @param token0Amount the amount of token0 (xyt) given to user\n     * @param token1Amount the amount of token1 given to user\n     * @param market The market address.\n     * @param exactInLp The exact Lp to remove\n     */\n    event Exit(\n        address indexed sender,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        address market,\n        uint256 exactInLp\n    );\n\n    /**\n     * @notice Gets a reference to the PendleData contract.\n     * @return Returns the data contract reference.\n     **/\n    function data() external view returns (IPendleData);\n\n    /**\n     * @notice Gets a reference of the WETH9 token contract address.\n     * @return WETH token reference.\n     **/\n    function weth() external view returns (IWETH);\n\n    /***********\n     *  FORGE  *\n     ***********/\n\n    function newYieldContracts(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (address ot, address xyt);\n\n    function redeemAfterExpiry(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (uint256 redeemedAmount);\n\n    function redeemDueInterests(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        address user\n    ) external returns (uint256 interests);\n\n    function redeemUnderlying(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToRedeem\n    ) external returns (uint256 redeemedAmount);\n\n    function renewYield(\n        bytes32 forgeId,\n        uint256 oldExpiry,\n        address underlyingAsset,\n        uint256 newExpiry,\n        uint256 renewalRate\n    )\n        external\n        returns (\n            uint256 redeemedAmount,\n            uint256 amountRenewed,\n            address ot,\n            address xyt,\n            uint256 amountTokenMinted\n        );\n\n    function tokenizeYield(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToTokenize,\n        address to\n    )\n        external\n        returns (\n            address ot,\n            address xyt,\n            uint256 amountTokenMinted\n        );\n\n    /***********\n     *  MARKET *\n     ***********/\n\n    function addMarketLiquidityDual(\n        bytes32 _marketFactoryId,\n        address _xyt,\n        address _token,\n        uint256 _desiredXytAmount,\n        uint256 _desiredTokenAmount,\n        uint256 _xytMinAmount,\n        uint256 _tokenMinAmount\n    )\n        external\n        payable\n        returns (\n            uint256 amountXytUsed,\n            uint256 amountTokenUsed,\n            uint256 lpOut\n        );\n\n    function addMarketLiquiditySingle(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        bool forXyt,\n        uint256 exactInAsset,\n        uint256 minOutLp\n    ) external payable returns (uint256 exactOutLp);\n\n    function removeMarketLiquidityDual(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        uint256 exactInLp,\n        uint256 minOutXyt,\n        uint256 minOutToken\n    ) external returns (uint256 exactOutXyt, uint256 exactOutToken);\n\n    function removeMarketLiquiditySingle(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        bool forXyt,\n        uint256 exactInLp,\n        uint256 minOutAsset\n    ) external returns (uint256 exactOutXyt, uint256 exactOutToken);\n\n    /**\n     * @notice Creates a market given a protocol ID, future yield token, and an ERC20 token.\n     * @param marketFactoryId Market Factory identifier.\n     * @param xyt Token address of the future yield token as base asset.\n     * @param token Token address of an ERC20 token as quote asset.\n     * @return market Returns the address of the newly created market.\n     **/\n    function createMarket(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token\n    ) external returns (address market);\n\n    function bootstrapMarket(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        uint256 initialXytLiquidity,\n        uint256 initialTokenLiquidity\n    ) external payable;\n\n    function swapExactIn(\n        address tokenIn,\n        address tokenOut,\n        uint256 inTotalAmount,\n        uint256 minOutTotalAmount,\n        bytes32 marketFactoryId\n    ) external payable returns (uint256 outTotalAmount);\n\n    function swapExactOut(\n        address tokenIn,\n        address tokenOut,\n        uint256 outTotalAmount,\n        uint256 maxInTotalAmount,\n        bytes32 marketFactoryId\n    ) external payable returns (uint256 inTotalAmount);\n\n    function redeemLpInterests(address market, address user) external returns (uint256 interests);\n}\n"
    },
    "contracts/interfaces/IPendleData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"./IPendleRouter.sol\";\nimport \"./IPendleYieldToken.sol\";\nimport \"./IPendlePausingManager.sol\";\nimport \"./IPendleMarket.sol\";\n\ninterface IPendleData {\n    /**\n     * @notice Emitted when validity of a forge-factory pair is updated\n     * @param _forgeId the forge id\n     * @param _marketFactoryId the market factory id\n     * @param _valid valid or not\n     **/\n    event ForgeFactoryValiditySet(bytes32 _forgeId, bytes32 _marketFactoryId, bool _valid);\n\n    /**\n     * @notice Emitted when Pendle and PendleFactory addresses have been updated.\n     * @param treasury The address of the new treasury contract.\n     **/\n    event TreasurySet(address treasury);\n\n    /**\n     * @notice Emitted when LockParams is changed\n     **/\n    event LockParamsSet(uint256 lockNumerator, uint256 lockDenominator);\n\n    /**\n     * @notice Emitted when ExpiryDivisor is changed\n     **/\n    event ExpiryDivisorSet(uint256 expiryDivisor);\n\n    /**\n     * @notice Emitted when forge fee is changed\n     **/\n    event ForgeFeeSet(uint256 forgeFee);\n\n    /**\n     * @notice Emitted when interestUpdateRateDeltaForMarket is changed\n     * @param interestUpdateRateDeltaForMarket new interestUpdateRateDeltaForMarket setting\n     **/\n    event InterestUpdateRateDeltaForMarketSet(uint256 interestUpdateRateDeltaForMarket);\n\n    /**\n     * @notice Emitted when market fees are changed\n     * @param _swapFee new swapFee setting\n     * @param _protocolSwapFee new protocolSwapFee setting\n     **/\n    event MarketFeesSet(uint256 _swapFee, uint256 _protocolSwapFee);\n\n    /**\n     * @notice Emitted when the curve shift block delta is changed\n     * @param _blockDelta new block delta setting\n     **/\n    event CurveShiftBlockDeltaSet(uint256 _blockDelta);\n\n    /**\n     * @dev Emitted when new forge is added\n     * @param marketFactoryId Human Readable Market Factory ID in Bytes\n     * @param marketFactoryAddress The Market Factory Address\n     */\n    event NewMarketFactory(bytes32 indexed marketFactoryId, address indexed marketFactoryAddress);\n\n    /**\n     * @notice Set/update validity of a forge-factory pair\n     * @param _forgeId the forge id\n     * @param _marketFactoryId the market factory id\n     * @param _valid valid or not\n     **/\n    function setForgeFactoryValidity(\n        bytes32 _forgeId,\n        bytes32 _marketFactoryId,\n        bool _valid\n    ) external;\n\n    /**\n     * @notice Sets the PendleTreasury contract addresses.\n     * @param newTreasury Address of new treasury contract.\n     **/\n    function setTreasury(address newTreasury) external;\n\n    /**\n     * @notice Gets a reference to the PendleRouter contract.\n     * @return Returns the router contract reference.\n     **/\n    function router() external view returns (IPendleRouter);\n\n    /**\n     * @notice Gets a reference to the PendleRouter contract.\n     * @return Returns the router contract reference.\n     **/\n    function pausingManager() external view returns (IPendlePausingManager);\n\n    /**\n     * @notice Gets the treasury contract address where fees are being sent to.\n     * @return Address of the treasury contract.\n     **/\n    function treasury() external view returns (address);\n\n    /***********\n     *  FORGE  *\n     ***********/\n\n    /**\n     * @notice Emitted when a forge for a protocol is added.\n     * @param forgeId Forge and protocol identifier.\n     * @param forgeAddress The address of the added forge.\n     **/\n    event ForgeAdded(bytes32 indexed forgeId, address indexed forgeAddress);\n\n    /**\n     * @notice Adds a new forge for a protocol.\n     * @param forgeId Forge and protocol identifier.\n     * @param forgeAddress The address of the added forge.\n     **/\n    function addForge(bytes32 forgeId, address forgeAddress) external;\n\n    /**\n     * @notice Store new OT and XYT details.\n     * @param forgeId Forge and protocol identifier.\n     * @param ot The address of the new XYT.\n     * @param xyt The address of the new XYT.\n     * @param underlyingAsset Token address of the underlying asset.\n     * @param expiry Yield contract expiry in epoch time.\n     **/\n    function storeTokens(\n        bytes32 forgeId,\n        address ot,\n        address xyt,\n        address underlyingAsset,\n        uint256 expiry\n    ) external;\n\n    /**\n     * @notice Set a new forge fee\n     * @param _forgeFee new forge fee\n     **/\n    function setForgeFee(uint256 _forgeFee) external;\n\n    /**\n     * @notice Gets the OT and XYT tokens.\n     * @param forgeId Forge and protocol identifier.\n     * @param underlyingYieldToken Token address of the underlying yield token.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return ot The OT token references.\n     * @return xyt The XYT token references.\n     **/\n    function getPendleYieldTokens(\n        bytes32 forgeId,\n        address underlyingYieldToken,\n        uint256 expiry\n    ) external view returns (IPendleYieldToken ot, IPendleYieldToken xyt);\n\n    /**\n     * @notice Gets a forge given the identifier.\n     * @param forgeId Forge and protocol identifier.\n     * @return forgeAddress Returns the forge address.\n     **/\n    function getForgeAddress(bytes32 forgeId) external view returns (address forgeAddress);\n\n    /**\n     * @notice Checks if an XYT token is valid.\n     * @param forgeId The forgeId of the forge.\n     * @param underlyingAsset Token address of the underlying asset.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return True if valid, false otherwise.\n     **/\n    function isValidXYT(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external view returns (bool);\n\n    /**\n     * @notice Checks if an OT token is valid.\n     * @param forgeId The forgeId of the forge.\n     * @param underlyingAsset Token address of the underlying asset.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return True if valid, false otherwise.\n     **/\n    function isValidOT(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external view returns (bool);\n\n    function validForgeFactoryPair(bytes32 _forgeId, bytes32 _marketFactoryId)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Gets a reference to a specific OT.\n     * @param forgeId Forge and protocol identifier.\n     * @param underlyingYieldToken Token address of the underlying yield token.\n     * @param expiry Yield contract expiry in epoch time.\n     * @return ot Returns the reference to an OT.\n     **/\n    function otTokens(\n        bytes32 forgeId,\n        address underlyingYieldToken,\n        uint256 expiry\n    ) external view returns (IPendleYieldToken ot);\n\n    /**\n     * @notice Gets a reference to a specific XYT.\n     * @param forgeId Forge and protocol identifier.\n     * @param underlyingAsset Token address of the underlying asset\n     * @param expiry Yield contract expiry in epoch time.\n     * @return xyt Returns the reference to an XYT.\n     **/\n    function xytTokens(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external view returns (IPendleYieldToken xyt);\n\n    /***********\n     *  MARKET *\n     ***********/\n\n    event MarketPairAdded(address indexed market, address indexed xyt, address indexed token);\n\n    function addMarketFactory(bytes32 marketFactoryId, address marketFactoryAddress) external;\n\n    function isMarket(address _addr) external view returns (bool result);\n\n    function isXyt(address _addr) external view returns (bool result);\n\n    function addMarket(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token,\n        address market\n    ) external;\n\n    function setMarketFees(uint256 _swapFee, uint256 _protocolSwapFee) external;\n\n    function setInterestUpdateRateDeltaForMarket(uint256 _interestUpdateRateDeltaForMarket)\n        external;\n\n    function setLockParams(uint256 _lockNumerator, uint256 _lockDenominator) external;\n\n    function setExpiryDivisor(uint256 _expiryDivisor) external;\n\n    function setCurveShiftBlockDelta(uint256 _blockDelta) external;\n\n    /**\n     * @notice Displays the number of markets currently existing.\n     * @return Returns markets length,\n     **/\n    function allMarketsLength() external view returns (uint256);\n\n    function forgeFee() external view returns (uint256);\n\n    function interestUpdateRateDeltaForMarket() external view returns (uint256);\n\n    function expiryDivisor() external view returns (uint256);\n\n    function lockNumerator() external view returns (uint256);\n\n    function lockDenominator() external view returns (uint256);\n\n    function swapFee() external view returns (uint256);\n\n    function protocolSwapFee() external view returns (uint256);\n\n    function curveShiftBlockDelta() external view returns (uint256);\n\n    function getMarketByIndex(uint256 index) external view returns (address market);\n\n    /**\n     * @notice Gets a market given a future yield token and an ERC20 token.\n     * @param xyt Token address of the future yield token as base asset.\n     * @param token Token address of an ERC20 token as quote asset.\n     * @return market Returns the market address.\n     **/\n    function getMarket(\n        bytes32 marketFactoryId,\n        address xyt,\n        address token\n    ) external view returns (address market);\n\n    /**\n     * @notice Gets a market factory given the identifier.\n     * @param marketFactoryId MarketFactory identifier.\n     * @return marketFactoryAddress Returns the factory address.\n     **/\n    function getMarketFactoryAddress(bytes32 marketFactoryId)\n        external\n        view\n        returns (address marketFactoryAddress);\n\n    function getMarketFromKey(\n        address xyt,\n        address token,\n        bytes32 marketFactoryId\n    ) external view returns (address market);\n}\n"
    },
    "contracts/interfaces/IPendleForge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IPendleRouter.sol\";\nimport \"./IPendleData.sol\";\nimport \"./IPendleRewardManager.sol\";\nimport \"./IPendleYieldContractDeployer.sol\";\n\ninterface IPendleForge {\n    /**\n     * @dev Emitted when the Forge has minted the OT and XYT tokens.\n     * @param forgeId The forgeId\n     * @param underlyingAsset The address of the underlying yield token.\n     * @param expiry The expiry of the XYT token\n     * @param amountToTokenize The amount of yield bearing assets to tokenize\n     * @param amountTokenMinted The amount of OT/XYT minted\n     **/\n    event MintYieldTokens(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        uint256 amountToTokenize,\n        uint256 amountTokenMinted,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted when the Forge has created new yield token contracts.\n     * @param forgeId The forgeId\n     * @param underlyingAsset The address of the underlying asset.\n     * @param expiry The date in epoch time when the contract will expire.\n     * @param ot The address of the ownership token.\n     * @param xyt The address of the new future yield token.\n     **/\n    event NewYieldContracts(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        address ot,\n        address xyt,\n        address yieldBearingAsset\n    );\n\n    /**\n     * @dev Emitted when the Forge has redeemed the OT and XYT tokens.\n     * @param forgeId The forgeId\n     * @param underlyingAsset the address of the underlying asset\n     * @param expiry The expiry of the XYT token\n     * @param amountToRedeem The amount of OT to be redeemed.\n     * @param redeemedAmount The amount of yield token received\n     **/\n    event RedeemYieldToken(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        uint256 amountToRedeem,\n        uint256 redeemedAmount,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted when interest claim is settled\n     * @param forgeId The forgeId\n     * @param underlyingAsset the address of the underlying asset\n     * @param expiry The expiry of the XYT token\n     * @param user Interest receiver Address\n     * @param amount The amount of interest claimed\n     **/\n    event DueInterestsSettled(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        uint256 amount,\n        uint256 forgeFeeAmount,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted when forge fee is withdrawn\n     * @param forgeId The forgeId\n     * @param underlyingAsset the address of the underlying asset\n     * @param expiry The expiry of the XYT token\n     * @param amount The amount of interest claimed\n     **/\n    event ForgeFeeWithdrawn(\n        bytes32 forgeId,\n        address indexed underlyingAsset,\n        uint256 indexed expiry,\n        uint256 amount\n    );\n\n    function setUpEmergencyMode(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address spender\n    ) external;\n\n    function newYieldContracts(address underlyingAsset, uint256 expiry)\n        external\n        returns (address ot, address xyt);\n\n    function redeemAfterExpiry(\n        address user,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (uint256 redeemedAmount);\n\n    function redeemDueInterests(\n        address user,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (uint256 interests);\n\n    function updateDueInterests(\n        address underlyingAsset,\n        uint256 expiry,\n        address user\n    ) external;\n\n    function updatePendingRewards(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) external;\n\n    function redeemUnderlying(\n        address user,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToRedeem\n    ) external returns (uint256 redeemedAmount);\n\n    function mintOtAndXyt(\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountToTokenize,\n        address to\n    )\n        external\n        returns (\n            address ot,\n            address xyt,\n            uint256 amountTokenMinted\n        );\n\n    function withdrawForgeFee(address underlyingAsset, uint256 expiry) external;\n\n    function getYieldBearingToken(address underlyingAsset) external returns (address);\n\n    /**\n     * @notice Gets a reference to the PendleRouter contract.\n     * @return Returns the router contract reference.\n     **/\n    function router() external view returns (IPendleRouter);\n\n    function data() external view returns (IPendleData);\n\n    function rewardManager() external view returns (IPendleRewardManager);\n\n    function yieldContractDeployer() external view returns (IPendleYieldContractDeployer);\n\n    function rewardToken() external view returns (IERC20);\n\n    /**\n     * @notice Gets the bytes32 ID of the forge.\n     * @return Returns the forge and protocol identifier.\n     **/\n    function forgeId() external view returns (bytes32);\n\n    function dueInterests(\n        address _underlyingAsset,\n        uint256 expiry,\n        address _user\n    ) external view returns (uint256);\n\n    function yieldTokenHolders(address _underlyingAsset, uint256 _expiry)\n        external\n        view\n        returns (address yieldTokenHolder);\n}\n"
    },
    "contracts/interfaces/IPendleMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"./IPendleRouter.sol\";\n\ninterface IPendleMarketFactory {\n    /**\n     * @notice Creates a market given a protocol ID, future yield token, and an ERC20 token.\n     * @param xyt Token address of the futuonlyCorere yield token as base asset.\n     * @param token Token address of an ERC20 token as quote asset.\n     * @return market Returns the address of the newly created market.\n     **/\n    function createMarket(address xyt, address token) external returns (address market);\n\n    /**\n     * @notice Gets a reference to the PendleRouter contract.\n     * @return Returns the router contract reference.\n     **/\n    function router() external view returns (IPendleRouter);\n\n    function marketFactoryId() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IPendleMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./IPendleRouter.sol\";\nimport \"./IPendleBaseToken.sol\";\nimport \"../libraries/PendleStructs.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPendleMarket is IERC20 {\n    /**\n     * @notice Emitted when reserves pool has been updated\n     * @param reserve0 The XYT reserves.\n     * @param weight0  The XYT weight\n     * @param reserve1 The generic token reserves.\n     * For the generic Token weight it can be inferred by (2^40) - weight0\n     **/\n    event Sync(uint256 reserve0, uint256 weight0, uint256 reserve1);\n\n    function setUpEmergencyMode(address spender) external;\n\n    function bootstrap(\n        address user,\n        uint256 initialXytLiquidity,\n        uint256 initialTokenLiquidity\n    ) external returns (PendingTransfer[2] memory transfers, uint256 exactOutLp);\n\n    function addMarketLiquiditySingle(\n        address user,\n        address inToken,\n        uint256 inAmount,\n        uint256 minOutLp\n    ) external returns (PendingTransfer[2] memory transfers, uint256 exactOutLp);\n\n    function addMarketLiquidityDual(\n        address user,\n        uint256 _desiredXytAmount,\n        uint256 _desiredTokenAmount,\n        uint256 _xytMinAmount,\n        uint256 _tokenMinAmount\n    ) external returns (PendingTransfer[2] memory transfers, uint256 lpOut);\n\n    function removeMarketLiquidityDual(\n        address user,\n        uint256 inLp,\n        uint256 minOutXyt,\n        uint256 minOutToken\n    ) external returns (PendingTransfer[2] memory transfers);\n\n    function removeMarketLiquiditySingle(\n        address user,\n        address outToken,\n        uint256 exactInLp,\n        uint256 minOutToken\n    ) external returns (PendingTransfer[2] memory transfers);\n\n    function swapExactIn(\n        address inToken,\n        uint256 inAmount,\n        address outToken,\n        uint256 minOutAmount\n    ) external returns (uint256 outAmount, PendingTransfer[2] memory transfers);\n\n    function swapExactOut(\n        address inToken,\n        uint256 maxInAmount,\n        address outToken,\n        uint256 outAmount\n    ) external returns (uint256 inAmount, PendingTransfer[2] memory transfers);\n\n    function redeemLpInterests(address user) external returns (uint256 interests);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint256 xytBalance,\n            uint256 xytWeight,\n            uint256 tokenBalance,\n            uint256 tokenWeight,\n            uint256 currentBlock\n        );\n\n    function factoryId() external view returns (bytes32);\n\n    function token() external view returns (address);\n\n    function xyt() external view returns (address);\n}\n"
    },
    "contracts/periphery/PermissionsV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../core/PendleGovernanceManager.sol\";\nimport \"../interfaces/IPermissionsV2.sol\";\n\nabstract contract PermissionsV2 is IPermissionsV2 {\n    PendleGovernanceManager public immutable override governanceManager;\n    address internal initializer;\n\n    constructor(address _governanceManager) {\n        require(_governanceManager != address(0), \"ZERO_ADDRESS\");\n        initializer = msg.sender;\n        governanceManager = PendleGovernanceManager(_governanceManager);\n    }\n\n    modifier initialized() {\n        require(initializer == address(0), \"NOT_INITIALIZED\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == _governance(), \"ONLY_GOVERNANCE\");\n        _;\n    }\n\n    function _governance() internal view returns (address) {\n        return governanceManager.governance();\n    }\n}\n"
    },
    "contracts/periphery/WithdrawableV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./PermissionsV2.sol\";\n\nabstract contract WithdrawableV2 is PermissionsV2 {\n    using SafeERC20 for IERC20;\n\n    event EtherWithdraw(uint256 amount, address sendTo);\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\n\n    /**\n     * @dev Allows governance to withdraw Ether in a Pendle contract\n     *      in case of accidental ETH transfer into the contract.\n     * @param amount The amount of Ether to withdraw.\n     * @param sendTo The recipient address.\n     */\n    function withdrawEther(uint256 amount, address payable sendTo) external onlyGovernance {\n        (bool success, ) = sendTo.call{value: amount}(\"\");\n        require(success, \"WITHDRAW_FAILED\");\n        emit EtherWithdraw(amount, sendTo);\n    }\n\n    /**\n     * @dev Allows governance to withdraw all IERC20 compatible tokens in a Pendle\n     *      contract in case of accidental token transfer into the contract.\n     * @param token IERC20 The address of the token contract.\n     * @param amount The amount of IERC20 tokens to withdraw.\n     * @param sendTo The recipient address.\n     */\n    function withdrawToken(\n        IERC20 token,\n        uint256 amount,\n        address sendTo\n    ) external onlyGovernance {\n        require(_allowedToWithdraw(address(token)), \"TOKEN_NOT_ALLOWED\");\n        token.safeTransfer(sendTo, amount);\n        emit TokenWithdraw(token, amount, sendTo);\n    }\n\n    // must be overridden by the sub contracts, so we must consider explicitly\n    // in each and every contract which tokens are allowed to be withdrawn\n    function _allowedToWithdraw(address) internal view virtual returns (bool allowed);\n}\n"
    },
    "contracts/periphery/PendleRouterNonReentrant.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \"../interfaces/IPendleData.sol\";\n\nabstract contract PendleRouterNonReentrant {\n    uint8 internal _guardCounter;\n\n    modifier nonReentrant() {\n        _checkNonReentrancy(); // use functions to reduce bytecode size\n        _;\n        _guardCounter--;\n    }\n\n    constructor() {\n        _guardCounter = 1;\n    }\n\n    /**\n    * We allow markets to make at most ONE Reentrant call\n    in the case of redeemLpInterests\n    * The flow of redeemLpInterests will be: Router.redeemLpInterests -> market.redeemLpInterests\n    -> Router.redeemDueInterests (so there is at most ONE Reentrant call)\n    */\n    function _checkNonReentrancy() internal {\n        if (_getData().isMarket(msg.sender)) {\n            require(_guardCounter <= 2, \"REENTRANT_CALL\");\n        } else {\n            require(_guardCounter == 1, \"REENTRANT_CALL\");\n        }\n        _guardCounter++;\n    }\n\n    function _getData() internal view virtual returns (IPendleData);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/libraries/PendleStructs.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.7.6;\n\nstruct TokenReserve {\n    uint256 weight;\n    uint256 balance;\n}\n\nstruct PendingTransfer {\n    uint256 amount;\n    bool isOut;\n}\n"
    },
    "contracts/interfaces/IPendleYieldToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IPendleBaseToken.sol\";\nimport \"./IPendleForge.sol\";\n\ninterface IPendleYieldToken is IERC20, IPendleBaseToken {\n    /**\n     * @notice Emitted when burning OT or XYT tokens.\n     * @param user The address performing the burn.\n     * @param amount The amount to be burned.\n     **/\n    event Burn(address indexed user, uint256 amount);\n\n    /**\n     * @notice Emitted when minting OT or XYT tokens.\n     * @param user The address performing the mint.\n     * @param amount The amount to be minted.\n     **/\n    event Mint(address indexed user, uint256 amount);\n\n    /**\n     * @notice Burns OT or XYT tokens from user, reducing the total supply.\n     * @param user The address performing the burn.\n     * @param amount The amount to be burned.\n     **/\n    function burn(address user, uint256 amount) external;\n\n    /**\n     * @notice Mints new OT or XYT tokens for user, increasing the total supply.\n     * @param user The address to send the minted tokens.\n     * @param amount The amount to be minted.\n     **/\n    function mint(address user, uint256 amount) external;\n\n    /**\n     * @notice Gets the forge address of the PendleForge contract for this yield token.\n     * @return Retuns the forge address.\n     **/\n    function forge() external view returns (IPendleForge);\n\n    /**\n     * @notice Returns the address of the underlying asset.\n     * @return Returns the underlying asset address.\n     **/\n    function underlyingAsset() external view returns (address);\n\n    /**\n     * @notice Returns the address of the underlying yield token.\n     * @return Returns the underlying yield token address.\n     **/\n    function underlyingYieldToken() external view returns (address);\n\n    /**\n     * @notice let the router approve itself to spend OT/XYT/LP from any wallet\n     * @param user user to approve\n     **/\n    function approveRouter(address user) external;\n}\n"
    },
    "contracts/interfaces/IPendlePausingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\ninterface IPendlePausingManager {\n    event AddPausingAdmin(address admin);\n    event RemovePausingAdmin(address admin);\n    event PendingForgeEmergencyHandler(address _pendingForgeHandler);\n    event PendingMarketEmergencyHandler(address _pendingMarketHandler);\n    event PendingLiqMiningEmergencyHandler(address _pendingLiqMiningHandler);\n    event ForgeEmergencyHandlerSet(address forgeEmergencyHandler);\n    event MarketEmergencyHandlerSet(address marketEmergencyHandler);\n    event LiqMiningEmergencyHandlerSet(address liqMiningEmergencyHandler);\n\n    event PausingManagerLocked();\n    event ForgeHandlerLocked();\n    event MarketHandlerLocked();\n    event LiqMiningHandlerLocked();\n\n    event SetForgePaused(bytes32 forgeId, bool settingToPaused);\n    event SetForgeAssetPaused(bytes32 forgeId, address underlyingAsset, bool settingToPaused);\n    event SetForgeAssetExpiryPaused(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        bool settingToPaused\n    );\n\n    event SetForgeLocked(bytes32 forgeId);\n    event SetForgeAssetLocked(bytes32 forgeId, address underlyingAsset);\n    event SetForgeAssetExpiryLocked(bytes32 forgeId, address underlyingAsset, uint256 expiry);\n\n    event SetMarketFactoryPaused(bytes32 marketFactoryId, bool settingToPaused);\n    event SetMarketPaused(bytes32 marketFactoryId, address market, bool settingToPaused);\n\n    event SetMarketFactoryLocked(bytes32 marketFactoryId);\n    event SetMarketLocked(bytes32 marketFactoryId, address market);\n\n    event SetLiqMiningPaused(address liqMiningContract, bool settingToPaused);\n    event SetLiqMiningLocked(address liqMiningContract);\n\n    function forgeEmergencyHandler()\n        external\n        view\n        returns (\n            address handler,\n            address pendingHandler,\n            uint256 timelockDeadline\n        );\n\n    function marketEmergencyHandler()\n        external\n        view\n        returns (\n            address handler,\n            address pendingHandler,\n            uint256 timelockDeadline\n        );\n\n    function liqMiningEmergencyHandler()\n        external\n        view\n        returns (\n            address handler,\n            address pendingHandler,\n            uint256 timelockDeadline\n        );\n\n    function permLocked() external view returns (bool);\n\n    function permForgeHandlerLocked() external view returns (bool);\n\n    function permMarketHandlerLocked() external view returns (bool);\n\n    function permLiqMiningHandlerLocked() external view returns (bool);\n\n    function isPausingAdmin(address) external view returns (bool);\n\n    function setPausingAdmin(address admin, bool isAdmin) external;\n\n    function requestForgeHandlerChange(address _pendingForgeHandler) external;\n\n    function requestMarketHandlerChange(address _pendingMarketHandler) external;\n\n    function requestLiqMiningHandlerChange(address _pendingLiqMiningHandler) external;\n\n    function applyForgeHandlerChange() external;\n\n    function applyMarketHandlerChange() external;\n\n    function applyLiqMiningHandlerChange() external;\n\n    function lockPausingManagerPermanently() external;\n\n    function lockForgeHandlerPermanently() external;\n\n    function lockMarketHandlerPermanently() external;\n\n    function lockLiqMiningHandlerPermanently() external;\n\n    function setForgePaused(bytes32 forgeId, bool paused) external;\n\n    function setForgeAssetPaused(\n        bytes32 forgeId,\n        address underlyingAsset,\n        bool paused\n    ) external;\n\n    function setForgeAssetExpiryPaused(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        bool paused\n    ) external;\n\n    function setForgeLocked(bytes32 forgeId) external;\n\n    function setForgeAssetLocked(bytes32 forgeId, address underlyingAsset) external;\n\n    function setForgeAssetExpiryLocked(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external;\n\n    function checkYieldContractStatus(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry\n    ) external returns (bool _paused, bool _locked);\n\n    function setMarketFactoryPaused(bytes32 marketFactoryId, bool paused) external;\n\n    function setMarketPaused(\n        bytes32 marketFactoryId,\n        address market,\n        bool paused\n    ) external;\n\n    function setMarketFactoryLocked(bytes32 marketFactoryId) external;\n\n    function setMarketLocked(bytes32 marketFactoryId, address market) external;\n\n    function checkMarketStatus(bytes32 marketFactoryId, address market)\n        external\n        returns (bool _paused, bool _locked);\n\n    function setLiqMiningPaused(address liqMiningContract, bool settingToPaused) external;\n\n    function setLiqMiningLocked(address liqMiningContract) external;\n\n    function checkLiqMiningStatus(address liqMiningContract)\n        external\n        returns (bool _paused, bool _locked);\n}\n"
    },
    "contracts/interfaces/IPendleBaseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPendleBaseToken is IERC20 {\n    /**\n     * @notice Decreases the allowance granted to spender by the caller.\n     * @param spender The address to reduce the allowance from.\n     * @param subtractedValue The amount allowance to subtract.\n     * @return Returns true if allowance has decreased, otherwise false.\n     **/\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    /**\n     * @notice The yield contract start in epoch time.\n     * @return Returns the yield start date.\n     **/\n    function start() external view returns (uint256);\n\n    /**\n     * @notice The yield contract expiry in epoch time.\n     * @return Returns the yield expiry date.\n     **/\n    function expiry() external view returns (uint256);\n\n    /**\n     * @notice Increases the allowance granted to spender by the caller.\n     * @param spender The address to increase the allowance from.\n     * @param addedValue The amount allowance to add.\n     * @return Returns true if allowance has increased, otherwise false\n     **/\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    /**\n     * @notice Returns the number of decimals the token uses.\n     * @return Returns the token's decimals.\n     **/\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Returns the name of the token.\n     * @return Returns the token's name.\n     **/\n    function name() external view returns (string memory);\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @return Returns the token's symbol.\n     **/\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice approve using the owner's signature\n     **/\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPendleRewardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\ninterface IPendleRewardManager {\n    event UpdateFrequencySet(address[], uint256[]);\n    event SkippingRewardsSet(bool);\n\n    event DueRewardsSettled(\n        bytes32 forgeId,\n        address underlyingAsset,\n        uint256 expiry,\n        uint256 amountOut,\n        address user\n    );\n\n    function redeemRewards(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) external returns (uint256 dueRewards);\n\n    function updatePendingRewards(\n        address _underlyingAsset,\n        uint256 _expiry,\n        address _user\n    ) external;\n\n    function updateParamLManual(address _underlyingAsset, uint256 _expiry) external;\n\n    function setUpdateFrequency(\n        address[] calldata underlyingAssets,\n        uint256[] calldata frequencies\n    ) external;\n\n    function setSkippingRewards(bool skippingRewards) external;\n\n    function forgeId() external returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IPendleYieldContractDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.7.6;\n\ninterface IPendleYieldContractDeployer {\n    function forgeId() external returns (bytes32);\n\n    function forgeOwnershipToken(\n        address _underlyingAsset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _expiry\n    ) external returns (address ot);\n\n    function forgeFutureYieldToken(\n        address _underlyingAsset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _expiry\n    ) external returns (address xyt);\n\n    function deployYieldTokenHolder(address yieldToken, uint256 expiry)\n        external\n        returns (address yieldTokenHolder);\n}\n"
    },
    "contracts/core/PendleGovernanceManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\ncontract PendleGovernanceManager {\n    address public governance;\n    address public pendingGovernance;\n\n    event GovernanceClaimed(address newGovernance, address previousGovernance);\n\n    event TransferGovernancePending(address pendingGovernance);\n\n    constructor(address _governance) {\n        require(_governance != address(0), \"ZERO_ADDRESS\");\n        governance = _governance;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"ONLY_GOVERNANCE\");\n        _;\n    }\n\n    /**\n     * @dev Allows the pendingGovernance address to finalize the change governance process.\n     */\n    function claimGovernance() external {\n        require(pendingGovernance == msg.sender, \"WRONG_GOVERNANCE\");\n        emit GovernanceClaimed(pendingGovernance, governance);\n        governance = pendingGovernance;\n        pendingGovernance = address(0);\n    }\n\n    /**\n     * @dev Allows the current governance to set the pendingGovernance address.\n     * @param _governance The address to transfer ownership to.\n     */\n    function transferGovernance(address _governance) external onlyGovernance {\n        require(_governance != address(0), \"ZERO_ADDRESS\");\n        pendingGovernance = _governance;\n\n        emit TransferGovernancePending(pendingGovernance);\n    }\n}\n"
    },
    "contracts/interfaces/IPermissionsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../core/PendleGovernanceManager.sol\";\n\ninterface IPermissionsV2 {\n    function governanceManager() external returns (PendleGovernanceManager);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}