{"ERC1155.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*///////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        for (uint256 i = 0; i \u003c idsLength; ) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can\u0027t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 ownersLength = owners.length; // Saves MLOADs.\n\n        require(ownersLength == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i \u003c ownersLength; i++) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i \u003c idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can\u0027t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i \u003c idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can\u0027t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\ninterface ERC1155TokenReceiver {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address =\u003e uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"ERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(uint256 =\u003e address) public ownerOf;\n\n    mapping(uint256 =\u003e address) public getApproved;\n\n    mapping(address =\u003e mapping(address =\u003e bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender\u0027s balance is impossible because we check for\n        // ownership above and the recipient\u0027s balance can\u0027t realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"ExitPayloadReader.sol":{"content":"pragma solidity ^0.8.0;\n\nimport {RLPReader} from \"./RLPReader.sol\";\n\nlibrary ExitPayloadReader {\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct ExitPayload {\n        RLPReader.RLPItem[] data;\n    }\n\n    struct Receipt {\n        RLPReader.RLPItem[] data;\n        bytes raw;\n        uint256 logIndex;\n    }\n\n    struct Log {\n        RLPReader.RLPItem data;\n        RLPReader.RLPItem[] list;\n    }\n\n    struct LogTopics {\n        RLPReader.RLPItem[] data;\n    }\n\n    // copy paste of private copy() from RLPReader to avoid changing of existing contracts\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len \u003e= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function toExitPayload(bytes memory data) internal pure returns (ExitPayload memory) {\n        RLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();\n\n        return ExitPayload(payloadData);\n    }\n\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[0].toUint();\n    }\n\n    function getBlockProof(ExitPayload memory payload) internal pure returns (bytes memory) {\n        return payload.data[1].toBytes();\n    }\n\n    function getBlockNumber(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[2].toUint();\n    }\n\n    function getBlockTime(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[3].toUint();\n    }\n\n    function getTxRoot(ExitPayload memory payload) internal pure returns (bytes32) {\n        return bytes32(payload.data[4].toUint());\n    }\n\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns (bytes32) {\n        return bytes32(payload.data[5].toUint());\n    }\n\n    function getReceipt(ExitPayload memory payload) internal pure returns (Receipt memory receipt) {\n        receipt.raw = payload.data[6].toBytes();\n        RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\n\n        if (receiptItem.isList()) {\n            // legacy tx\n            receipt.data = receiptItem.toList();\n        } else {\n            // pop first byte before parsting receipt\n            bytes memory typedBytes = receipt.raw;\n            bytes memory result = new bytes(typedBytes.length - 1);\n            uint256 srcPtr;\n            uint256 destPtr;\n            assembly {\n                srcPtr := add(33, typedBytes)\n                destPtr := add(0x20, result)\n            }\n\n            copy(srcPtr, destPtr, result.length);\n            receipt.data = result.toRlpItem().toList();\n        }\n\n        receipt.logIndex = getReceiptLogIndex(payload);\n        return receipt;\n    }\n\n    function getReceiptProof(ExitPayload memory payload) internal pure returns (bytes memory) {\n        return payload.data[7].toBytes();\n    }\n\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns (bytes memory) {\n        return payload.data[8].toBytes();\n    }\n\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[8].toUint();\n    }\n\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[9].toUint();\n    }\n\n    // Receipt methods\n    function toBytes(Receipt memory receipt) internal pure returns (bytes memory) {\n        return receipt.raw;\n    }\n\n    function getLog(Receipt memory receipt) internal pure returns (Log memory) {\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\n        return Log(logData, logData.toList());\n    }\n\n    // Log methods\n    function getEmitter(Log memory log) internal pure returns (address) {\n        return RLPReader.toAddress(log.list[0]);\n    }\n\n    function getTopics(Log memory log) internal pure returns (LogTopics memory) {\n        return LogTopics(log.list[1].toList());\n    }\n\n    function getData(Log memory log) internal pure returns (bytes memory) {\n        return log.list[2].toBytes();\n    }\n\n    function toRlpBytes(Log memory log) internal pure returns (bytes memory) {\n        return log.data.toRlpBytes();\n    }\n\n    // LogTopics methods\n    function getField(LogTopics memory topics, uint256 index) internal pure returns (RLPReader.RLPItem memory) {\n        return topics.data[index];\n    }\n}\n"},"FXBaseChildTunnel.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// IFxMessageProcessor represents interface to process message\ninterface IFxMessageProcessor {\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n\n/**\n * @notice Mock child tunnel contract to receive and send message from L2\n */\nabstract contract FxBaseChildTunnel is IFxMessageProcessor {\n    // MessageTunnel on L1 will get data from this event\n    event MessageSent(bytes message);\n\n    // fx child\n    address public fxChild;\n\n    // fx root tunnel\n    address public fxRootTunnel;\n\n    constructor(address _fxChild) {\n        fxChild = _fxChild;\n    }\n\n    // Sender must be fxRootTunnel in case of ERC20 tunnel\n    modifier validateSender(address sender) {\n        require(sender == fxRootTunnel, \"FxBaseChildTunnel: INVALID_SENDER_FROM_ROOT\");\n        _;\n    }\n\n    // set fxRootTunnel if not set already\n    function setFxRootTunnel(address _fxRootTunnel) external {\n        require(fxRootTunnel == address(0x0), \"FxBaseChildTunnel: ROOT_TUNNEL_ALREADY_SET\");\n        fxRootTunnel = _fxRootTunnel;\n    }\n\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external override {\n        require(msg.sender == fxChild, \"FxBaseChildTunnel: INVALID_SENDER\");\n        _processMessageFromRoot(stateId, rootMessageSender, data);\n    }\n\n    /**\n     * @notice Emit message that can be received on Root Tunnel\n     * @dev Call the internal function when need to emit message\n     * @param message bytes message that will be sent to Root Tunnel\n     * some message examples -\n     *   abi.encode(tokenId);\n     *   abi.encode(tokenId, tokenMetadata);\n     *   abi.encode(messageType, messageData);\n     */\n    function _sendMessageToRoot(bytes memory message) internal {\n        emit MessageSent(message);\n    }\n\n    /**\n     * @notice Process message received from Root Tunnel\n     * @dev function needs to be implemented to handle message as per requirement\n     * This is called by onStateReceive function.\n     * Since it is called via a system call, any event will not be emitted during its execution.\n     * @param stateId unique state id\n     * @param sender root message sender\n     * @param message bytes message that was sent from Root Tunnel\n     */\n    function _processMessageFromRoot(\n        uint256 stateId,\n        address sender,\n        bytes memory message\n    ) internal virtual;\n}\n"},"FxBaseRootTunnel.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {RLPReader} from \"./RLPReader.sol\";\nimport {MerklePatriciaProof} from \"./MerklePatriciaProof.sol\";\nimport {Merkle} from \"./Merkle.sol\";\nimport \"./ExitPayloadReader.sol\";\n\ninterface IFxStateSender {\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\n}\n\ncontract ICheckpointManager {\n    struct HeaderBlock {\n        bytes32 root;\n        uint256 start;\n        uint256 end;\n        uint256 createdAt;\n        address proposer;\n    }\n\n    /**\n     * @notice mapping of checkpoint header numbers to block details\n     * @dev These checkpoints are submited by plasma contracts\n     */\n    mapping(uint256 =\u003e HeaderBlock) public headerBlocks;\n}\n\nabstract contract FxBaseRootTunnel {\n    using RLPReader for RLPReader.RLPItem;\n    using Merkle for bytes32;\n    using ExitPayloadReader for bytes;\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\n    using ExitPayloadReader for ExitPayloadReader.Log;\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\n\n    // keccak256(MessageSent(bytes))\n    bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\n\n    // state sender contract\n    IFxStateSender public fxRoot;\n    // root chain manager\n    ICheckpointManager public checkpointManager;\n    // child tunnel contract which receives and sends messages\n    address public fxChildTunnel;\n\n    // storage to avoid duplicate exits\n    mapping(bytes32 =\u003e bool) public processedExits;\n\n    constructor(address _checkpointManager, address _fxRoot) {\n        checkpointManager = ICheckpointManager(_checkpointManager);\n        fxRoot = IFxStateSender(_fxRoot);\n    }\n\n    // set fxChildTunnel if not set already\n    function setFxChildTunnel(address _fxChildTunnel) public {\n        require(fxChildTunnel == address(0x0), \"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\");\n        fxChildTunnel = _fxChildTunnel;\n    }\n\n    /**\n     * @notice Send bytes message to Child Tunnel\n     * @param message bytes message that will be sent to Child Tunnel\n     * some message examples -\n     *   abi.encode(tokenId);\n     *   abi.encode(tokenId, tokenMetadata);\n     *   abi.encode(messageType, messageData);\n     */\n    function _sendMessageToChild(bytes memory message) internal {\n        fxRoot.sendMessageToChild(fxChildTunnel, message);\n    }\n\n    function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {\n        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();\n\n        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\n        uint256 blockNumber = payload.getBlockNumber();\n        // checking if exit has already been processed\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\n        bytes32 exitHash = keccak256(\n            abi.encodePacked(\n                blockNumber,\n                // first 2 nibbles are dropped while generating nibble array\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\n                // so converting to nibble array and then hashing it\n                MerklePatriciaProof._getNibbleArray(branchMaskBytes),\n                payload.getReceiptLogIndex()\n            )\n        );\n        require(processedExits[exitHash] == false, \"FxRootTunnel: EXIT_ALREADY_PROCESSED\");\n        processedExits[exitHash] = true;\n\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\n        ExitPayloadReader.Log memory log = receipt.getLog();\n\n        // check child tunnel\n        require(fxChildTunnel == log.getEmitter(), \"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\");\n\n        bytes32 receiptRoot = payload.getReceiptRoot();\n        // verify receipt inclusion\n        require(\n            MerklePatriciaProof.verify(receipt.toBytes(), branchMaskBytes, payload.getReceiptProof(), receiptRoot),\n            \"FxRootTunnel: INVALID_RECEIPT_PROOF\"\n        );\n\n        // verify checkpoint inclusion\n        _checkBlockMembershipInCheckpoint(\n            blockNumber,\n            payload.getBlockTime(),\n            payload.getTxRoot(),\n            receiptRoot,\n            payload.getHeaderNumber(),\n            payload.getBlockProof()\n        );\n\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\n\n        require(\n            bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\n            \"FxRootTunnel: INVALID_SIGNATURE\"\n        );\n\n        // received message data\n        bytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\n        return message;\n    }\n\n    function _checkBlockMembershipInCheckpoint(\n        uint256 blockNumber,\n        uint256 blockTime,\n        bytes32 txRoot,\n        bytes32 receiptRoot,\n        uint256 headerNumber,\n        bytes memory blockProof\n    ) private view returns (uint256) {\n        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = checkpointManager.headerBlocks(headerNumber);\n\n        require(\n            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(\n                blockNumber - startBlock,\n                headerRoot,\n                blockProof\n            ),\n            \"FxRootTunnel: INVALID_HEADER\"\n        );\n        return createdAt;\n    }\n\n    /**\n     * @notice receive message from  L2 to L1, validated by proof\n     * @dev This function verifies if the transaction actually happened on child chain\n     *\n     * @param inputData RLP encoded data of the reference tx containing following list of fields\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\n     *  2 - blockNumber - Block number containing the reference tx on child chain\n     *  3 - blockTime - Reference tx block time\n     *  4 - txRoot - Transactions root of block\n     *  5 - receiptRoot - Receipts root of block\n     *  6 - receipt - Receipt of the reference transaction\n     *  7 - receiptProof - Merkle proof of the reference receipt\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\n     *  9 - receiptLogIndex - Log Index to read from the receipt\n     */\n    function receiveMessage(bytes memory inputData) public virtual {\n        bytes memory message = _validateAndExtractMessage(inputData);\n        _processMessageFromChild(message);\n    }\n\n    /**\n     * @notice Process message received from Child Tunnel\n     * @dev function needs to be implemented to handle message as per requirement\n     * This is called by onStateReceive function.\n     * Since it is called via a system call, any event will not be emitted during its execution.\n     * @param message bytes message that was sent from Child Tunnel\n     */\n    function _processMessageFromChild(bytes memory message) internal virtual;\n}\n"},"LlamaZoo.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport \"./ERC1155.sol\";\nimport \"./SpitToken.sol\";\nimport \"./ERC721.sol\";\nimport \"./FxBaseRootTunnel.sol\";\nimport \"./Ownable.sol\";\n\n/**\n   __ _                                               \n  / /| | __ _ _ __ ___   __ _/\\   /\\___ _ __ ___  ___ \n / / | |/ _` | \u0027_ ` _ \\ / _` \\ \\ / / _ \\ \u0027__/ __|/ _ \\\n/ /__| | (_| | | | | | | (_| |\\ V /  __/ |  \\__ \\  __/\n\\____/_|\\__,_|_| |_| |_|\\__,_| \\_/ \\___|_|  |___/\\___|\n\n**/\n\n/// @title Llama Zoo\n/// @author delta devs (https://twitter.com/deltadevelopers)\n\ncontract LlamaZoo is FxBaseRootTunnel, Ownable {\n    /*///////////////////////////////////////////////////////////////\n                            STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice ERC721 instance of the PixelatedLlama contract.\n    ERC721 public pixellatedLlamaContract;\n    /// @notice ERC721 instance of the LlamaDraws contract.\n    ERC721 public llamaDrawsContract;\n    /// @notice ERC1155 instance of the StakingBoost contract.\n    ERC1155 public boostContract;\n    /// @notice ERC1155 instance of the Pixlet contract.\n    ERC1155 public pixletContract;\n\n    struct Staker {\n        uint256[] stakedLlamas;\n        uint256 stakedPixletCanvas;\n        uint256 stakedLlamaDraws;\n        uint128 stakedSilverBoosts;\n        uint128 stakedGoldBoosts;\n    }\n\n    mapping(address =\u003e Staker) public userInfo;\n\n    bool public stakingPaused;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor(\n        address checkpointManager,\n        address fxRoot,\n        address _pixellatedLlamaContract,\n        address _llamaDrawsContract,\n        address _boostContract,\n        address _pixletContract\n    ) FxBaseRootTunnel(checkpointManager, fxRoot) {\n        pixellatedLlamaContract = ERC721(_pixellatedLlamaContract);\n        llamaDrawsContract = ERC721(_llamaDrawsContract);\n        boostContract = ERC1155(_boostContract);\n        pixletContract = ERC1155(_pixletContract);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        CONTRACT SETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set the contract addresses for all contract instances.\n    /// @param _pixellatedLlamaContract The contract address of PixellatedLlama.\n    /// @param _llamaDrawsContract The contract address of LlamaDraws.\n    /// @param _boostContract The contract address of RewardBooster.\n    /// @param _pixletContract The contract address of the Pixlet contract.\n    function setContractAddresses(\n        address _pixellatedLlamaContract,\n        address _llamaDrawsContract,\n        address _boostContract,\n        address _pixletContract\n    ) public onlyOwner {\n        pixellatedLlamaContract = ERC721(_pixellatedLlamaContract);\n        llamaDrawsContract = ERC721(_llamaDrawsContract);\n        boostContract = ERC1155(_boostContract);\n        pixletContract = ERC1155(_pixletContract);\n    }\n\n    /// @notice Pauses staking and unstaking, for emergency purposes\n    /// @dev If we have to migrate because of Polygon instability or state sync issues, this will save us\n    function setStakingPaused(bool paused) public onlyOwner {\n        stakingPaused = paused;\n    }\n\n    /// @notice For collab.land to give a role based on staking status\n    function balanceOf(address owner) public view returns (uint256) {\n        uint[] memory llamas = userInfo[owner].stakedLlamas;\n        if(llamas.length == 0) return 0;\n        for (uint256 i = 0; i \u003c llamas.length; i++) {\n           if(llamas[i] \u003c 500) return 1;\n        }\n        return 2;\n    }\n\n    /// @dev Using the mapping directly wasn\u0027t returning the array, so we made this helper fuction.\n    function getStakedTokens(address user)\n        public\n        view\n        returns (\n            uint256[] memory llamas,\n            uint256 pixletCanvas,\n            uint256 llamaDraws,\n            uint128 silverBoosts,\n            uint128 goldBoosts\n        )\n    {\n        Staker memory staker = userInfo[user];\n        return (\n            staker.stakedLlamas,\n            staker.stakedPixletCanvas,\n            staker.stakedLlamaDraws,\n            staker.stakedSilverBoosts,\n            staker.stakedGoldBoosts\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        UTILITY STAKING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function bulkStake(\n        uint256[] memory llamas,\n        uint128 silverBoosts,\n        uint128 goldBoosts,\n        uint256 pixletStudio,\n        uint256 llamaDraws\n    ) public {\n        if (llamas.length \u003e 0) stakeMultipleLlamas(llamas);\n        stakeBoosts(silverBoosts, goldBoosts);\n        if (pixletStudio != 0) stakePixletCanvas(pixletStudio);\n        if (llamaDraws != 0) stakeLlamaDraws(llamaDraws);\n    }\n\n    function bulkUnstake(\n        uint256[] memory llamas,\n        uint128 silverBoosts,\n        uint128 goldBoosts,\n        bool pixletStudio,\n        bool llamaDraws\n    ) public {\n        if (llamas.length \u003e 0) unstakeMultipleLlamas(llamas);\n        unstakeBoosts(silverBoosts, goldBoosts);\n        if (pixletStudio) unstakePixletCanvas();\n        if (llamaDraws) unstakeLlamaDraws();\n    }\n\n    function stakeMultipleLlamas(uint256[] memory tokenIds) public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        uint256 animatedCount = 0;\n        Staker storage staker = userInfo[msg.sender];\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            if (tokenIds[i] \u003c 500) ++animatedCount;\n            staker.stakedLlamas.push(tokenIds[i]);\n            pixellatedLlamaContract.transferFrom(\n                msg.sender,\n                address(this),\n                tokenIds[i]\n            );\n        }\n        if (animatedCount \u003e 0) {\n            _sendMessageToChild(\n                abi.encode(\n                    msg.sender,\n                    uint256(TokenType.AnimatedLlama),\n                    animatedCount,\n                    true\n                )\n            );\n        }\n        if ((tokenIds.length - animatedCount) \u003e 0) {\n            _sendMessageToChild(\n                abi.encode(\n                    msg.sender,\n                    uint256(TokenType.StaticLlama),\n                    tokenIds.length - animatedCount,\n                    true\n                )\n            );\n        }\n    }\n\n    function unstakeMultipleLlamas(uint256[] memory tokenIds) public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        uint256 animatedCount = 0;\n        Staker storage staker = userInfo[msg.sender];\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            require(containsElement(staker.stakedLlamas, tokenId), \"You do not own this llama.\");\n            if (tokenId \u003c 500) ++animatedCount;\n            pixellatedLlamaContract.transferFrom(\n                address(this),\n                msg.sender,\n                tokenId\n            );\n\n            uint256[] memory stakedLlamas = staker.stakedLlamas;\n            uint256 index;\n            for (uint256 j; j \u003c stakedLlamas.length; j++) {\n                if (stakedLlamas[j] == tokenId) index = j;\n            }\n            if (stakedLlamas[index] == tokenId) {\n                staker.stakedLlamas[index] = stakedLlamas[\n                    staker.stakedLlamas.length - 1\n                ];\n                staker.stakedLlamas.pop();\n            }\n        }\n\n        if (animatedCount \u003e 0) {\n            _sendMessageToChild(\n                abi.encode(\n                    msg.sender,\n                    uint256(TokenType.AnimatedLlama),\n                    animatedCount,\n                    false\n                )\n            );\n        }\n        if ((tokenIds.length - animatedCount) \u003e 0) {\n            _sendMessageToChild(\n                abi.encode(\n                    msg.sender,\n                    uint256(TokenType.StaticLlama),\n                    tokenIds.length - animatedCount,\n                    false\n                )\n            );\n        }\n    }\n\n    /// @notice Stake a LlamaVerse llama.\n    /// @param tokenId The tokenId of the llama to stake\n    function stakeLlama(uint256 tokenId) external {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        bool animated = tokenId \u003c 500;\n        Staker storage staker = userInfo[msg.sender];\n        staker.stakedLlamas.push(tokenId);\n        pixellatedLlamaContract.transferFrom(\n            msg.sender,\n            address(this),\n            tokenId\n        );\n        _sendMessageToChild(\n            abi.encode(\n                msg.sender,\n                uint256(\n                    animated ? TokenType.AnimatedLlama : TokenType.StaticLlama\n                ),\n                1,\n                true\n            )\n        );\n    }\n\n    /// @notice Unstake a LlamaVerse llama.\n    /// @param tokenId The tokenId of the llama to unstake\n    function unstakeLlama(uint256 tokenId) external {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        bool animated = tokenId \u003c 500;\n        Staker storage staker = userInfo[msg.sender];\n        require(containsElement(staker.stakedLlamas, tokenId), \"You do not own this llama.\");\n\n        pixellatedLlamaContract.transferFrom(\n            address(this),\n            msg.sender,\n            tokenId\n        );\n\n        uint256[] memory stakedLlamas = staker.stakedLlamas;\n        uint256 index;\n        for (uint256 i; i \u003c stakedLlamas.length; i++) {\n            if (stakedLlamas[i] == tokenId) index = i;\n        }\n        if (stakedLlamas[index] == tokenId) {\n            _sendMessageToChild(\n                abi.encode(\n                    msg.sender,\n                    uint256(\n                        animated\n                            ? TokenType.AnimatedLlama\n                            : TokenType.StaticLlama\n                    ),\n                    1,\n                    false\n                )\n            );\n            staker.stakedLlamas[index] = stakedLlamas[\n                staker.stakedLlamas.length - 1\n            ];\n            staker.stakedLlamas.pop();\n        }\n    }\n\n    /// @notice Stake silver boosts.\n    /// @param amount The amount of boosts to stake.\n    function stakeSilverBoosts(uint128 amount) public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        require(amount != 0, \"Staking 0 is not allowed.\");\n\n        userInfo[msg.sender].stakedSilverBoosts += amount;\n        boostContract.safeTransferFrom(\n            msg.sender,\n            address(this),\n            2,\n            amount,\n            \"\"\n        );\n        _sendMessageToChild(\n            abi.encode(msg.sender, uint256(TokenType.SilverBoost), amount, true)\n        );\n    }\n\n    /// @notice Unstake silver boosts.\n    /// @param amount The amount of boosts to unstake.\n    function unstakeSilverBoosts(uint128 amount) public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        require(amount != 0, \"Unstaking 0 is not allowed.\");\n\n        userInfo[msg.sender].stakedSilverBoosts -= amount;\n        boostContract.safeTransferFrom(\n            address(this),\n            msg.sender,\n            2,\n            amount,\n            \"\"\n        );\n        _sendMessageToChild(\n            abi.encode(\n                msg.sender,\n                uint256(TokenType.SilverBoost),\n                amount,\n                false\n            )\n        );\n    }\n\n    /// @notice Stake gold boosts with the requested tokenID.\n    /// @param amount The amount of boosts to stake.\n    function stakeGoldBoosts(uint128 amount) public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        require(amount != 0, \"Staking 0 is not allowed.\");\n        userInfo[msg.sender].stakedGoldBoosts += amount;\n        boostContract.safeTransferFrom(\n            msg.sender,\n            address(this),\n            1,\n            amount,\n            \"\"\n        );\n        _sendMessageToChild(\n            abi.encode(msg.sender, uint256(TokenType.GoldBoost), amount, true)\n        );\n    }\n\n    /// @notice Unstake gold boosts with the requested tokenID.\n    /// @param amount The amount of boosts to stake.\n    function unstakeGoldBoosts(uint128 amount) public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        require(amount != 0, \"Unstaking 0 is not allowed.\");\n        userInfo[msg.sender].stakedGoldBoosts -= amount;\n        boostContract.safeTransferFrom(\n            address(this),\n            msg.sender,\n            1,\n            amount,\n            \"\"\n        );\n        _sendMessageToChild(\n            abi.encode(msg.sender, uint256(TokenType.GoldBoost), amount, false)\n        );\n    }\n\n    function stakeBoosts(uint128 silverAmount, uint128 goldAmount) public {\n        if (silverAmount != 0) stakeSilverBoosts(silverAmount);\n        if (goldAmount != 0) stakeGoldBoosts(goldAmount);\n    }\n\n    function unstakeBoosts(uint128 silverAmount, uint128 goldAmount) public {\n        if (silverAmount != 0) unstakeSilverBoosts(silverAmount);\n        if (goldAmount != 0) unstakeGoldBoosts(goldAmount);\n    }\n\n    /// @notice Stake a Pixlet Canvas with the requested tokenID.\n    /// @param tokenId The token ID of the pixlet canvas to stake.\n    function stakePixletCanvas(uint256 tokenId) public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        require(\n            userInfo[msg.sender].stakedPixletCanvas == 0,\n            \"You already have a pixlet canvas staked.\"\n        );\n\n        userInfo[msg.sender].stakedPixletCanvas = tokenId;\n        pixletContract.safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenId,\n            1,\n            \"\"\n        );\n\n        _sendMessageToChild(\n            abi.encode(msg.sender, uint256(TokenType.PixletCanvas), 1, true)\n        );\n    }\n\n    /// @notice Unstake your Pixlet Canvas.\n    function unstakePixletCanvas() public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        require(\n            userInfo[msg.sender].stakedPixletCanvas != 0,\n            \"You do not have a pixlet canvas staked.\"\n        );\n\n        pixletContract.safeTransferFrom(\n            address(this),\n            msg.sender,\n            userInfo[msg.sender].stakedPixletCanvas,\n            1,\n            \"\"\n        );\n        userInfo[msg.sender].stakedPixletCanvas = 0;\n\n        _sendMessageToChild(\n            abi.encode(msg.sender, uint256(TokenType.PixletCanvas), 1, false)\n        );\n    }\n\n    /// @notice Stake a Llamadraws.\n    /// @param tokenId The token ID of the llamadraws to stake.\n    function stakeLlamaDraws(uint256 tokenId) public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        require(\n            userInfo[msg.sender].stakedLlamaDraws == 0,\n            \"You already have a llamadraws staked.\"\n        );\n\n        userInfo[msg.sender].stakedLlamaDraws = tokenId;\n        llamaDrawsContract.transferFrom(msg.sender, address(this), tokenId);\n\n        _sendMessageToChild(\n            abi.encode(msg.sender, uint256(TokenType.LlamaDraws), 1, true)\n        );\n    }\n\n    /// @notice Unstake your Llamadraws.\n    function unstakeLlamaDraws() public {\n        require(!stakingPaused, \"Staking is currently paused.\");\n        require(\n            userInfo[msg.sender].stakedLlamaDraws != 0,\n            \"You do not have a llamadraws staked.\"\n        );\n\n        llamaDrawsContract.transferFrom(\n            address(this),\n            msg.sender,\n            userInfo[msg.sender].stakedLlamaDraws\n        );\n        userInfo[msg.sender].stakedLlamaDraws = 0;\n\n        _sendMessageToChild(\n            abi.encode(msg.sender, uint256(TokenType.LlamaDraws), 1, false)\n        );\n    }\n\n    function _processMessageFromChild(bytes memory message) internal override {\n        // We don\u0027t need a message from child\n    }\n\n    function containsElement(uint[] memory elements, uint tokenId) internal returns (bool) {\n        for (uint256 i = 0; i \u003c elements.length; i++) {\n           if(elements[i] == tokenId) return true;\n        }\n        return false;\n    }\n\n\n    /*///////////////////////////////////////////////////////////////\n                        ERC ON RECEIVED LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    /**\n     * @notice Handle the receipt of a single ERC1155 token type.\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\n     * This function MAY throw to revert and reject the transfer.\n     * Return of other amount than the magic value MUST result in the transaction being reverted.\n     * Note: The token contract address is always the message sender.\n     * @param operator  The address which called the `safeTransferFrom` function.\n     * @param from      The address which previously owned the token.\n     * @param id        The id of the token being transferred.\n     * @param amount    The amount of tokens being transferred.\n     * @param data      Additional data with no specified format.\n     * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`.\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    /**\n     * @notice Handle the receipt of multiple ERC1155 token types.\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\n     * This function MAY throw to revert and reject the transfer.\n     * Return of other amount than the magic value WILL result in the transaction being reverted.\n     * Note: The token contract address is always the message sender.\n     * @param operator  The address which called the `safeBatchTransferFrom` function.\n     * @param from      The address which previously owned the token.\n     * @param ids       An array containing ids of each token being transferred.\n     * @param amounts   An array containing amounts of each token being transferred.\n     * @param data      Additional data with no specified format.\n     * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`.\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"},"Merkle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Merkle {\n    function checkMembership(\n        bytes32 leaf,\n        uint256 index,\n        bytes32 rootHash,\n        bytes memory proof\n    ) internal pure returns (bool) {\n        require(proof.length % 32 == 0, \"Invalid proof length\");\n        uint256 proofHeight = proof.length / 32;\n        // Proof of size n means, height of the tree is n+1.\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\n        require(index \u003c 2**proofHeight, \"Leaf index is too big\");\n\n        bytes32 proofElement;\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i \u003c= proof.length; i += 32) {\n            assembly {\n                proofElement := mload(add(proof, i))\n            }\n\n            if (index % 2 == 0) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n\n            index = index / 2;\n        }\n        return computedHash == rootHash;\n    }\n}\n"},"MerklePatriciaProof.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {RLPReader} from \"./RLPReader.sol\";\n\nlibrary MerklePatriciaProof {\n    /*\n     * @dev Verifies a merkle patricia proof.\n     * @param value The terminating value in the trie.\n     * @param encodedPath The path in the trie leading to value.\n     * @param rlpParentNodes The rlp encoded stack of nodes.\n     * @param root The root hash of the trie.\n     * @return The boolean validity of the proof.\n     */\n    function verify(\n        bytes memory value,\n        bytes memory encodedPath,\n        bytes memory rlpParentNodes,\n        bytes32 root\n    ) internal pure returns (bool) {\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\n\n        bytes memory currentNode;\n        RLPReader.RLPItem[] memory currentNodeList;\n\n        bytes32 nodeKey = root;\n        uint256 pathPtr = 0;\n\n        bytes memory path = _getNibbleArray(encodedPath);\n        if (path.length == 0) {\n            return false;\n        }\n\n        for (uint256 i = 0; i \u003c parentNodes.length; i++) {\n            if (pathPtr \u003e path.length) {\n                return false;\n            }\n\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\n            if (nodeKey != keccak256(currentNode)) {\n                return false;\n            }\n            currentNodeList = RLPReader.toList(parentNodes[i]);\n\n            if (currentNodeList.length == 17) {\n                if (pathPtr == path.length) {\n                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n                uint8 nextPathNibble = uint8(path[pathPtr]);\n                if (nextPathNibble \u003e 16) {\n                    return false;\n                }\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));\n                pathPtr += 1;\n            } else if (currentNodeList.length == 2) {\n                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);\n                if (pathPtr + traversed == path.length) {\n                    //leaf node\n                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n                //extension node\n                if (traversed == 0) {\n                    return false;\n                }\n\n                pathPtr += traversed;\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\n            } else {\n                return false;\n            }\n        }\n    }\n\n    function _nibblesToTraverse(\n        bytes memory encodedPartialPath,\n        bytes memory path,\n        uint256 pathPtr\n    ) private pure returns (uint256) {\n        uint256 len = 0;\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\n        // and slicedPath have elements that are each one hex character (1 nibble)\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\n        bytes memory slicedPath = new bytes(partialPath.length);\n\n        // pathPtr counts nibbles in path\n        // partialPath.length is a number of nibbles\n        for (uint256 i = pathPtr; i \u003c pathPtr + partialPath.length; i++) {\n            bytes1 pathNibble = path[i];\n            slicedPath[i - pathPtr] = pathNibble;\n        }\n\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\n            len = partialPath.length;\n        } else {\n            len = 0;\n        }\n        return len;\n    }\n\n    // bytes b must be hp encoded\n    function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {\n        bytes memory nibbles = \"\";\n        if (b.length \u003e 0) {\n            uint8 offset;\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\n            if (hpNibble == 1 || hpNibble == 3) {\n                nibbles = new bytes(b.length * 2 - 1);\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\n                nibbles[0] = oddNibble;\n                offset = 1;\n            } else {\n                nibbles = new bytes(b.length * 2 - 2);\n                offset = 0;\n            }\n\n            for (uint256 i = offset; i \u003c nibbles.length; i++) {\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\n            }\n        }\n        return nibbles;\n    }\n\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\n        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nerror NotOwner();\n\n// https://github.com/m1guelpf/erc721-drop/blob/main/src/LilOwnable.sol\nabstract contract Ownable {\n    address internal _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function owner() external view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address _newOwner) external {\n        if (msg.sender != _owner) revert NotOwner();\n\n        _owner = _newOwner;\n    }\n\n    function renounceOwnership() public {\n        if (msg.sender != _owner) revert NotOwner();\n\n        _owner = address(0);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        returns (bool)\n    {\n        return interfaceId == 0x7f5828d0; // ERC165 Interface ID for ERC173\n    }\n}\n"},"RLPReader.sol":{"content":"/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity ^0.8.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that\u0027s being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr \u003c item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An \u0027Iterator\u0027 over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n     * @param item RLP encoded list in bytes\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i \u003c items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 \u003c LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len \u003e 0 \u0026\u0026 item.len \u003c= 33);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len \u003e 0);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr \u003c endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 \u003c STRING_SHORT_START) itemLen = 1;\n        else if (byte0 \u003c STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 \u003c LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 \u003c LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 \u003c STRING_SHORT_START) return 0;\n        else if (byte0 \u003c STRING_LONG_START || (byte0 \u003e= LIST_SHORT_START \u0026\u0026 byte0 \u003c LIST_LONG_START)) return 1;\n        else if (byte0 \u003c LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len \u003e= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len == 0) return;\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\n\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"},"SpitToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport \"./ERC20.sol\";\nimport \"./FXBaseChildTunnel.sol\";\nimport \"./Ownable.sol\";\n\n/**\n   __ _                                               \n  / /| | __ _ _ __ ___   __ _/\\   /\\___ _ __ ___  ___ \n / / | |/ _` | \u0027_ ` _ \\ / _` \\ \\ / / _ \\ \u0027__/ __|/ _ \\\n/ /__| | (_| | | | | | | (_| |\\ V /  __/ |  \\__ \\  __/\n\\____/_|\\__,_|_| |_| |_|\\__,_| \\_/ \\___|_|  |___/\\___|\n\n**/\n\n/// @title $SPIT Token\n/// @author delta devs (https://twitter.com/deltadevelopers)\n\nenum TokenType {\n    StaticLlama,\n    AnimatedLlama,\n    SilverBoost,\n    GoldBoost,\n    PixletCanvas,\n    LlamaDraws\n}\n\ncontract SpitToken is ERC20, FxBaseChildTunnel, Ownable {\n    /*///////////////////////////////////////////////////////////////\n                            STORAGE\n    /////////////////////////////////////////////////////////////*/\n\n    struct Rewards {\n        uint256 staticLlama;\n        uint256 animatedLlama;\n        uint256 silverEnergy;\n        uint256 goldEnergy;\n        uint256 pixletCanvas;\n        uint256 llamaDraws;\n    }\n\n    /// @notice The current reward rates per token type.\n    Rewards public rewards;\n\n    /// @notice Keeps track of the staking balances (how much is being staked) of each token type for all holders.\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public balances;\n\n    /// @notice Keeps track of the timestamp of when a holder last withdrew their rewards.\n    mapping(address =\u003e uint256) public lastUpdated;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _fxChild)\n        FxBaseChildTunnel(_fxChild)\n        ERC20(\"Spit Token\", \"SPIT\", 18)\n    {\n        rewards.staticLlama = (uint256(10) * 1e18) / 1 days;\n        rewards.animatedLlama = (uint256(30) * 1e18) / 1 days;\n        rewards.silverEnergy = (uint256(4) * 1e18) / 1 days;\n        rewards.goldEnergy = (uint256(12) * 1e18) / 1 days;\n        rewards.llamaDraws = (uint256(1) * 1e18) / 1 days;\n        rewards.pixletCanvas = (uint256(1) * 1e18) / 1 days;\n\n        _mint(address(this), 100_000_000 * 1e18);\n        uint256 allocation = (30_000_000 + 5_000_000 + 5_000_000 + 2_500_000) *\n            1e18;\n        balanceOf[address(this)] -= allocation;\n\n        unchecked {\n            balanceOf[\n                0xcc5cDaB325689Bcd654aB8611c528e60CC8CBe6A\n            ] += (30_000_000 * 1e18);\n            balanceOf[\n                0x58B96f5C8ef1CdD7e12a9b71Bbbe575E7B26b142\n            ] += (5_000_000 * 1e18);\n            balanceOf[\n                0x58caDf06fcC222f573F81B08B6Cc156e420D35d7\n            ] += (5_000_000 * 1e18);\n            balanceOf[\n                0x5D31E4A33470e1a15e54aAdD1d913b613fd0E9ED\n            ] += (2_500_000 * 1e18);\n        }\n\n        emit Transfer(\n            address(this),\n            0xcc5cDaB325689Bcd654aB8611c528e60CC8CBe6A,\n            30_000_000 * 1e18\n        );\n        emit Transfer(\n            address(this),\n            0x58B96f5C8ef1CdD7e12a9b71Bbbe575E7B26b142,\n            5_000_000 * 1e18\n        );\n        emit Transfer(\n            address(this),\n            0x58caDf06fcC222f573F81B08B6Cc156e420D35d7,\n            5_000_000 * 1e18\n        );\n        emit Transfer(\n            address(this),\n            0x5D31E4A33470e1a15e54aAdD1d913b613fd0E9ED,\n            2_500_000 * 1e18\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            STAKING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Called when withdrawing rewards. $SPIT is transferred to the address, and the lastUpdated field is updated.\n    /// @param account The address to mint to.\n    modifier updateReward(address account) {\n        uint256 amount = earned(account);\n        balanceOf[address(this)] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[account] += amount;\n        }\n\n        lastUpdated[account] = block.timestamp;\n        emit Transfer(address(this), account, amount);\n        _;\n    }\n\n    /// @notice Internal call to stake an amount of a specific token type.\n    /// @param account The address which will be staking.\n    /// @param tokenType The token type to stake.\n    /// @param amount The amount to stake.\n    function processStake(\n        address account,\n        TokenType tokenType,\n        uint256 amount\n    ) internal updateReward(account) {\n        balances[account][uint256(tokenType)] += amount;\n    }\n\n    /// @notice Internal call to unstake an amount of a specific token type.\n    /// @param account The address which will be unstaking.\n    /// @param tokenType The token type to unstake.\n    /// @param amount The amount to unstake.\n    function processUnstake(\n        address account,\n        TokenType tokenType,\n        uint256 amount\n    ) internal updateReward(account) {\n        balances[account][uint256(tokenType)] -= amount;\n    }\n\n    /**\n     * @notice Process message received from FxChild\n     * @param stateId unique state id\n     * @param sender root message sender\n     * @param message bytes message that was sent from Root Tunnel\n     */\n    function _processMessageFromRoot(\n        uint256 stateId,\n        address sender,\n        bytes memory message\n    ) internal override validateSender(sender) {\n        (address from, uint256 token, uint256 count, bool action) = abi.decode(\n            message,\n            (address, uint256, uint256, bool)\n        );\n        action\n            ? processStake(from, TokenType(token), count)\n            : processUnstake(from, TokenType(token), count);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            USER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Forwards a user\u0027s purchase in SPIT to this contract using EIP-2612\n    /// @dev This function exists so that the permit and transfer can be done in a single transaction.\n    function purchaseUtility(\n        address owner,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public updateReward(owner) {\n        permit(owner, msg.sender, value, deadline, v, r, s);\n        transferFrom(owner, address(this), value);\n    }\n\n    /// @notice Calculates the total amount of rewards accumulated for a staker, for staking all owned token types.\n    /// @dev Calculates based on when the staker last withdrew rewards, and compares it with the current block\u0027s timestamp.\n    /// @param account The account to calculate the accumulated rewards for.\n    function earned(address account) public view returns (uint256) {\n        return\n            spitPerSecond(account) * (block.timestamp - lastUpdated[account]);\n    }\n\n    /// @notice Calculates the current balance of the user including the unclaimed rewards.\n    /// @dev Unclaimed rewards are withdrawn automatically when a utility purchase is made or an unstake/stake occurs.\n    function totalBalance(address account) public view returns (uint256) {\n        return balanceOf[account] + earned(account);\n    }\n\n    /// @notice Calculates the amount of SPIT earned per second by the given user\n    /// @param account The account to calculate the accumulated rewards for.\n    function spitPerSecond(address account) public view returns (uint256) {\n        return ((balances[account][0] * rewards.staticLlama) +\n            (balances[account][1] * rewards.animatedLlama) +\n            (min(balances[account][2], balances[account][0]) *\n                rewards.silverEnergy) +\n            (min(balances[account][3], balances[account][1]) *\n                rewards.goldEnergy) +\n            (balances[account][4] * rewards.pixletCanvas) +\n            (balances[account][5] * rewards.llamaDraws));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows the contract owner to burn SPIT owned by the contract.\n    function burn(uint256 amount) public onlyOwner {\n        _burn(address(this), amount);\n    }\n\n    /// @notice Allows the contract owner to airdrop SPIT owned by the contract.\n    function airdrop(address[] calldata accounts, uint256[] calldata amounts) public onlyOwner {\n        require(accounts.length == amounts.length);\n        for(uint i = 0; i \u003c accounts.length; i++) {\n            uint amount = amounts[i];\n            balanceOf[address(this)] -= amount;\n\n            // Cannot overflow because the sum of all user\n            // balances can\u0027t exceed the max uint256 value.\n            unchecked {\n                balanceOf[accounts[i]] += amount;\n            }\n\n            emit Transfer(address(this), accounts[i], amount);\n        }\n    }\n\n    /// @notice Allows the contract owner to mint SPIT to the contract.\n    function mint(uint256 amount) public onlyOwner {\n        _mint(address(this), amount);\n    }\n\n    /// @notice Withdraw  $SPIT being held on this contract to the requested address.\n    /// @param recipient The address to withdraw the funds to.\n    /// @param amount The amount of SPIT to withdraw\n    function withdrawSpit(address recipient, uint256 amount) public onlyOwner {\n        balanceOf[address(this)] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[recipient] += amount;\n        }\n\n        emit Transfer(address(this), recipient, amount);\n    }\n\n    /// @notice Allows the contract deployer to sets the reward rates for each token type.\n    /// @param staticLlama The reward rate for staking a static llama.\n    /// @param animatedLlama The reward rate for staking an animated llama.\n    /// @param silverEnergy The reward rate for staking a silver llama boost.\n    /// @param goldEnergy The reward rate for staking a gold llama boost.\n    /// @param pixletCanvas The reward rate for staking a pixlet canvas.\n    function setRewardRates(\n        uint256 staticLlama,\n        uint256 animatedLlama,\n        uint256 silverEnergy,\n        uint256 goldEnergy,\n        uint256 pixletCanvas,\n        uint256 llamaDraws\n    ) public onlyOwner {\n        rewards.staticLlama = staticLlama;\n        rewards.animatedLlama = animatedLlama;\n        rewards.silverEnergy = silverEnergy;\n        rewards.goldEnergy = goldEnergy;\n        rewards.pixletCanvas = pixletCanvas;\n        rewards.llamaDraws = llamaDraws;\n    }\n\n    function updateFxRootRunnel(address _fxRootTunnel) external onlyOwner {\n        fxRootTunnel = _fxRootTunnel;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x \u003c y ? x : y;\n    }\n}\n"}}