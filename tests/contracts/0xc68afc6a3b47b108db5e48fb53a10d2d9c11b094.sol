{{
  "language": "Solidity",
  "sources": {
    "contracts/manifold/edition/ManifoldERC721Edition.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@manifoldxyz/libraries-solidity/contracts/access/IAdminControl.sol\";\nimport \"@manifoldxyz/creator-core-solidity/contracts/core/IERC721CreatorCore.sol\";\nimport \"@manifoldxyz/creator-core-solidity/contracts/extensions/CreatorExtension.sol\";\nimport \"@manifoldxyz/creator-core-solidity/contracts/extensions/ICreatorExtensionTokenURI.sol\";\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./IManifoldERC721Edition.sol\";\n\n/**\n * Manifold ERC721 Edition Controller Implementation\n */\ncontract ManifoldERC721Edition is CreatorExtension, ICreatorExtensionTokenURI, IManifoldERC721Edition, ReentrancyGuard {\n    using Strings for uint256;\n\n    struct IndexRange {\n        uint256 startIndex;\n        uint256 count;\n    }\n\n    mapping(address => mapping(uint256 => string)) _tokenPrefix;\n    mapping(address => mapping(uint256 => uint256)) _maxSupply;\n    mapping(address => mapping(uint256 => uint256)) _totalSupply;\n    mapping(address => mapping(uint256 => IndexRange[])) _indexRanges;\n    mapping(address => uint256) _currentSeries;\n    \n    /**\n     * @dev Only allows approved admins to call the specified function\n     */\n    modifier creatorAdminRequired(address creator) {\n        require(IAdminControl(creator).isAdmin(msg.sender), \"Must be owner or admin of creator contract\");\n        _;\n    }\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override(CreatorExtension, IERC165) returns (bool) {\n        return interfaceId == type(ICreatorExtensionTokenURI).interfaceId || interfaceId == type(IManifoldERC721Edition).interfaceId ||\n               CreatorExtension.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IManifoldERC721Edition-totalSupply}.\n     */\n    function totalSupply(address creator, uint256 series) external view override returns(uint256) {\n        return _totalSupply[creator][series];\n    }\n\n    /**\n     * @dev See {IManifoldERC721Edition-maxSupply}.\n     */\n    function maxSupply(address creator, uint256 series) external view override returns(uint256) {\n        return _maxSupply[creator][series];\n    }\n\n    /**\n     * @dev See {IManifoldERC721Edition-createSeries}.\n     */\n    function createSeries(address creator, uint256 maxSupply_, string calldata prefix) external override creatorAdminRequired(creator) returns(uint256) {\n        _currentSeries[creator] += 1;\n        uint256 series = _currentSeries[creator];\n        _maxSupply[creator][series] = maxSupply_;\n        _tokenPrefix[creator][series] = prefix;\n        emit SeriesCreated(msg.sender, creator, series, maxSupply_);\n        return series;\n    }\n\n    /**\n     * @dev See {IManifoldERC721Edition-latestSeries}.\n     */\n    function latestSeries(address creator) external view override returns(uint256) {\n        return _currentSeries[creator];\n    }\n\n    /**\n     * See {IManifoldERC721Edition-setTokenURIPrefix}.\n     */\n    function setTokenURIPrefix(address creator, uint256 series, string calldata prefix) external override creatorAdminRequired(creator) {\n        require(series > 0 && series <= _currentSeries[creator], \"Invalid series\");\n        _tokenPrefix[creator][series] = prefix;\n    }\n    \n    /**\n     * @dev See {ICreatorExtensionTokenURI-tokenURI}.\n     */\n    function tokenURI(address creator, uint256 tokenId) external view override returns (string memory) {\n        (uint256 series, uint256 index) = _tokenSeriesAndIndex(creator, tokenId);\n        return string(abi.encodePacked(_tokenPrefix[creator][series], (index+1).toString()));\n    }\n    \n    /**\n     * @dev See {IManifoldERC721Edition-mint}.\n     */\n    function mint(address creator, uint256 series, address recipient, uint16 count) external override nonReentrant creatorAdminRequired(creator) {\n        require(count > 0, \"Invalid amount requested\");\n        require(_totalSupply[creator][series]+count <= _maxSupply[creator][series], \"Too many requested\");\n        \n        uint256[] memory tokenIds = IERC721CreatorCore(creator).mintExtensionBatch(recipient, count);\n        _updateIndexRanges(creator, series, tokenIds[0], count);\n    }\n\n    /**\n     * @dev See {IManifoldERC721Edition-mint}.\n     */\n    function mint(address creator, uint256 series, address[] calldata recipients) external override nonReentrant creatorAdminRequired(creator) {\n        require(recipients.length > 0, \"Invalid amount requested\");\n        require(_totalSupply[creator][series]+recipients.length <= _maxSupply[creator][series], \"Too many requested\");\n        \n        uint256 startIndex = IERC721CreatorCore(creator).mintExtension(recipients[0]);\n        for (uint256 i = 1; i < recipients.length; i++) {\n            IERC721CreatorCore(creator).mintExtension(recipients[i]);\n        }\n        _updateIndexRanges(creator, series, startIndex, recipients.length);\n    }\n\n    /**\n     * @dev Update the index ranges, which is used to figure out the index from a tokenId\n     */\n    function _updateIndexRanges(address creator, uint256 series, uint256 startIndex, uint256 count) internal {\n        IndexRange[] storage indexRanges = _indexRanges[creator][series];\n        if (indexRanges.length == 0) {\n           indexRanges.push(IndexRange(startIndex, count));\n        } else {\n          IndexRange storage lastIndexRange = indexRanges[indexRanges.length-1];\n          if ((lastIndexRange.startIndex + lastIndexRange.count) == startIndex) {\n             lastIndexRange.count += count;\n          } else {\n            indexRanges.push(IndexRange(startIndex, count));\n          }\n        }\n        _totalSupply[creator][series] += count;\n    }\n\n    /**\n     * @dev Index from tokenId\n     */\n    function _tokenSeriesAndIndex(address creator, uint256 tokenId) internal view returns(uint256, uint256) {\n        require(_currentSeries[creator] > 0, \"Invalid token\");\n        for (uint series=1; series <= _currentSeries[creator]; series++) {\n            IndexRange[] memory indexRanges = _indexRanges[creator][series];\n            uint256 offset;\n            for (uint i = 0; i < indexRanges.length; i++) {\n                IndexRange memory currentIndex = indexRanges[i];\n                if (tokenId < currentIndex.startIndex) break;\n                if (tokenId >= currentIndex.startIndex && tokenId < currentIndex.startIndex + currentIndex.count) {\n                   return (series, tokenId - currentIndex.startIndex + offset);\n                }\n                offset += currentIndex.count;\n            }\n        }\n        revert(\"Invalid token\");\n    }\n\n}\n"
    },
    "@manifoldxyz/libraries-solidity/contracts/access/IAdminControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for admin control\n */\ninterface IAdminControl is IERC165 {\n\n    event AdminApproved(address indexed account, address indexed sender);\n    event AdminRevoked(address indexed account, address indexed sender);\n\n    /**\n     * @dev gets address of all admins\n     */\n    function getAdmins() external view returns (address[] memory);\n\n    /**\n     * @dev add an admin.  Can only be called by contract owner.\n     */\n    function approveAdmin(address admin) external;\n\n    /**\n     * @dev remove an admin.  Can only be called by contract owner.\n     */\n    function revokeAdmin(address admin) external;\n\n    /**\n     * @dev checks whether or not given address is an admin\n     * Returns True if they are\n     */\n    function isAdmin(address admin) external view returns (bool);\n\n}"
    },
    "@manifoldxyz/creator-core-solidity/contracts/core/IERC721CreatorCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"./ICreatorCore.sol\";\n\n/**\n * @dev Core ERC721 creator interface\n */\ninterface IERC721CreatorCore is ICreatorCore {\n\n    /**\n     * @dev mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBase(address to) external returns (uint256);\n\n    /**\n     * @dev mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBase(address to, string calldata uri) external returns (uint256);\n\n    /**\n     * @dev batch mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBaseBatch(address to, uint16 count) external returns (uint256[] memory);\n\n    /**\n     * @dev batch mint a token with no extension. Can only be called by an admin.\n     * Returns tokenId minted\n     */\n    function mintBaseBatch(address to, string[] calldata uris) external returns (uint256[] memory);\n\n    /**\n     * @dev mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtension(address to) external returns (uint256);\n\n    /**\n     * @dev mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtension(address to, string calldata uri) external returns (uint256);\n\n    /**\n     * @dev batch mint a token. Can only be called by a registered extension.\n     * Returns tokenIds minted\n     */\n    function mintExtensionBatch(address to, uint16 count) external returns (uint256[] memory);\n\n    /**\n     * @dev batch mint a token. Can only be called by a registered extension.\n     * Returns tokenId minted\n     */\n    function mintExtensionBatch(address to, string[] calldata uris) external returns (uint256[] memory);\n\n    /**\n     * @dev burn a token. Can only be called by token owner or approved address.\n     * On burn, calls back to the registered extension's onBurn method\n     */\n    function burn(uint256 tokenId) external;\n\n}"
    },
    "@manifoldxyz/creator-core-solidity/contracts/extensions/CreatorExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev Base creator extension variables\n */\nabstract contract CreatorExtension is ERC165 {\n\n    /**\n     * @dev Legacy extension interface identifiers\n     *\n     * {IERC165-supportsInterface} needs to return 'true' for this interface\n     * in order backwards compatible with older creator contracts\n     */\n    bytes4 constant internal LEGACY_EXTENSION_INTERFACE = 0x7005caad;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {\n        return interfaceId == LEGACY_EXTENSION_INTERFACE\n            || super.supportsInterface(interfaceId);\n    }\n    \n}"
    },
    "@manifoldxyz/creator-core-solidity/contracts/extensions/ICreatorExtensionTokenURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Implement this if you want your extension to have overloadable URI's\n */\ninterface ICreatorExtensionTokenURI is IERC165 {\n\n    /**\n     * Get the uri for a given creator/tokenId\n     */\n    function tokenURI(address creator, uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/manifold/edition/IManifoldERC721Edition.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\n/**\n * Manifold ERC721 Edition Controller interface\n */\ninterface IManifoldERC721Edition {\n\n    event SeriesCreated(address caller, address creator, uint256 series, uint256 maxSupply);\n\n    /**\n     * @dev Create a new series.  Returns the series id.\n     */\n    function createSeries(address creator, uint256 maxSupply, string calldata prefix) external returns(uint256);\n\n    /**\n     * @dev Get the latest series created.\n     */\n    function latestSeries(address creator) external view returns(uint256);\n\n    /**\n     * @dev Set the token uri prefix\n     */\n    function setTokenURIPrefix(address creator, uint256 series, string calldata prefix) external;\n    \n    /**\n     * @dev Mint NFTs to a single recipient\n     */\n    function mint(address creator, uint256 series, address recipient, uint16 count) external;\n\n    /**\n     * @dev Mint NFTS to the recipients\n     */\n    function mint(address creator, uint256 series, address[] calldata recipients) external;\n\n    /**\n     * @dev Total supply of editions\n     */\n    function totalSupply(address creator, uint256 series) external view returns(uint256);\n\n    /**\n     * @dev Max supply of editions\n     */\n    function maxSupply(address creator, uint256 series) external view returns(uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@manifoldxyz/creator-core-solidity/contracts/core/ICreatorCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Core creator interface\n */\ninterface ICreatorCore is IERC165 {\n\n    event ExtensionRegistered(address indexed extension, address indexed sender);\n    event ExtensionUnregistered(address indexed extension, address indexed sender);\n    event ExtensionBlacklisted(address indexed extension, address indexed sender);\n    event MintPermissionsUpdated(address indexed extension, address indexed permissions, address indexed sender);\n    event RoyaltiesUpdated(uint256 indexed tokenId, address payable[] receivers, uint256[] basisPoints);\n    event DefaultRoyaltiesUpdated(address payable[] receivers, uint256[] basisPoints);\n    event ExtensionRoyaltiesUpdated(address indexed extension, address payable[] receivers, uint256[] basisPoints);\n    event ExtensionApproveTransferUpdated(address indexed extension, bool enabled);\n\n    /**\n     * @dev gets address of all extensions\n     */\n    function getExtensions() external view returns (address[] memory);\n\n    /**\n     * @dev add an extension.  Can only be called by contract owner or admin.\n     * extension address must point to a contract implementing ICreatorExtension.\n     * Returns True if newly added, False if already added.\n     */\n    function registerExtension(address extension, string calldata baseURI) external;\n\n    /**\n     * @dev add an extension.  Can only be called by contract owner or admin.\n     * extension address must point to a contract implementing ICreatorExtension.\n     * Returns True if newly added, False if already added.\n     */\n    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external;\n\n    /**\n     * @dev add an extension.  Can only be called by contract owner or admin.\n     * Returns True if removed, False if already removed.\n     */\n    function unregisterExtension(address extension) external;\n\n    /**\n     * @dev blacklist an extension.  Can only be called by contract owner or admin.\n     * This function will destroy all ability to reference the metadata of any tokens created\n     * by the specified extension. It will also unregister the extension if needed.\n     * Returns True if removed, False if already removed.\n     */\n    function blacklistExtension(address extension) external;\n\n    /**\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\n     */\n    function setBaseTokenURIExtension(string calldata uri) external;\n\n    /**\n     * @dev set the baseTokenURI of an extension.  Can only be called by extension.\n     * For tokens with no uri configured, tokenURI will return \"uri+tokenId\"\n     */\n    function setBaseTokenURIExtension(string calldata uri, bool identical) external;\n\n    /**\n     * @dev set the common prefix of an extension.  Can only be called by extension.\n     * If configured, and a token has a uri set, tokenURI will return \"prefixURI+tokenURI\"\n     * Useful if you want to use ipfs/arweave\n     */\n    function setTokenURIPrefixExtension(string calldata prefix) external;\n\n    /**\n     * @dev set the tokenURI of a token extension.  Can only be called by extension that minted token.\n     */\n    function setTokenURIExtension(uint256 tokenId, string calldata uri) external;\n\n    /**\n     * @dev set the tokenURI of a token extension for multiple tokens.  Can only be called by extension that minted token.\n     */\n    function setTokenURIExtension(uint256[] memory tokenId, string[] calldata uri) external;\n\n    /**\n     * @dev set the baseTokenURI for tokens with no extension.  Can only be called by owner/admin.\n     * For tokens with no uri configured, tokenURI will return \"uri+tokenId\"\n     */\n    function setBaseTokenURI(string calldata uri) external;\n\n    /**\n     * @dev set the common prefix for tokens with no extension.  Can only be called by owner/admin.\n     * If configured, and a token has a uri set, tokenURI will return \"prefixURI+tokenURI\"\n     * Useful if you want to use ipfs/arweave\n     */\n    function setTokenURIPrefix(string calldata prefix) external;\n\n    /**\n     * @dev set the tokenURI of a token with no extension.  Can only be called by owner/admin.\n     */\n    function setTokenURI(uint256 tokenId, string calldata uri) external;\n\n    /**\n     * @dev set the tokenURI of multiple tokens with no extension.  Can only be called by owner/admin.\n     */\n    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external;\n\n    /**\n     * @dev set a permissions contract for an extension.  Used to control minting.\n     */\n    function setMintPermissions(address extension, address permissions) external;\n\n    /**\n     * @dev Configure so transfers of tokens created by the caller (must be extension) gets approval\n     * from the extension before transferring\n     */\n    function setApproveTransferExtension(bool enabled) external;\n\n    /**\n     * @dev get the extension of a given token\n     */\n    function tokenExtension(uint256 tokenId) external view returns (address);\n\n    /**\n     * @dev Set default royalties\n     */\n    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external;\n\n    /**\n     * @dev Set royalties of a token\n     */\n    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\n\n    /**\n     * @dev Set royalties of an extension\n     */\n    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external;\n\n    /**\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\n     */\n    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n    \n    // Royalty support for various other standards\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\n    function getFeeBps(uint256 tokenId) external view returns (uint[] memory);\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\n\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}