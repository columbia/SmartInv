{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/VotingPowerPrism.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/PrismProxy.sol\";\n\n/**\n * @title VotingPowerPrism\n * @dev Storage for voting power is at this address, while execution is delegated to the prism proxy implementation contract\n * All contracts that use voting power should reference this contract.\n */\ncontract VotingPowerPrism is PrismProxy {\n\n    /**\n     * @notice Construct a new Voting Power Prism Proxy\n     * @dev Sets initial proxy admin to `_admin`\n     * @param _admin Initial proxy admin\n     */\n    constructor(address _admin) {\n        // Initialize storage\n        ProxyStorage storage s = proxyStorage();\n        // Set initial proxy admin\n        s.admin = _admin;\n    }\n\n    /**\n     * @notice Forwards call to implementation contract\n     */\n    receive() external payable {\n        _forwardToImplementation();\n    }\n\n    /**\n     * @notice Forwards call to implementation contract\n     */\n    fallback() external payable {\n        _forwardToImplementation();\n    }\n}\n"
    },
    "contracts/lib/PrismProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\ncontract PrismProxy {\n\n    /// @notice Proxy admin and implementation storage variables\n    struct ProxyStorage {\n        // Administrator for this contract\n        address admin;\n\n        // Pending administrator for this contract\n        address pendingAdmin;\n\n        // Active implementation of this contract\n        address implementation;\n\n        // Pending implementation of this contract\n        address pendingImplementation;\n\n        // Implementation version of this contract\n        uint8 version;\n    }\n\n    /// @dev Position in contract storage where prism ProxyStorage struct will be stored\n    bytes32 constant PRISM_PROXY_STORAGE_POSITION = keccak256(\"prism.proxy.storage\");\n\n    /// @notice Emitted when pendingImplementation is changed\n    event NewPendingImplementation(address indexed oldPendingImplementation, address indexed newPendingImplementation);\n\n    /// @notice Emitted when pendingImplementation is accepted, which means implementation is updated\n    event NewImplementation(address indexed oldImplementation, address indexed newImplementation);\n\n    /// @notice Emitted when pendingAdmin is changed\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /**\n     * @notice Load proxy storage struct from specified PRISM_PROXY_STORAGE_POSITION\n     * @return ps ProxyStorage struct\n     */\n    function proxyStorage() internal pure returns (ProxyStorage storage ps) {        \n        bytes32 position = PRISM_PROXY_STORAGE_POSITION;\n        assembly {\n            ps.slot := position\n        }\n    }\n\n    /*** Admin Functions ***/\n    \n    /**\n     * @notice Create new pending implementation for prism. msg.sender must be admin\n     * @dev Admin function for proposing new implementation contract\n     * @return boolean indicating success of operation\n     */\n    function setPendingProxyImplementation(address newPendingImplementation) public returns (bool) {\n        ProxyStorage storage s = proxyStorage();\n        require(msg.sender == s.admin, \"Prism::setPendingProxyImp: caller must be admin\");\n\n        address oldPendingImplementation = s.pendingImplementation;\n\n        s.pendingImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, s.pendingImplementation);\n\n        return true;\n    }\n\n    /**\n     * @notice Accepts new implementation for prism. msg.sender must be pendingImplementation\n     * @dev Admin function for new implementation to accept it's role as implementation\n     * @return boolean indicating success of operation\n     */\n    function acceptProxyImplementation() public returns (bool) {\n        ProxyStorage storage s = proxyStorage();\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n        require(msg.sender == s.pendingImplementation && s.pendingImplementation != address(0), \"Prism::acceptProxyImp: caller must be pending implementation\");\n \n        // Save current values for inclusion in log\n        address oldImplementation = s.implementation;\n        address oldPendingImplementation = s.pendingImplementation;\n\n        s.implementation = s.pendingImplementation;\n\n        s.pendingImplementation = address(0);\n        s.version++;\n\n        emit NewImplementation(oldImplementation, s.implementation);\n        emit NewPendingImplementation(oldPendingImplementation, s.pendingImplementation);\n\n        return true;\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return boolean indicating success of operation\n     */\n    function setPendingProxyAdmin(address newPendingAdmin) public returns (bool) {\n        ProxyStorage storage s = proxyStorage();\n        // Check caller = admin\n        require(msg.sender == s.admin, \"Prism::setPendingProxyAdmin: caller must be admin\");\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = s.pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        s.pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return true;\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return boolean indicating success of operation\n     */\n    function acceptProxyAdmin() public returns (bool) {\n        ProxyStorage storage s = proxyStorage();\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        require(msg.sender == s.pendingAdmin && msg.sender != address(0), \"Prism::acceptProxyAdmin: caller must be pending admin\");\n\n        // Save current values for inclusion in log\n        address oldAdmin = s.admin;\n        address oldPendingAdmin = s.pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        s.admin = s.pendingAdmin;\n\n        // Clear the pending value\n        s.pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, s.admin);\n        emit NewPendingAdmin(oldPendingAdmin, s.pendingAdmin);\n\n        return true;\n    }\n\n    /**\n     * @notice Get current admin for prism proxy\n     * @return admin address\n     */\n    function proxyAdmin() public view returns (address) {\n        ProxyStorage storage s = proxyStorage();\n        return s.admin;\n    }\n\n    /**\n     * @notice Get pending admin for prism proxy\n     * @return admin address\n     */\n    function pendingProxyAdmin() public view returns (address) {\n        ProxyStorage storage s = proxyStorage();\n        return s.pendingAdmin;\n    }\n\n    /**\n     * @notice Address of implementation contract\n     * @return implementation address\n     */\n    function proxyImplementation() public view returns (address) {\n        ProxyStorage storage s = proxyStorage();\n        return s.implementation;\n    }\n\n    /**\n     * @notice Address of pending implementation contract\n     * @return pending implementation address\n     */\n    function pendingProxyImplementation() public view returns (address) {\n        ProxyStorage storage s = proxyStorage();\n        return s.pendingImplementation;\n    }\n\n    /**\n     * @notice Current implementation version for proxy\n     * @return version number\n     */\n    function proxyImplementationVersion() public view returns (uint8) {\n        ProxyStorage storage s = proxyStorage();\n        return s.version;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract.\n     * @dev Returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    function _forwardToImplementation() internal {\n        ProxyStorage storage s = proxyStorage();\n        // delegate all other functions to current implementation\n        (bool success, ) = s.implementation.delegatecall(msg.data);\n\n        assembly {\n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize())\n\n              switch success\n              case 0 { revert(free_mem_ptr, returndatasize()) }\n              default { return(free_mem_ptr, returndatasize()) }\n        }\n    }\n}"
    }
  }
}}