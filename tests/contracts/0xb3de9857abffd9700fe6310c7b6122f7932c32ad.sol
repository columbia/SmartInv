{{
  "language": "Solidity",
  "sources": {
    "contracts/Comics/MimeticComic.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\nimport { ERC721 } from \"./ERC721/ERC721.sol\";\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport { IMimeticComic } from \"./IMimeticComic.sol\";\r\nimport { Base64 } from \"./Base64.sol\"; \r\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport { IMirror } from \"./IMirror.sol\";\r\nimport { IERC2981 } from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\n\r\n/**\r\n * @title Mimetic Comic w/ Phantom Ownership\r\n * @author @nftchance and @masonthechain \r\n * @dev Implementation of EIP-721 Non-Fungible Token Standard, including the \r\n *      Metadata extension and combining with the usage of Mimetic Metadata, \r\n *      Phantom Ownership, and EIP-2309. Many of the features included in this \r\n *      contract will be limited time use / reserved for the future. \r\n * @dev The use of hooks is not enabled by default which will leave some \r\n *      indexers not having the most up to date ownership record. Hooks solve \r\n *      this, however full benefits can only be enjoyed after migration.\r\n */\r\ncontract MimeticComic is\r\n      ERC721\r\n    , Ownable\r\n    , IMimeticComic\r\n{\r\n    using Strings for uint8;\r\n    using Strings for uint256;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    TOKEN METADATA STORAGE/LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    ///@dev Comic series metadata info and redemption time period.\r\n    struct Series {\r\n        string description;     // Token description in displays\r\n        string ipfsHash;        // Comic book cover\r\n        uint256 issuanceEnd;    // When this issue can no longer be focused\r\n    }\r\n\r\n    ///@dev Comic series index to series data.\r\n    mapping(uint8 => Series) public seriesToSeries;\r\n\r\n    ///@dev Token id to comic series index.\r\n    mapping(uint256 => uint256) internal tokenToSeries;\r\n\r\n    ///@dev Number of comic series indexes stored in a single index.\r\n    uint256 public constant PACKED = 64;\r\n    \r\n    ///@dev Number of bytes a series can take up.\r\n    uint256 public constant PACKED_SHIFT = 4;\r\n    \r\n    ///@dev Number of tokens required for end-of-road redemption.\r\n    uint256 public constant REDEMPTION_QUALIFIER = 13;\r\n\r\n    ///@dev Nuclear Nerds token id to comic wildcard condition truth.\r\n    mapping(uint256 => bool) internal nerdToWildcard;\r\n\r\n    ///@dev The default description of the collection and tokens.\r\n    string private collectionDescription;\r\n\r\n    ///@dev Disclaimer message appended to wildcard tokens for buyer safety.\r\n    string private wildcardDescription;\r\n\r\n    ///@dev Disclaimer message appended to tokens that have been redeemed.\r\n    string private redeemedDescription;\r\n\r\n    ///@dev Management of redemption booleans bitpacked to lower storage needs.\r\n    ///@notice `tokens` as it is a bitpacked mapping returned.\r\n    mapping(uint256 => uint256) public tokensToRedeemed;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                      COLLECTION STATE MANAGEMENT\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    ///@dev Controls whether or not wildcards can be loaded.\r\n    bool public wildcardsLocked;\r\n\r\n    ///@dev Controls whether or not master actions can be called.\r\n    bool public masterLocked;\r\n\r\n    ///@dev Controls all series progression within the collection.\r\n    bool public locked;\r\n\r\n    ///@dev Nuclear Nerd contracts that call transferHooks upon transfer.\r\n    mapping(address => bool) public hooks;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ROYALTY LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    ///@dev IPFS hash to the contract URI json.\r\n    string public contractURIHash;\r\n\r\n    ///@dev On-chain royalty basis points.\r\n    uint256 public royaltyBasis = 690;\r\n    \r\n    ///@dev The floating point percentage used for royalty calculation.\r\n    uint256 private constant percentageTotal = 10000;\r\n\r\n    ///@dev Team address that receives royalties from secondary sales.\r\n    address public royaltyReceiver;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    ///@dev EIP-2309 standard for more efficient ownership indexing events.\r\n    event ConsecutiveTransfer(\r\n          uint256 indexed fromTokenId\r\n        , uint256 toTokenId\r\n        , address indexed fromAddress\r\n        , address indexed toAddress\r\n    );\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    error CollectionStateInvalid();\r\n    error CollectionMasterLocked();\r\n    error CollectionWildcardsLocked();\r\n\r\n    error HookCallerMismatch();\r\n\r\n    error TokenMinted();\r\n    error TokenDoesNotExist();\r\n    error TokenOwnerMismatch();\r\n    error TokenNotWildcard();\r\n    error TokenBundleInvalid();\r\n    error TokenRedeemed();\r\n\r\n    error SeriesNotLoaded();\r\n    error SeriesAlreadyLoaded();\r\n    error SeriesAlreadyLocked();\r\n    error SeriesNotLocked();\r\n    error SeriesDirectionProhibited();\r\n    error SeriesBundleInvalid();\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n          string memory _name\r\n        , string memory _symbol\r\n        , string memory _seriesZeroDescription\r\n        , string memory _seriesZeroHash\r\n        , string memory _collectionDescription\r\n        , string memory _wildcardDescription\r\n        , string memory _redeemedDescription        \r\n        , address _nerds\r\n        , address _royaltyReceiver\r\n        , string memory _contractURIHash\r\n    ) ERC721(\r\n          _name\r\n        , _symbol\r\n        , _nerds\r\n    ) {\r\n        ///@dev Initialize series 0 that everyone starts with.\r\n        seriesToSeries[0] = Series(\r\n              _seriesZeroDescription\r\n            , _seriesZeroHash\r\n            , 42069\r\n        );\r\n\r\n        collectionDescription = _collectionDescription;\r\n        wildcardDescription = _wildcardDescription;\r\n        redeemedDescription = _redeemedDescription;\r\n\r\n        royaltyReceiver = _royaltyReceiver;\r\n        contractURIHash = _contractURIHash;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              MODIFIERS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    ///@dev Prevents master locked actions.\r\n    modifier onlyMasterUnlocked() {\r\n        if(masterLocked) revert CollectionMasterLocked();\r\n        _;\r\n    }\r\n\r\n    ///@dev Prevents unlocked actions.\r\n    modifier onlyUnlocked() {\r\n        if(locked) revert SeriesAlreadyLocked();\r\n        _;\r\n    }\r\n\r\n    ///@dev Prevents locked actions.\r\n    modifier onlyLocked() {\r\n        if(!locked) revert SeriesNotLocked();\r\n        _;\r\n    }\r\n\r\n    ///@dev Prevents actions not on a non-loaded series.\r\n    modifier onlyLoaded(uint8 _series) {\r\n        if(bytes(seriesToSeries[_series].ipfsHash).length == 0)\r\n            revert SeriesNotLoaded();\r\n        _;\r\n    }\r\n\r\n    ///@dev Prevents actions on tokenIds greater than max supply.\r\n    modifier onlyInRange(uint256 _tokenId) {\r\n        if(_tokenId > MAX_SUPPLY - 1) revert TokenDoesNotExist();\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        METADATA INTILIAZATION\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Allows the Nuclear Nerds team migrate the primary Nuclear\r\n     *         Nerds collection without having to migrate comics and \r\n     *         having instant updates as the comics would follow the migration.\r\n     *         As soon as utilization has completed the enabling of\r\n     *         master lock will prevent this function from ever being used\r\n     *         again. Contract ownership is delegated to multi-sig for \r\n     *         maximum security.\r\n     * @notice THIS WOULD NOT BE IMPLEMENTED IF IT WAS NOT NEEDED. ;) \r\n     *         (Short time horizon on the usage and locking.)\r\n     * @param _mirror The address of the parent token to mirror ownership of.\r\n     * \r\n     * Requires:\r\n     * - sender must be contract owner\r\n     * - `masterLocked` must be false (default value)\r\n     */\r\n    function loadMirror(\r\n        address _mirror\r\n    )\r\n        public\r\n        virtual\r\n        onlyMasterUnlocked()\r\n        onlyOwner()\r\n    { \r\n        mirror = IMirror(_mirror);\r\n    }\r\n\r\n    /**\r\n     * @notice Loads the wildcards that have direct redemption at the\r\n     *         locking-point for physical transformation.\r\n     * @dev This function can only be ran once so that wildcards cannot\r\n     *      be adjusted past the time of being established.\r\n     * @param _tokenIds The ids of the tokens that are wildcards.\r\n     * \r\n     * Requires:\r\n     * - sender must be contract owner\r\n     * - `wildcardsLocked` hash must be false (default value).\r\n     */\r\n    function loadWildcards(\r\n        uint256[] calldata _tokenIds\r\n    )\r\n        public\r\n        virtual\r\n        onlyOwner()\r\n    {\r\n        if(wildcardsLocked) revert CollectionWildcardsLocked();\r\n        \r\n        wildcardsLocked = true;\r\n\r\n        for(\r\n            uint8 i;\r\n            i < _tokenIds.length;\r\n            i++\r\n        ) {\r\n            nerdToWildcard[_tokenIds[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows token holders to emit an event with\r\n     *         'refreshed' ownership that using the mirrored ownership\r\n     *         of the parent token. This way, indexers will pick up the new\r\n     *         ownership for far cheaper still without having to write \r\n     *         ownership.\r\n     * @notice Does not update the real ownership state and merely notifies the\r\n     *         platforms of an ownership record 'change' that they need \r\n     *         to catalog.\r\n     * @dev This is not needed for primary-use however, this is here for\r\n     *      future-proofing backup for any small issues that \r\n     *      take place upon delivery or future roll outs of new platforms. The \r\n     *      primary of this use would be that the comic has not been seperated, \r\n     *      but has found it's in a smart contract that needs the hook to \r\n     *      complete processing.\r\n     *\r\n     * Requires:\r\n     * - `masterLocked` must be false.\r\n     * - token must NOT be claimed\r\n     * - sender must be owner of the token.\r\n     */\r\n    function refreshToken(\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        onlyMasterUnlocked()\r\n    {\r\n        if(_exists(_tokenId)) revert TokenMinted();\r\n  \r\n        address _owner = mirror.ownerOf(_tokenId);\r\n        \r\n        if(_msgSender() != _owner) revert TokenOwnerMismatch();\r\n\r\n        emit Transfer(\r\n              address(this)\r\n            , _owner\r\n            , _tokenId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Bundle version of token refreshing. This can only be called\r\n     *         if all tokens are still paired and the caller is the owner\r\n     *         of all comics being called.\r\n     * @notice Does not update the real ownership state and merely notifies the\r\n     *         platforms of an ownership record 'change' that they need \r\n     *         to catalog.\r\n     *\r\n     * Requires:\r\n     * - `masterLocked` must be false.\r\n     * - all tokens must NOT be claimed.\r\n     * - sender must be owner of all tokens.\r\n     */\r\n    function refreshTokenBundle(\r\n        uint256[] calldata _tokenIds\r\n    )\r\n        public\r\n        onlyMasterUnlocked()\r\n    {\r\n        if(!mirror.isOwnerOf(\r\n              _msgSender()\r\n            , _tokenIds\r\n        )) revert TokenOwnerMismatch();\r\n\r\n        for(\r\n            uint256 i;\r\n            i < _tokenIds.length;\r\n            i++\r\n        ) {\r\n            if(_exists(_tokenIds[i])) revert TokenMinted();\r\n\r\n            emit Transfer(\r\n                  address(this)\r\n                , _msgSender()\r\n                , _tokenIds[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the Nuclear Nerds team to emit an event with\r\n     *         'refreshed' ownership utilizing the mirrored ownership\r\n     *         of the parent token.\r\n     * @notice Does not update the real ownership state and merely notifies the\r\n     *         platforms of an ownership record 'change' that they need \r\n     *         to catalog.\r\n     * @dev This is not needed for primary-use however, this is here for\r\n     *      future-proofing backup for any small issues that \r\n     *      take place upon delivery or future roll outs of new platforms. The \r\n     *      primary of this use would be that the comic has not been seperated, \r\n     *      but has found it's in a smart contract that needs the hook to \r\n     *      complete processing.\r\n     *\r\n     * Requires:\r\n     * - `masterLocked` must be false.\r\n     * - sender must be contract owner.\r\n     */\r\n    function loadCollectionOwners(\r\n          uint256 _fromTokenId\r\n        , uint256 _toTokenId\r\n    )\r\n        public\r\n        onlyMasterUnlocked()\r\n        onlyOwner()\r\n    {\r\n        for(\r\n            uint256 tokenId = _fromTokenId;\r\n            tokenId < _toTokenId;\r\n            tokenId++\r\n        ) { \r\n            address _owner = mirror.ownerOf(tokenId);\r\n\r\n            emit Transfer(\r\n                  address(0)\r\n                , _owner\r\n                , tokenId\r\n            );\r\n\r\n            require(\r\n                _checkOnERC721Received(\r\n                      address(0)\r\n                    , _owner\r\n                    , tokenId\r\n                    , \"\"\r\n                )\r\n                , \"ERC721: transfer to non ERC721Receiver implementer\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the Nuclear Nerds team to emit Transfer events to a \r\n     *         a specific target. \r\n     * @notice Does not update the real ownership state and merely notifies the\r\n     *         platforms of an ownership record 'change' that they need \r\n     *         to catalog.\r\n     * @dev This is not needed for primary-use however,\r\n     *      this is here for future-proofing/backup for any small issues that \r\n     *      take place upon delivery or future roll outs of new platforms.\r\n     * \r\n     * Requires:\r\n     * - `masterLocked` must be false.\r\n     * - sender must be contract owner.\r\n     * - length of `to` must be the same length as the range of token ids.\r\n     */\r\n    function loadCollectionCalldata(\r\n            uint256 _fromTokenId\r\n          , uint256 _toTokenId\r\n          , address[] calldata _to\r\n    )\r\n        public\r\n        onlyMasterUnlocked()\r\n        onlyOwner()\r\n    { \r\n        uint256 length =  _toTokenId - _fromTokenId + 1;\r\n\r\n        if(length != _to.length) revert CollectionStateInvalid();\r\n\r\n        uint256 index;\r\n        for(\r\n            uint256 tokenId = _fromTokenId;\r\n            tokenId <= _toTokenId;\r\n            tokenId++\r\n        ) { \r\n            emit Transfer(\r\n                  address(0)\r\n                , _to[index++]\r\n                , tokenId\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Utilizes EIP-2309 to most efficiently emit the Transfer events\r\n     *         needed to notify the platforms that this token exists.\r\n     * @notice Does not update the real ownership state and merely notifies the\r\n     *         platforms of an ownership record 'change' that they need \r\n     *         to catalog.\r\n     *\r\n     * Requires:\r\n     * - `masterLocked` must be false.\r\n     * - sender must be contract owner\r\n     */\r\n    function loadCollection2309(\r\n            uint256 _fromTokenId\r\n          , uint256 _toTokenId\r\n    ) \r\n        public\r\n        onlyMasterUnlocked()\r\n        onlyOwner()\r\n    { \r\n        emit ConsecutiveTransfer(\r\n              _fromTokenId\r\n            , _toTokenId\r\n            , address(0)\r\n            , address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Utilizes EIP-2309 to refresh the ownership of tokens in a \r\n     *         collective batch. This is to be fired after tokens have been \r\n     *         minted.\r\n     * @notice Does not update the real ownership state and merely notifies the\r\n     *         platforms of an ownership record 'change' that they need \r\n     *         to catalog.\r\n     *\r\n     * Requires:\r\n     * - `masterLocked` must be false.\r\n     * - sender must be contract owner\r\n     */\r\n    function loadCollection2309From(\r\n            uint256 _fromTokenId\r\n          , uint256 _toTokenId\r\n          , address _from\r\n    ) \r\n        public\r\n        onlyMasterUnlocked()\r\n        onlyOwner()\r\n    { \r\n        emit ConsecutiveTransfer(\r\n              _fromTokenId\r\n            , _toTokenId\r\n            , _from\r\n            , address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Utilizes EIP-2309 to most efficiently emit the Transfer events\r\n     *         needed to notify the platforms that this token exists of a \r\n     *         specific range of token ids AND receivers.\r\n     * @notice Does not update the real ownership state and merely notifies the\r\n     *         platforms of an ownership record 'change' that they need \r\n     *         to catalog.\r\n     *\r\n     * Requires:\r\n     * - `masterLocked` must be false.\r\n     * - sender must be contract owner\r\n     */\r\n    function loadCollection2309To(\r\n            uint256 _fromTokenId\r\n          , uint256 _toTokenId\r\n          , address _to\r\n    ) \r\n        public\r\n        onlyMasterUnlocked()\r\n        onlyOwner()\r\n    { \r\n        emit ConsecutiveTransfer(\r\n              _fromTokenId\r\n            , _toTokenId\r\n            , address(0)\r\n            , _to\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows owners of contract to initialize a new series of \r\n     *         the comic as Chapter 12 cannot be published on the same\r\n     *         day as Chapter 1.\r\n     * @dev Fundamentally, a series is 'just' an IPFS hash.\r\n     * @param _series The index of the series being initialized.\r\n     * @param _ipfsHash The ipfs hash of the cover image of the series.\r\n     * @param _issuanceEnd When the issue can no longer be focused.\r\n     * \r\n     * Requires:\r\n     * - `locked` must be false.\r\n     * - sender must be contract owner\r\n     * `_series` hash must not be set.\r\n     */\r\n    function loadSeries(\r\n          uint8 _series\r\n        , string memory _description\r\n        , string memory _ipfsHash\r\n        , uint256 _issuanceEnd\r\n    )\r\n        override\r\n        public\r\n        virtual\r\n        onlyUnlocked()\r\n        onlyOwner()\r\n    {\r\n        if(bytes(seriesToSeries[_series].ipfsHash).length != 0) {\r\n            revert SeriesAlreadyLoaded();\r\n        }\r\n\r\n        seriesToSeries[_series] = Series(\r\n              _description\r\n            , _ipfsHash\r\n            , _issuanceEnd\r\n        );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            LOCK MANAGEMENT\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Locks the emission of Nuclear Nerd team member called \r\n     *         loadCollection(x). By default this will remain open,\r\n     *         however with time and the completed release of series\r\n     *         the community may prefer the contract reach a truly \r\n     *         immutable and decentralized state.\r\n     *\r\n     * Requires:\r\n     * - sender must be contract owner\r\n     */\r\n    function masterLock()\r\n        public\r\n        virtual\r\n        onlyOwner()\r\n    {\r\n        masterLocked = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Locks the series upgrading of the collection preventing any\r\n     *         further series from being added and preventing holders\r\n     *         from upgrading their series any further.\r\n     * \r\n     * Requires:\r\n     * - sender must be contract owner\r\n     */\r\n    function lock()\r\n        override\r\n        public\r\n        virtual\r\n        onlyOwner()\r\n    {     \r\n        locked = true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            HOOK MANAGEMENT\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Allows The Nuclear Nerd team to connect Transfer hooks\r\n     *         to the comic state of a token.\r\n     * @dev Future feature. This can also be completely disabled and \r\n     *      then locked to prevent any new team additions of hook contracts.\r\n     * @param _hook The address of the contract to accept an incoming \r\n     *              event from.\r\n     * \r\n     * Requires:\r\n     * - `masterLocked` must be false.\r\n     * - sender must be contract owner.\r\n     */\r\n    function toggleHook(\r\n        address _hook\r\n    )\r\n        public\r\n        onlyMasterUnlocked()\r\n        onlyOwner()\r\n    {\r\n        hooks[_hook] = !hooks[_hook];\r\n    }\r\n\r\n    /**\r\n     * @notice Handles the processing when a parent token of this\r\n     *         is transferred. To be procesed within the handling of \r\n     *         of the parent token. With this, ownership\r\n     *         of the child token will update immediately across all\r\n     *         indexers, marketplaces and tools.\r\n     * @dev Only emits an event for children tokens that haven't been seperated.\r\n     * @param _from The address transferring the parent token.\r\n     * @param _to The address transferring the child token.\r\n     * @param _tokenId The id of the parent:child token being transferred.\r\n     * \r\n     * Requires:\r\n     * - sender must be an enabled hook contract.\r\n     */\r\n    function transferHook(\r\n          address _from\r\n        , address _to\r\n        , uint256 _tokenId\r\n    )\r\n        public\r\n        virtual\r\n    {\r\n        if(!hooks[_msgSender()]) revert HookCallerMismatch();\r\n\r\n        if(!_exists(_tokenId)) {\r\n            delete _tokenApprovals[_tokenId][_from];\r\n            emit Approval(\r\n                  _from\r\n                , address(0)\r\n                , _tokenId\r\n            );\r\n\r\n            emit Transfer(\r\n                  _from\r\n                , _to\r\n                , _tokenId\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Handles the processing when a parent token of this\r\n     *         is transferred. To be procesed within the handling of \r\n     *         of the parent token. With this, ownership\r\n     *         of the child token will update immediately across all\r\n     *         indexers, marketplaces and tools.\r\n     * @dev Only emits an event for children tokens that haven't been seperated.\r\n     * @param _from The address transferring the parent token.\r\n     * @param _to The address transferring the child token.\r\n     * @param _tokenId The id of the parent:child token being transferred.\r\n     * \r\n     * Requires:\r\n     * - sender must be an enabled hook contract.\r\n     */\r\n    function safeTransferHook(\r\n          address _from\r\n        , address _to\r\n        , uint256 _tokenId\r\n        , bytes memory _data\r\n    )\r\n        public\r\n        virtual\r\n    {\r\n        if(!hooks[_msgSender()]) revert HookCallerMismatch();\r\n\r\n        if(!_exists(_tokenId)) {\r\n            delete _tokenApprovals[_tokenId][_from];\r\n            emit Approval(\r\n                  _from\r\n                , address(0)\r\n                , _tokenId\r\n            );\r\n\r\n            emit Transfer(\r\n                  _from\r\n                , _to\r\n                , _tokenId\r\n            );\r\n\r\n            require(\r\n                  _checkOnERC721Received(\r\n                        _from\r\n                      , _to\r\n                      , _tokenId\r\n                      , _data\r\n                  )\r\n                , \"ERC721: transfer to non ERC721Receiver implementer\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            COMIC METADATA\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Returns the ipfs image url.\r\n     * @param _series The index of the series we are getting the image for.\r\n     * @return ipfsString The url to ipfs where the image is represented. \r\n     * \r\n     * Requires:\r\n     * - Series index provided must be loaded.\r\n     * - Token of id must exist.\r\n     */\r\n    function seriesImage(\r\n        uint8 _series\r\n    )\r\n        override\r\n        public\r\n        virtual\r\n        view\r\n        onlyLoaded(_series)\r\n        returns (\r\n            string memory ipfsString\r\n        )\r\n    {\r\n        ipfsString = string(\r\n            abi.encodePacked(\r\n                  \"ipfs://\"\r\n                , seriesToSeries[_series].ipfsHash\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the series JSON metadata that conforms to standards.\r\n     * @dev The response from this function is not intended for on-chain usage.\r\n     * @param _series The index of the series we are getting the image for.\r\n     * @return metadataString The JSON string of the metadata that represents\r\n     *                        the supplied series. \r\n     * \r\n     * Requires:\r\n     * - Series index provided must be loaded.\r\n     * - Token of id must exist.\r\n     */\r\n    function seriesMetadata(\r\n          uint8 _series\r\n        , uint256 _tokenId\r\n        , bool redeemed\r\n        , bool exists\r\n        , bool wildcard\r\n        , uint256 votes\r\n    ) \r\n        override\r\n        public\r\n        virtual\r\n        view\r\n        onlyLoaded(_series)\r\n        returns (\r\n            string memory metadataString\r\n        )\r\n    {\r\n        ///@dev Append active series \r\n        ///@note Nerds special prologue of #00 and all series below 10 are 0 padded\r\n        metadataString = string(\r\n            abi.encodePacked(\r\n                  '{\"trait_type\":\"Series\",\"value\":\"#'\r\n                , _series < 10 ? string(\r\n                    abi.encodePacked(\r\n                          \"0\"\r\n                        , _series.toString()\r\n                    )\r\n                ) : _series.toString()\r\n                , '\"},'\r\n            )\r\n        );\r\n\r\n        ///@dev Reflect the state of the series the comic is currently at\r\n        ///@note Minting if issues is still open -- Limited if issues is closed and no more comics can evolve to this stage (series supply is functionally max supply locked)\r\n        metadataString = string(\r\n            abi.encodePacked(\r\n                  metadataString\r\n                , string(\r\n                    abi.encodePacked(\r\n                         '{\"trait_type\":\"Edition\",\"value\":\"'\r\n                        , seriesToSeries[_series].issuanceEnd < block.timestamp ? \"Limited\" : \"Minting\"\r\n                        , '\"},'\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        \r\n        ///@dev Append metadata to reflect the Pairing Status of the token\r\n        ///@note When appended the ownership of the token is automatically updating until the pairing is broken through transferring or claiming.\r\n        metadataString = string(\r\n            abi.encodePacked(\r\n                  metadataString\r\n                , string(\r\n                    abi.encodePacked(\r\n                        '{\"trait_type\":\"Nerd\",\"value\":\"'\r\n                        , !exists ? string(\r\n                            abi.encodePacked(\r\n                                  \"#\"\r\n                                , _tokenId.toString()\r\n                            )\r\n                        ) : \"Unpaired\"\r\n                        , '\"},'\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        ///@dev Adds the Schrodinger trait if applicable and reflects the status of usage\r\n        if(wildcard) { \r\n            metadataString = string(\r\n                abi.encodePacked(\r\n                      metadataString\r\n                    , '{\"trait_type\":\"Schrodinger'\r\n                    , \"'\"\r\n                    , 's Cat\",\"value\":\"'\r\n                    , redeemed ? \"Dead\" : \"Alive\"\r\n                    , '\"},'\r\n                )\r\n            );\r\n\r\n        ///@dev Show whether or not the token has been used for the physical comic redemption -- does not show on Schrodingers\r\n        } else { \r\n            metadataString = string(\r\n                abi.encodePacked(\r\n                      metadataString\r\n                    , string(\r\n                        abi.encodePacked(\r\n                            '{\"trait_type\":\"Status\",\"value\":\"'\r\n                            , redeemed ? \"Redeemed\" : \"Unredeemed\"\r\n                            , '\"},'\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n        }\r\n\r\n        ///@dev Reflect the current number of Story Votes the owner of a Comic token earns through ownership.\r\n        metadataString = string(\r\n            abi.encodePacked(\r\n                  metadataString\r\n                , string(\r\n                    abi.encodePacked(\r\n                        '{\"display_type\":\"number\",\"trait_type\":\"Story Votes\",\"value\":\"'\r\n                        , votes.toString()\r\n                        , '\",\"max_value\":\"12\"}'\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the active series of the token to be retrieved.\r\n     * @dev Pick the number out from where it lives. All this does is pull down\r\n     *      the number that we've stored in the data packed index. With the \r\n     *      cumulative number in hand we nagivate into the proper bits and \r\n     *      make sure we return the properly cased number.\r\n     * @param _tokenId The token to retrieve the comic book series for.\r\n     * @return series The index of the series the retrieved comic represents.\r\n     * \r\n     * Requires:\r\n     * - token id must exist\r\n     */\r\n    function tokenSeries(\r\n        uint256 _tokenId\r\n    )\r\n        override\r\n        public\r\n        virtual\r\n        view\r\n        onlyInRange(_tokenId)\r\n        returns (\r\n            uint8 series\r\n        )\r\n    {\r\n        series = uint8(\r\n            (\r\n                tokenToSeries[_tokenId / PACKED] >> (\r\n                    (_tokenId % PACKED) * PACKED_SHIFT\r\n                )\r\n            ) & 0xF\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of votes for a token.\r\n     * @param _tokenId The comic tokenId to check votes for.\r\n     * @return The number of votes the token actively contributes. \r\n     * \r\n     * Requires:\r\n     * - token id must exist\r\n     */\r\n    function tokenVotes(\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        virtual\r\n        view\r\n        onlyInRange(_tokenId)\r\n        returns (\r\n            uint8\r\n        ) \r\n    {\r\n        if(nerdToWildcard[_tokenId]) return 12;\r\n        \r\n        return tokenSeries(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Determines if a Comic has been used for redemption.\r\n     * @param _tokenId The comic tokenId being checked.\r\n     * @return bool url to ipfs where the image is represented.\r\n     * \r\n     * Requires:\r\n     * - token id must exist\r\n     */\r\n    function tokenRedeemed(\r\n        uint256 _tokenId\r\n    )\r\n        public \r\n        view \r\n        onlyInRange(_tokenId)\r\n        returns(\r\n            bool\r\n        )\r\n    {\r\n        uint256 flag = (\r\n            tokensToRedeemed[_tokenId / 256] >> _tokenId % 256\r\n        ) & uint256(1);\r\n\r\n        return (flag == 1 ? true : false);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the ipfs image url for a given token.\r\n     * @param _tokenId The comic tokenId desired to be updated.\r\n     * @return The url to ipfs where the image is represented.\r\n     * \r\n     * Requires:\r\n     * - token id must exist\r\n     */\r\n    function tokenImage(\r\n        uint256 _tokenId\r\n    )\r\n        override\r\n        public\r\n        virtual\r\n        view\r\n        onlyInRange(_tokenId)\r\n        returns (\r\n            string memory\r\n        )\r\n    {\r\n        return seriesImage(tokenSeries(_tokenId));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the series JSON metadata that conforms to standards.\r\n     * @dev The response from this function is not intended for on-chain usage.\r\n     * @param _tokenId The comic tokenId desired to be updated.\r\n     * @return The JSON string of the metadata that represents\r\n     *         the supplied series.\r\n     * \r\n     * Requires:\r\n     * - token id must exist\r\n     */\r\n    function tokenMetadata(\r\n        uint256 _tokenId\r\n    ) \r\n        override\r\n        public\r\n        virtual\r\n        view\r\n        onlyInRange(_tokenId)\r\n        returns (\r\n            string memory\r\n        )\r\n    {\r\n        return seriesMetadata(\r\n              tokenSeries(_tokenId)\r\n            , _tokenId\r\n            , tokenRedeemed(_tokenId)\r\n            , _exists(_tokenId)\r\n            , nerdToWildcard[_tokenId]\r\n            , tokenVotes(_tokenId)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Generates the on-chain metadata for each non-fungible 1155.\r\n     * @param _tokenId The id of the token to get the uri data for.\r\n     * @return uri encoded json in the form of a string detailing the \r\n     *         retrieved token.\r\n     * \r\n     * Requires:\r\n     * - token id must exist\r\n     */\r\n    function tokenURI(\r\n        uint256 _tokenId\r\n    )\r\n        override\r\n        public\r\n        virtual\r\n        view\r\n        onlyInRange(_tokenId)\r\n        returns (\r\n            string memory uri\r\n        )        \r\n    { \r\n        uint8 series = tokenSeries(_tokenId);\r\n\r\n        uri = seriesToSeries[series].description;\r\n\r\n        if(nerdToWildcard[_tokenId]) { \r\n            uri = string(\r\n                abi.encodePacked(\r\n                      uri\r\n                    , wildcardDescription\r\n                )\r\n            );\r\n        }\r\n\r\n        if(tokenRedeemed(_tokenId)) { \r\n            uri = string(\r\n                abi.encodePacked(\r\n                      uri\r\n                    , redeemedDescription\r\n                )\r\n            );\r\n        }\r\n\r\n        // Build the metadata string and return it as encoded data\r\n        uri = string(\r\n            abi.encodePacked(\r\n                  \"data:application/json;base64,\"\r\n                , Base64.encode(\r\n                    bytes(  \r\n                        abi.encodePacked(\r\n                              '{\"name\":\"Nuclear Nerds Comic #'\r\n                            , _tokenId.toString()\r\n                            , '\",\"description\":\"'\r\n                            , collectionDescription\r\n                            , uri\r\n                            , '\",\"image\":\"'\r\n                            , seriesImage(series)\r\n                            , '?owner='\r\n                            , Strings.toHexString(\r\n                                    uint160(ownerOf(_tokenId))\r\n                                , 20\r\n                             )\r\n                            , '\",\"attributes\":['\r\n                            , tokenMetadata(_tokenId)\r\n                            , ']}'\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to assist in determining whether a Nuclear Nerd\r\n     *         has been used to claim a comic.\r\n     * @dev This function will return false if even one of the tokenId \r\n     *      parameters has been previously used to claim.\r\n     * @param _tokenIds The tokenIds of the Nuclear Nerds being checked \r\n     *                  for their claiming status.\r\n     */\r\n    function isClaimable(\r\n        uint256[] calldata _tokenIds\r\n    ) \r\n        public\r\n        view\r\n        returns (\r\n            bool\r\n        )\r\n    {\r\n        for(\r\n            uint256 i; \r\n            i < _tokenIds.length;\r\n            i++\r\n        ) {\r\n            if(_exists(_tokenIds[i])) \r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to used to determine if an array of \r\n     *         tokens can still be used to redeem a physical.\r\n     * @dev This function will return false if even one of the tokenId\r\n     *      parameters has been previously used to claim.\r\n     * @param _tokenIds The tokenIds of the comcis being checked.\r\n     */\r\n    function isRedeemable(\r\n        uint256[] calldata _tokenIds\r\n    )\r\n        public\r\n        view \r\n        returns ( \r\n            bool\r\n        )\r\n    {\r\n        for(\r\n            uint256 i;\r\n            i < _tokenIds.length;\r\n            i++ \r\n        ) { \r\n            if(tokenRedeemed(_tokenIds[i]))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            COMIC CONTROL\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Allows holders of a Nuclear Nerd to claim a comic.\r\n     * @dev This mint function acts as the single token call for claiming\r\n     *      multiple tokens at a time.\r\n     * @param _tokenId The tokenId of the Nuclear Nerd being used \r\n     *                  to claim a Comic.\r\n     * \r\n     * Requires:\r\n     * - sender must be owner of mirrored token.\r\n     * - token of id must NOT exist.\r\n     */\r\n    function claimComic(\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        virtual\r\n    {\r\n        if (\r\n            mirror.ownerOf(_tokenId) != _msgSender()\r\n        ) revert TokenOwnerMismatch();\r\n\r\n        _mint(\r\n              _msgSender()\r\n            , _tokenId\r\n        );\r\n    }    \r\n\r\n    /**\r\n     * @notice Allows holders of Nuclear Nerds to claim a comic for each \r\n     *         Nerd they own.\r\n     * @dev This function should be used with reason in mind. A holder with 100 \r\n     *      Nerds is far more likely to have a Nerd purchased in a\r\n     *      long-pending transaction given low gas urgency. \r\n     * @param _tokenIds The tokenIds of the Nuclear Nerds being used \r\n     *                  to claim Comics.\r\n     * \r\n     * Requires:\r\n     * - sender must be owner of all mirrored tokens.\r\n     * - all ids of token must NOT exist.\r\n     */\r\n    function claimComicBundle(\r\n          uint256[] calldata _tokenIds\r\n    ) \r\n        public\r\n        virtual \r\n    {\r\n        if(!mirror.isOwnerOf(\r\n              _msgSender()\r\n            , _tokenIds\r\n        )) revert TokenOwnerMismatch();\r\n\r\n        for(\r\n            uint256 i; \r\n            i < _tokenIds.length;\r\n            i++\r\n        ) {\r\n            _mint(\r\n                  _msgSender()\r\n                , _tokenIds[i]\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @notice Focuses a specific comic on a specific series.\r\n     * @dev Every _series has at most 8 bits so we can bitpack 32 of them \r\n     *      (8 * 32 = 256) into a single storage slot of a uint256. \r\n     *      This saves a significant amount of money because setting a \r\n     *      non-zero slot consumes 20,000 gas where as it only costs 5,000 \r\n     *      gas. So it is cheaper to store 31/32 times.\r\n     * \r\n     * Requires:\r\n     * - series being upgraded to must have been loaded.\r\n     * - message sender must be the token owner.\r\n     * - comic cannot be downgraded.\r\n     * - cannot upgrade to series with closed issuance.\r\n     */\r\n    function _focusSeries(\r\n          uint8 _series\r\n        , uint256 _tokenId\r\n    )\r\n        internal\r\n        onlyLoaded(_series)\r\n    {        \r\n        if(_msgSender() != ownerOf(_tokenId)) revert TokenOwnerMismatch();\r\n    \r\n        uint256 seriesIndex = _tokenId / PACKED;\r\n        uint256 bitShift = (_tokenId % PACKED) * PACKED_SHIFT;\r\n\r\n        if(uint8(\r\n            (tokenToSeries[seriesIndex] >> bitShift) & 0xF\r\n        ) > _series) revert SeriesDirectionProhibited();\r\n\r\n        if(seriesToSeries[_series].issuanceEnd < block.timestamp) {\r\n            revert SeriesAlreadyLocked();\r\n        }\r\n\r\n        tokenToSeries[seriesIndex] =\r\n              (tokenToSeries[seriesIndex] & ~(0xF << bitShift)) \r\n            | (uint256(_series) << bitShift);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the holder of a comic to progress\r\n     *         the comic token to a subsequent issued series.\r\n     * @dev Once a comic has progressed to the next issued series,\r\n     *      it cannot be reverted back to a previous series.\r\n     * @dev A token can progress from an early series to any series\r\n     *      in the future provided Comics have not been locked.\r\n     * @param _series The desired series index.\r\n     * @param _tokenId The comic tokenId desired to be updated.\r\n     *\r\n     * Requires:\r\n     * - series of index must be unlocked.\r\n     */\r\n    function focusSeries(\r\n          uint8 _series\r\n        , uint256 _tokenId\r\n    ) \r\n        override\r\n        public\r\n        virtual\r\n        onlyUnlocked()\r\n    {\r\n        _focusSeries(\r\n              _series\r\n            , _tokenId\r\n        );\r\n    }\r\n \r\n    /**\r\n     * @notice Allows the holder to focus multiple comics with multiple series\r\n     *         in the same transaction so that they can update a series of\r\n     *         comics all at once without having to go through pain.\r\n     * @dev Once a comic has progressed to the next issued series,\r\n     *      it cannot be reverted back to a previous series.\r\n     * @dev A token can progress from an early series to any series\r\n     * @param _series The array of desired series to be focused by tokenId.\r\n     * @param _tokenIds The array of tokenIds to be focused.\r\n     *\r\n     * Requires:\r\n     * - series of index must be unlocked.\r\n     * - series array and token id array lengths must be the same.\r\n     */\r\n    function focusSeriesBundle(\r\n          uint8[] calldata _series\r\n        , uint256[] calldata _tokenIds\r\n    ) \r\n        public\r\n        virtual\r\n        onlyUnlocked()\r\n    {\r\n        if(_series.length != _tokenIds.length) revert SeriesBundleInvalid();\r\n\r\n        for(\r\n            uint256 i;\r\n            i < _series.length;\r\n            i++\r\n        ) {\r\n            _focusSeries(\r\n                  _series[i]\r\n                , _tokenIds[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Toggles the redemption stage for a token id.\r\n     * @dev Implements the boolean bitpacking of 256 values into a single \r\n     *      storage slot. This means, that while we've created a gas-consuming\r\n     *      mechanism we've minimized cost to the highest extent. A boolean is \r\n     *      only 1 bit of information, but is typically 8 bits in solidity.\r\n     *      With bitpacking, we can stuff 256 values into a single storage slot\r\n     *      making it cheaper for the following 255 comics. This cost-savings \r\n     *      scales through the entire collection.\r\n     * \r\n     * Requires:\r\n     * - message sender must be the token owner\r\n     * - cannot already be redeemed\r\n     */\r\n    function _redeemComic(\r\n        uint256 _tokenId\r\n    )\r\n        internal\r\n    {\r\n        if(ownerOf(_tokenId) != _msgSender()) revert TokenOwnerMismatch();\r\n\r\n        uint256 tokenIndex = _tokenId / 256;\r\n        uint256 tokenShift =  _tokenId % 256;\r\n\r\n        if(((\r\n            tokensToRedeemed[tokenIndex] >> tokenShift\r\n        ) & uint256(1)) == 1) revert TokenRedeemed();\r\n\r\n        tokensToRedeemed[tokenIndex] = (\r\n            tokensToRedeemed[tokenIndex] | uint256(1) << tokenShift\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows a holder to redee an array of tokens.\r\n     * @dev The utilization of this function is not fully gated, though the \r\n     *      return for 'redeeming comics' is dependent on external criteria. \r\n     *      Nothing is earned or entitled by the redemption of a Comic unless \r\n     *      in the defined times and opportunities.\r\n     * @dev Interface calls are extremely expensive. It is worthwhile to use \r\n     *      the higher level processing that is available.\r\n     * @param _tokenIds The ids of the tokens to redeem.\r\n     *\r\n     * Requires:\r\n     * - collection evolution must be locked preventing any future focusing.\r\n     * - token ids array length must be equal to redemption capacity\r\n     */\r\n    function redeemComics(\r\n          uint256[] calldata _tokenIds\r\n    ) \r\n        public\r\n        virtual\r\n        onlyLocked()\r\n    {\r\n        if(\r\n            _tokenIds.length != REDEMPTION_QUALIFIER\r\n        ) revert TokenBundleInvalid();\r\n\r\n        for (\r\n            uint256 i; \r\n            i < _tokenIds.length; \r\n            i++\r\n        ) {\r\n            _redeemComic(_tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows a wildcard holder to redeem their token.\r\n     * @dev The utilization of this function is not fully gated, though the\r\n     *      return for 'redeeming comics' is dependent on external criteria. \r\n     *      Nothing is earned or entitled by the redemption of a Comic unless \r\n     *      in the defined times and opportunities.\r\n     * @dev Interface calls are extremely expensive. It is worthwhile to use \r\n     *      the higher level processing that is available.\r\n     * @param _tokenId The id of the token to redeem.\r\n     *\r\n     * Requires:\r\n     * - collection evolution must be locked preventing any future focusing.\r\n     * - token id must be a wildcard representative of a wildcard Nuclear Nerd.\r\n     */\r\n    function redeemWildcardComic(\r\n        uint256 _tokenId\r\n    ) \r\n        public\r\n        virtual\r\n        onlyLocked()\r\n    {   \r\n        if(!nerdToWildcard[_tokenId]) revert TokenNotWildcard();\r\n\r\n        _redeemComic(_tokenId);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC721 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) \r\n        public \r\n        view \r\n        virtual \r\n        override\r\n        returns (\r\n            bool\r\n        ) \r\n    {\r\n        return\r\n            interfaceId == type(IERC2981).interfaceId ||\r\n            interfaceId == type(IMimeticComic).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC2981 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    /**\r\n     * @notice Allows the Nuclear Nerds team to adjust contract-level metadata\r\n     * @param _contractURIHash The ipfs hash of the contract metadata\r\n     */\r\n    function setContractURI(\r\n        string memory _contractURIHash\r\n    )\r\n        public\r\n        onlyOwner()\r\n    { \r\n        contractURIHash = _contractURIHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the accesible url of the contract level metadata\r\n     */\r\n    function contractURI() \r\n        public \r\n        view \r\n        returns (\r\n            string memory\r\n        ) \r\n    {\r\n        return string(\r\n            abi.encodePacked(\r\n                  \"ipfs://\"\r\n                , contractURIHash\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Allows the Nuclear Nerds team to adjust where royalties\r\n    *         are paid out if necessary.\r\n    * @param _royaltyReceiver The address to send royalties to\r\n    */\r\n    function setRoyaltyReceiver(\r\n        address _royaltyReceiver\r\n    ) \r\n        public \r\n        onlyOwner() \r\n    {\r\n        require(\r\n              _royaltyReceiver != address(0)\r\n            , \"Royalties: new recipient is the zero address\"\r\n        );\r\n\r\n        royaltyReceiver = _royaltyReceiver;\r\n    }\r\n\r\n    /**\r\n    * @notice Allows the Nuclear Nerds team to adjust the on-chain\r\n    *         royalty basis points.\r\n    * @param _royaltyBasis The new basis points earned in royalties\r\n    */\r\n    function setRoyaltyBasis(\r\n        uint256 _royaltyBasis\r\n    )\r\n        public\r\n        onlyOwner()\r\n    {\r\n        royaltyBasis = _royaltyBasis;\r\n    }\r\n\r\n    /**\r\n    * @notice EIP-2981 compliant view function for marketplaces\r\n    *         to calculate the royalty percentage and what address\r\n    *         receives them. \r\n    * @param _salePrice Total price of secondary sale\r\n    * @return address of receiver and the amount of payment to send\r\n    */\r\n    function royaltyInfo(\r\n          uint256\r\n        , uint256 _salePrice\r\n    ) \r\n        public \r\n        view \r\n        returns (\r\n              address\r\n            , uint256\r\n        ) \r\n    {\r\n        return (\r\n              royaltyReceiver\r\n            , (_salePrice * royaltyBasis) / percentageTotal\r\n        );\r\n    }\r\n}"
    },
    "contracts/Comics/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\n\r\nimport { IMirror } from \"../IMirror.sol\";\r\n\r\n/**\r\n * @notice This implementation of ERC721 is focused on mirroring the ownership \r\n *         of an existing collection to provide the initial ownership record.\r\n *         With this, functionally the token deployed is attached to the mirror \r\n *         --> until being detached. <--\r\n *         Once the Comic token has moved wallets independently, it functions \r\n *         as a normal ERC721 with it's own ownership.\r\n */\r\ncontract ERC721 is \r\n      Context\r\n    , ERC165\r\n    , IERC721\r\n    , IERC721Metadata \r\n{\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    ///@dev Token name\r\n    string private _name;\r\n\r\n    ///@dev Token symbol\r\n    string private _symbol;\r\n\r\n    uint256 internal constant MAX_SUPPLY = 8999;\r\n\r\n    ///@dev hard coding in a max range of _owners is required.\r\n    address[MAX_SUPPLY] internal _owners;\r\n\r\n    ///@dev Mapping from token ID to approved address\r\n    ///@notice This is outside of the standard implementation as it is \r\n    ///        token:holder due to an ownership record that mirrors\r\n    ///        the parent. Once a token has been seperated from it's\r\n    ///        parent, approvals are cleared upon transfer. While \r\n    ///        paired, approvals are tied to the owning address.\r\n    ///        This has been accepted as this is also how operator \r\n    ///        approvals function by default.\r\n    mapping(uint256 => mapping(address => address)) internal _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\r\n\r\n    IMirror public mirror;\r\n\r\n    constructor(\r\n          string memory name_\r\n        , string memory symbol_\r\n        , address _mirror\r\n    ) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        mirror = IMirror(_mirror);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) \r\n        public \r\n        view \r\n        virtual \r\n        override(ERC165, IERC165) \r\n        returns (\r\n            bool\r\n        ) \r\n    {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance of address utilizing the existing ownership *         records of comic books / nerds\r\n     * @dev See {IERC721-balanceOf}.\r\n     * @dev This is extremely gassy and IS NOT intended for on-chain usage.\r\n     * @param account The address to check the total balance of.\r\n     * @return Amount of tokens that are owned by account\r\n     */\r\n    function balanceOf(\r\n        address account\r\n    ) \r\n        override\r\n        public\r\n        view \r\n        returns(\r\n            uint256\r\n        ) \r\n    {\r\n        require(\r\n              account != address(0)\r\n            , \"ERC721: balance query for the zero address\"\r\n        );\r\n\r\n        uint256 counter;\r\n\r\n        for (\r\n            uint256 i; \r\n            i < MAX_SUPPLY; \r\n            i++\r\n        ) {\r\n            if (ERC721.ownerOf(i) == account)\r\n                counter++;\r\n        }\r\n\r\n        return counter;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     * @notice Overrides the default functionality of ownerOf() to utilize \r\n     *         phantom ownership of the tokens until they are first\r\n     *         transferred.\r\n     */\r\n    function ownerOf(\r\n        uint256 tokenId\r\n    ) \r\n        public \r\n        view \r\n        virtual \r\n        override \r\n        returns (\r\n            address\r\n        ) \r\n    {\r\n        address _owner = _owners[tokenId];\r\n        \r\n        if(_owner != address(0))\r\n            return _owner;\r\n\r\n        return mirror.ownerOf(tokenId);\r\n    }\r\n    \r\n    /**\r\n     * @notice Returns the entire ownership record of the comic books up to \r\n     *         the max supply.\r\n     */\r\n    function owners()\r\n        external \r\n        view \r\n        returns(\r\n            address[MAX_SUPPLY] memory\r\n        ) \r\n    {\r\n        return _owners;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() \r\n        public \r\n        view \r\n        virtual \r\n        override \r\n        returns (\r\n            string memory\r\n        ) \r\n    {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() \r\n        public \r\n        view \r\n        virtual \r\n        override \r\n        returns (\r\n            string memory\r\n        ) \r\n    {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) \r\n        public \r\n        view \r\n        virtual \r\n        override \r\n        returns (\r\n            string memory\r\n        ) \r\n    {\r\n        require(\r\n              _exists(tokenId)\r\n            , \"ERC721Metadata: URI query for nonexistent token\"\r\n        );\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() \r\n        internal \r\n        view \r\n        virtual \r\n        returns (\r\n            string memory\r\n        ) \r\n    {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(\r\n          address to\r\n        , uint256 tokenId\r\n    ) \r\n        public \r\n        virtual \r\n        override \r\n    {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(\r\n              to\r\n            , tokenId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(\r\n        uint256 tokenId\r\n    ) \r\n        public \r\n        view \r\n        virtual \r\n        override \r\n        returns (\r\n            address\r\n        ) \r\n    {\r\n        require(\r\n              tokenId < MAX_SUPPLY\r\n            , \"ERC721: approved query for nonexistent token\"\r\n        );\r\n\r\n        address _owner = ERC721.ownerOf(tokenId);\r\n\r\n        return _tokenApprovals[tokenId][_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(\r\n          address operator\r\n        , bool approved\r\n    ) \r\n        public \r\n        virtual \r\n        override \r\n    {\r\n        _setApprovalForAll(\r\n              _msgSender()\r\n            , operator\r\n            , approved\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(\r\n          address owner\r\n        , address operator\r\n    ) \r\n        public \r\n        view \r\n        virtual \r\n        override \r\n        returns (\r\n            bool\r\n        ) \r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n          address from\r\n        , address to\r\n        , uint256 tokenId\r\n    ) \r\n        public \r\n        virtual \r\n        override \r\n    {\r\n        require(\r\n          _isApprovedOrOwner(\r\n              _msgSender()\r\n            , tokenId\r\n          )\r\n        , \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(\r\n              from\r\n            , to\r\n            , tokenId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n          address from\r\n        , address to\r\n        , uint256 tokenId\r\n    ) \r\n        public \r\n        virtual \r\n        override \r\n    {\r\n        safeTransferFrom(\r\n              from\r\n            , to\r\n            , tokenId\r\n            , \"\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n          address from\r\n        , address to\r\n        , uint256 tokenId\r\n        , bytes memory _data\r\n    ) \r\n        public \r\n        virtual \r\n        override \r\n    {\r\n        require(\r\n          _isApprovedOrOwner(\r\n              _msgSender()\r\n            , tokenId\r\n          )\r\n        , \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _safeTransfer(\r\n              from\r\n            , to\r\n            , tokenId\r\n            , _data\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking \r\n     *      first that contract recipients are aware of the ERC721 protocol to \r\n     *      prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(\r\n              from\r\n            , to\r\n            , tokenId\r\n        );\r\n\r\n        require(\r\n              _checkOnERC721Received(\r\n                  from\r\n                , to\r\n                , tokenId\r\n                , _data\r\n              )\r\n            , \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(\r\n        uint256 tokenId\r\n    ) \r\n        internal \r\n        view \r\n        virtual \r\n        returns (\r\n            bool\r\n        ) \r\n    {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(\r\n          address spender\r\n        , uint256 tokenId\r\n    ) \r\n        internal \r\n        view \r\n        virtual \r\n        returns (\r\n            bool\r\n        ) \r\n    {\r\n        require(\r\n              tokenId < MAX_SUPPLY\r\n            , \"ERC721: operator query for nonexistent token\"\r\n        );\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (\r\n               spender == owner \r\n            || getApproved(tokenId) == spender \r\n            || isApprovedForAll(owner, spender)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(\r\n          address to\r\n        , uint256 tokenId\r\n    ) \r\n        internal \r\n        virtual \r\n    {\r\n        _safeMint(\r\n              to\r\n            , tokenId\r\n            , \"\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n          address to\r\n        , uint256 tokenId\r\n        , bytes memory _data\r\n    ) \r\n        internal \r\n        virtual \r\n    {\r\n        _mint(\r\n              to\r\n            , tokenId\r\n        );\r\n        require(\r\n              _checkOnERC721Received(\r\n                  address(0)\r\n                , to\r\n                , tokenId\r\n                , _data\r\n              )\r\n            , \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(\r\n          address to\r\n        , uint256 tokenId\r\n    ) \r\n        internal \r\n        virtual \r\n    {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(\r\n              address(0)\r\n            , to\r\n            , tokenId\r\n        );\r\n\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(\r\n              address(0)\r\n            , to\r\n            , tokenId\r\n        );\r\n\r\n        _afterTokenTransfer(\r\n              address(0)\r\n            , to\r\n            , tokenId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(\r\n        uint256 tokenId\r\n    ) \r\n        internal \r\n        virtual \r\n    {\r\n        address _owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(\r\n              _owner\r\n            , address(0)\r\n            , tokenId\r\n        );\r\n\r\n        // Clear approvals\r\n        delete _tokenApprovals[tokenId][_owner];\r\n        emit Approval(\r\n              _owner\r\n            , address(0)\r\n            , tokenId\r\n        );\r\n\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(\r\n              _owner\r\n            , address(0)\r\n            , tokenId\r\n        );\r\n\r\n        _afterTokenTransfer(\r\n              _owner\r\n            , address(0)\r\n            , tokenId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n          address from\r\n        , address to\r\n        , uint256 tokenId\r\n    ) \r\n        internal \r\n        virtual \r\n    {\r\n        address _owner = ERC721.ownerOf(tokenId);\r\n\r\n        require(\r\n              _owner == from\r\n            , \"ERC721: transfer from incorrect owner\"\r\n        );\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(\r\n              from\r\n            , to\r\n            , tokenId\r\n        );\r\n\r\n        // Clear approvals from the previous owner\r\n        delete _tokenApprovals[tokenId][_owner];\r\n        emit Approval(\r\n              _owner\r\n            , address(0)\r\n            , tokenId\r\n        );\r\n\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(\r\n              from\r\n            , to\r\n            , tokenId\r\n        );\r\n\r\n        _afterTokenTransfer(\r\n              from\r\n            , to\r\n            , tokenId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(\r\n          address to\r\n        , uint256 tokenId\r\n    ) \r\n        internal \r\n        virtual \r\n    {\r\n        address _owner = ERC721.ownerOf(tokenId);\r\n\r\n        _tokenApprovals[tokenId][_owner] = to;\r\n        emit Approval(\r\n              _owner\r\n            , to\r\n            , tokenId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n          address owner\r\n        , address operator\r\n        , bool approved\r\n    ) \r\n        internal \r\n        virtual \r\n    {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) \r\n        internal \r\n        returns (\r\n            bool\r\n        ) \r\n    {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/Comics/IMimeticComic.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface IMimeticComic {\r\n    function loadSeries(\r\n          uint8 _series\r\n        , string memory _description\r\n        , string memory _ipfsHash\r\n        , uint256 _issuanceEnd\r\n    )\r\n        external;\r\n\r\n    function lock()\r\n        external;\r\n\r\n    function seriesImage(\r\n        uint8 _series\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            string memory ipfsString\r\n        );\r\n\r\n    function seriesMetadata(\r\n          uint8 _series\r\n        , uint256 _tokenId\r\n        , bool redeemed\r\n        , bool exists\r\n        , bool wildcard\r\n        , uint256 votes\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            string memory metadataString\r\n        );\r\n\r\n    function tokenSeries(\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint8 series\r\n        );\r\n\r\n    function tokenImage(\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            string memory\r\n        );\r\n\r\n    function tokenMetadata(\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            string memory\r\n        );\r\n\r\n    function focusSeries(\r\n          uint8 _series\r\n        , uint256 _tokenId\r\n    )\r\n        external;\r\n}"
    },
    "contracts/Comics/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0;\r\n\r\n/// @title Base64\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @notice Provides functions for encoding/decoding base64\r\nlibrary Base64 {\r\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\r\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\r\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\r\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\r\n\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length == 0) return '';\r\n\r\n        // load the table into memory\r\n        string memory table = TABLE_ENCODE;\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n        // add some extra buffer at the end required for the writing\r\n        string memory result = new string(encodedLen + 32);\r\n\r\n        assembly {\r\n            // set the actual output length\r\n            mstore(result, encodedLen)\r\n\r\n            // prepare the lookup table\r\n            let tablePtr := add(table, 1)\r\n\r\n            // input ptr\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            // result ptr, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // run over the input, 3 bytes at a time\r\n            for {} lt(dataPtr, endPtr) {}\r\n            {\r\n                // read 3 bytes\r\n                dataPtr := add(dataPtr, 3)\r\n                let input := mload(dataPtr)\r\n\r\n                // write 4 characters\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n            }\r\n\r\n            // padding with '='\r\n            switch mod(mload(data), 3)\r\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\r\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function decode(string memory _data) internal pure returns (bytes memory) {\r\n        bytes memory data = bytes(_data);\r\n\r\n        if (data.length == 0) return new bytes(0);\r\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\r\n\r\n        // load the table into memory\r\n        bytes memory table = TABLE_DECODE;\r\n\r\n        // every 4 characters represent 3 bytes\r\n        uint256 decodedLen = (data.length / 4) * 3;\r\n\r\n        // add some extra buffer at the end required for the writing\r\n        bytes memory result = new bytes(decodedLen + 32);\r\n\r\n        assembly {\r\n            // padding with '='\r\n            let lastBytes := mload(add(data, mload(data)))\r\n            if eq(and(lastBytes, 0xFF), 0x3d) {\r\n                decodedLen := sub(decodedLen, 1)\r\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\r\n                    decodedLen := sub(decodedLen, 1)\r\n                }\r\n            }\r\n\r\n            // set the actual output length\r\n            mstore(result, decodedLen)\r\n\r\n            // prepare the lookup table\r\n            let tablePtr := add(table, 1)\r\n\r\n            // input ptr\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            // result ptr, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // run over the input, 4 characters at a time\r\n            for {} lt(dataPtr, endPtr) {}\r\n            {\r\n               // read 4 characters\r\n               dataPtr := add(dataPtr, 4)\r\n               let input := mload(dataPtr)\r\n\r\n               // write 3 bytes\r\n               let output := add(\r\n                   add(\r\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\r\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\r\n                   add(\r\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\r\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\r\n                    )\r\n                )\r\n                mstore(resultPtr, shl(232, output))\r\n                resultPtr := add(resultPtr, 3)\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/Comics/IMirror.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface IMirror {\r\n    function ownerOf(uint256 tokenId_) \r\n        external \r\n        view \r\n        returns (\r\n            address\r\n        );\r\n\r\n    function isOwnerOf(\r\n          address account\r\n        , uint256[] calldata _tokenIds\r\n    ) \r\n        external \r\n        view \r\n        returns (\r\n            bool\r\n        );\r\n}"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}