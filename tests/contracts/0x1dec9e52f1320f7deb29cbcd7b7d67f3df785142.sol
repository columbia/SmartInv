{{
  "language": "Solidity",
  "sources": {
    "contracts/minter-suite/MinterSetPriceV0.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"../interfaces/0.8.x/IGenArt721CoreContractV1.sol\";\nimport \"../interfaces/0.8.x/IMinterFilterV0.sol\";\nimport \"../interfaces/0.8.x/IFilteredMinterV0.sol\";\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\npragma solidity 0.8.9;\n\n/**\n * @title Filtered Minter contract that allows tokens to be minted with ETH.\n * @author Art Blocks Inc.\n */\ncontract MinterSetPriceV0 is ReentrancyGuard, IFilteredMinterV0 {\n    /// Core contract address this minter interacts with\n    address public immutable genArt721CoreAddress;\n\n    /// This contract handles cores with interface IV1\n    IGenArt721CoreContractV1 private immutable genArtCoreContract;\n\n    /// Minter filter address this minter interacts with\n    address public immutable minterFilterAddress;\n\n    /// Minter filter this minter may interact with.\n    IMinterFilterV0 private immutable minterFilter;\n\n    /// minterType for this minter\n    string public constant minterType = \"MinterSetPriceV0\";\n\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    /// projectId => are contracts allowed to mint?\n    mapping(uint256 => bool) public contractMintable;\n    /// projectId => are tokens allowed to be minted to other addresses?\n    mapping(uint256 => bool) public purchaseToDisabled;\n    /// purchaser address => projectId => number of mints purchased\n    mapping(address => mapping(uint256 => uint256)) public projectMintCounter;\n    /// projectId => maximum number of mints a given address may invoke\n    mapping(uint256 => uint256) public projectMintLimit;\n    /// projectId => has project reached its maximum number of invocations?\n    mapping(uint256 => bool) public projectMaxHasBeenInvoked;\n    /// projectId => project's maximum number of invocations\n    mapping(uint256 => uint256) public projectMaxInvocations;\n    /// projectId => price per token in wei - supersedes any defined core price\n    mapping(uint256 => uint256) private projectIdToPricePerTokenInWei;\n    /// projectId => price per token has been configured on this minter\n    mapping(uint256 => bool) private projectIdToPriceIsConfigured;\n\n    modifier onlyCoreWhitelisted() {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"Only Core whitelisted\"\n        );\n        _;\n    }\n\n    modifier onlyArtist(uint256 _projectId) {\n        require(\n            msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId),\n            \"Only Artist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initializes contract to be a Filtered Minter for\n     * `_minterFilter`, integrated with Art Blocks core contract\n     * at address `_genArt721Address`.\n     * @param _genArt721Address Art Blocks core contract address for\n     * which this contract will be a minter.\n     * @param _minterFilter Minter filter for whichccthis will a\n     * filtered minter.\n     */\n    constructor(address _genArt721Address, address _minterFilter)\n        ReentrancyGuard()\n    {\n        genArt721CoreAddress = _genArt721Address;\n        genArtCoreContract = IGenArt721CoreContractV1(_genArt721Address);\n        minterFilterAddress = _minterFilter;\n        minterFilter = IMinterFilterV0(_minterFilter);\n        require(\n            minterFilter.genArt721CoreAddress() == _genArt721Address,\n            \"Illegal contract pairing\"\n        );\n    }\n\n    /**\n     * @notice Sets the mint limit of a single purchaser for project\n     * `_projectId` to `_limit`.\n     * @param _projectId Project ID to set the mint limit for.\n     * @param _limit Number of times a given address may mint the\n     * project's tokens.\n     */\n    function setProjectMintLimit(uint256 _projectId, uint8 _limit)\n        external\n        onlyCoreWhitelisted\n    {\n        projectMintLimit[_projectId] = _limit;\n    }\n\n    /**\n     * @notice Sets the maximum invocations of project `_projectId` based\n     * on the value currently defined in the core contract.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @dev also checks and may refresh projectMaxHasBeenInvoked for project\n     * @dev this enables gas reduction after maxInvocations have been reached -\n     * core contracts shall still enforce a maxInvocation check during mint.\n     */\n    function setProjectMaxInvocations(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        uint256 invocations;\n        uint256 maxInvocations;\n        (, , invocations, maxInvocations, , , , , ) = genArtCoreContract\n            .projectTokenInfo(_projectId);\n        // update storage with results\n        projectMaxInvocations[_projectId] = maxInvocations;\n        if (invocations < maxInvocations) {\n            projectMaxHasBeenInvoked[_projectId] = false;\n        }\n    }\n\n    /**\n     * @notice Toggles if contracts are allowed to mint tokens for\n     * project `_projectId`.\n     * @param _projectId Project ID to be toggled.\n     */\n    function toggleContractMintable(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        contractMintable[_projectId] = !contractMintable[_projectId];\n    }\n\n    /**\n     * @notice Toggles if purchases to other address are enabled for\n     * project `_projectId`.\n     * @param _projectId Project ID to be toggled.\n     */\n    function togglePurchaseToDisabled(uint256 _projectId)\n        external\n        onlyCoreWhitelisted\n    {\n        purchaseToDisabled[_projectId] = !purchaseToDisabled[_projectId];\n        emit PurchaseToDisabledUpdated(\n            _projectId,\n            purchaseToDisabled[_projectId]\n        );\n    }\n\n    /**\n     * @notice Updates this minter's price per token of project `_projectId`\n     * to be '_pricePerTokenInWei`, in Wei.\n     * This price supersedes any legacy core contract price per token value.\n     */\n    function updatePricePerTokenInWei(\n        uint256 _projectId,\n        uint256 _pricePerTokenInWei\n    ) external onlyArtist(_projectId) {\n        projectIdToPricePerTokenInWei[_projectId] = _pricePerTokenInWei;\n        projectIdToPriceIsConfigured[_projectId] = true;\n        emit PricePerTokenInWeiUpdated(_projectId, _pricePerTokenInWei);\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId`.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        tokenId = purchaseTo(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId` and sets\n     * the token's owner to `_to`.\n     * @param _to Address to be the new token's owner.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchaseTo(address _to, uint256 _projectId)\n        public\n        payable\n        nonReentrant\n        returns (uint256 tokenId)\n    {\n        // CHECKS\n        require(\n            !projectMaxHasBeenInvoked[_projectId],\n            \"Maximum number of invocations reached\"\n        );\n\n        // require artist to have configured price of token on this minter\n        require(\n            projectIdToPriceIsConfigured[_projectId],\n            \"Price not configured\"\n        );\n\n        // if contract filter is off, allow calls from another contract\n        if (!contractMintable[_projectId]) {\n            require(msg.sender == tx.origin, \"No Contract Buys\");\n        }\n\n        // if purchaseTo is disabled, enforce purchase destination to be the TX\n        // sending address.\n        if (purchaseToDisabled[_projectId]) {\n            require(msg.sender == _to, \"No `purchaseTo` Allowed\");\n        }\n\n        require(\n            msg.value >= projectIdToPricePerTokenInWei[_projectId],\n            \"Must send minimum value to mint!\"\n        );\n\n        // limit mints per address by project\n        if (projectMintLimit[_projectId] > 0) {\n            require(\n                projectMintCounter[msg.sender][_projectId] <\n                    projectMintLimit[_projectId],\n                \"Reached minting limit\"\n            );\n            // EFFECTS\n            projectMintCounter[msg.sender][_projectId]++;\n        }\n\n        tokenId = minterFilter.mint(_to, _projectId, msg.sender);\n        // what if projectMaxInvocations[_projectId] is 0 (default value)?\n        // that is intended, so that by default the minter allows infinite transactions,\n        // allowing the artblocks contract to stop minting\n        // uint256 tokenInvocation = tokenId % ONE_MILLION;\n        if (\n            projectMaxInvocations[_projectId] > 0 &&\n            tokenId % ONE_MILLION == projectMaxInvocations[_projectId] - 1\n        ) {\n            projectMaxHasBeenInvoked[_projectId] = true;\n        }\n\n        // INTERACTIONS\n        _splitFundsETH(_projectId);\n\n        return tokenId;\n    }\n\n    /**\n     * @dev splits ETH funds between sender (if refund), foundation,\n     * artist, and artist's additional payee for a token purchased on\n     * project `_projectId`.\n     * @dev utilizes transfer() to send ETH, so access lists may need to be\n     * populated when purchasing tokens.\n     */\n    function _splitFundsETH(uint256 _projectId) internal {\n        if (msg.value > 0) {\n            uint256 pricePerTokenInWei = projectIdToPricePerTokenInWei[\n                _projectId\n            ];\n            uint256 refund = msg.value - pricePerTokenInWei;\n            if (refund > 0) {\n                (bool success_, ) = msg.sender.call{value: refund}(\"\");\n                require(success_, \"Refund failed\");\n            }\n            uint256 foundationAmount = (pricePerTokenInWei *\n                genArtCoreContract.artblocksPercentage()) / 100;\n            if (foundationAmount > 0) {\n                (bool success_, ) = genArtCoreContract.artblocksAddress().call{\n                    value: foundationAmount\n                }(\"\");\n                require(success_, \"Foundation payment failed\");\n            }\n            uint256 projectFunds = pricePerTokenInWei - foundationAmount;\n            uint256 additionalPayeeAmount;\n            if (\n                genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                    _projectId\n                ) > 0\n            ) {\n                additionalPayeeAmount =\n                    (projectFunds *\n                        genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                            _projectId\n                        )) /\n                    100;\n                if (additionalPayeeAmount > 0) {\n                    (bool success_, ) = genArtCoreContract\n                        .projectIdToAdditionalPayee(_projectId)\n                        .call{value: additionalPayeeAmount}(\"\");\n                    require(success_, \"Additional payment failed\");\n                }\n            }\n            uint256 creatorFunds = projectFunds - additionalPayeeAmount;\n            if (creatorFunds > 0) {\n                (bool success_, ) = genArtCoreContract\n                    .projectIdToArtistAddress(_projectId)\n                    .call{value: creatorFunds}(\"\");\n                require(success_, \"Artist payment failed\");\n            }\n        }\n    }\n\n    /**\n     * @notice Gets if price of token is configured, price of minting a\n     * token on project `_projectId`, and currency symbol and address to be\n     * used as payment. Supersedes any core contract price information.\n     * @param _projectId Project ID to get price information for.\n     * @return isConfigured true only if token price has been configured on\n     * this minter\n     * @return tokenPriceInWei current price of token on this minter - invalid\n     * if price has not yet been configured\n     * @return currencySymbol currency symbol for purchases of project on this\n     * minter. This minter always returns \"ETH\"\n     * @return currencyAddress currency address for purchases of project on\n     * this minter. This minter always returns null address, reserved for ether\n     */\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        )\n    {\n        isConfigured = projectIdToPriceIsConfigured[_projectId];\n        tokenPriceInWei = projectIdToPricePerTokenInWei[_projectId];\n        currencySymbol = \"ETH\";\n        currencyAddress = address(0);\n    }\n}\n"
    },
    "contracts/interfaces/0.8.x/IGenArt721CoreContractV1.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IGenArt721CoreContractV1 {\n    event Mint(\n        address indexed _to,\n        uint256 indexed _tokenId,\n        uint256 indexed _projectId\n    );\n\n    // getter function of public variable\n    function admin() external view returns (address);\n\n    // getter function of public variable\n    function nextProjectId() external view returns (uint256);\n\n    // getter function of public mapping\n    function tokenIdToProjectId(uint256 tokenId)\n        external\n        view\n        returns (uint256 projectId);\n\n    function isWhitelisted(address sender) external view returns (bool);\n\n    // @dev this is not available in V0\n    function isMintWhitelisted(address minter) external view returns (bool);\n\n    function projectIdToArtistAddress(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayee(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayeePercentage(uint256 _projectId)\n        external\n        view\n        returns (uint256);\n\n    function projectTokenInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            address,\n            uint256,\n            string memory,\n            address\n        );\n\n    function artblocksAddress() external view returns (address payable);\n\n    function artblocksPercentage() external view returns (uint256);\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n\n    function getRoyaltyData(uint256 _tokenId)\n        external\n        view\n        returns (\n            address artistAddress,\n            address additionalPayee,\n            uint256 additionalPayeePercentage,\n            uint256 royaltyFeeByID\n        );\n}\n"
    },
    "contracts/interfaces/0.8.x/IMinterFilterV0.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IMinterFilterV0 {\n    /**\n     * @notice Approved minter `_minterAddress`.\n     */\n    event MinterApproved(address indexed _minterAddress, string _minterType);\n\n    /**\n     * @notice Revoked approval for minter `_minterAddress`\n     */\n    event MinterRevoked(address indexed _minterAddress);\n\n    /**\n     * @notice Minter `_minterAddress` of type `_minterType`\n     * registered for project `_projectId`.\n     */\n    event ProjectMinterRegistered(\n        uint256 indexed _projectId,\n        address indexed _minterAddress,\n        string _minterType\n    );\n\n    /**\n     * @notice Any active minter removed for project `_projectId`.\n     */\n    event ProjectMinterRemoved(uint256 indexed _projectId);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function setMinterForProject(uint256, address) external;\n\n    function removeMinterForProject(uint256) external;\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address sender\n    ) external returns (uint256);\n\n    function getMinterForProject(uint256) external view returns (address);\n\n    function projectHasMinter(uint256) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/0.8.x/IFilteredMinterV0.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IFilteredMinterV0 {\n    /**\n     * @notice Price per token in wei updated for project `_projectId` to\n     * `_pricePerTokenInWei`.\n     */\n    event PricePerTokenInWeiUpdated(\n        uint256 indexed _projectId,\n        uint256 indexed _pricePerTokenInWei\n    );\n\n    /**\n     * @notice Currency updated for project `_projectId` to symbol\n     * `_currencySymbol` and address `_currencyAddress`.\n     */\n    event ProjectCurrencyInfoUpdated(\n        uint256 indexed _projectId,\n        address indexed _currencyAddress,\n        string _currencySymbol\n    );\n\n    /// togglePurchaseToDisabled updated\n    event PurchaseToDisabledUpdated(\n        uint256 indexed _projectId,\n        bool _purchaseToDisabled\n    );\n\n    // getter function of public variable\n    function minterType() external view returns (string memory);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function minterFilterAddress() external returns (address);\n\n    // Triggers a purchase of a token from the desired project, to the\n    // TX-sending address.\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Triggers a purchase of a token from the desired project, to the specified\n    // receiving address.\n    function purchaseTo(address _to, uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Toggles the ability for `purchaseTo` to be called directly with a\n    // specified receiving address that differs from the TX-sending address.\n    function togglePurchaseToDisabled(uint256 _projectId) external;\n\n    // Called to make the minter contract aware of the max invocations for a\n    // given project.\n    function setProjectMaxInvocations(uint256 _projectId) external;\n\n    // Gets if token price is configured, token price in wei, currency symbol,\n    // and currency address, assuming this is project's minter.\n    // Supersedes any defined core price.\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        );\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}