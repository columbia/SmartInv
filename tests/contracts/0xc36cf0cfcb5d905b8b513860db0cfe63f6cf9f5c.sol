{"Address.sol":{"content":"pragma solidity ^0.5.0;\n\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n}\n"},"Common.sol":{"content":"pragma solidity ^0.5.0;\n\n\ncontract CommonConstants {\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n}\n"},"ERC165.sol":{"content":"pragma solidity ^0.5.0;\n\n\ninterface ERC165 {\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool);\n}\n"},"Gala.sol":{"content":"import \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./Common.sol\";\nimport \"./IERC1155TokenReceiver.sol\";\nimport \"./IERC1155.sol\";\n\npragma solidity ^0.5.0;\n\n\ncontract Gala is IERC1155, ERC165, CommonConstants {\n    using SafeMath for uint256;\n    using Address for address;\n\n    uint256 constant TYPE_MASK = uint256(uint128(~0)) \u003c\u003c 128;\n    uint256 constant NF_INDEX_MASK = uint128(~0);\n    uint256 constant TYPE_NF_BIT = 1 \u003c\u003c 255;\n    uint256 nonce;\n\n    address public owner;\n\n    mapping(uint256 =\u003e mapping(address =\u003e uint256)) internal balances; // id =\u003e (owner =\u003e balance)\n    mapping(address =\u003e mapping(address =\u003e bool)) internal operatorApproval; // owner =\u003e (operator =\u003e approved)\n    mapping(uint256 =\u003e address) nfOwners;\n    mapping(uint256 =\u003e uint256) public maxIndex;\n    mapping(address =\u003e mapping(address =\u003e mapping(uint256 =\u003e uint256))) allowances;\n    mapping(uint256 =\u003e uint256) public tokenSupply;\n    mapping(uint256 =\u003e uint256) public tokenSupplyLimit;\n    mapping(address =\u003e bool) internal creators;\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 indexed _id,\n        uint256 _oldValue,\n        uint256 _value\n    );\n    event SupplyLimit(uint256 indexed _id, uint256 _supplyLimit);\n\n    event TransferSingle(\n        address indexed _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256 _id,\n        uint256 _value\n    );\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n    event URI(string _value, uint256 indexed _id);\n    event TransferBatch(\n        address indexed _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256[] _ids,\n        uint256[] _values\n    );\n\n    event Creator(address _creator);\n\n    constructor() public {\n        owner = msg.sender;\n        creators[msg.sender] = true;\n    }\n\n    modifier creatorOnly() {\n        require(creators[msg.sender], \"Creator permission required\");\n        _;\n    }\n\n    modifier ownerOnly() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function create(string calldata _uri, bool _isNF) external creatorOnly returns (uint256 _type) {\n        _type = (++nonce \u003c\u003c 128);\n\n        if (_isNF) _type = _type | TYPE_NF_BIT;\n\n        emit TransferSingle(msg.sender, address(0x0), address(0x0), _type, 0);\n\n        if (bytes(_uri).length \u003e 0) emit URI(_uri, _type);\n        return _type;\n    }\n\n    function mintNonFungible(\n        uint256 _type,\n        address[] calldata _to,\n        bytes calldata _data\n    ) external creatorOnly {\n        require(isNonFungible(_type));\n        uint256 index = maxIndex[_type] + 1;\n        maxIndex[_type] = _to.length.add(maxIndex[_type]);\n        for (uint256 i = 0; i \u003c _to.length; ++i) {\n            address distributeTo = _to[i];\n            uint256 id = _type | (index + i);\n            require(\n                tokenSupplyLimit[_type] == 0 ||\n                    tokenSupply[_type].add(1) \u003c= tokenSupplyLimit[_type],\n                \"Token supply limit exceeded\"\n            );\n            nfOwners[id] = distributeTo;\n            tokenSupply[_type] = tokenSupply[_type].add(1);\n            balances[_type][distributeTo] = balances[_type][distributeTo].add(1);\n\n            emit TransferSingle(msg.sender, address(0x0), distributeTo, id, 1);\n\n            if (distributeTo.isContract()) {\n                _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, distributeTo, id, 1, _data);\n            }\n        }\n    }\n\n    function mintFungible(\n        uint256 _id,\n        address[] calldata _to,\n        uint256[] calldata _quantities,\n        bytes calldata _data\n    ) external creatorOnly {\n        require(isFungible(_id), \"ID must be a non-fungible ID\");\n        for (uint256 i = 0; i \u003c _to.length; ++i) {\n            require(\n                tokenSupplyLimit[_id] == 0 ||\n                    tokenSupply[_id].add(_quantities[i]) \u003c= tokenSupplyLimit[_id],\n                \"Token supply limit exceeded\"\n            );\n            balances[_id][_to[i]] = _quantities[i].add(balances[_id][_to[i]]);\n            tokenSupply[_id] = tokenSupply[_id].add(_quantities[i]);\n\n            emit TransferSingle(msg.sender, address(0x0), _to[i], _id, _quantities[i]);\n\n            if (_to[i].isContract()) {\n                _doSafeTransferAcceptanceCheck(\n                    msg.sender,\n                    msg.sender,\n                    _to[i],\n                    _id,\n                    _quantities[i],\n                    _data\n                );\n            }\n        }\n    }\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external {\n        require(_to != address(0x0), \"cannot send to zero address\");\n        require(\n            _from == msg.sender || operatorApproval[_from][msg.sender] == true,\n            \"Need operator approval for 3rd party transfers.\"\n        );\n\n        if (isNonFungible(_id)) {\n            require(nfOwners[_id] == _from);\n            nfOwners[_id] = _to;\n            // You could keep balance of NF type in base type id like so:\n            uint256 baseType = getNonFungibleBaseType(_id);\n            balances[baseType][_from] = balances[baseType][_from].sub(_value);\n            balances[baseType][_to] = balances[baseType][_to].add(_value);\n        } else {\n            balances[_id][_from] = balances[_id][_from].sub(_value);\n            balances[_id][_to] = balances[_id][_to].add(_value);\n        }\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _value);\n\n        if (_to.isContract()) {\n            _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, _value, _data);\n        }\n    }\n\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external {\n        require(_to != address(0x0), \"cannot send to zero address\");\n        require(_ids.length == _values.length, \"Array length must match\");\n        require(\n            _from == msg.sender || operatorApproval[_from][msg.sender] == true,\n            \"Need operator approval for 3rd party transfers.\"\n        );\n\n        for (uint256 i = 0; i \u003c _ids.length; ++i) {\n            if (isNonFungible(_ids[i])) {\n                require(nfOwners[_ids[i]] == _from);\n                nfOwners[_ids[i]] = _to;\n                balances[getNonFungibleBaseType(_ids[i])][_from] = balances[getNonFungibleBaseType(\n                    _ids[i]\n                )][_from]\n                    .sub(_values[i]);\n                balances[getNonFungibleBaseType(_ids[i])][_to] = balances[getNonFungibleBaseType(\n                    _ids[i]\n                )][_to]\n                    .add(_values[i]);\n            } else {\n                balances[_ids[i]][_from] = balances[_ids[i]][_from].sub(_values[i]);\n                balances[_ids[i]][_to] = _values[i].add(balances[_ids[i]][_to]);\n            }\n        }\n\n        emit TransferBatch(msg.sender, _from, _to, _ids, _values);\n\n        if (_to.isContract()) {\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, _from, _to, _ids, _values, _data);\n        }\n    }\n\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256) {\n        if (isNonFungibleItem(_id)) return nfOwners[_id] == _owner ? 1 : 0;\n        return balances[_id][_owner];\n    }\n\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(_owners.length == _ids.length);\n        uint256[] memory balances_ = new uint256[](_owners.length);\n        for (uint256 i = 0; i \u003c _owners.length; ++i) {\n            uint256 id = _ids[i];\n            if (isNonFungibleItem(id)) {\n                balances_[i] = nfOwners[id] == _owners[i] ? 1 : 0;\n            } else {\n                balances_[i] = balances[id][_owners[i]];\n            }\n        }\n\n        return balances_;\n    }\n\n    function setApprovalForAll(address _operator, bool _approved) external {\n        operatorApproval[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return operatorApproval[_owner][_operator];\n    }\n\n    function setSupplyLimit(uint256 _typeOrId, uint256 _supplyLimit) external creatorOnly {\n        require(_supplyLimit \u003e 0);\n        if (isNonFungibleItem(_typeOrId)) {\n            uint256 typeId = getNonFungibleBaseType(_typeOrId);\n            require(tokenSupplyLimit[typeId] == 0);\n            tokenSupplyLimit[typeId] = _supplyLimit;\n            emit SupplyLimit(typeId, _supplyLimit);\n        } else {\n            require(tokenSupplyLimit[_typeOrId] == 0);\n            tokenSupplyLimit[_typeOrId] = _supplyLimit;\n            emit SupplyLimit(_typeOrId, _supplyLimit);\n        }\n    }\n\n    function approveBatch(\n        address _spender,\n        uint256[] calldata _ids,\n        uint256[] calldata _currentValues,\n        uint256[] calldata _values\n    ) external {\n        require(_ids.length == _currentValues.length, \"Arrays must be same length\");\n        require(_currentValues.length == _values.length, \"Arrays must be same length\");\n        for (uint256 i = 0; i \u003c _values.length; i++) {\n            uint256 id = _ids[i];\n            uint256 currentValue = _currentValues[i];\n            uint256 value = _values[i];\n            require(allowances[msg.sender][_spender][id] == currentValue);\n            allowances[msg.sender][_spender][id] = value;\n            emit Approval(msg.sender, _spender, id, currentValue, value);\n        }\n    }\n\n    function isNonFungible(uint256 _id) public pure returns (bool) {\n        return _id \u0026 TYPE_NF_BIT == TYPE_NF_BIT;\n    }\n\n    function isFungible(uint256 _id) public pure returns (bool) {\n        return _id \u0026 TYPE_NF_BIT == 0;\n    }\n\n    function getNonFungibleIndex(uint256 _id) public pure returns (uint256) {\n        return _id \u0026 NF_INDEX_MASK;\n    }\n\n    function getNonFungibleBaseType(uint256 _id) public pure returns (uint256) {\n        return _id \u0026 TYPE_MASK;\n    }\n\n    function isNonFungibleBaseType(uint256 _id) public pure returns (bool) {\n        // A base type has the NF bit but does not have an index.\n        return (_id \u0026 TYPE_NF_BIT == TYPE_NF_BIT) \u0026\u0026 (_id \u0026 NF_INDEX_MASK == 0);\n    }\n\n    function isNonFungibleItem(uint256 _id) public pure returns (bool) {\n        // A base type has the NF bit but does has an index.\n        return (_id \u0026 TYPE_NF_BIT == TYPE_NF_BIT) \u0026\u0026 (_id \u0026 NF_INDEX_MASK != 0);\n    }\n\n    function ownerOf(uint256 _id) public view returns (address) {\n        return nfOwners[_id];\n    }\n\n    /////////////////////////////////////////// ERC165 //////////////////////////////////////////////\n\n    bytes4 private constant INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\n    bytes4 private constant INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n\n    function supportsInterface(bytes4 _interfaceId) public view returns (bool) {\n        if (\n            _interfaceId == INTERFACE_SIGNATURE_ERC165 ||\n            _interfaceId == INTERFACE_SIGNATURE_ERC1155\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /////////////////////////////////////////// Internal //////////////////////////////////////////////\n\n    function _doSafeTransferAcceptanceCheck(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes memory _data\n    ) internal {\n        require(\n            ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) ==\n                ERC1155_ACCEPTED,\n            \"contract returned an unknown value from onERC1155Received\"\n        );\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address _operator,\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _values,\n        bytes memory _data\n    ) internal {\n        require(\n            ERC1155TokenReceiver(_to).onERC1155BatchReceived(\n                _operator,\n                _from,\n                _ids,\n                _values,\n                _data\n            ) == ERC1155_BATCH_ACCEPTED,\n            \"contract returned an unknown value from onERC1155BatchReceived\"\n        );\n    }\n\n    /////////////////////////////////////////// ERC1155 //////////////////////////////////////////////\n\n    function batchAuthorizeCreators(address[] calldata _addresses) external ownerOnly {\n        for (uint256 i = 0; i \u003c _addresses.length; ++i) {\n            emit Creator(_addresses[i]);\n            creators[_addresses[i]] = true;\n        }\n    }\n\n    function batchDeauthorizeCreators(address[] calldata _addresses) external ownerOnly {\n        for (uint256 i = 0; i \u003c _addresses.length; ++i) {\n            delete creators[_addresses[i]];\n        }\n    }\n\n    function allowance(\n        address _owner,\n        address _spender,\n        uint256 _id\n    ) external view returns (uint256) {\n        return allowances[_owner][_spender][_id];\n    }\n\n    function burn(\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values\n    ) external {\n        require(\n            _from == msg.sender || operatorApproval[_from][msg.sender] == true,\n            \"Need operator approval for 3rd party burn.\"\n        );\n        require(_ids.length \u003e 0 \u0026\u0026 _ids.length == _values.length);\n        for (uint256 i = 0; i \u003c _ids.length; i++) {\n            if (isFungible(_ids[i])) {\n                require(balances[_ids[i]][_from] \u003e= _values[i]);\n                balances[_ids[i]][_from] = balances[_ids[i]][_from].sub(_values[i]);\n            } else {\n                require(isNonFungible(_ids[i]));\n                require(_values[i] == 1);\n                uint256 baseType = getNonFungibleBaseType(_ids[i]);\n                // --totalSupply?\n                balances[baseType][_from] = balances[baseType][_from].sub(1);\n                delete nfOwners[_ids[i]];\n            }\n            emit TransferSingle(msg.sender, _from, address(0x0), _ids[i], _values[i]);\n        }\n    }\n\n    function setNewUri(string calldata _uri, uint256 _id) external creatorOnly {\n        require(bytes(_uri).length \u003e 0);\n        emit URI(_uri, _id);\n    }\n}\n"},"IERC1155.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ERC165.sol\";\n\n\n/* is ERC165 */\ninterface IERC1155 {\n    event TransferSingle(\n        address indexed _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256 _id,\n        uint256 _value\n    );\n    event TransferBatch(\n        address indexed _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256[] _ids,\n        uint256[] _values\n    );\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n    event URI(string _value, uint256 indexed _id);\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"},"IERC1155TokenReceiver.sol":{"content":"pragma solidity ^0.5.0;\n\n\ninterface ERC1155TokenReceiver {\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"},"Migrations.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.7.0;\n\n\ncontract Migrations {\n    address public owner;\n    uint256 public last_completed_migration;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint256 completed) public restricted {\n        last_completed_migration = completed;\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b \u003c= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c \u003e= a);\n        return c;\n    }\n}\n"},"SignatureVerifier.sol":{"content":"pragma solidity ^0.5.0;\n\n\ncontract SignatureVerifier {\n    function validateNodeSignature(\n        string memory nodeHardwareLicenseId,\n        uint256 sigNonce,\n        bytes memory signature\n    ) internal view returns (address signer) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        (v, r, s) = splitSignature(signature);\n        bytes32 hash = keccak256(abi.encodePacked(nodeHardwareLicenseId, sigNonce, this));\n        bytes32 hashWithHeader = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n\n        return ecrecover(hashWithHeader, v, r, s);\n    }\n\n    function splitSignature(bytes memory signature)\n        internal\n        pure\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        )\n    {\n        require(signature.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            // first 32 bytes, after the length prefix\n            r := mload(add(signature, 32))\n            // second 32 bytes\n            s := mload(add(signature, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(signature, 96)))\n        }\n\n        return (v, r, s);\n    }\n}\n"}}