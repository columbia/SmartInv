{{
  "language": "Solidity",
  "sources": {
    "src/OKPCGold.sol": {
      "content": "/*\n\n          \n            .oooooo.   oooo    oooo ooooooooo.     .oooooo.     \n           d8P'  `Y8b  `888   .8P'  `888   `Y88.  d8P'  `Y8b    \n          888      888  888  d8'     888   .d88' 888            \n          888      888  88888[       888ooo88P'  888            \n          888      888  888`88b.     888         888            \n          `88b    d88'  888  `88b.   888         `88b    ooo    \n           `Y8bood8P'  o888o  o888o o888o         `Y8bood8P'    \n          \n          \n            .oooooo.      .oooooo.   ooooo        oooooooooo.   \n           d8P'  `Y8b    d8P'  `Y8b  `888'        `888'   `Y8b  \n          888           888      888  888          888      888 \n          888           888      888  888          888      888 \n          888     ooooo 888      888  888          888      888 \n          `88.    .88'  `88b    d88'  888       o  888     d88' \n           `Y8bood8P'    `Y8bood8P'  o888ooooood8 o888bood8P'   \n          \n           \n          \n           ð™°ð™½ ð™´ðš‡ðšƒð™´ð™½ðš‚ð™¸ð™¾ð™½ ðšƒð™¾ ð™¾ð™ºð™¿ð™² ð™¶ð™°ð™»ð™»ð™´ðšðšˆ ð™°ðšðšƒðš†ð™¾ðšð™º #ðŸ¼ðŸ¿: \"ð™°ð™¸ðšð™³ðšð™¾ð™¿\"\n\n*/\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity ^0.8.14;\n\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/auth/Owned.sol\";\nimport \"./interfaces/IOKPC.sol\";\nimport \"./interfaces/IOKPCMarketplace.sol\";\n\n/** \n@title OKPC Gold\n@author shahruz.eth\n*/\n\ncontract OKPCGold is Owned, ERC20 {\n    // @dev Core OKPC contract\n    IOKPC public immutable OKPC;\n\n    // @dev Claim config\n    uint256 public constant OKPC_CLAIM_MAX = 1_024;\n    uint256 public constant AIRDROP_CLAIM = 10_000;\n\n    // @dev Screen staking config\n    uint256 public SCREEN_STAKING_INTERVAL = 64 days;\n    uint256 public SCREEN_STAKING_REWARD = 256;\n\n    // @dev Claim registry\n    bool public CLAIMABLE;\n    struct OKPCClaim {\n        bool okpcClaimed;\n        bool artworkClaimed;\n        uint128 stakingLastClaimed;\n    }\n    mapping(uint256 => OKPCClaim) public okpcClaims;\n    error ClaimNotOpen();\n    error NoOKGLDClaimable();\n\n    // @dev Modifiers\n    modifier ifClaimable() {\n        if (!CLAIMABLE) revert ClaimNotOpen();\n        _;\n    }\n\n    // @dev Constructor\n    constructor(IOKPC okpcAddress)\n        Owned(msg.sender)\n        ERC20(\"OKPC GOLD\", \"OKGLD\", 18)\n    {\n        OKPC = okpcAddress;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  CLAIM ALL                                 */\n    /* -------------------------------------------------------------------------- */\n\n    // @notice Claim all eligible OKGLD for an OKPC.\n    // @param pcId An OKPC tokenId. Reverts if the token is not owned by the caller.\n    function claim(uint256 pcId) external ifClaimable {\n        if (OKPC.ownerOf(pcId) != msg.sender) revert NoOKGLDClaimable();\n        uint256 amount;\n        amount += _claimForOKPC(pcId);\n        amount += _claimForArtwork(pcId);\n        amount += _claimForScreenStaking(pcId);\n        if (amount == 0) revert NoOKGLDClaimable();\n        _mint(msg.sender, amount * 10**decimals);\n    }\n\n    // @notice Claim all eligible OKGLD for a set of OKPCs.\n    // @param pcIds An array of OKPC tokenIds. Tokens not owned by the caller are skipped.\n    function claim(uint256[] calldata pcIds) external ifClaimable {\n        uint256 amount;\n        for (uint256 i; i < pcIds.length; i++)\n            if (OKPC.ownerOf(pcIds[i]) == msg.sender) {\n                amount += _claimForOKPC(pcIds[i]);\n                amount += _claimForArtwork(pcIds[i]);\n                amount += _claimForScreenStaking(pcIds[i]);\n            }\n        if (amount == 0) revert NoOKGLDClaimable();\n        _mint(msg.sender, amount * 10**decimals);\n    }\n\n    // @notice Calculate the total amount of OKGLD an OKPC is eligible to claim.\n    // @param pcId An OKPC tokenId.\n    function claimableAmount(uint256 pcId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        return\n            claimableAmountForOKPC(pcId) +\n            claimableAmountForArtwork(pcId) +\n            claimableAmountForScreenStaking(pcId);\n    }\n\n    // @notice Calculate the total amount of OKGLD a set of OKPCs are eligible to claim.\n    // @param pcIds An array of OKPC tokenIds.\n    function claimableAmount(uint256[] calldata pcIds)\n        public\n        view\n        returns (uint256 amount)\n    {\n        for (uint256 i; i < pcIds.length; i++)\n            amount += claimableAmount(pcIds[i]);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 OKPC CLAIM                                 */\n    /* -------------------------------------------------------------------------- */\n\n    // @notice Claim OKGLD for an OKPC, based on its clock speed and amount of art collected.\n    // @param pcId An OKPC tokenId. Reverts if the token is not owned by the caller.\n    function claimForOKPC(uint256 pcId) external ifClaimable {\n        if (OKPC.ownerOf(pcId) != msg.sender) revert NoOKGLDClaimable();\n        uint256 amount = _claimForOKPC(pcId);\n        if (amount == 0) revert NoOKGLDClaimable();\n        _mint(msg.sender, amount * 10**decimals);\n    }\n\n    // @notice Claim OKGLD for a set of OKPCs, based on their clock speeds and amounts of art collected.\n    // @param pcIds An array of OKPC tokenIds. Tokens not owned by the caller are skipped.\n    function claimForOKPC(uint256[] calldata pcIds) external ifClaimable {\n        uint256 amount;\n        for (uint256 i; i < pcIds.length; i++)\n            if (OKPC.ownerOf(pcIds[i]) == msg.sender)\n                amount += _claimForOKPC(pcIds[i]);\n        if (amount == 0) revert NoOKGLDClaimable();\n        _mint(msg.sender, amount * 10**decimals);\n    }\n\n    // @dev Calculate the amount of OKGLD an OKPC is eligible to claim, based on its clock speed and amount of art collected.\n    // @dev Register the claimed OKPC using its tokenId to lock future claims.\n    function _claimForOKPC(uint256 pcId) private returns (uint256 amount) {\n        amount = claimableAmountForOKPC(pcId);\n        if (amount > 0) okpcClaims[pcId].okpcClaimed = true;\n    }\n\n    // @notice Calculate the amount of OKGLD an OKPC is eligible to claim, based on its clock speed and amount of art collected.\n    // @param pcId An OKPC tokenId.\n    function claimableAmountForOKPC(uint256 pcId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        return claimableAmountForOKPC(pcId, 0);\n    }\n\n    // @notice Calculate the amount of OKGLD a set of OKPCs is eligible to claim, based on its clock speed and amount of art collected.\n    // @param pcIds An array of OKPC tokenIds.\n    function claimableAmountForOKPC(uint256[] calldata pcIds)\n        public\n        view\n        returns (uint256 amount)\n    {\n        for (uint256 i; i < pcIds.length; i++)\n            amount += claimableAmountForOKPC(pcIds[i], 0);\n    }\n\n    // @notice Calculate the projected amount of OKGLD a set of OKPCs will be eligible to claim after a specified number of blocks, based on their clock speeds and amount of art collected.\n    // @param pcIds An array of OKPC tokenIds.\n    // @param afterBlocks An optional number of blocks to skip ahead for projected clock speed scores.\n    function claimableAmountForOKPC(\n        uint256[] calldata pcIds,\n        uint256 afterBlocks\n    ) public view returns (uint256 amount) {\n        for (uint256 i; i < pcIds.length; i++)\n            amount += claimableAmountForOKPC(pcIds[i], afterBlocks);\n    }\n\n    // @notice Calculate the projected amount of OKGLD an OKPC will be eligible to claim after a specified number of blocks, based on its clock speed and amount of art collected.\n    // @param pcId An OKPC tokenId.\n    // @param afterBlocks An optional number of blocks to skip ahead for projected clock speed scores.\n    function claimableAmountForOKPC(uint256 pcId, uint256 afterBlocks)\n        public\n        view\n        returns (uint256 amount)\n    {\n        if (okpcClaims[pcId].okpcClaimed == false) {\n            uint256 artCount = OKPC.artCountForOKPC(pcId);\n            uint256 total = (clockSpeedProjected(pcId, afterBlocks) / 2) *\n                2**(artCount > 3 ? 3 : artCount);\n            amount = total > OKPC_CLAIM_MAX ? OKPC_CLAIM_MAX : total;\n        }\n    }\n\n    // @notice Calculate the projected clock speed of an OKPC after a specified number of blocks.\n    // @param pcId An OKPC tokenId.\n    // @param afterBlocks A number of blocks to skip ahead.\n    function clockSpeedProjected(uint256 pcId, uint256 afterBlocks)\n        public\n        view\n        returns (uint256)\n    {\n        (uint256 savedSpeed, uint256 lastBlock, , ) = OKPC.clockSpeedData(pcId);\n        if (lastBlock == 0) return 1;\n        uint256 delta = block.number + afterBlocks - lastBlock;\n        uint256 multiplier = delta / 200_000;\n        uint256 clockSpeedMaxMultiplier = OKPC.clockSpeedMaxMultiplier();\n        if (multiplier > clockSpeedMaxMultiplier)\n            multiplier = clockSpeedMaxMultiplier;\n        uint256 total = savedSpeed + ((delta * (multiplier + 1)) / 10_000);\n        if (total < 1) total = 1;\n        return total;\n    }\n\n    // @notice Calculate the projected clock speed of a set of OKPCs after a specified number of blocks.\n    // @param pcIds An array of OKPC tokenIds.\n    // @param afterBlocks A number of blocks to skip ahead.\n    function clockSpeedProjected(uint256[] calldata pcIds, uint256 afterBlocks)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory result = new uint256[](pcIds.length);\n        for (uint256 i; i < pcIds.length; i++)\n            result[i] = clockSpeedProjected(pcIds[i], afterBlocks);\n        return result;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                ARTWORK CLAIM                               */\n    /* -------------------------------------------------------------------------- */\n\n    // @notice Claim OKGLD for an OKPC that has collected the AIRDROP artwork from the Gallery.\n    // @param pcId An OKPC tokenId. Reverts if the token is not owned by the caller.\n    function claimForArtwork(uint256 pcId) external ifClaimable {\n        if (OKPC.ownerOf(pcId) != msg.sender) revert NoOKGLDClaimable();\n        uint256 amount = _claimForArtwork(pcId);\n        if (amount == 0) revert NoOKGLDClaimable();\n        _mint(msg.sender, amount * 10**decimals);\n    }\n\n    // @notice Claim OKGLD for a set of OKPCs that have collected the AIRDROP artwork from the Gallery.\n    // @param pcIds An array of OKPC tokenIds. Tokens not owned by the caller are skipped.\n    function claimForArtwork(uint256[] calldata pcIds) external ifClaimable {\n        uint256 amount;\n        for (uint256 i; i < pcIds.length; i++)\n            if (OKPC.ownerOf(pcIds[i]) == msg.sender)\n                amount += _claimForArtwork(pcIds[i]);\n        if (amount == 0) revert NoOKGLDClaimable();\n        _mint(msg.sender, amount * 10**decimals);\n    }\n\n    // @dev Calculate the amount of OKGLD an OKPC is eligible to claim, based on collecting the AIRDROP artwork from the Gallery.\n    // @dev Register the artwork claim using its tokenId to lock future claims.\n    function _claimForArtwork(uint256 pcId) private returns (uint256 amount) {\n        amount = claimableAmountForArtwork(pcId);\n        if (amount > 0) okpcClaims[pcId].artworkClaimed = true;\n    }\n\n    // @notice Calculate the amount of OKGLD an OKPC is eligible to claim, based on collecting the AIRDROP artwork from the Gallery.\n    // @param pcId An OKPC tokenId.\n    function claimableAmountForArtwork(uint256 pcId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        if (\n            okpcClaims[pcId].artworkClaimed == false &&\n            OKPC.artCollectedByOKPC(pcId, 69)\n        ) {\n            if (\n                OKPC.marketplaceAddress() == address(0) ||\n                IOKPCMarketplace(OKPC.marketplaceAddress()).didMint(pcId, 69)\n            ) amount = AIRDROP_CLAIM;\n        }\n    }\n\n    // @notice Calculate the amount of OKGLD a set of OKPCs is eligible to claim, based on collecting the AIRDROP artwork from the Gallery.\n    // @param pcId An array of OKPC tokenIds.\n    function claimableAmountForArtwork(uint256[] calldata pcIds)\n        public\n        view\n        returns (uint256 amount)\n    {\n        for (uint256 i; i < pcIds.length; i++)\n            amount += claimableAmountForArtwork(pcIds[i]);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               SCREEN STAKING                               */\n    /* -------------------------------------------------------------------------- */\n\n    // @notice Claim OKGLD for an OKPC that is continuously displaying the AIRDROP artwork from the Gallery.\n    // @param pcId An OKPC tokenId. Reverts if the token is not owned by the caller.\n    function claimForScreenStaking(uint256 pcId) external ifClaimable {\n        if (OKPC.ownerOf(pcId) != msg.sender) revert NoOKGLDClaimable();\n        uint256 amount = _claimForScreenStaking(pcId);\n        if (amount == 0) revert NoOKGLDClaimable();\n        _mint(msg.sender, amount * 10**decimals);\n    }\n\n    // @notice Claim OKGLD for a set of OKPCs that are continuously displaying the AIRDROP artwork from the Gallery.\n    // @param pcIds A set of OKPC tokenIds. Tokens not owned by the caller are skipped.\n    function claimForScreenStaking(uint256[] calldata pcIds)\n        external\n        ifClaimable\n    {\n        uint256 amount;\n        for (uint256 i; i < pcIds.length; i++)\n            if (OKPC.ownerOf(pcIds[i]) == msg.sender)\n                amount += _claimForScreenStaking(pcIds[i]);\n        if (amount == 0) revert NoOKGLDClaimable();\n        _mint(msg.sender, amount * 10**decimals);\n    }\n\n    // @dev Calculate the amount of OKGLD an OKPC is eligible to claim, based on continuously displaying the AIRDROP artwork from the Gallery.\n    // @dev Register the screen staking claim to reset the clock.\n    function _claimForScreenStaking(uint256 pcId)\n        private\n        returns (uint256 amount)\n    {\n        amount = claimableAmountForScreenStaking(pcId);\n        if (amount > 0)\n            okpcClaims[pcId].stakingLastClaimed = uint128(block.timestamp);\n    }\n\n    // @notice Calculate the amount of OKGLD an OKPC is eligible to claim, based on continuously displaying the AIRDROP artwork from the Gallery.\n    // @param pcId An OKPC tokenId.\n    function claimableAmountForScreenStaking(uint256 pcId)\n        public\n        view\n        returns (uint256 amount)\n    {\n        return claimableAmountForScreenStaking(pcId, 0);\n    }\n\n    // @notice Calculate the amount of OKGLD a set of OKPCs is eligible to claim, based on continuously displaying the AIRDROP artwork from the Gallery.\n    // @param pcIds An array of OKPC tokenIds.\n    function claimableAmountForScreenStaking(uint256[] calldata pcIds)\n        public\n        view\n        returns (uint256 amount)\n    {\n        for (uint256 i; i < pcIds.length; i++)\n            amount += claimableAmountForScreenStaking(pcIds[i]);\n    }\n\n    // @notice Calculate the projected amount of OKGLD an OKPC will be eligible to claim after a specified number of seconds, based on continuously displaying the AIRDROP artwork from the Gallery.\n    // @param pcId An OKPC tokenId.\n    // @param afterTime An optional number of seconds to skip ahead for projected screen staking rewards.\n    function claimableAmountForScreenStaking(uint256 pcId, uint256 afterTime)\n        public\n        view\n        returns (uint256 amount)\n    {\n        if (OKPC.activeArtForOKPC(pcId) != 69) return 0;\n        (, , , uint256 artLastChanged) = OKPC.clockSpeedData(pcId);\n        uint256 previous = (\n            okpcClaims[pcId].stakingLastClaimed > artLastChanged\n                ? okpcClaims[pcId].stakingLastClaimed\n                : artLastChanged\n        );\n        if (block.timestamp + afterTime >= previous + SCREEN_STAKING_INTERVAL)\n            amount =\n                SCREEN_STAKING_REWARD *\n                ((block.timestamp + afterTime - previous) /\n                    SCREEN_STAKING_INTERVAL);\n    }\n\n    // @notice Calculate the projected amount of OKGLD a set of OKPCs will be eligible to claim after a specified number of seconds, based on continuously displaying the AIRDROP artwork from the Gallery.\n    // @param pcIds An array of OKPC tokenIds.\n    // @param afterTime An optional number of seconds to skip ahead for projected screen staking rewards.\n    function claimableAmountForScreenStaking(\n        uint256[] calldata pcIds,\n        uint256 afterTime\n    ) public view returns (uint256 amount) {\n        for (uint256 i; i < pcIds.length; i++)\n            amount += claimableAmountForScreenStaking(pcIds[i], afterTime);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               TOKEN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    // @notice Burn tokens and decrease the totalSupply.\n    // @param amount An amount of tokens to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                    OWNER                                   */\n    /* -------------------------------------------------------------------------- */\n\n    // @notice Turn the ability to claim on or off. Owner only.\n    function setClaimable(bool claimable) external onlyOwner {\n        CLAIMABLE = claimable;\n    }\n\n    // @notice Adjust the screen staking configuration. Owner only.\n    function setScreenStakingConfig(\n        uint256 screenStakingInterval,\n        uint256 screenStakingReward\n    ) external onlyOwner {\n        SCREEN_STAKING_INTERVAL = screenStakingInterval;\n        SCREEN_STAKING_REWARD = screenStakingReward;\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n"
    },
    "src/interfaces/IOKPC.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.14;\n\ninterface IOKPC {\n    function marketplaceAddress() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function artCountForOKPC(uint256) external view returns (uint256);\n\n    function clockSpeed(uint256) external view returns (uint256);\n\n    function clockSpeedMaxMultiplier() external view returns (uint256);\n\n    function clockSpeedData(uint256 pcId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function activeArtForOKPC(uint256 pcId) external view returns (uint256);\n\n    function artCollectedByOKPC(uint256 pcId, uint256 artId)\n        external\n        view\n        returns (bool);\n\n    function setMarketplaceAddress(address marketplaceAddress) external;\n\n    function transferArt(\n        uint256 fromOKPC,\n        uint256 toOKPC,\n        uint256 artId\n    ) external;\n}\n"
    },
    "src/interfaces/IOKPCMarketplace.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.14;\n\ninterface IOKPCMarketplace {\n    function didMint(uint256 pcId, uint256 artId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/solmate/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/src/",
      "src/=src/",
      "test/=test/",
      "script/=script/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}