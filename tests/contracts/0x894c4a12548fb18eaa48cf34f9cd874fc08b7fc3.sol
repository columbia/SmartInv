{"CairoBootloaderProgram.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\ncontract CairoBootloaderProgramSize {\n    uint256 internal constant PROGRAM_SIZE = 224;\n}\n\ncontract CairoBootloaderProgram is CairoBootloaderProgramSize {\n    function getCompiledProgram()\n        external pure\n        returns (uint256[PROGRAM_SIZE] memory)\n    {\n        return [\n            1226245742482522112,\n            181,\n            74168662805676031,\n            0,\n            146226256843603965,\n            4,\n            5191102238658887680,\n            2345108766317314046,\n            290341444919459839,\n            3,\n            4632937381316558848,\n            4612671182992932865,\n            4612671182992998402,\n            146226256843603968,\n            4,\n            74168662805676031,\n            4,\n            4612671182993063937,\n            4612671182993129474,\n            5198983563776196608,\n            1,\n            5198983563776262144,\n            1,\n            5200109459388203008,\n            5200109459388268544,\n            5198983563776458752,\n            3618502788666131213697322783095070105623107215331596699973092056135872020480,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020458,\n            2345108766317314046,\n            2345108766317314046,\n            1226245742482522112,\n            5,\n            5198420613823102976,\n            3618502788666131213697322783095070105623107215331596699973092056135872020479,\n            2345108766317314046,\n            2345108766317314046,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020474,\n            5198420613823168512,\n            3618502788666131213697322783095070105623107215331596699973092056135872020442,\n            5202361254907052032,\n            2345108766317314046,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020468,\n            5191102234363920384,\n            5191102238658887680,\n            5191102242953854976,\n            5198420613822906368,\n            50,\n            5189976364521848832,\n            4,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020433,\n            4623648689905041407,\n            291467327646433279,\n            2345108766317314046,\n            146226256843603965,\n            4,\n            5191102230068953088,\n            2345108766317314046,\n            5188850460319711232,\n            5188850460319776768,\n            5201798300658860031,\n            5188850460319842304,\n            5210805504208568318,\n            4612389708016222207,\n            5198983563776196608,\n            1,\n            5198983563776262144,\n            1,\n            5198983563776327680,\n            1,\n            5198983563776393216,\n            1,\n            5198983563776458752,\n            3618502788666131213697322783095070105623107215331596699973092056135872020480,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020461,\n            2345108766317314046,\n            5188850460319907840,\n            5202361254907052032,\n            5191102242953854976,\n            5188287510366552064,\n            5188287506071519232,\n            5188287510366486527,\n            4611826762357964797,\n            5198420613822906368,\n            3618502788666131213697322783095070105623107215331596699973092056135872020480,\n            5198420613822906368,\n            3,\n            5188287518956224512,\n            4623085744246521853,\n            145944781866893308,\n            3618502788666131213697322783095070105623107215331596699973092056135872020472,\n            2345108766317314046,\n            146226256843603965,\n            6,\n            5191102225773985792,\n            5191102238658887680,\n            5191102242953854976,\n            2345108766317314046,\n            290341444919459839,\n            16,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020407,\n            4617174774030761984,\n            4612671182992867338,\n            5189976364521848832,\n            0,\n            4612389712311713791,\n            5188850464614547456,\n            5191102264428691456,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020448,\n            4612389712312303615,\n            4622804286450008075,\n            4,\n            4612671195878359052,\n            5200109510928859136,\n            5188850468910104576,\n            4625619027626983437,\n            4622804286450597890,\n            2,\n            4617174765440827395,\n            4612671191582801924,\n            4612671195877769221,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020384,\n            4612389712311386110,\n            5189976364521848832,\n            16,\n            5201798304953696256,\n            4612389708016418815,\n            5191102230068953088,\n            5198983563776655360,\n            2,\n            5191102307378364416,\n            5191102311673331712,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020385,\n            1191342896910008320,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020370,\n            4623648758625632255,\n            722405534170316800,\n            0,\n            5191102230068953088,\n            5198983563776655360,\n            6,\n            5191102307378364416,\n            5191102320263266304,\n            5189976364521848832,\n            4,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020331,\n            4623648754330533887,\n            5191102238658887680,\n            5198983563776655360,\n            2,\n            5198983563776655360,\n            6,\n            5191102234363920384,\n            5189976364521848832,\n            4,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020373,\n            4623930225012473862,\n            4612671182994046991,\n            5198983563776655360,\n            6,\n            5191102230068953088,\n            5191102234363920384,\n            5193354042767540224,\n            5198983563776393216,\n            2,\n            5198983563776458752,\n            3618502788666131213697322783095070105623107215331596699973092056135872020480,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020399,\n            2345108766317314046,\n            290341444919459839,\n            1,\n            5199265038752907265,\n            1,\n            5191383709340631042,\n            5191383735110434819,\n            5191383717930565636,\n            5190257839498559493,\n            122550255383924,\n            5190257839498559494,\n            8098989891770344814,\n            5190257839498559495,\n            138277649577220228665140075,\n            5190257839498559496,\n            435459224417,\n            5190257839498559497,\n            1,\n            5190257839498559498,\n            3,\n            5190257839498559499,\n            1,\n            5190257839498559500,\n            2,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020307,\n            5198420613823102976,\n            1,\n            5198420613823037440,\n            5,\n            5198420613822971904,\n            9,\n            5191102238658887680,\n            5191102247248822272,\n            5188850460319645696,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020362,\n            4614641507830300670,\n            5188287510366486528,\n            5188287514661388288,\n            5188287518956290048,\n            5188287523251191808,\n            5193354038472572928,\n            2345108766317314046\n        ];\n    }\n}\n// ---------- End of auto-generated code. ----------\n"},"CairoVerifierContract.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\ninterface CairoVerifierContract {\n    function verifyProofExternal(\n        uint256[] calldata proofParams, uint256[] calldata proof, uint256[] calldata publicInput)\n        external;\n}\n"},"CpuPublicInputOffsets.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\ncontract CpuPublicInputOffsets {\n    // The following constants are offsets of data expected in the public input.\n    uint256 internal constant OFFSET_LOG_N_STEPS = 0;\n    uint256 internal constant OFFSET_RC_MIN = 1;\n    uint256 internal constant OFFSET_RC_MAX = 2;\n    uint256 internal constant OFFSET_LAYOUT_CODE = 3;\n    uint256 internal constant OFFSET_PROGRAM_BEGIN_ADDR = 4;\n    uint256 internal constant OFFSET_PROGRAM_STOP_PTR = 5;\n    uint256 internal constant OFFSET_EXECUTION_BEGIN_ADDR = 6;\n    uint256 internal constant OFFSET_EXECUTION_STOP_PTR = 7;\n    uint256 internal constant OFFSET_OUTPUT_BEGIN_ADDR = 8;\n    uint256 internal constant OFFSET_OUTPUT_STOP_PTR = 9;\n    uint256 internal constant OFFSET_PEDERSEN_BEGIN_ADDR = 10;\n    uint256 internal constant OFFSET_PEDERSEN_STOP_PTR = 11;\n    uint256 internal constant OFFSET_RANGE_CHECK_BEGIN_ADDR = 12;\n    uint256 internal constant OFFSET_RANGE_CHECK_STOP_PTR = 13;\n    uint256 internal constant OFFSET_ECDSA_BEGIN_ADDR = 14;\n    uint256 internal constant OFFSET_ECDSA_STOP_PTR = 15;\n    uint256 internal constant OFFSET_CHECKPOINTS_BEGIN_PTR = 16;\n    uint256 internal constant OFFSET_CHECKPOINTS_STOP_PTR = 17;\n    uint256 internal constant OFFSET_PUBLIC_MEMORY_PADDING_ADDR = 18;\n    uint256 internal constant OFFSET_PUBLIC_MEMORY_PADDING_VALUE = 19;\n    uint256 internal constant OFFSET_N_PUBLIC_MEMORY_PAGES = 20;\n    uint256 internal constant OFFSET_PUBLIC_MEMORY = 21;\n\n    uint256 internal constant N_WORDS_PER_PUBLIC_MEMORY_ENTRY = 2;\n    // The program segment starts from 1, so that memory address 0 is kept for the null pointer.\n    uint256 internal constant INITIAL_PC = 1;\n    uint256 internal constant FINAL_PC = INITIAL_PC + 2;\n\n    // The format of the public input, starting at OFFSET_PUBLIC_MEMORY is as follows:\n    //   * For each page:\n    //     * First address in the page (this field is not included for the first page).\n    //     * Page size.\n    //     * Page hash.\n    //   # All data above this line, appears in the initial seed of the proof.\n    //   * For each page:\n    //     * Cumulative product.\n\n    function getOffsetPageSize(uint256 pageId) internal pure returns (uint256) {\n        return OFFSET_PUBLIC_MEMORY + 3 * pageId;\n    }\n\n    function getOffsetPageHash(uint256 pageId) internal pure returns (uint256) {\n        return OFFSET_PUBLIC_MEMORY + 3 * pageId + 1;\n    }\n\n    function getOffsetPageAddr(uint256 pageId) internal pure returns (uint256) {\n        require(pageId \u003e= 1, \"Address of page 0 is not part of the public input.\");\n        return OFFSET_PUBLIC_MEMORY + 3 * pageId - 1;\n    }\n\n    function getOffsetPageProd(uint256 pageId, uint256 nPages) internal pure returns (uint256) {\n        return OFFSET_PUBLIC_MEMORY + 3 * nPages - 1 + pageId;\n    }\n\n    function getPublicInputLength(uint256 nPages) internal pure returns (uint256) {\n        return OFFSET_PUBLIC_MEMORY + 4 * nPages - 1;\n    }\n\n}\n"},"FactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\nimport \"IQueryableFactRegistry.sol\";\n\ncontract FactRegistry is IQueryableFactRegistry {\n    // Mapping: fact hash -\u003e true.\n    mapping (bytes32 =\u003e bool) private verifiedFact;\n\n    // Indicates whether the Fact Registry has at least one fact registered.\n    bool anyFactRegistered;\n\n    /*\n      Checks if a fact has been verified.\n    */\n    function isValid(bytes32 fact)\n        external view override\n        returns(bool)\n    {\n        return _factCheck(fact);\n    }\n\n\n    /*\n      This is an internal method to check if the fact is already registered.\n      In current implementation of FactRegistry it\u0027s identical to isValid().\n      But the check is against the local fact registry,\n      So for a derived referral fact registry, it\u0027s not the same.\n    */\n    function _factCheck(bytes32 fact)\n        internal view\n        returns(bool)\n    {\n        return verifiedFact[fact];\n    }\n\n    function registerFact(\n        bytes32 factHash\n        )\n        internal\n    {\n        // This function stores the fact hash in the mapping.\n        verifiedFact[factHash] = true;\n\n        // Mark first time off.\n        if (!anyFactRegistered) {\n            anyFactRegistered = true;\n        }\n    }\n\n    /*\n      Indicates whether at least one fact was registered.\n    */\n    function hasRegisteredFact()\n        external view override\n        returns(bool)\n    {\n        return anyFactRegistered;\n    }\n\n}\n"},"GpsOutputParser.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\nimport \"CpuPublicInputOffsets.sol\";\nimport \"FactRegistry.sol\";\n\n/*\n  A utility contract to parse the GPS output.\n  See registerGpsFacts for more details.\n*/\ncontract GpsOutputParser is CpuPublicInputOffsets, FactRegistry {\n    uint256 internal constant METADATA_TASKS_OFFSET = 1;\n    uint256 internal constant METADATA_OFFSET_TASK_OUTPUT_SIZE = 0;\n    uint256 internal constant METADATA_OFFSET_TASK_PROGRAM_HASH = 1;\n    uint256 internal constant METADATA_OFFSET_TASK_N_TREE_PAIRS = 2;\n    uint256 internal constant METADATA_TASK_HEADER_SIZE = 3;\n\n    uint256 internal constant METADATA_OFFSET_TREE_PAIR_N_PAGES = 0;\n    uint256 internal constant METADATA_OFFSET_TREE_PAIR_N_NODES = 1;\n\n    uint256 internal constant NODE_STACK_OFFSET_HASH = 0;\n    uint256 internal constant NODE_STACK_OFFSET_END = 1;\n    // The size of each node in the node stack.\n    uint256 internal constant NODE_STACK_ITEM_SIZE = 2;\n\n    uint256 internal constant FIRST_CONTINUOUS_PAGE_INDEX = 1;\n\n    /*\n      Logs the fact hash together with the relavent continuous memory pages\u0027 hashes.\n      Emitted for each registered fact.\n    */\n    event LogMemoryPagesHashes(bytes32 factHash, bytes32[] pagesHashes);\n\n    /*\n      Parses the GPS program output (using taskMetadata, which should be verified by the caller),\n      and registers the facts of the tasks which were executed.\n\n      The first entry in taskMetadata is the number of tasks.\n\n      For each task, the structure is as follows:\n        1. Size (including the size and hash fields).\n        2. Program hash.\n        3. The numebr of pairs in the Merkle tree structure (see below).\n        4. The Merkle tree structure (see below).\n\n      The fact of each task is stored as a (non-binary) Merkle tree.\n      Each non-leaf node is 1 + the hash of (node0, end0, node1, end1, ...)\n      where node* are its children and end* is the the total number of data words up to and\n      including that node and its children (including the previous sibling nodes).\n      We add 1 to the result of the hash to distinguish it from a leaf node.\n      Leaf nodes are the hash of their data.\n\n      The structure of the tree is passed as a list of pairs (n_pages, n_nodes), and the tree is\n      constructed using a stack of nodes (initialized to an empty stack) by repeating for each pair:\n      1. Add n_pages to the stack of nodes.\n      2. Pop the top n_nodes, construct a parent node for them, and push it back to the stack.\n      After applying the steps above, the stack much contain exactly one node, which will\n      constitute the root of the Merkle tree.\n      For example, [(2, 2)] will create a Merkle tree with a root and two direct children, while\n      [(3, 2), (0, 2)] will create a Merkle tree with a root whose left child is a leaf and\n      right child has two leaf children.\n\n      Assumptions: taskMetadata and cairoAuxInput are verified externaly.\n    */\n    function registerGpsFacts(uint256[] memory taskMetadata, uint256[] memory cairoAuxInput)\n        internal\n    {\n        // Allocate some of the loop variables here to avoid the stack-too-deep error.\n        uint256 task;\n        uint256 nTreePairs;\n        uint256 nTasks = taskMetadata[0];\n\n        // Contains fact hash with the relevant memory pages\u0027 hashes.\n        // Size is bounded from above with the total number of pages. Three extra places are\n        // dedicated for the fact hash and the array address and length.\n        uint256[] memory pageHashesLogData = new uint256[](\n            cairoAuxInput[OFFSET_N_PUBLIC_MEMORY_PAGES] + 3);\n        // Relative address to the beginning of the memory pages\u0027 hashes in the array.\n        pageHashesLogData[1] = 0x40;\n\n        uint256 taskMetadataOffset = METADATA_TASKS_OFFSET;\n\n        // Skip the 3 first output cells which contain the number of tasks and the size and\n        // program hash of the first task. curAddr points to the output of the first task.\n        uint256 curAddr = cairoAuxInput[OFFSET_OUTPUT_BEGIN_ADDR] + 3;\n\n        // Skip the main page.\n        uint256 curPage = FIRST_CONTINUOUS_PAGE_INDEX;\n\n        // Bound the size of the stack by the total number of pages.\n        uint256[] memory nodeStack = new uint256[](\n            NODE_STACK_ITEM_SIZE * cairoAuxInput[OFFSET_N_PUBLIC_MEMORY_PAGES]);\n\n        // Copy to avoid the \"stack too deep\" error.\n        uint256[] memory taskMetadataCopy = taskMetadata;\n        uint256[] memory cairoAuxInputCopy = cairoAuxInput;\n\n        // Register the fact for each task.\n        for (task = 0; task \u003c nTasks; task++) {\n            uint256 curOffset = 0;\n            uint256 firstPageOfTask = curPage;\n            nTreePairs = taskMetadataCopy[\n                taskMetadataOffset + METADATA_OFFSET_TASK_N_TREE_PAIRS];\n\n            // Build the Merkle tree using a stack (see the function documentation) to compute\n            // the fact.\n            uint256 nodeStackLen = 0;\n            for (uint256 treePair = 0; treePair \u003c nTreePairs; treePair++) {\n                // Add n_pages to the stack of nodes.\n                uint256 nPages = taskMetadataCopy[\n                    taskMetadataOffset + METADATA_TASK_HEADER_SIZE + 2 * treePair +\n                    METADATA_OFFSET_TREE_PAIR_N_PAGES];\n                require(nPages \u003c 2**20, \"Invalid value of n_pages in tree structure.\");\n\n                for (uint256 i = 0; i \u003c nPages; i++) {\n                    (uint256 pageSize, uint256 pageHash) = pushPageToStack(\n                        curPage, curAddr, curOffset, nodeStack, nodeStackLen, cairoAuxInputCopy);\n                    pageHashesLogData[curPage - firstPageOfTask + 3] = pageHash;\n                    curPage += 1;\n                    nodeStackLen += 1;\n                    curAddr += pageSize;\n                    curOffset += pageSize;\n                }\n\n                // Pop the top n_nodes, construct a parent node for them, and push it back to the\n                // stack.\n                uint256 nNodes = taskMetadataCopy[\n                    taskMetadataOffset + METADATA_TASK_HEADER_SIZE + 2 * treePair +\n                    METADATA_OFFSET_TREE_PAIR_N_NODES];\n                if (nNodes != 0) {\n                    nodeStackLen = constructNode(nodeStack, nodeStackLen, nNodes);\n                }\n            }\n            require(nodeStackLen == 1, \"Node stack must contain exactly one item.\");\n\n            uint256 programHash = taskMetadataCopy[\n                taskMetadataOffset + METADATA_OFFSET_TASK_PROGRAM_HASH];\n\n            // Verify that the sizes of the pages correspond to the task output, to make\n            // sure that the computed hash is indeed the hash of the entire output of the task.\n            {\n            uint256 outputSize = taskMetadataCopy[\n                taskMetadataOffset + METADATA_OFFSET_TASK_OUTPUT_SIZE];\n\n            require(\n                nodeStack[NODE_STACK_OFFSET_END] + 2 == outputSize,\n                \"The sum of the page sizes does not match output size.\");\n            }\n\n            uint256 fact_without_program_hash = nodeStack[NODE_STACK_OFFSET_HASH];\n            bytes32 fact = keccak256(abi.encode(programHash, fact_without_program_hash));\n\n            // Update taskMetadataOffset.\n            taskMetadataOffset += METADATA_TASK_HEADER_SIZE + 2 * nTreePairs;\n\n            {\n            // Documents each fact hash together with the hashes of the relavent memory pages.\n            // Instead of emit, we use log1 https://docs.soliditylang.org/en/v0.4.24/assembly.html,\n            // https://docs.soliditylang.org/en/v0.6.2/abi-spec.html#use-of-dynamic-types.\n\n            bytes32 logHash = keccak256(\"LogMemoryPagesHashes(bytes32,bytes32[])\");\n            assembly {\n                let buf := add(pageHashesLogData, 0x20)\n                // Number of memory pages that are relavent for this fact.\n                let length := sub(curPage, firstPageOfTask)\n                mstore(buf, fact_without_program_hash)\n                mstore(add(buf, 0x40), length)\n                log1(buf, mul(add(length, 3), 0x20), logHash)\n            }\n            }\n            registerFact(fact);\n\n            // Move curAddr to the output of the next task (skipping the size and hash fields).\n            curAddr += 2;\n        }\n\n        require(\n            cairoAuxInput[OFFSET_N_PUBLIC_MEMORY_PAGES] == curPage,\n            \"Not all memory pages were processed.\");\n    }\n\n    /*\n      Push one page (curPage) to the top of the node stack.\n      curAddr is the memory address, curOffset is the offset from the beginning of the task output.\n      Verifies that the page has the right start address and returns the page size and the page\n      hash.\n    */\n    function pushPageToStack(\n        uint256 curPage, uint256 curAddr, uint256 curOffset, uint256[] memory nodeStack,\n        uint256 nodeStackLen, uint256[] memory cairoAuxInput)\n        internal pure returns (uint256, uint256)\n    {\n        // Extract the page size, first address and hash from cairoAuxInput.\n        uint256 pageSizeOffset = getOffsetPageSize(curPage);\n        uint256 pageSize;\n        uint256 pageAddrOffset = getOffsetPageAddr(curPage);\n        uint256 pageAddr;\n        uint256 pageHashOffset = getOffsetPageHash(curPage);\n        uint256 pageHash;\n        assembly {\n            pageSize := mload(add(cairoAuxInput, mul(add(pageSizeOffset, 1), 0x20)))\n            pageAddr := mload(add(cairoAuxInput, mul(add(pageAddrOffset, 1), 0x20)))\n            pageHash := mload(add(cairoAuxInput, mul(add(pageHashOffset, 1), 0x20)))\n        }\n        require(pageSize \u003c 2**30, \"Invalid page size.\");\n        require(pageAddr == curAddr, \"Invalid page address.\");\n\n        nodeStack[NODE_STACK_ITEM_SIZE * nodeStackLen + NODE_STACK_OFFSET_END] =\n            curOffset + pageSize;\n        nodeStack[NODE_STACK_ITEM_SIZE * nodeStackLen + NODE_STACK_OFFSET_HASH] = pageHash;\n        return (pageSize, pageHash);\n    }\n\n    /*\n      Pops the top nNodes nodes from the stack and pushes one parent node instead.\n      Returns the new value of nodeStackLen.\n    */\n    function constructNode(uint256[] memory nodeStack, uint256 nodeStackLen, uint256 nNodes)\n        internal pure returns (uint256) {\n        require(nNodes \u003c= nodeStackLen, \"Invalid value of n_nodes in tree structure.\");\n        // The end of the node is the end of the last child.\n        uint256 newNodeEnd = nodeStack[\n            NODE_STACK_ITEM_SIZE * (nodeStackLen - 1) + NODE_STACK_OFFSET_END];\n        uint256 newStackLen = nodeStackLen - nNodes;\n        // Compute node hash.\n        uint256 nodeStart = 0x20 + newStackLen * NODE_STACK_ITEM_SIZE * 0x20;\n        uint256 newNodeHash;\n        assembly {\n            newNodeHash := keccak256(add(nodeStack, nodeStart), mul(\n                nNodes, /*NODE_STACK_ITEM_SIZE * 0x20*/0x40))\n        }\n\n        nodeStack[NODE_STACK_ITEM_SIZE * newStackLen + NODE_STACK_OFFSET_END] = newNodeEnd;\n        // Add one to the new node hash to distinguish it from the hash of a leaf (a page).\n        nodeStack[NODE_STACK_ITEM_SIZE * newStackLen + NODE_STACK_OFFSET_HASH] = newNodeHash + 1;\n        return newStackLen + 1;\n    }\n}\n"},"GpsStatementVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\nimport \"CairoBootloaderProgram.sol\";\nimport \"CairoVerifierContract.sol\";\nimport \"CpuPublicInputOffsets.sol\";\nimport \"MemoryPageFactRegistry.sol\";\nimport \"Identity.sol\";\nimport \"PrimeFieldElement0.sol\";\nimport \"GpsOutputParser.sol\";\n\ncontract GpsStatementVerifier is\n        GpsOutputParser, Identity, CairoBootloaderProgramSize, PrimeFieldElement0 {\n    CairoBootloaderProgram bootloaderProgramContractAddress;\n    MemoryPageFactRegistry memoryPageFactRegistry;\n    CairoVerifierContract[] cairoVerifierContractAddresses;\n\n    uint256 internal constant N_MAIN_ARGS = 5;\n    uint256 internal constant N_MAIN_RETURN_VALUES = 5;\n    uint256 internal constant N_BUILTINS = 4;\n\n    /*\n      Constructs an instance of GpsStatementVerifier.\n      bootloaderProgramContract is the address of the bootloader program contract\n      and cairoVerifierContracts is a list of cairoVerifiers indexed by their id.\n    */\n    constructor(\n        address bootloaderProgramContract,\n        address memoryPageFactRegistry_,\n        address[] memory cairoVerifierContracts)\n        public\n    {\n        bootloaderProgramContractAddress = CairoBootloaderProgram(bootloaderProgramContract);\n        memoryPageFactRegistry = MemoryPageFactRegistry(memoryPageFactRegistry_);\n        cairoVerifierContractAddresses = new CairoVerifierContract[](cairoVerifierContracts.length);\n        for (uint256 i = 0; i \u003c cairoVerifierContracts.length; ++i) {\n            cairoVerifierContractAddresses[i] = CairoVerifierContract(cairoVerifierContracts[i]);\n        }\n    }\n\n    function identify()\n        external pure override\n        returns(string memory)\n    {\n        return \"StarkWare_GpsStatementVerifier_2020_1\";\n    }\n\n    /*\n      Verifies a proof and registers the corresponding facts.\n      For the structure of cairoAuxInput, see cpu/CpuPublicInputOffsets.sol.\n      taskMetadata is structured as follows:\n      1. Number of tasks.\n      2. For each task:\n         1. Task output size (including program hash and size).\n         2. Program hash.\n    */\n    function verifyProofAndRegister(\n        uint256[] calldata proofParams,\n        uint256[] calldata proof,\n        uint256[] calldata taskMetadata,\n        uint256[] calldata cairoAuxInput,\n        uint256 cairoVerifierId\n    )\n        external\n    {\n        require(\n            cairoAuxInput.length \u003e OFFSET_N_PUBLIC_MEMORY_PAGES,\n            \"Invalid cairoAuxInput length.\");\n        uint256 nPages = cairoAuxInput[OFFSET_N_PUBLIC_MEMORY_PAGES];\n        require(\n            cairoAuxInput.length == getPublicInputLength(nPages) + /*z and alpha*/ 2,\n            \"Invalid cairoAuxInput length.\");\n\n        // The values z and alpha are used only for the fact registration of the main page.\n        // They are not needed in the auxiliary input of CpuVerifier as they are computed there.\n        // Create a copy of cairoAuxInput without z and alpha.\n        uint256[] memory cairoPublicInput = new uint256[](cairoAuxInput.length - /*z and alpha*/ 2);\n        for (uint256 i = 0; i \u003c cairoAuxInput.length - /*z and alpha*/ 2; i++) {\n            cairoPublicInput[i] = cairoAuxInput[i];\n        }\n\n        {\n        // Process public memory.\n        (uint256 publicMemoryLength, uint256 memoryHash, uint256 prod) =\n            registerPublicMemoryMainPage(taskMetadata, cairoAuxInput);\n\n        // Make sure the first page is valid.\n        // If the size or the hash are invalid, it may indicate that there is a mismatch between the\n        // bootloader program contract and the program in the proof.\n        require(\n            cairoAuxInput[getOffsetPageSize(0)] == publicMemoryLength,\n            \"Invalid size for memory page 0.\");\n        require(\n            cairoAuxInput[getOffsetPageHash(0)] == memoryHash,\n            \"Invalid hash for memory page 0.\");\n        require(\n            cairoAuxInput[getOffsetPageProd(0, nPages)] == prod,\n            \"Invalid cumulative product for memory page 0.\");\n        }\n\n        require(\n            cairoVerifierId \u003c cairoVerifierContractAddresses.length,\n            \"cairoVerifierId is out of range.\");\n\n        // NOLINTNEXTLINE: reentrancy-benign.\n        cairoVerifierContractAddresses[cairoVerifierId].verifyProofExternal(\n            proofParams, proof, cairoPublicInput);\n\n        registerGpsFacts(taskMetadata, cairoAuxInput);\n    }\n\n    /*\n      Registers the fact for memory page 0, which includes:\n      1. The bootloader program,\n      2. Arguments and return values of main()\n      3. Some of the data required for computing the task facts. which is represented in\n         taskMetadata.\n      Returns information on the registered fact.\n\n      Assumptions: cairoAuxInput is connected to the public input, which is verified by\n      cairoVerifierContractAddresses.\n      Guarantees: taskMetadata is consistent with the public memory, with some sanity checks.\n    */\n    function registerPublicMemoryMainPage(\n        uint256[] memory taskMetadata,\n        uint256[] memory cairoAuxInput\n    ) internal returns (uint256 publicMemoryLength, uint256 memoryHash, uint256 prod) {\n        uint256 nTasks = taskMetadata[0];\n        require(nTasks \u003c 2**30, \"Invalid number of tasks.\");\n\n        // Public memory length.\n        publicMemoryLength = (\n            PROGRAM_SIZE + N_MAIN_ARGS + N_MAIN_RETURN_VALUES + /*Number of tasks cell*/1 +\n            2 * nTasks);\n        uint256[] memory publicMemory = new uint256[](\n            N_WORDS_PER_PUBLIC_MEMORY_ENTRY * publicMemoryLength);\n\n        uint256 offset = 0;\n\n        // Write public memory, which is a list of pairs (address, value).\n        {\n        // Program segment.\n        uint256[PROGRAM_SIZE] memory bootloaderProgram =\n            bootloaderProgramContractAddress.getCompiledProgram();\n        for (uint256 i = 0; i \u003c bootloaderProgram.length; i++) {\n            // Force that memory[i + INITIAL_PC] = bootloaderProgram[i].\n            publicMemory[offset] = i + INITIAL_PC;\n            publicMemory[offset + 1] = bootloaderProgram[i];\n            offset += 2;\n        }\n        }\n\n        {\n        // Execution segment - main\u0027s arguments.\n        uint256 executionBeginAddr = cairoAuxInput[OFFSET_EXECUTION_BEGIN_ADDR];\n        publicMemory[offset + 0] = executionBeginAddr - 5;\n        publicMemory[offset + 1] = cairoAuxInput[OFFSET_OUTPUT_BEGIN_ADDR];\n        publicMemory[offset + 2] = executionBeginAddr - 4;\n        publicMemory[offset + 3] = cairoAuxInput[OFFSET_PEDERSEN_BEGIN_ADDR];\n        publicMemory[offset + 4] = executionBeginAddr - 3;\n        publicMemory[offset + 5] = cairoAuxInput[OFFSET_RANGE_CHECK_BEGIN_ADDR];\n        publicMemory[offset + 6] = executionBeginAddr - 2;\n        publicMemory[offset + 7] = cairoAuxInput[OFFSET_ECDSA_BEGIN_ADDR];\n        publicMemory[offset + 8] = executionBeginAddr - 1;\n        publicMemory[offset + 9] = cairoAuxInput[OFFSET_CHECKPOINTS_BEGIN_PTR];\n        offset += 10;\n        }\n\n        {\n        // Execution segment - return values.\n        uint256 executionStopPtr = cairoAuxInput[OFFSET_EXECUTION_STOP_PTR];\n        publicMemory[offset + 0] = executionStopPtr - 5;\n        publicMemory[offset + 1] = cairoAuxInput[OFFSET_OUTPUT_STOP_PTR];\n        publicMemory[offset + 2] = executionStopPtr - 4;\n        publicMemory[offset + 3] = cairoAuxInput[OFFSET_PEDERSEN_STOP_PTR];\n        publicMemory[offset + 4] = executionStopPtr - 3;\n        publicMemory[offset + 5] = cairoAuxInput[OFFSET_RANGE_CHECK_STOP_PTR];\n        publicMemory[offset + 6] = executionStopPtr - 2;\n        publicMemory[offset + 7] = cairoAuxInput[OFFSET_ECDSA_STOP_PTR];\n        publicMemory[offset + 8] = executionStopPtr - 1;\n        publicMemory[offset + 9] = cairoAuxInput[OFFSET_CHECKPOINTS_STOP_PTR];\n        offset += 10;\n        }\n\n        // Program output.\n        {\n        // Check that there are enough range checks for the bootloader builtin validation.\n        // Each builtin is validated for each task and each validation uses one range check.\n        require(\n            cairoAuxInput[OFFSET_RANGE_CHECK_STOP_PTR] \u003e=\n            cairoAuxInput[OFFSET_RANGE_CHECK_BEGIN_ADDR] + N_BUILTINS * nTasks,\n            \"Range-check stop pointer should be after all range checks used for validations.\");\n        // The checkpoint builtin is used once for each task, taking up two cells.\n        require(\n            cairoAuxInput[OFFSET_CHECKPOINTS_STOP_PTR] \u003e=\n            cairoAuxInput[OFFSET_CHECKPOINTS_BEGIN_PTR] + 2 * nTasks,\n            \"Number of checkpoints should be at least the number of tasks.\");\n\n        uint256 outputAddress = cairoAuxInput[OFFSET_OUTPUT_BEGIN_ADDR];\n        // Force that memory[outputAddress] = nTasks.\n        publicMemory[offset + 0] = outputAddress;\n        publicMemory[offset + 1] = nTasks;\n        offset += 2;\n        outputAddress += 1;\n        uint256 taskMetadataOffset = METADATA_TASKS_OFFSET;\n\n        for (uint256 task = 0; task \u003c nTasks; task++) {\n            uint256 outputSize = taskMetadata[\n                taskMetadataOffset + METADATA_OFFSET_TASK_OUTPUT_SIZE];\n            require(2 \u003c= outputSize \u0026\u0026 outputSize \u003c 2**30, \"Invalid task output size.\");\n            uint256 programHash = taskMetadata[\n                taskMetadataOffset + METADATA_OFFSET_TASK_PROGRAM_HASH];\n            uint256 nTreePairs = taskMetadata[\n                taskMetadataOffset + METADATA_OFFSET_TASK_N_TREE_PAIRS];\n            require(\n                1 \u003c= nTreePairs \u0026\u0026 nTreePairs \u003c 2**20,\n                \"Invalid number of pairs in the Merkle tree structure.\");\n            // Force that memory[outputAddress] = outputSize.\n            publicMemory[offset + 0] = outputAddress;\n            publicMemory[offset + 1] = outputSize;\n            // Force that memory[outputAddress + 1] = programHash.\n            publicMemory[offset + 2] = outputAddress + 1;\n            publicMemory[offset + 3] = programHash;\n            offset += 4;\n            outputAddress += outputSize;\n            taskMetadataOffset += METADATA_TASK_HEADER_SIZE + 2 * nTreePairs;\n        }\n        require(taskMetadata.length == taskMetadataOffset, \"Invalid length of taskMetadata.\");\n\n        require(\n            cairoAuxInput[OFFSET_OUTPUT_STOP_PTR] == outputAddress,\n            \"Inconsistent program output length.\");\n        }\n\n        require(publicMemory.length == offset, \"Not all Cairo public inputs were written.\");\n\n        bytes32 factHash;\n        (factHash, memoryHash, prod) = memoryPageFactRegistry.registerRegularMemoryPage(\n            publicMemory,\n            /*z=*/cairoAuxInput[cairoAuxInput.length - 2],\n            /*alpha=*/cairoAuxInput[cairoAuxInput.length - 1],\n            K_MODULUS);\n    }\n}\n"},"Identity.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\ninterface Identity {\n\n    /*\n      Allows a caller, typically another contract,\n      to ensure that the provided address is of the expected type and version.\n    */\n    function identify()\n        external pure\n        returns(string memory);\n}\n"},"IFactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\n/*\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\n  business logic of the contract flow.\n\n  A fact registry holds a hash table of verified \"facts\" which are represented by a hash of claims\n  that the registry hash check and found valid. This table may be queried by accessing the\n  isValid() function of the registry with a given hash.\n\n  In addition, each fact registry exposes a registry specific function for submitting new claims\n  together with their proofs. The information submitted varies from one registry to the other\n  depending of the type of fact requiring verification.\n\n  For further reading on the Fact Registry design pattern see this\n  `StarkWare blog post \u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\u003e`_.\n*/\ninterface IFactRegistry {\n    /*\n      Returns true if the given fact was previously registered in the contract.\n    */\n    function isValid(bytes32 fact)\n        external view\n        returns(bool);\n}\n"},"IQueryableFactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\nimport \"IFactRegistry.sol\";\n\n/*\n  Extends the IFactRegistry interface with a query method that indicates\n  whether the fact registry has successfully registered any fact or is still empty of such facts.\n*/\ninterface IQueryableFactRegistry is IFactRegistry {\n\n    /*\n      Returns true if at least one fact has been registered.\n    */\n    function hasRegisteredFact()\n        external view\n        returns(bool);\n\n}\n"},"MemoryPageFactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\nimport \"FactRegistry.sol\";\n\ncontract MemoryPageFactRegistryConstants {\n    // A page based on a list of pairs (address, value).\n    // In this case, memoryHash = hash(address, value, address, value, address, value, ...).\n    uint256 internal constant REGULAR_PAGE = 0;\n    // A page based on adjacent memory cells, starting from a given address.\n    // In this case, memoryHash = hash(value, value, value, ...).\n    uint256 internal constant CONTINUOUS_PAGE = 1;\n}\n\n/*\n  A fact registry for the claim:\n    I know n pairs (addr, value) for which the hash of the pairs is memoryHash, and the cumulative\n    product: \\prod_i( z - (addr_i + alpha * value_i) ) is prod.\n  The exact format of the hash depends on the type of the page\n  (see MemoryPageFactRegistryConstants).\n  The fact consists of (pageType, prime, n, z, alpha, prod, memoryHash, address).\n  Note that address is only available for CONTINUOUS_PAGE, and otherwise it is 0.\n*/\ncontract MemoryPageFactRegistry is FactRegistry, MemoryPageFactRegistryConstants {\n    event LogMemoryPageFactRegular(bytes32 factHash, uint256 memoryHash, uint256 prod);\n    event LogMemoryPageFactContinuous(bytes32 factHash, uint256 memoryHash, uint256 prod);\n\n    /*\n      Registers a fact based of the given memory (address, value) pairs (REGULAR_PAGE).\n    */\n    function registerRegularMemoryPage(\n        uint256[] calldata memoryPairs, uint256 z, uint256 alpha, uint256 prime)\n        external returns (bytes32 factHash, uint256 memoryHash, uint256 prod)\n    {\n        require(memoryPairs.length \u003c 2**20, \"Too many memory values.\");\n        require(memoryPairs.length % 2 == 0, \"Size of memoryPairs must be even.\");\n        require(z \u003c prime, \"Invalid value of z.\");\n        require(alpha \u003c prime, \"Invalid value of alpha.\");\n        (factHash, memoryHash, prod) = computeFactHash(memoryPairs, z, alpha, prime);\n        emit LogMemoryPageFactRegular(factHash, memoryHash, prod);\n\n        registerFact(factHash);\n    }\n\n    function computeFactHash(\n        uint256[] memory memoryPairs, uint256 z, uint256 alpha, uint256 prime)\n        internal pure returns (bytes32 factHash, uint256 memoryHash, uint256 prod) {\n        uint256 memorySize = memoryPairs.length / 2;\n\n        prod = 1;\n\n        assembly {\n            let memoryPtr := add(memoryPairs, 0x20)\n\n            // Each value of memoryPairs is a pair: (address, value).\n            let lastPtr := add(memoryPtr, mul(memorySize, 0x40))\n            for { let ptr := memoryPtr } lt(ptr, lastPtr) { ptr := add(ptr, 0x40) } {\n                // Compute address + alpha * value.\n                let address_value_lin_comb := addmod(\n                    /*address*/ mload(ptr),\n                    mulmod(/*value*/ mload(add(ptr, 0x20)), alpha, prime),\n                    prime)\n                prod := mulmod(prod, add(z, sub(prime, address_value_lin_comb)), prime)\n            }\n\n            memoryHash := keccak256(memoryPtr, mul(/*0x20 * 2*/ 0x40, memorySize))\n        }\n\n        factHash = keccak256(\n            abi.encodePacked(\n                REGULAR_PAGE, prime, memorySize, z, alpha, prod, memoryHash, uint256(0))\n        );\n    }\n\n    /*\n      Registers a fact based on the given values, assuming continuous addresses.\n      values should be [value at startAddr, value at (startAddr + 1), ...].\n    */\n    function registerContinuousMemoryPage(  // NOLINT: external-function.\n        uint256 startAddr, uint256[] memory values, uint256 z, uint256 alpha, uint256 prime)\n        public returns (bytes32 factHash, uint256 memoryHash, uint256 prod)\n    {\n        require(values.length \u003c 2**20, \"Too many memory values.\");\n        require(prime \u003c 2**254, \"prime is too big for the optimizations in this function.\");\n        require(z \u003c prime, \"Invalid value of z.\");\n        require(alpha \u003c prime, \"Invalid value of alpha.\");\n        require(startAddr \u003c 2**64 \u0026\u0026 startAddr \u003c prime, \"Invalid value of startAddr.\");\n\n        uint256 nValues = values.length;\n\n        assembly {\n            // Initialize prod to 1.\n            prod := 1\n            // Initialize valuesPtr to point to the first value in the array.\n            let valuesPtr := add(values, 0x20)\n\n            let minus_z := mod(sub(prime, z), prime)\n\n            // Start by processing full batches of 8 cells, addr represents the last address in each\n            // batch.\n            let addr := add(startAddr, 7)\n            let lastAddr := add(startAddr, nValues)\n            for {} lt(addr, lastAddr) { addr := add(addr, 8) } {\n                // Compute the product of (lin_comb - z) instead of (z - lin_comb), since we\u0027re\n                // doing an even number of iterations, the result is the same.\n                prod :=\n                    mulmod(prod,\n                    mulmod(add(add(sub(addr, 7), mulmod(\n                        mload(valuesPtr), alpha, prime)), minus_z),\n                    add(add(sub(addr, 6), mulmod(\n                        mload(add(valuesPtr, 0x20)), alpha, prime)), minus_z),\n                    prime), prime)\n\n                prod :=\n                    mulmod(prod,\n                    mulmod(add(add(sub(addr, 5), mulmod(\n                        mload(add(valuesPtr, 0x40)), alpha, prime)), minus_z),\n                    add(add(sub(addr, 4), mulmod(\n                        mload(add(valuesPtr, 0x60)), alpha, prime)), minus_z),\n                    prime), prime)\n\n                prod :=\n                    mulmod(prod,\n                    mulmod(add(add(sub(addr, 3), mulmod(\n                        mload(add(valuesPtr, 0x80)), alpha, prime)), minus_z),\n                    add(add(sub(addr, 2), mulmod(\n                        mload(add(valuesPtr, 0xa0)), alpha, prime)), minus_z),\n                    prime), prime)\n\n                prod :=\n                    mulmod(prod,\n                    mulmod(add(add(sub(addr, 1), mulmod(\n                        mload(add(valuesPtr, 0xc0)), alpha, prime)), minus_z),\n                    add(add(addr, mulmod(\n                        mload(add(valuesPtr, 0xe0)), alpha, prime)), minus_z),\n                    prime), prime)\n\n                valuesPtr := add(valuesPtr, 0x100)\n            }\n\n            // Handle leftover.\n            // Translate addr to the beginning of the last incomplete batch.\n            addr := sub(addr, 7)\n            for {} lt(addr, lastAddr) { addr := add(addr, 1) } {\n                let address_value_lin_comb := addmod(\n                    addr, mulmod(mload(valuesPtr), alpha, prime), prime)\n                prod := mulmod(prod, add(z, sub(prime, address_value_lin_comb)), prime)\n                valuesPtr := add(valuesPtr, 0x20)\n            }\n\n            memoryHash := keccak256(add(values, 0x20), mul(0x20, nValues))\n        }\n\n        factHash = keccak256(\n            abi.encodePacked(\n                CONTINUOUS_PAGE, prime, nValues, z, alpha, prod, memoryHash, startAddr)\n        );\n\n        emit LogMemoryPageFactContinuous(factHash, memoryHash, prod);\n\n        registerFact(factHash);\n    }\n}\n"},"PrimeFieldElement0.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\n\ncontract PrimeFieldElement0 {\n    uint256 constant internal K_MODULUS =\n    0x800000000000011000000000000000000000000000000000000000000000001;\n    uint256 constant internal K_MODULUS_MASK =\n    0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 constant internal K_MONTGOMERY_R =\n    0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1;\n    uint256 constant internal K_MONTGOMERY_R_INV =\n    0x40000000000001100000000000012100000000000000000000000000000000;\n    uint256 constant internal GENERATOR_VAL = 3;\n    uint256 constant internal ONE_VAL = 1;\n    uint256 constant internal GEN1024_VAL =\n    0x659d83946a03edd72406af6711825f5653d9e35dc125289a206c054ec89c4f1;\n\n    function fromMontgomery(uint256 val) internal pure returns (uint256 res) {\n        // uint256 res = fmul(val, kMontgomeryRInv);\n        assembly {\n            res := mulmod(val,\n                          0x40000000000001100000000000012100000000000000000000000000000000,\n                          0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fromMontgomeryBytes(bytes32 bs) internal pure returns (uint256) {\n        // Assuming bs is a 256bit bytes object, in Montgomery form, it is read into a field\n        // element.\n        uint256 res = uint256(bs);\n        return fromMontgomery(res);\n    }\n\n    function toMontgomeryInt(uint256 val) internal pure returns (uint256 res) {\n        //uint256 res = fmul(val, kMontgomeryR);\n        assembly {\n            res := mulmod(val,\n                          0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1,\n                          0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fmul(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        //uint256 res = mulmod(a, b, kModulus);\n        assembly {\n            res := mulmod(a, b,\n                0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fadd(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, b, kModulus);\n        assembly {\n            res := addmod(a, b,\n                0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fsub(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, kModulus - b, kModulus);\n        assembly {\n            res := addmod(\n                a,\n                sub(0x800000000000011000000000000000000000000000000000000000000000001, b),\n                0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fpow(uint256 val, uint256 exp) internal view returns (uint256) {\n        return expmod(val, exp, K_MODULUS);\n    }\n\n    function expmod(uint256 base, uint256 exponent, uint256 modulus)\n        internal view returns (uint256 res)\n    {\n        assembly {\n            let p := mload(0x40)\n            mstore(p, 0x20)                  // Length of Base.\n            mstore(add(p, 0x20), 0x20)       // Length of Exponent.\n            mstore(add(p, 0x40), 0x20)       // Length of Modulus.\n            mstore(add(p, 0x60), base)       // Base.\n            mstore(add(p, 0x80), exponent)   // Exponent.\n            mstore(add(p, 0xa0), modulus)    // Modulus.\n            // Call modexp precompile.\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n            res := mload(p)\n        }\n    }\n\n    function inverse(uint256 val) internal view returns (uint256) {\n        return expmod(val, K_MODULUS - 2, K_MODULUS);\n    }\n}\n"}}