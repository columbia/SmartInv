{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "details": {
        "constantOptimizer": true,
        "cse": true,
        "deduplicate": true,
        "inliner": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "peephole": true,
        "yul": true,
        "yulDetails": {
          "optimizerSteps": "dhfoDgvulfnTUtnIf",
          "stackAllocation": true
        }
      },
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*///////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    event URI(string value, uint256 indexed id);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) internal _balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function isApproved(address account, address operator)\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return isApprovedForAll[account][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        _balanceOf[from][id] -= amount;\n        _balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender,\n                    from,\n                    id,\n                    amount,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        for (uint256 i = 0; i < idsLength; ) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balanceOf[from][id] -= amount;\n            _balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _balanceOfBatch(address[] memory owners, uint256[] memory ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 ownersLength = owners.length; // Saves MLOADs.\n\n        require(ownersLength == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < ownersLength; i++) {\n                balances[i] = _balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        returns (bool)\n    {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        _balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender,\n                    address(0),\n                    id,\n                    amount,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            _balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    address(0),\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            _balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        _balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\ninterface ERC1155TokenReceiver {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/RAW.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"./ERC1155.sol\";\r\nimport \"./interfaces/IRAW.sol\";\r\nimport \"./interfaces/IRAWoriginal.sol\";\r\nimport \"./interfaces/IEON.sol\";\r\n\r\ncontract RAW is IRAW, ERC1155, Pausable {\r\n    using Strings for uint256;\r\n\r\n    struct LastWrite {\r\n        uint64 time;\r\n        uint64 blockNum;\r\n    }\r\n\r\n    // struct to store each trait's data for metadata and rendering\r\n    struct Image {\r\n        string name;\r\n        string png;\r\n    }\r\n\r\n    struct TypeInfo {\r\n        uint256 mints;\r\n        uint256 burns;\r\n        uint256 maxSupply;\r\n        uint256 eonExchangeAmt;\r\n    }\r\n\r\n    mapping(uint256 => TypeInfo) private typeInfo;\r\n    // storage of each image data\r\n    mapping(uint256 => Image) public traitData;\r\n\r\n    // address => allowedToCallFunctions\r\n    mapping(address => bool) private admins;\r\n\r\n    // Tracks the last block and timestamp that a caller has written to state.\r\n    // Disallow some access to functions if they occur while a change is being written.\r\n    mapping(address => LastWrite) private lastWriteAddress;\r\n\r\n    event UpdateMintBurns(uint256 typeId, uint256 mintQty, uint256 burnQty);\r\n\r\n    // reference to the $EON contract for exchange rate if accepted\r\n    IEON public eon;\r\n\r\n    // reference to the original Raw contract\r\n    IRAWoriginal public originalRaw;\r\n\r\n    address public auth;\r\n\r\n    uint256 public migrated;\r\n\r\n    constructor() {\r\n        _pause();\r\n        auth = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == auth);\r\n        _;\r\n    }\r\n\r\n    /** CRITICAL TO SETUP */\r\n\r\n    modifier requireContractsSet() {\r\n        require(address(eon) != address(0), \"Contracts not set\");\r\n        _;\r\n    }\r\n\r\n    modifier blockIfChangingAddress() {\r\n        require(\r\n            admins[msg.sender] ||\r\n                lastWriteAddress[tx.origin].blockNum < block.number,\r\n            \"Your trying the cheat\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setContracts(address _eon, address _originalRaw)\r\n        external\r\n        onlyOwner\r\n    {\r\n        eon = IEON(_eon);\r\n        originalRaw = IRAWoriginal(_originalRaw);\r\n    }\r\n\r\n    /**\r\n     * Mint a token - any payment / game logic should be handled in the game contract.\r\n     */\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address recipient\r\n    ) external override whenNotPaused {\r\n        require(admins[msg.sender],  \"Only admins\");\r\n        require(\r\n            (typeInfo[typeId].mints + qty) <= typeInfo[typeId].maxSupply,\r\n            \"MaxSupply Minted\"\r\n        );\r\n        typeInfo[typeId].mints += qty;\r\n        _mint(recipient, typeId, qty, \"\");\r\n    }\r\n\r\n    /**\r\n     * Burn a token - any payment / game logic should be handled in the game contract.\r\n     */\r\n    function burn(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address burnFrom\r\n    ) external override whenNotPaused {\r\n        require(admins[msg.sender], \"Only admins\");\r\n        typeInfo[typeId].burns += qty;\r\n        _burn(burnFrom, typeId, qty);\r\n    }\r\n\r\n    function setType(uint256 typeId, uint256 maxSupply) external onlyOwner {\r\n        require(typeId != 0, \"TypeId cannot be 0\");\r\n        require(typeInfo[typeId].mints <= maxSupply, \"max supply too low\");\r\n        typeInfo[typeId].maxSupply = maxSupply;\r\n    }\r\n\r\n    // a function to update the mint and burn amounts\r\n    // to save gas costs of doing both a mint and then\r\n    // burn when cost is paid from an amount owed\r\n    function updateMintBurns(\r\n        uint256 typeId,\r\n        uint256 mintQty,\r\n        uint256 burnQty\r\n    ) external {\r\n        require(admins[msg.sender], \"Only Admins\");\r\n        typeInfo[typeId].mints += mintQty;\r\n        typeInfo[typeId].burns += burnQty;\r\n\r\n        emit UpdateMintBurns(typeId, mintQty, burnQty);\r\n    }\r\n\r\n    function setExchangeAmt(uint256 typeId, uint256 exchangeAmt)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            typeInfo[typeId].maxSupply > 0,\r\n            \"this type has not been set up\"\r\n        );\r\n        typeInfo[typeId].eonExchangeAmt = exchangeAmt;\r\n    }\r\n\r\n    function balanceOf(address tokenOwner, uint256 typeId)\r\n        public\r\n        view\r\n        blockIfChangingAddress\r\n        returns (uint256)\r\n    {\r\n        //Prevent chencking balance in the same block it's being modified..\r\n        require(\r\n            admins[msg.sender] ||\r\n                lastWriteAddress[tokenOwner].blockNum < block.number,\r\n            \"no checking balance in the same block it's being modified\"\r\n        );\r\n        uint256 balance = _balanceOf[tokenOwner][typeId];\r\n        return balance;\r\n    }\r\n  function updateOriginAccess(address user) external override {\r\n        require(admins[_msgSender()], \"Only admins can call this\");\r\n        uint64 blockNum = uint64(block.number);\r\n        uint64 time = uint64(block.timestamp);\r\n        lastWriteAddress[user] = LastWrite(time, blockNum);\r\n  }\r\n    /**\r\n     * creates identical tokens in the new contract\r\n     * and burns any original tokens\r\n     * @param typeId the type of the tokens to migrate\r\n     */\r\n    function migrate(uint256 typeId) external whenNotPaused {\r\n        uint256 amount = originalRaw.getBalance(msg.sender, typeId);\r\n        require(amount > 0, \"no tokens to migrate\");\r\n        originalRaw.burn(typeId, amount, msg.sender);\r\n        _mint(msg.sender, typeId, amount, \"\");\r\n        migrated += amount;\r\n    }\r\n\r\n    /**\r\n     * enables an address to mint / burn\r\n     * @param addr the address to enable\r\n     */\r\n    function addAdmin(address addr) external onlyOwner {\r\n        admins[addr] = true;\r\n    }\r\n\r\n    /**\r\n     * disables an address from minting / burning\r\n     * @param addr the address to disbale\r\n     */\r\n    function removeAdmin(address addr) external onlyOwner {\r\n        admins[addr] = false;\r\n    }\r\n\r\n    function setPaused(bool _paused) external onlyOwner requireContractsSet {\r\n        if (_paused) _pause();\r\n        else _unpause();\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        auth = newOwner;\r\n    }\r\n\r\n    function getInfoForType(uint256 typeId)\r\n        external\r\n        view\r\n        returns (TypeInfo memory)\r\n    {\r\n        require(typeInfo[typeId].maxSupply > 0, \"invalid type\");\r\n        return typeInfo[typeId];\r\n    }\r\n\r\n    function uri(uint256 typeId) public view override returns (string memory) {\r\n        require(typeInfo[typeId].maxSupply > 0, \"invalid type\");\r\n        Image memory img = traitData[typeId];\r\n        string memory metadata = string(\r\n            abi.encodePacked(\r\n                '{\"name\": \"',\r\n                img.name,\r\n                '\", \"description\": \"Raw Pytheas resources - All the metadata and images are generated and stored 100% on-chain. No IPFS. NO API. Just the Ethereum blockchain.\", \"image\": \"data:image/svg+xml;base64,',\r\n                base64(bytes(drawSVG(typeId))),\r\n                '\", \"attributes\": []',\r\n                \"}\"\r\n            )\r\n        );\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    \"data:application/json;base64,\",\r\n                    base64(bytes(metadata))\r\n                )\r\n            );\r\n    }\r\n\r\n    function uploadImage(uint256 typeId, Image calldata image)\r\n        external\r\n        onlyOwner\r\n    {\r\n        traitData[typeId] = Image(image.name, image.png);\r\n    }\r\n\r\n    function drawImage(Image memory image)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    '<image x=\"0\" y=\"0\" width=\"64\" height=\"64\" image-rendering=\"pixelated\" preserveAspectRatio=\"xMidYMid\" xlink:href=\"data:image/png;base64,',\r\n                    image.png,\r\n                    '\"/>'\r\n                )\r\n            );\r\n    }\r\n\r\n    function drawSVG(uint256 typeId) internal view returns (string memory) {\r\n        string memory svgString = string(\r\n            abi.encodePacked(drawImage(traitData[typeId]))\r\n        );\r\n\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    '<svg id=\"rawResources\" width=\"100%\" height=\"100%\" version=\"1.1\" viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\r\n                    svgString,\r\n                    \"</svg>\"\r\n                )\r\n            );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override(ERC1155, IRAW) {\r\n        require(lastWriteAddress[from].blockNum < block.number, \"no overwriting\");\r\n        // allow admin contracts to send without approval\r\n        if (!admins[msg.sender]) {\r\n            require(\r\n                msg.sender == from || isApprovedForAll[from][msg.sender],\r\n                \"NOT_AUTHORIZED\"\r\n            );\r\n        }\r\n        _balanceOf[from][id] -= amount;\r\n        _balanceOf[to][id] += amount;\r\n\r\n        emit TransferSingle(msg.sender, from, to, id, amount);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155Received(\r\n                    msg.sender,\r\n                    from,\r\n                    id,\r\n                    amount,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override(ERC1155, IRAW) {\r\n         require(lastWriteAddress[from].blockNum < block.number, \"no overwriting\");\r\n        // allow admin contracts to send without approval\r\n        uint256 idsLength = ids.length; // Saves MLOADs.\r\n\r\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\r\n\r\n        // allow admin contracts to send without approval\r\n        if (!admins[msg.sender]) {\r\n            require(\r\n                msg.sender == from || isApprovedForAll[from][msg.sender],\r\n                \"NOT_AUTHORIZED\"\r\n            );\r\n        }\r\n\r\n        for (uint256 i = 0; i < idsLength; ) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            _balanceOf[from][id] -= amount;\r\n            _balanceOf[to][id] += amount;\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\r\n                    msg.sender,\r\n                    from,\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    /** BASE 64 - Written by Brech Devos */\r\n\r\n    string internal constant TABLE =\r\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    function base64(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length == 0) return \"\";\r\n\r\n        // load the table into memory\r\n        string memory table = TABLE;\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n        // add some extra buffer at the end required for the writing\r\n        string memory result = new string(encodedLen + 32);\r\n\r\n        assembly {\r\n            // set the actual output length\r\n            mstore(result, encodedLen)\r\n\r\n            // prepare the lookup table\r\n            let tablePtr := add(table, 1)\r\n\r\n            // input ptr\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            // result ptr, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // run over the input, 3 bytes at a time\r\n            for {\r\n\r\n            } lt(dataPtr, endPtr) {\r\n\r\n            } {\r\n                dataPtr := add(dataPtr, 3)\r\n\r\n                // read 3 bytes\r\n                let input := mload(dataPtr)\r\n\r\n                // write 4 characters\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n            }\r\n\r\n            // padding with '='\r\n            switch mod(mload(data), 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // For OpenSeas\r\n    function owner() public view virtual returns (address) {\r\n        return auth;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IEON.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IEON {\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    function burn(address from, uint256 amount) external;\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IRAW.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\npragma solidity ^0.8.0;\n\ninterface IRAW {\n\n    function updateOriginAccess(address user) external;\n\n\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external returns(uint256);\n\n    function mint(\n        uint256 typeId,\n        uint256 qty,\n        address recipient\n    ) external;\n\n    function burn(\n        uint256 typeId,\n        uint256 qty,\n        address burnFrom\n    ) external;\n\n    function updateMintBurns(\n        uint256 typeId,\n        uint256 mintQty,\n        uint256 burnQty\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external;\n\n}\n"
    },
    "contracts/interfaces/IRAWoriginal.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRAWoriginal {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function updateMintBurns(\r\n        uint256 typeId,\r\n        uint256 mintQty,\r\n        uint256 burnQty\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n\r\n}\r\n"
    }
  }
}}