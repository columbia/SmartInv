{{
  "language": "Solidity",
  "sources": {
    "contracts/governance/Entropy.sol": {
      "content": "// SPDX-License-Identifier: GPL 3.0\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./SafeMath.sol\";\n\ncontract Entropy {\n\t/// @notice EIP-20 token name for this token\n\tstring public constant name = \"Entropy\";\n\n\t/// @notice EIP-20 token symbol for this token\n\tstring public constant symbol = \"ERP\";\n\n\t/// @notice EIP-20 token decimals for this token\n\tuint8 public constant decimals = 18;\n\n\t/// @notice Total number of tokens in circulation\n\tuint256 public totalSupply = 1_000_000_000e18; // 1 billion Erp\n\n\t/// @notice Address which may mint new tokens\n\taddress public minter;\n\n\t/// @notice The timestamp after which minting may occur\n\tuint256 public mintingAllowedAfter;\n\n\t/// @notice Minimum time between mints\n\tuint32 public constant minimumTimeBetweenMints = 1 days * 365;\n\n\t/// @notice Cap on the percentage of totalSupply that can be minted at each mint\n\tuint8 public constant mintCap = 2;\n\n\t/// @notice Allowance amounts on behalf of others\n\tmapping(address => mapping(address => uint96)) internal allowances;\n\n\t/// @notice Official record of token balances for each account\n\tmapping(address => uint96) internal balances;\n\n\t/// @notice A record of each accounts delegate\n\tmapping(address => address) public delegates;\n\n\t/// @notice A checkpoint for marking number of votes from a given block\n\tstruct Checkpoint {\n\t\tuint32 fromBlock;\n\t\tuint96 votes;\n\t}\n\n\t/// @notice A record of votes checkpoints for each account, by index\n\tmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n\t/// @notice The number of checkpoints for each account\n\tmapping(address => uint32) public numCheckpoints;\n\n\t/// @notice The EIP-712 typehash for the contract's domain\n\tbytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\t/// @notice The EIP-712 typehash for the delegation struct used by the contract\n\tbytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n\t/// @notice The EIP-712 typehash for the permit struct used by the contract\n\tbytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\t/// @notice A record of states for signing / validating signatures\n\tmapping(address => uint256) public nonces;\n\n\t/// @notice An event thats emitted when the minter address is changed\n\tevent MinterChanged(address minter, address newMinter);\n\n\t/// @notice An event thats emitted when an account changes its delegate\n\tevent DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n\t/// @notice An event thats emitted when a delegate account's vote balance changes\n\tevent DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n\t/// @notice The standard EIP-20 transfer event\n\tevent Transfer(address indexed from, address indexed to, uint256 amount);\n\n\t/// @notice The standard EIP-20 approval event\n\tevent Approval(address indexed owner, address indexed spender, uint256 amount);\n\n\t/**\n\t * @notice Construct a new Erp token\n\t * @param account The initial account to grant all the tokens\n\t * @param minter_ The account with minting ability\n\t * @param mintingAllowedAfter_ The timestamp after which minting may occur\n\t */\n\tconstructor(\n\t\taddress account,\n\t\taddress minter_,\n\t\tuint256 mintingAllowedAfter_\n\t) public {\n\t\trequire(mintingAllowedAfter_ >= block.timestamp, \"Erp::constructor: minting can only begin after deployment\");\n\n\t\tbalances[account] = uint96(totalSupply);\n\t\temit Transfer(address(0), account, totalSupply);\n\t\tminter = minter_;\n\t\temit MinterChanged(address(0), minter);\n\t\tmintingAllowedAfter = mintingAllowedAfter_;\n\t}\n\n\t/**\n\t * @notice Change the minter address\n\t * @param minter_ The address of the new minter\n\t */\n\tfunction setMinter(address minter_) external {\n\t\trequire(msg.sender == minter, \"Erp::setMinter: only the minter can change the minter address\");\n\t\temit MinterChanged(minter, minter_);\n\t\tminter = minter_;\n\t}\n\n\t/**\n\t * @notice Mint new tokens\n\t * @param dst The address of the destination account\n\t * @param rawAmount The number of tokens to be minted\n\t */\n\tfunction mint(address dst, uint256 rawAmount) external {\n\t\trequire(msg.sender == minter, \"Erp::mint: only the minter can mint\");\n\t\trequire(block.timestamp >= mintingAllowedAfter, \"Erp::mint: minting not allowed yet\");\n\t\trequire(dst != address(0), \"Erp::mint: cannot transfer to the zero address\");\n\n\t\t// record the mint\n\t\tmintingAllowedAfter = SafeMath.add(block.timestamp, minimumTimeBetweenMints);\n\n\t\t// mint the amount\n\t\tuint96 amount = safe96(rawAmount, \"Erp::mint: amount exceeds 96 bits\");\n\t\trequire(amount <= SafeMath.div(SafeMath.mul(totalSupply, mintCap), 100), \"Erp::mint: exceeded mint cap\");\n\t\ttotalSupply = safe96(SafeMath.add(totalSupply, amount), \"Erp::mint: totalSupply exceeds 96 bits\");\n\n\t\t// transfer the amount to the recipient\n\t\tbalances[dst] = add96(balances[dst], amount, \"Erp::mint: transfer amount overflows\");\n\t\temit Transfer(address(0), dst, amount);\n\n\t\t// move delegates\n\t\t_moveDelegates(address(0), delegates[dst], amount);\n\t}\n\n\t/**\n\t * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n\t * @param account The address of the account holding the funds\n\t * @param spender The address of the account spending the funds\n\t * @return The number of tokens approved\n\t */\n\tfunction allowance(address account, address spender) external view returns (uint256) {\n\t\treturn allowances[account][spender];\n\t}\n\n\t/**\n\t * @notice Approve `spender` to transfer up to `amount` from `src`\n\t * @dev This will overwrite the approval amount for `spender`\n\t *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n\t * @param spender The address of the account which may transfer tokens\n\t * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n\t * @return Whether or not the approval succeeded\n\t */\n\tfunction approve(address spender, uint256 rawAmount) external returns (bool) {\n\t\tuint96 amount;\n\t\tif (rawAmount == uint256(-1)) {\n\t\t\tamount = uint96(-1);\n\t\t} else {\n\t\t\tamount = safe96(rawAmount, \"Erp::approve: amount exceeds 96 bits\");\n\t\t}\n\n\t\tallowances[msg.sender][spender] = amount;\n\n\t\temit Approval(msg.sender, spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Triggers an approval from owner to spends\n\t * @param owner The address to approve from\n\t * @param spender The address to be approved\n\t * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n\t * @param deadline The time at which to expire the signature\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 rawAmount,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\tuint96 amount;\n\t\tif (rawAmount == uint256(-1)) {\n\t\t\tamount = uint96(-1);\n\t\t} else {\n\t\t\tamount = safe96(rawAmount, \"Erp::permit: amount exceeds 96 bits\");\n\t\t}\n\n\t\tbytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\t\tbytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t\taddress signatory = ecrecover(digest, v, r, s);\n\t\trequire(signatory != address(0), \"Erp::permit: invalid signature\");\n\t\trequire(signatory == owner, \"Erp::permit: unauthorized\");\n\t\trequire(now <= deadline, \"Erp::permit: signature expired\");\n\n\t\tallowances[owner][spender] = amount;\n\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\t/**\n\t * @notice Get the number of tokens held by the `account`\n\t * @param account The address of the account to get the balance of\n\t * @return The number of tokens held\n\t */\n\tfunction balanceOf(address account) external view returns (uint256) {\n\t\treturn balances[account];\n\t}\n\n\t/**\n\t * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n\t * @param dst The address of the destination account\n\t * @param rawAmount The number of tokens to transfer\n\t * @return Whether or not the transfer succeeded\n\t */\n\tfunction transfer(address dst, uint256 rawAmount) external returns (bool) {\n\t\tuint96 amount = safe96(rawAmount, \"Erp::transfer: amount exceeds 96 bits\");\n\t\t_transferTokens(msg.sender, dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfer `amount` tokens from `src` to `dst`\n\t * @param src The address of the source account\n\t * @param dst The address of the destination account\n\t * @param rawAmount The number of tokens to transfer\n\t * @return Whether or not the transfer succeeded\n\t */\n\tfunction transferFrom(\n\t\taddress src,\n\t\taddress dst,\n\t\tuint256 rawAmount\n\t) external returns (bool) {\n\t\taddress spender = msg.sender;\n\t\tuint96 spenderAllowance = allowances[src][spender];\n\t\tuint96 amount = safe96(rawAmount, \"Erp::approve: amount exceeds 96 bits\");\n\n\t\tif (spender != src && spenderAllowance != uint96(-1)) {\n\t\t\tuint96 newAllowance = sub96(spenderAllowance, amount, \"Erp::transferFrom: transfer amount exceeds spender allowance\");\n\t\t\tallowances[src][spender] = newAllowance;\n\n\t\t\temit Approval(src, spender, newAllowance);\n\t\t}\n\n\t\t_transferTokens(src, dst, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` to `delegatee`\n\t * @param delegatee The address to delegate votes to\n\t */\n\tfunction delegate(address delegatee) public {\n\t\treturn _delegate(msg.sender, delegatee);\n\t}\n\n\t/**\n\t * @notice Delegates votes from signatory to `delegatee`\n\t * @param delegatee The address to delegate votes to\n\t * @param nonce The contract state required to match the signature\n\t * @param expiry The time at which to expire the signature\n\t * @param v The recovery byte of the signature\n\t * @param r Half of the ECDSA signature pair\n\t * @param s Half of the ECDSA signature pair\n\t */\n\tfunction delegateBySig(\n\t\taddress delegatee,\n\t\tuint256 nonce,\n\t\tuint256 expiry,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\tbytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\t\tbytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t\taddress signatory = ecrecover(digest, v, r, s);\n\t\trequire(signatory != address(0), \"Erp::delegateBySig: invalid signature\");\n\t\trequire(nonce == nonces[signatory]++, \"Erp::delegateBySig: invalid nonce\");\n\t\trequire(now <= expiry, \"Erp::delegateBySig: signature expired\");\n\t\treturn _delegate(signatory, delegatee);\n\t}\n\n\t/**\n\t * @notice Gets the current votes balance for `account`\n\t * @param account The address to get votes balance\n\t * @return The number of current votes for `account`\n\t */\n\tfunction getCurrentVotes(address account) external view returns (uint96) {\n\t\tuint32 nCheckpoints = numCheckpoints[account];\n\t\treturn nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of votes for an account as of a block number\n\t * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n\t * @param account The address of the account to check\n\t * @param blockNumber The block number to get the vote balance at\n\t * @return The number of votes the account had as of the given block\n\t */\n\tfunction getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"Erp::getPriorVotes: not yet determined\");\n\n\t\tuint32 nCheckpoints = numCheckpoints[account];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// First check most recent balance\n\t\tif (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn checkpoints[account][nCheckpoints - 1].votes;\n\t\t}\n\n\t\t// Next check implicit zero balance\n\t\tif (checkpoints[account][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\t\t\tCheckpoint memory cp = checkpoints[account][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.votes;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn checkpoints[account][lower].votes;\n\t}\n\n\tfunction _delegate(address delegator, address delegatee) internal {\n\t\taddress currentDelegate = delegates[delegator];\n\t\tuint96 delegatorBalance = balances[delegator];\n\t\tdelegates[delegator] = delegatee;\n\n\t\temit DelegateChanged(delegator, currentDelegate, delegatee);\n\n\t\t_moveDelegates(currentDelegate, delegatee, delegatorBalance);\n\t}\n\n\tfunction _transferTokens(\n\t\taddress src,\n\t\taddress dst,\n\t\tuint96 amount\n\t) internal {\n\t\trequire(src != address(0), \"Erp::_transferTokens: cannot transfer from the zero address\");\n\t\trequire(dst != address(0), \"Erp::_transferTokens: cannot transfer to the zero address\");\n\n\t\tbalances[src] = sub96(balances[src], amount, \"Erp::_transferTokens: transfer amount exceeds balance\");\n\t\tbalances[dst] = add96(balances[dst], amount, \"Erp::_transferTokens: transfer amount overflows\");\n\t\temit Transfer(src, dst, amount);\n\n\t\t_moveDelegates(delegates[src], delegates[dst], amount);\n\t}\n\n\tfunction _moveDelegates(\n\t\taddress srcRep,\n\t\taddress dstRep,\n\t\tuint96 amount\n\t) internal {\n\t\tif (srcRep != dstRep && amount > 0) {\n\t\t\tif (srcRep != address(0)) {\n\t\t\t\tuint32 srcRepNum = numCheckpoints[srcRep];\n\t\t\t\tuint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n\t\t\t\tuint96 srcRepNew = sub96(srcRepOld, amount, \"Erp::_moveVotes: vote amount underflows\");\n\t\t\t\t_writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n\t\t\t}\n\n\t\t\tif (dstRep != address(0)) {\n\t\t\t\tuint32 dstRepNum = numCheckpoints[dstRep];\n\t\t\t\tuint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n\t\t\t\tuint96 dstRepNew = add96(dstRepOld, amount, \"Erp::_moveVotes: vote amount overflows\");\n\t\t\t\t_writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _writeCheckpoint(\n\t\taddress delegatee,\n\t\tuint32 nCheckpoints,\n\t\tuint96 oldVotes,\n\t\tuint96 newVotes\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Erp::_writeCheckpoint: block number exceeds 32 bits\");\n\n\t\tif (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tcheckpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n\t\t} else {\n\t\t\tcheckpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n\t\t\tnumCheckpoints[delegatee] = nCheckpoints + 1;\n\t\t}\n\n\t\temit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n\t}\n\n\tfunction safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n\t\trequire(n < 2**32, errorMessage);\n\t\treturn uint32(n);\n\t}\n\n\tfunction safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n\t\trequire(n < 2**96, errorMessage);\n\t\treturn uint96(n);\n\t}\n\n\tfunction add96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tuint96 c = a + b;\n\t\trequire(c >= a, errorMessage);\n\t\treturn c;\n\t}\n\n\tfunction sub96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\trequire(b <= a, errorMessage);\n\t\treturn a - b;\n\t}\n\n\tfunction getChainId() internal pure returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n}\n"
    },
    "contracts/governance/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL 3.0\npragma solidity ^0.5.16;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, errorMessage);\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot underflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction underflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot underflow.\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, errorMessage);\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers.\n\t * Reverts on division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers.\n\t * Reverts with custom message on division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}