{"ERC20Interface.sol":{"content":"pragma solidity \u003e= 0.5.3 \u003c 0.6.0;\r\n\r\n//  ERC20 Interface\r\n//  - interface for ERC20 token functions for compatibility\r\ninterface ERC20Interface {\r\n    function balanceOf(address _who) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"LockupCampaign.sol":{"content":"pragma solidity \u003e= 0.5.3 \u003c 0.6.0;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./TimestampMonthConv.sol\";\r\nimport \"./ERC20Interface.sol\";\r\n//import \"./ERC223ReceivingContract.sol\";\r\n\r\n//  Ownership contract\r\n//  - token contract ownership for owner \u0026 lockup addresses\r\n\r\ncontract Ownership {\r\n    address private _owner;\r\n    \r\n    event OwnerOwnershipTransferred(address indexed prevOwner, address indexed newOwner);\r\n    \r\n    // Returns contract owner address\r\n    function owner() public view returns (address){\r\n        return _owner;\r\n    }\r\n    \r\n    // Check if caller is owner account\r\n    function isOwner() public view returns (bool){\r\n        return (msg.sender == _owner);\r\n    }\r\n    \r\n    // Modifier for function restricted to owner only\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownership: the caller is not the owner address\");\r\n        _;\r\n    }\r\n    \r\n    // Transfer owner\u0027s ownership to new address\r\n    // # param newOwner: address of new owner to be transferred\r\n    function transferOwnerOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnerOwnership(newOwner);\r\n    }\r\n    \r\n    // ==== internal functions ====\r\n\r\n    function _transferOwnerOwnership(address newOwner) internal {\r\n        require (newOwner != address(0), \"Ownable: new owner is zero address\");\r\n        emit OwnerOwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    \r\n    function _setupOwnership(address own) internal {\r\n        require (own != address(0), \"Ownable: owner is zero address\");\r\n        _owner = own;\r\n        \r\n        emit OwnerOwnershipTransferred(address(0), own);\r\n    }\r\n}\r\n\r\ncontract LockupCampaign is Ownership {\r\n    using SafeMath for uint256;\r\n    using TimestampMonthConv for uint;\r\n    \r\n    enum LockStatus {NULL, LOCKED, UNLOCKED, RELEASED}\r\n    \r\n    struct WowbitInfo {\r\n        uint256 totalLocked;\r\n        uint256 totalExtraGiven;\r\n        uint256 currentLocked;\r\n        uint256 incentive3;\r\n        uint256 incentive6;\r\n        uint256 incentive9;\r\n    }\r\n    \r\n    struct ParticipatingUsers {\r\n        uint256 amountWWB;\r\n        uint256 month;\r\n        uint256 lockEnd;\r\n        bool incCalculated;\r\n        LockStatus status;\r\n    }\r\n    \r\n    struct UsersExtraTokens {\r\n        address[] exTokenAddress;\r\n        uint8[] exTokenDecimals;\r\n        uint256[] exTokenAmount;\r\n    }\r\n    \r\n    WowbitInfo public wwbInfo;\r\n    address public wwbAddress;\r\n    address[] public tokenAddresses;\r\n    uint8[] public tokenDecimals;\r\n    bool public firstSet = false;\r\n    mapping (address =\u003e ParticipatingUsers) internal userList;\r\n    mapping (address =\u003e UsersExtraTokens) internal extraList;\r\n    \r\n    event PreRegister(address indexed _userAddress);\r\n    event ConfirmRegister(address indexed _userAddress, uint256 startLock, uint256 endLock);\r\n    event TokenLocked(address indexed _userAddress, uint256 amount);\r\n    event TokenUnlocked(address indexed _userAddress, uint256 timestamp);\r\n    event TokenReleased(address indexed _userAddress, uint256 amount);\r\n    event RegisterEtcToken(address indexed _token);\r\n    event RemoveEtcToken(address indexed _token);\r\n    event EtcTokenRequested(address indexed _userAddress, address indexed _tokenAddress);\r\n    event EtcTokenReleased(address indexed _userAddress, address indexed _tokenAddress, uint256 _amountIncentives);\r\n    \r\n    constructor(address owner, address WwbTokenAddress) public{\r\n        _setupOwnership(owner);\r\n        wwbAddress = WwbTokenAddress;\r\n    }\r\n    \r\n    // --------------- ERC223 token fallback function ---------------\r\n    \r\n    // ERC223 supported tokenFallback: use erc223 transfer from token contract\r\n    function tokenFallback(address _from, uint _value, bytes memory _data) public {\r\n        string memory str = string(_data);\r\n        if(_from == owner()){\r\n            require((keccak256(abi.encodePacked((str))) == keccak256(abi.encodePacked((\"supply\")))),\r\n                    \"LockupCampaign: bytes command not authorized\");\r\n            // balance can be require from wwbTokenBalance() / otherTokenBalance()\r\n        } else if(_from != owner()){\r\n            require(userList[_from].lockEnd == 0, \"LockupCampaign: user not registered\");\r\n            _confirmRegister(_from, _value);\r\n            emit TokenLocked(_from, _value);\r\n        } else {\r\n            revert(\"LockupCampaign: not authorized\");\r\n        }\r\n    }\r\n    \r\n    // --------------- ERC20 token deposit function ---------------\r\n    \r\n    // ERC20 deposit function: owner needs to approve token using `approve()` function in respective participating ERC20 token contract\r\n    // before using this function (only owner function).\r\n    // # params erc20TokenAddress: address of the token to deposit\r\n    // # params amountToken: amount of token to deposit in contract\r\n    function depositApprovedERC20(address erc20TokenAddress, uint256 amountToken) public onlyOwner {\r\n        ERC20Interface(erc20TokenAddress).transferFrom(msg.sender, address(this), amountToken);\r\n    }\r\n    \r\n    // --------------- WWB tokens functions ---------------\r\n    \r\n    // Set the percentage interest rates (where 7% = 700) for respective months for WWB token (only owner function).\r\n    // # params rate_3month: percentage rate in 3 months\r\n    // # params rate_6month: percentage rate in 6 months\r\n    // # params rate_9month: percentage rate in 9 months\r\n    function setWwbRate(uint256 rate_3month, uint256 rate_6month, uint256 rate_9month) public onlyOwner {\r\n        _setWwbRate(rate_3month, rate_6month, rate_9month);\r\n    }\r\n    \r\n    // Retrieve the balance of WWB tokens in this contract.\r\n    // * returns (uint256): the amount of token in the contract\r\n    function wwbTokenBalance() public view returns (uint256){\r\n        return ERC20Interface(wwbAddress).balanceOf(address(this));\r\n    }\r\n    \r\n    // Returns all WWB tokens back to the owner (only owner function).\r\n    function returnAllWWBTokens() public onlyOwner {\r\n        ERC20Interface(wwbAddress).transfer(owner(), ERC20Interface(wwbAddress).balanceOf(address(this)));\r\n    }\r\n\r\n    // Returns WWB information (only owner function).\r\n    function getWwbInfo() public view onlyOwner returns (uint256, uint256, uint256, uint256, uint256, uint256){\r\n        return (wwbInfo.totalLocked, wwbInfo.totalExtraGiven, wwbInfo.currentLocked, wwbInfo.incentive3, wwbInfo.incentive6, wwbInfo.incentive9);\r\n    }\r\n    \r\n    // --------------- participating tokens functions ---------------\r\n    \r\n    // Retrieve if token address is a participating token in lockup campaign.\r\n    // # params tokenAddress: address of the participating token\r\n    // * returns (bool): indication of token participation\r\n    function isParticipatingTokens(address tokenAddress) public view returns(bool){\r\n        for(uint i = 0; i \u003c tokenAddresses.length; i++){\r\n            if(tokenAddresses[i] == tokenAddress) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Retrieve the balance of participating tokens in this contract.\r\n    // # params tokenAddress: address of the participating token\r\n    // * returns (uint256): the amount of participating token in the contract\r\n    function participatingTokenBalance(address tokenAddress) public view returns (uint256){\r\n        return ERC20Interface(tokenAddress).balanceOf(address(this));\r\n    }\r\n    \r\n    // Adds the participating tokens to be involved in lockup campaign\r\n    // # params tokenAddress: address of the participating token\r\n    // # params decimals: decimal of the participating token\r\n    function addParticipatingToken(address tokenAddress, uint8 decimals) public onlyOwner {\r\n        require(!isParticipatingTokens(tokenAddress), \"LockupCampaign: token data exists\");\r\n        require(tokenAddress != address(0), \"LockupCampaign: token contract address is zero\");\r\n        require(decimals != 0, \"LockupCampaign: token contract decimals is zero\");\r\n        require(decimals \u003c= 18, \"LockupCampaign: token contract decimals invalid\");\r\n        tokenAddresses.push(tokenAddress);\r\n        tokenDecimals.push(decimals);\r\n\r\n        emit RegisterEtcToken(tokenAddress);\r\n    }\r\n    \r\n    // Edit the registered participating tokens rates\r\n    // # params tokenAddress: address of the participating token\r\n    // # params incentive_6month: amount of token to be given for 6 month lock period\r\n    // # params incentive_9month: amount of token to be given for 9 month lock period\r\n    function removeParticipatingToken(address tokenAddress) public onlyOwner {\r\n        for (uint i = 0; i \u003c tokenAddresses.length; i++){\r\n            if(tokenAddresses[i] == tokenAddress){\r\n                tokenAddresses[i] = tokenAddresses[i+1];\r\n                tokenDecimals[i] = tokenDecimals[i+1];\r\n            }\r\n        }\r\n        tokenAddresses.length--;\r\n        tokenDecimals.length--;\r\n        emit RemoveEtcToken(tokenAddress);\r\n    }\r\n    \r\n    // Returns all participating tokens to owner\r\n    // # params tokenAddress: address of the participating token\r\n    function returnAllOtherTokens(address tokenAddress) public onlyOwner {\r\n        ERC20Interface(tokenAddress).transfer(owner(), ERC20Interface(tokenAddress).balanceOf(address(this)));\r\n    }\r\n    \r\n    // --------------- register participants functions ---------------\r\n\r\n    // Checks whether the use have registered (pre-registered, not sent token to contract yet for lockup)\r\n    // # params userAddress: address of pre-registered user\r\n    // * returns (bool): indication whether user have pre-registered (true) or not registered (false)\r\n    function isPreParticipant(address userAddress) public view returns (bool) {\r\n        return (userList[userAddress].month != 0);\r\n    }\r\n\r\n    // Checks whether the use have registered (already sent token to contract for lockup)\r\n    // # params userAddress: address of registered user\r\n    // * returns (bool): indication whether user have pre-registered (true) or not registered (false)\r\n    function isRegisteredParticipant(address userAddress) public view returns (bool){\r\n        return (userList[userAddress].lockEnd != 0);\r\n    }\r\n\r\n    // Returns user\u0027s current lock amount\r\n    // # params userAddress: address of registered user\r\n    // * returns (uint256): amount of user\u0027s token locked in contract\r\n    function getParticipantLockAmount(address userAddress) public view returns (uint256){\r\n        return userList[userAddress].amountWWB;\r\n    }\r\n\r\n    // Returns the registered user\u0027s lock info\r\n    // # params userAddress: address of registered user\r\n    // * returns (uint256): amount of user\u0027s token locked in contract\r\n    // * returns (uint256): month of token lockup\r\n    // * returns (uint256): end date of token\u0027s lockup period (unix timestamp)\r\n    // * returns (bool): indication of user\u0027s locked token have been calculated or not\r\n    // * returns (uint256): indication whether token has been unlocked or not\r\n    function getParticipantInfo(address userAddress) public view returns (uint256, uint256, uint256, bool, bool){\r\n        return(userList[userAddress].amountWWB, userList[userAddress].month,\r\n               userList[userAddress].lockEnd, userList[userAddress].incCalculated,\r\n               _getLockStatus(userList[userAddress].status)\r\n        );\r\n    }\r\n\r\n    // Returns if user have applied for additional tokens\r\n    // # params userAddress: address of registered user\r\n    // * returns (bool): indication whether user have applied for additional token\r\n    function isParticipantExtraTokens(address user) public view returns (bool){\r\n        return (extraList[user].exTokenAddress.length != 0);\r\n    }\r\n\r\n    // Returns the data of additional token requested\r\n    // # params userAddress: address of registered user\r\n    // * returns (address[]): array of participating token contract address\r\n    // * returns (uint256[]): array of amount of respective participating tokens should be given out\r\n    function getParticipantExtraTokens(address user) public view returns (address[] memory, uint256[] memory){\r\n        return (extraList[user].exTokenAddress, extraList[user].exTokenAmount);\r\n    }\r\n    \r\n    // Updates the user\u0027s info on current time\r\n    // # params userAddress: address of registered user\r\n    function updateParticipantInfo(address userAddress) public {\r\n        _incentiveTimeCheck(userAddress);\r\n    }\r\n    \r\n    // Pre-register participants for lockup campaign, will be properly registered after user transfer tokens to contract\r\n    // # params userAddr: address of registered user\r\n    // # params wwbAmount: amount of token to lock (in wei)\r\n    // # params months: address of registered user\r\n    function preRegisterParticipant(address userAddr, uint256 months) public returns (bool) {\r\n        require(firstSet == true, \"LockupCampaign: rates data for WWB token not yet set for first time\");\r\n        require(userAddr != address(0), \"LockupCampaign: user address is zero\");\r\n        require(months \u003e 0, \"LockupCampaign: months to lock is zero\");\r\n        \r\n        _registParticipant(userAddr, months);\r\n        return true;\r\n    }\r\n    \r\n    // Requests additional tokens for users locked more than 6 months\r\n    // # params user: address of registered user\r\n    // # params token: address of participating token to request\r\n    function requestExtraToken(address user, address token) public {\r\n        require(isRegisteredParticipant(user), \"LockupCampaign: User not registered.\");\r\n        require(tokenAddresses.length \u003e 0, \"LockupCampaign: no participating token data is entered yet\");\r\n        require(userList[user].month \u003e= 6, \"LockupCampaign: user must lock more than 6 months to request extra token\");\r\n        \r\n        _requestExtraTokens(user, token);\r\n    }\r\n    \r\n    // Releases the token and respective additional tokens to user after lock period passed\r\n    // # params user: address of registered user\r\n    function releaseParticipantTokens(address userAddr) public returns (bool){\r\n        require(isRegisteredParticipant(userAddr), \"LockupCampaign: User not registered.\");\r\n        require(_incentiveTimeCheck(userAddr));\r\n        require(userList[userAddr].status != LockStatus.LOCKED, \"LockupCampaign: Token lock period still ongoing.\");\r\n        require(userList[userAddr].status != LockStatus.RELEASED, \"LockupCampaign: Token already released.\");\r\n        \r\n        _releaseWwbTokens(userAddr);\r\n        \r\n        if(extraList[userAddr].exTokenAddress.length != 0){\r\n            _releaseOtherTokens(userAddr);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    // --------------- extra functions ---------------\r\n    \r\n    // Returns string converted bytes value\r\n    // # params str: a string value to convert\r\n    // * returns (bytes): converted string in bytes value\r\n    function convertStrToBytes(string memory str) public pure returns (bytes memory){\r\n        return bytes(str);\r\n    }\r\n    \r\n    // --------------- internal functions ---------------\r\n    \r\n    function _setWwbRate(uint256 i3, uint256 i6, uint256 i9) internal {\r\n        wwbInfo.incentive3 = i3;\r\n        wwbInfo.incentive6 = i6;\r\n        wwbInfo.incentive9 = i9;\r\n        firstSet = true;\r\n    }\r\n    \r\n    function _registParticipant(address addr, uint256 month) internal {\r\n        ParticipatingUsers memory user = ParticipatingUsers(0, month, 0, false, LockStatus.NULL);\r\n        userList[addr] = user;\r\n        \r\n        emit PreRegister(addr);\r\n    }\r\n    \r\n    function _confirmRegister(address addr, uint256 val) internal {\r\n        uint256 finalDate = now.addMonths(userList[addr].month);\r\n        userList[addr].amountWWB = val;\r\n        userList[addr].lockEnd = finalDate;\r\n        userList[addr].status = LockStatus.LOCKED;\r\n        \r\n        wwbInfo.totalLocked = wwbInfo.totalLocked.add(val);\r\n        wwbInfo.currentLocked = wwbInfo.currentLocked.add(val);\r\n        \r\n        emit ConfirmRegister(addr, now, finalDate);\r\n    }\r\n    \r\n    function _getLockStatus(LockStatus stat) internal pure returns (bool) {\r\n        if (stat == LockStatus.LOCKED || stat == LockStatus.NULL){\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // Updates the status and send user incentives given to lockup\r\n    function _incentiveTimeCheck(address user) internal returns (bool) {\r\n        if (now \u003e= userList[user].lockEnd){\r\n            if (userList[user].status == LockStatus.LOCKED \u0026\u0026 userList[user].incCalculated != true) {\r\n                uint256 val = _calcIncentives(user);\r\n                if (extraList[user].exTokenAddress.length != 0) { _calcExtra(user, val); }\r\n                userList[user].status = LockStatus.UNLOCKED;\r\n                userList[user].incCalculated = true;\r\n                \r\n                emit TokenUnlocked(user, now);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    // Incentives calculation\r\n    function _calcIncentives(address user) internal returns (uint256){\r\n        uint256 m = userList[user].month;\r\n        uint256 added;\r\n        if (m \u003e= 3 \u0026\u0026 m \u003c 6){\r\n            added = _calcAdd(userList[user].amountWWB, wwbInfo.incentive3);\r\n        } else if (m \u003e= 6 \u0026\u0026 m \u003c 12){\r\n            added = _calcAdd(userList[user].amountWWB, wwbInfo.incentive6);\r\n        } else if (m \u003e= 12) {\r\n            added = _calcAdd(userList[user].amountWWB, wwbInfo.incentive9);\r\n        }\r\n        userList[user].amountWWB = userList[user].amountWWB.add(added);\r\n        wwbInfo.totalExtraGiven = wwbInfo.totalExtraGiven.add(added);\r\n        wwbInfo.currentLocked = wwbInfo.currentLocked.add(added);\r\n        \r\n        return added;\r\n    }\r\n    \r\n    function _calcExtra(address user, uint256 added) internal {\r\n        for (uint i = 0; i \u003c extraList[user].exTokenAddress.length; i++){\r\n            uint8 dec = extraList[user].exTokenDecimals[i];\r\n            uint256 total;\r\n                \r\n            if (dec \u003e 6) { total = added.mul((10 ** uint256(dec - 6))); }\r\n            else if (dec \u003c 6) { total = added.div((10 ** uint256(6 - dec))); }\r\n                \r\n            extraList[user].exTokenAmount.push(total);\r\n        }\r\n    }\r\n\r\n    // rate calc\r\n    function _calcAdd(uint256 total, uint256 rate) internal pure returns (uint256){\r\n        uint256 r = total.mul(rate);\r\n        r = r.div(10000);\r\n        return r;\r\n    }\r\n    \r\n    function _requestExtraTokens(address user, address token) internal {\r\n        require(isParticipatingTokens(token), \"LockupCampaign: token address is not participating token\");\r\n        //extraList[user].exTokenAddress.push(token);\r\n        \r\n        for (uint i = 0; i \u003c tokenAddresses.length; i++){\r\n            if(token == tokenAddresses[i]){\r\n                extraList[user].exTokenAddress.push(token);\r\n                extraList[user].exTokenDecimals.push(tokenDecimals[i]);\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit EtcTokenRequested(user, token);\r\n    }\r\n    \r\n    function _releaseWwbTokens(address user) internal {\r\n        uint256 amt = userList[user].amountWWB;\r\n        ERC20Interface(wwbAddress).transfer(user, amt);\r\n        wwbInfo.currentLocked = wwbInfo.currentLocked.sub(amt);\r\n        userList[user].status = LockStatus.RELEASED;\r\n\r\n        emit TokenReleased(user, amt);\r\n    }\r\n    \r\n    function _releaseOtherTokens(address user) internal {\r\n        for (uint i = 0; i \u003c extraList[user].exTokenAddress.length; i++){\r\n            address addr =  extraList[user].exTokenAddress[i];\r\n            uint amt = extraList[user].exTokenAmount[i];\r\n            \r\n            ERC20Interface(addr).transfer(user, amt);\r\n            \r\n            emit EtcTokenReleased(user, addr, amt);\r\n        }\r\n    }\r\n}"},"SafeMath.sol":{"content":"pragma solidity \u003e= 0.5.3 \u003c 0.6.0;\r\n\r\n//  SafeMath library\r\n//  - uint security overflow/underflow prevention\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) { return 0; }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003e 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n"},"TimestampMonthConv.sol":{"content":"pragma solidity \u003e=0.5.3 \u003c 0.6.0;\r\n\r\n//   Timestamp Month Conversion library\r\n//  - date and timestamp related conversion/operations for months\r\n\r\nlibrary TimestampMonthConv {\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n    \r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year \u003e= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n    \r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n        \r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n    \r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n    \r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) \u0026\u0026 (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n    \r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day \u003e daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp \u003e= timestamp);\r\n    }\r\n    \r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n        require(fromTimestamp \u003c= toTimestamp);\r\n        uint fromYear;\r\n        uint fromMonth;\r\n        uint fromDay;\r\n        uint toYear;\r\n        uint toMonth;\r\n        uint toDay;\r\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    }\r\n}\r\n"}}