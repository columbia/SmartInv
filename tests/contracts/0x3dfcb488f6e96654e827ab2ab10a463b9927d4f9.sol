{"ApymonPack.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Receiver.sol\";\nimport \u0027./IERC1155Receiver.sol\u0027;\nimport \"./ERC165.sol\";\nimport \u0027./Events.sol\u0027;\nimport \u0027./Ownable.sol\u0027;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IERC721 {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function totalSupply() external view returns (uint256);\n    function exists(uint256 tokenId) external view returns (bool);\n    function approve(address to, uint256 tokenId) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function mintCreature() external returns (uint256 creatureId);\n}\n\ninterface IERC1155 {\n    function setApprovalForAll(address operator, bool approved) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n}\n\ninterface ISwap {\n    function swapErc20(\n        uint256 eggId,\n        address inToken,\n        uint256 inAmount,\n        address outToken,\n        uint8 router,\n        address to\n    ) external;\n    function swapErc721(\n        uint256 eggId,\n        address inToken,\n        uint256 inId,\n        address outToken,\n        uint8 router,\n        address to\n    ) external;\n    function swapErc1155(\n        uint256 eggId,\n        address inToken,\n        uint256 inId,\n        uint256 inAmount,\n        address outToken,\n        uint256 outId,\n        uint8 router,\n        address to\n    ) external;\n}\n\ncontract ApymonPack is ERC165, IERC1155Receiver, IERC721Receiver, Context, Events, Ownable {\n\n    struct Token {\n        uint8 tokenType; // 1: ERC20, 2: ERC721, 3: ERC1155\n        address tokenAddress;\n    }\n\n    // Token types\n    uint8 private constant TOKEN_TYPE_ERC20 = 1;\n    uint8 private constant TOKEN_TYPE_ERC721 = 2;\n    uint8 private constant TOKEN_TYPE_ERC1155 = 3;\n\n    uint256 private constant MAX_EGG_SUPPLY = 6400;\n\n    // Mapping from egg ID -\u003e token(erc20) -\u003e balance\n    mapping(uint256 =\u003e mapping(address =\u003e uint256)) private _insideERC20TokenBalances;\n\n    // Mapping from egg ID -\u003e token(erc1155) -\u003e tokenId -\u003e balance\n    mapping(uint256 =\u003e mapping(address =\u003e mapping(uint256 =\u003e uint256))) private _insideERC1155TokenBalances;\n\n    // Mapping from egg ID -\u003e tokens\n    mapping(uint256 =\u003e Token[]) private _insideTokens;\n\n    // Mapping from egg ID -\u003e token(erc721 or erc1155) -\u003e ids\n    mapping(uint256 =\u003e mapping(address =\u003e uint256[])) private _insideTokenIds;\n\n    // Mapping from egg ID -\u003e locked time\n    mapping(uint256 =\u003e uint256) private _lockedTimestamp;\n\n    // Mapping from egg ID -\u003e opened\n    mapping(uint256 =\u003e bool) private _opened;\n\n    IERC721 public _apymon;\n\n    bool public _enableClose;\n    ISwap public _swap;\n\n    modifier onlyEggOwner(uint256 eggId) {\n        require(_apymon.exists(eggId));\n        require(_apymon.ownerOf(eggId) == msg.sender);\n        _;\n    }\n\n    modifier unlocked(uint256 eggId) {\n        require(\n            _lockedTimestamp[eggId] == 0 ||\n            _lockedTimestamp[eggId] \u003c block.timestamp\n        );\n        _;\n    }\n\n    modifier opened(uint256 eggId) {\n        require(isOpened(eggId));\n        _;\n    }\n\n    constructor(\n        address apymon\n    ) {\n        _apymon = IERC721(apymon);\n        _enableClose = false;\n    }\n\n    // View functions\n\n    /**\n     * @dev check if egg has been locked.\n     */\n    function existsId(\n        uint256 eggId,\n        address token,\n        uint256 id\n    ) public view returns (bool) {\n        uint256[] memory ids = _insideTokenIds[eggId][token];\n\n        for (uint256 i; i \u003c ids.length; i++) {\n            if (ids[i] == id) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev check if egg has been locked.\n     */\n    function isLocked(\n        uint256 eggId\n    ) external view returns (bool locked, uint256 endTime) {\n        if (\n            _lockedTimestamp[eggId] == 0 ||\n            _lockedTimestamp[eggId] \u003c block.timestamp\n        ) {\n            locked = false;\n        } else {\n            locked = true;\n            endTime = _lockedTimestamp[eggId];\n        }\n    }\n\n    /**\n     * @dev check if egg opened or not.\n     */\n    function isOpened(\n        uint256 eggId\n    ) public view returns (bool) {\n        return _opened[eggId];\n    }\n\n    /**\n     * @dev check if claimed creature for certain egg.\n     */\n    function isClaimedCreature(\n        uint256 eggId\n    ) public view returns (bool) {\n        return _apymon.exists(eggId + MAX_EGG_SUPPLY);\n    }\n\n    /**\n     * @dev check if tokenId exists in egg\n     */\n    function getInsideTokensCount(\n        uint256 eggId\n    ) public view opened(eggId) returns (\n        uint256 erc20Len,\n        uint256 erc721Len,\n        uint256 erc1155Len\n    ) {\n        Token[] memory tokens = _insideTokens[eggId];\n        for (uint256 i; i \u003c tokens.length; i++) {\n            Token memory token = tokens[i];\n            if (token.tokenType == TOKEN_TYPE_ERC20) {\n                erc20Len += 1;\n            }\n            if (token.tokenType == TOKEN_TYPE_ERC721) {\n                erc721Len += 1;\n            }\n            if (token.tokenType == TOKEN_TYPE_ERC1155) {\n                erc1155Len += 1;\n            }\n        }\n    }\n\n    /**\n     * @dev get tokens by eggId\n     */\n    function getTokens(\n        uint256 eggId\n    ) external view opened(eggId) returns (\n        uint8[] memory tokenTypes,\n        address[] memory tokenAddresses\n    ) {\n        Token[] memory tokens = _insideTokens[eggId];\n        \n        tokenTypes = new uint8[](tokens.length);\n        tokenAddresses = new address[](tokens.length);\n\n        for (uint256 i; i \u003c tokens.length; i++) {\n            tokenTypes[i] = tokens[i].tokenType;\n            tokenAddresses[i] = tokens[i].tokenAddress;\n        }        \n    }\n\n    /**\n     * @dev get ERC20 token info\n     */\n    function getERC20Tokens(\n        uint256 eggId\n    ) public view opened(eggId) returns (\n        address[] memory addresses,\n        uint256[] memory tokenBalances\n    ) {\n        Token[] memory tokens = _insideTokens[eggId];\n        (\n            uint256 erc20Len,\n            ,\n        ) = getInsideTokensCount(eggId);\n        \n        tokenBalances = new uint256[](erc20Len);\n        addresses = new address[](erc20Len);\n        uint256 j;\n\n        for (uint256 i; i \u003c tokens.length; i++) {\n            Token memory token = tokens[i];\n            if (token.tokenType == TOKEN_TYPE_ERC20) {\n                addresses[j] = token.tokenAddress;\n                tokenBalances[j] = _insideERC20TokenBalances[eggId][token.tokenAddress];\n                j++;\n            }\n        }        \n    }\n\n    /**\n     * @dev get ERC721 token info\n     */\n    function getERC721Tokens(\n        uint256 eggId\n    ) public view opened(eggId) returns (\n        address[] memory addresses,\n        uint256[] memory tokenBalances\n    ) {\n        Token[] memory tokens = _insideTokens[eggId];\n        (\n            ,\n            uint256 erc721Len\n            ,\n        ) = getInsideTokensCount(eggId);\n        \n        tokenBalances = new uint256[](erc721Len);\n        addresses = new address[](erc721Len);\n        uint256 j;\n\n        for (uint256 i; i \u003c tokens.length; i++) {\n            Token memory token = tokens[i];\n            if (token.tokenType == TOKEN_TYPE_ERC721) {\n                addresses[j] = token.tokenAddress;\n                tokenBalances[j] = _insideTokenIds[eggId][token.tokenAddress].length;\n                j++;\n            }\n        }\n    }\n\n    /**\n     * @dev get ERC721 or ERC1155 ids\n     */\n    function getERC721OrERC1155Ids(\n        uint256 eggId,\n        address insideToken\n    ) public view opened(eggId) returns (uint256[] memory) {\n        return _insideTokenIds[eggId][insideToken];\n    }\n\n    /**\n     * @dev get ERC1155 token addresses info\n     */\n    function getERC1155Tokens(\n        uint256 eggId\n    ) public view opened(eggId) returns (address[] memory addresses) {\n        Token[] memory tokens = _insideTokens[eggId];\n        (\n            ,\n            ,\n            uint256 erc1155Len\n        ) = getInsideTokensCount(eggId);\n        \n        addresses = new address[](erc1155Len);\n        uint256 j;\n\n        for (uint256 i; i \u003c tokens.length; i++) {\n            Token memory token = tokens[i];\n            if (token.tokenType == TOKEN_TYPE_ERC1155) {\n                addresses[j] = token.tokenAddress;\n                j++;\n            }\n        }\n    }\n\n    /**\n     * @dev get ERC1155 token balances by ids\n     */\n    function getERC1155TokenBalances(\n        uint256 eggId,\n        address insideToken,\n        uint256[] memory tokenIds\n    ) public view opened(eggId) returns (uint256[] memory tokenBalances) {\n        tokenBalances = new uint256[](tokenIds.length);\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            tokenBalances[i] = _insideERC1155TokenBalances[eggId][insideToken][tokenIds[i]];\n        }\n    }\n\n    // Write functions\n\n    /**\n     * @dev lock egg.\n     */\n    function lockEgg(\n        uint256 eggId,\n        uint256 timeInSeconds\n    ) external onlyEggOwner(eggId) opened(eggId) unlocked(eggId) {\n        _lockedTimestamp[eggId] = block.timestamp + timeInSeconds;\n        emit LockedEgg(\n            eggId,\n            msg.sender,\n            block.timestamp,\n            block.timestamp + timeInSeconds\n        );\n    }\n\n    function setEnableClose(bool enabled) external onlyOwner {\n        _enableClose = enabled;\n    }\n\n    function setSwap(address swap) external onlyOwner {\n        _swap = ISwap(swap);\n    }\n\n    /**\n     * @dev open egg.\n     */\n    function openEgg(\n        uint256 eggId,\n        bool isClaimCreature\n    ) external onlyEggOwner(eggId) {\n        _opened[eggId] = true;\n        emit OpenedEgg(\n            eggId,\n            msg.sender\n        );\n\n        if (isClaimCreature \u0026\u0026 !isClaimedCreature(eggId)) {\n            claimCreature(eggId);\n        }\n    }\n\n    /**\n     * @dev open egg.\n     */\n    function closeEgg(\n        uint256 eggId\n    ) external onlyEggOwner(eggId) {\n        require(_enableClose == true);\n        _opened[eggId] = false;\n        emit ClosedEgg(\n            eggId,\n            msg.sender\n        );\n    }\n\n    /**\n     * @dev deposit erc20 tokens into egg.\n     */\n    function depositErc20IntoEgg(\n        uint256 eggId,\n        address[] memory tokens,\n        uint256[] memory amounts\n    ) external {\n        require(\n            tokens.length \u003e 0 \u0026\u0026\n            tokens.length == amounts.length\n        );\n\n        for (uint256 i; i \u003c tokens.length; i++) {\n            require(tokens[i] != address(0));\n            IERC20 iToken = IERC20(tokens[i]);\n\n            uint256 prevBalance = iToken.balanceOf(address(this));\n            iToken.transferFrom(\n                msg.sender,\n                address(this),\n                amounts[i]\n            );\n            uint256 receivedAmount = iToken.balanceOf(address(this)) - prevBalance;\n\n            _increaseInsideTokenBalance(\n                eggId,\n                TOKEN_TYPE_ERC20,\n                tokens[i],\n                receivedAmount\n            );\n\n            if (isOpened(eggId)) {\n                emit DepositedErc20IntoEgg(\n                    eggId,\n                    msg.sender,\n                    tokens[i],\n                    receivedAmount\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev withdraw erc20 tokens from egg.\n     */\n    function withdrawErc20FromEgg(\n        uint256 eggId,\n        address[] memory tokens,\n        uint256[] memory amounts,\n        address to\n    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n        require(\n            tokens.length \u003e 0 \u0026\u0026\n            tokens.length == amounts.length\n        );\n\n        for (uint256 i; i \u003c tokens.length; i++) {\n            require(tokens[i] != address(0));\n            IERC20 iToken = IERC20(tokens[i]);\n\n            iToken.transfer(to, amounts[i]);\n\n            _decreaseInsideTokenBalance(\n                eggId,\n                TOKEN_TYPE_ERC20,\n                tokens[i],\n                amounts[i]\n            );\n            emit WithdrewErc20FromEgg(\n                eggId,\n                msg.sender,\n                tokens[i],\n                amounts[i],\n                to\n            );\n        }\n    }\n\n    /**\n     * @dev send erc20 tokens from my egg to another egg.\n     */\n    function sendErc20(\n        uint256 fromEggId,\n        address[] memory tokens,\n        uint256[] memory amounts,\n        uint256 toEggId\n    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\n        require(fromEggId != toEggId);\n        require(\n            tokens.length \u003e 0 \u0026\u0026\n            tokens.length == amounts.length\n        );\n\n        for (uint256 i; i \u003c tokens.length; i++) {\n            require(tokens[i] != address(0));\n            require(_apymon.exists(toEggId));\n\n            _decreaseInsideTokenBalance(\n                fromEggId,\n                TOKEN_TYPE_ERC20,\n                tokens[i],\n                amounts[i]\n            );\n\n            _increaseInsideTokenBalance(\n                toEggId,\n                TOKEN_TYPE_ERC20,\n                tokens[i],\n                amounts[i]\n            );\n\n            emit SentErc20(\n                fromEggId,\n                msg.sender,\n                tokens[i],\n                amounts[i],\n                toEggId\n            );\n        }\n    }\n\n    /**\n     * @dev deposit erc721 tokens into egg.\n     */\n    function depositErc721IntoEgg(\n        uint256 eggId,\n        address token,\n        uint256[] memory tokenIds\n    ) external {\n        require(token != address(0));\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            require(\n                token != address(this) ||\n                (token == address(this) \u0026\u0026 eggId != tokenIds[i])\n            );\n            IERC721 iToken = IERC721(token);\n            \n            iToken.safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenIds[i]\n            );\n\n            _putInsideTokenId(\n                eggId,\n                token,\n                tokenIds[i]\n            );\n\n            if (isOpened(eggId)) {\n                emit DepositedErc721IntoEgg(\n                    eggId,\n                    msg.sender,\n                    token,\n                    tokenIds[i]\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev withdraw erc721 token from egg.\n     */\n    function withdrawErc721FromEgg(\n        uint256 eggId,\n        address token,\n        uint256[] memory tokenIds,\n        address to\n    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n        require(token != address(0));\n        IERC721 iToken = IERC721(token);\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            address tokenOwner = iToken.ownerOf(tokenIds[i]);\n\n            require(tokenOwner == address(this));\n\n            iToken.safeTransferFrom(\n                tokenOwner,\n                to,\n                tokenIds[i]\n            );\n\n            _popInsideTokenId(\n                eggId,\n                token,\n                tokenIds[i]\n            );\n\n            emit WithdrewErc721FromEgg(\n                eggId,\n                msg.sender,\n                token,\n                tokenIds[i],\n                to\n            );\n        }\n    }\n\n    /**\n     * @dev send erc721 tokens from my egg to another egg.\n     */\n    function sendErc721(\n        uint256 fromEggId,\n        address token,\n        uint256[] memory tokenIds,\n        uint256 toEggId\n    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\n        require(fromEggId != toEggId);\n        require(token != address(0));\n        require(_apymon.exists(toEggId));\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            _popInsideTokenId(\n                fromEggId,\n                token,\n                tokenIds[i]\n            );\n\n            _putInsideTokenId(\n                toEggId,\n                token,\n                tokenIds[i]\n            );\n\n            emit SentErc721(\n                fromEggId,\n                msg.sender,\n                token,\n                tokenIds[i],\n                toEggId\n            );\n        }\n    }\n\n    /**\n     * @dev deposit erc1155 token into egg.\n     */\n    function depositErc1155IntoEgg(\n        uint256 eggId,\n        address token,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts\n    ) external {\n        require(token != address(0));\n        IERC1155 iToken = IERC1155(token);\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            iToken.safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenIds[i],\n                amounts[i],\n                bytes(\"\")\n            );\n\n            _putInsideTokenIdForERC1155(\n                eggId,\n                token,\n                tokenIds[i]\n            );\n\n            _increaseInsideERC1155TokenBalance(\n                eggId,\n                TOKEN_TYPE_ERC1155,\n                token,\n                tokenIds[i],\n                amounts[i]\n            );\n\n            if (isOpened(eggId)) {\n                emit DepositedErc1155IntoEgg(\n                    eggId,\n                    msg.sender,\n                    token,\n                    tokenIds[i],\n                    amounts[i]\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev withdraw erc1155 token from egg.\n     */\n    function withdrawErc1155FromEgg(\n        uint256 eggId,\n        address token,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        address to\n    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n        require(token != address(0));\n        IERC1155 iToken = IERC1155(token);\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            uint256 amount = amounts[i];\n\n            iToken.safeTransferFrom(\n                address(this),\n                to,\n                tokenId,\n                amount,\n                bytes(\"\")\n            );\n\n            _decreaseInsideERC1155TokenBalance(\n                eggId,\n                token,\n                tokenId,\n                amount\n            );\n\n            _popInsideTokenIdForERC1155(\n                eggId,\n                token,\n                tokenId\n            );\n\n            _popERC1155FromEgg(\n                eggId,\n                token,\n                tokenId\n            );\n            emit WithdrewErc1155FromEgg(\n                eggId,\n                msg.sender,\n                token,\n                tokenId,\n                amount,\n                to\n            );\n        }\n    }\n\n    /**\n     * @dev send erc1155 token from my egg to another egg.\n     */\n    function sendErc1155(\n        uint256 fromEggId,\n        address token,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        uint256 toEggId\n    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\n        require(fromEggId != toEggId);\n        require(token != address(0));\n        require(_apymon.exists(toEggId));\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            uint256 amount = amounts[i];\n\n            _decreaseInsideERC1155TokenBalance(\n                fromEggId,\n                token,\n                tokenId,\n                amount\n            );\n\n            _increaseInsideERC1155TokenBalance(\n                toEggId,\n                TOKEN_TYPE_ERC1155,\n                token,\n                tokenId,\n                amount\n            );\n\n            _popInsideTokenIdForERC1155(\n                fromEggId,\n                token,\n                tokenId\n            );\n\n            _putInsideTokenIdForERC1155(\n                toEggId,\n                token,\n                tokenId\n            );\n\n            _popERC1155FromEgg(\n                fromEggId,\n                token,\n                tokenId\n            );\n            emit SentErc1155(\n                fromEggId,\n                msg.sender,\n                token,\n                tokenId,\n                amount,\n                toEggId\n            );\n        }\n    }\n\n    /**\n     * @dev withdraw all of inside tokens into specific address.\n     */\n    function withdrawAll(\n        uint256 eggId,\n        address to\n    ) external {\n        require(to != address(0));\n        (address[] memory erc20Addresses, uint256[] memory erc20Balances) = getERC20Tokens(eggId);\n        withdrawErc20FromEgg(\n            eggId,\n            erc20Addresses,\n            erc20Balances,\n            to\n        );\n\n        (address[] memory erc721Addresses, ) = getERC721Tokens(eggId);\n        for (uint256 a; a \u003c erc721Addresses.length; a++) {\n            uint256[] memory ids = getERC721OrERC1155Ids(\n                eggId,\n                erc721Addresses[a]\n            );\n            withdrawErc721FromEgg(\n                eggId,\n                erc721Addresses[a],\n                ids,\n                to\n            );\n        }\n\n        address[] memory erc1155Addresses = getERC1155Tokens(eggId);\n        for (uint256 a; a \u003c erc1155Addresses.length; a++) {\n            uint256[] memory ids = getERC721OrERC1155Ids(\n                eggId,\n                erc1155Addresses[a]\n            );\n            uint256[] memory tokenBalances = getERC1155TokenBalances(\n                eggId,\n                erc1155Addresses[a],\n                ids\n            );\n            withdrawErc1155FromEgg(\n                eggId,\n                erc1155Addresses[a],\n                ids,\n                tokenBalances,\n                to\n            );\n        }\n    }\n\n    /**\n     * @dev send all of inside tokens to specific egg.\n     */\n    function sendAll(\n        uint256 fromEggId,\n        uint256 toEggId\n    ) external {\n        (\n            address[] memory erc20Addresses,\n            uint256[] memory erc20Balances\n        ) = getERC20Tokens(fromEggId);\n        sendErc20(\n            fromEggId,\n            erc20Addresses,\n            erc20Balances,\n            toEggId\n        );\n\n        (\n            address[] memory erc721Addresses\n            ,\n        ) = getERC721Tokens(fromEggId);\n        for (uint256 a; a \u003c erc721Addresses.length; a++) {\n            uint256[] memory ids = getERC721OrERC1155Ids(\n                fromEggId,\n                erc721Addresses[a]\n            );\n            sendErc721(\n                fromEggId,\n                erc721Addresses[a],\n                ids,\n                toEggId\n            );\n        }\n\n        address[] memory erc1155Addresses = getERC1155Tokens(fromEggId);\n        for (uint256 a; a \u003c erc1155Addresses.length; a++) {\n            uint256[] memory ids = getERC721OrERC1155Ids(\n                fromEggId,\n                erc1155Addresses[a]\n            );\n            uint256[] memory tokenBalances = getERC1155TokenBalances(\n                fromEggId,\n                erc1155Addresses[a],\n                ids\n            );\n            sendErc1155(\n                fromEggId,\n                erc1155Addresses[a],\n                ids,\n                tokenBalances,\n                toEggId\n            );\n        }\n    }\n    \n    /**\n     * @dev external function to increase token balance of egg\n     */\n    function increaseInsideTokenBalance(\n        uint256 eggId,\n        uint8 tokenType,\n        address token,\n        uint256 amount\n    ) external {\n        require(msg.sender != address(0));\n        require(msg.sender == address(_apymon));\n\n        _increaseInsideTokenBalance(\n            eggId,\n            tokenType,\n            token,\n            amount\n        );\n    }\n\n    /**\n     * @dev external function to put creature into egg\n     * Must be called by egg owner\n     */\n    function claimCreature(\n        uint256 eggId\n    ) public onlyEggOwner(eggId) {\n        uint256 creatureId = _apymon.mintCreature();\n\n        _putInsideTokenId(\n            eggId,\n            address(_apymon),\n            creatureId\n        );\n\n        emit DepositedErc721IntoEgg(\n            eggId,\n            address(this),\n            address(_apymon),\n            creatureId\n        );\n    }\n\n    function swapErc20(\n        uint256 eggId,\n        address inToken,\n        uint256 inAmount,\n        address outToken,\n        uint8 router,\n        address to\n    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n        require(address(_swap) != address(0));\n        require(_insideERC20TokenBalances[eggId][inToken] \u003e= inAmount);\n\n        IERC20(inToken).approve(address(_swap), inAmount);\n\n        _swap.swapErc20(\n            eggId,\n            inToken,\n            inAmount,\n            outToken,\n            router,\n            to\n        );\n        emit SwapedErc20(\n            msg.sender,\n            eggId,\n            inToken,\n            inAmount,\n            outToken,\n            to\n        );\n\n        _decreaseInsideTokenBalance(\n            eggId,\n            TOKEN_TYPE_ERC20,\n            inToken,\n            inAmount\n        );\n    }\n\n    function swapErc721(\n        uint256 eggId,\n        address inToken,\n        uint256 inId,\n        address outToken,\n        uint8 router,\n        address to\n    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n        require(address(_swap) != address(0));\n        require(existsId(eggId, inToken, inId));\n        \n        IERC721(inToken).approve(address(_swap), inId);\n\n        _swap.swapErc721(\n            eggId,\n            inToken,\n            inId,\n            outToken,\n            router,\n            to\n        );\n        emit SwapedErc721(\n            msg.sender,\n            eggId,\n            inToken,\n            inId,\n            outToken,\n            to\n        );\n\n        _popInsideTokenId(\n            eggId,\n            inToken,\n            inId\n        );\n    }\n\n    function swapErc1155(\n        uint256 eggId,\n        address inToken,\n        uint256 inId,\n        uint256 inAmount,\n        address outToken,\n        uint256 outId,\n        uint8 router,\n        address to\n    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n        require(address(_swap) != address(0));\n        require(existsId(eggId, inToken, inId));\n        require(\n            _insideERC1155TokenBalances[eggId][inToken][inId] \u003e= inAmount\n        );\n\n        IERC1155(inToken).setApprovalForAll(address(_swap), true);\n\n        _swap.swapErc1155(\n            eggId,\n            inToken,\n            inId,\n            inAmount,\n            outToken,\n            outId,\n            router,\n            to\n        );\n        emit SwapedErc1155(\n            msg.sender,\n            eggId,\n            inToken,\n            inId,\n            inAmount,\n            outToken,\n            outId,\n            to\n        );\n\n        _decreaseInsideERC1155TokenBalance(\n            eggId,\n            inToken,\n            inId,\n            inAmount\n        );\n\n        _popInsideTokenIdForERC1155(\n            eggId,\n            inToken,\n            inId\n        );\n\n        _popERC1155FromEgg(\n            eggId,\n            inToken,\n            inId\n        );\n    }\n\n    function _popERC1155FromEgg(\n        uint256 eggId,\n        address token,\n        uint256 tokenId\n    ) private {\n        uint256[] memory ids = _insideTokenIds[eggId][token];\n        if (\n            _insideERC1155TokenBalances[eggId][token][tokenId] == 0 \u0026\u0026 \n            ids.length == 0\n        ) {\n            delete _insideERC1155TokenBalances[eggId][token][tokenId];\n            delete _insideTokenIds[eggId][token];\n            _popTokenFromEgg(\n                eggId,\n                TOKEN_TYPE_ERC1155,\n                token\n            );\n        }\n    }\n    \n    /**\n     * @dev private function to increase token balance of egg\n     */\n    function _increaseInsideTokenBalance(\n        uint256 eggId,\n        uint8 tokenType,\n        address token,\n        uint256 amount\n    ) private {\n        _insideERC20TokenBalances[eggId][token] += amount;\n        _putTokenIntoEgg(\n            eggId,\n            tokenType,\n            token\n        );\n    }\n\n    /**\n     * @dev private function to increase erc1155 token balance of egg\n     */\n    function _increaseInsideERC1155TokenBalance(\n        uint256 eggId,\n        uint8 tokenType,\n        address token,\n        uint256 tokenId,\n        uint256 amount\n    ) private {\n        _insideERC1155TokenBalances[eggId][token][tokenId] += amount;\n        _putTokenIntoEgg(\n            eggId,\n            tokenType,\n            token\n        );\n    }\n\n    /**\n     * @dev private function to decrease token balance of egg\n     */\n    function _decreaseInsideTokenBalance(\n        uint256 eggId,\n        uint8 tokenType,\n        address token,\n        uint256 amount\n    ) private {\n        require(_insideERC20TokenBalances[eggId][token] \u003e= amount);\n        _insideERC20TokenBalances[eggId][token] -= amount;\n        if (_insideERC20TokenBalances[eggId][token] == 0) {\n            delete _insideERC20TokenBalances[eggId][token];\n            _popTokenFromEgg(\n                eggId,\n                tokenType,\n                token\n            );\n        }\n    }\n\n    /**\n     * @dev private function to decrease erc1155 token balance of egg\n     */\n    function _decreaseInsideERC1155TokenBalance(\n        uint256 eggId,\n        address token,\n        uint256 tokenId,\n        uint256 amount\n    ) private {\n        require(_insideERC1155TokenBalances[eggId][token][tokenId] \u003e= amount);\n        _insideERC1155TokenBalances[eggId][token][tokenId] -= amount;\n    }\n\n    /**\n     * @dev private function to put a token id to egg\n     */\n    function _putInsideTokenId(\n        uint256 eggId,\n        address token,\n        uint256 tokenId\n    ) private {\n        uint256[] storage ids = _insideTokenIds[eggId][token];\n        ids.push(tokenId);\n    }\n\n    /**\n     * @dev private function to put a token id to egg in ERC1155\n     */\n    function _putInsideTokenIdForERC1155(\n        uint256 eggId,\n        address token,\n        uint256 tokenId\n    ) private {\n        uint256[] storage ids = _insideTokenIds[eggId][token];\n        bool isExist;\n        for (uint256 i; i \u003c ids.length; i++) {\n            if (ids[i] == tokenId) {\n                isExist = true;\n            }\n        }\n        if (!isExist) {\n            ids.push(tokenId);\n        }\n    }\n\n    /**\n     * @dev private function to pop a token id from egg\n     */\n    function _popInsideTokenId(\n        uint256 eggId,\n        address token,\n        uint256 tokenId\n    ) private {\n        uint256[] storage ids = _insideTokenIds[eggId][token];\n        for (uint256 i; i \u003c ids.length; i++) {\n            if (ids[i] == tokenId) {\n                ids[i] = ids[ids.length - 1];\n                ids.pop();\n            }\n        }\n\n        if (ids.length == 0) {\n            delete _insideTokenIds[eggId][token];\n        }\n    }\n\n    /**\n     * @dev private function to pop a token id from egg in ERC1155\n     */\n    function _popInsideTokenIdForERC1155(\n        uint256 eggId,\n        address token,\n        uint256 tokenId\n    ) private {\n        uint256 tokenBalance = _insideERC1155TokenBalances[eggId][token][tokenId];\n        if (tokenBalance \u003c= 0) {\n            delete _insideERC1155TokenBalances[eggId][token][tokenId];\n            _popInsideTokenId(\n                eggId,\n                token,\n                tokenId\n            );\n        }\n    }\n\n    /**\n     * @dev put token(type, address) to egg\n     */\n    function _putTokenIntoEgg(\n        uint256 eggId,\n        uint8 tokenType,\n        address tokenAddress\n    ) private {\n        Token[] storage tokens = _insideTokens[eggId];\n        bool exists = false;\n        for (uint256 i; i \u003c tokens.length; i++) {\n            if (\n                tokens[i].tokenType == tokenType \u0026\u0026\n                tokens[i].tokenAddress == tokenAddress\n            ) {\n                exists = true;\n                break;\n            }\n        }\n\n        if (!exists) {\n            tokens.push(Token({\n                tokenType: tokenType,\n                tokenAddress: tokenAddress\n            }));\n        }\n    }\n\n    /**\n     * @dev pop token(type, address) from egg\n     */\n    function _popTokenFromEgg(\n        uint256 eggId,\n        uint8 tokenType,\n        address tokenAddress\n    ) private {\n        Token[] storage tokens = _insideTokens[eggId];\n        for (uint256 i; i \u003c tokens.length; i++) {\n            if (\n                tokens[i].tokenType == tokenType \u0026\u0026\n                tokens[i].tokenAddress == tokenAddress\n            ) {\n                tokens[i] = tokens[tokens.length - 1];\n                tokens.pop();\n                break;\n            }\n        }\n\n        if (tokens.length == 0) {\n            delete _insideTokens[eggId];\n        }\n    }\n   \n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override returns(bytes4) {\n        return 0xf23a6e61;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns(bytes4) {\n        return 0xbc197c81;\n    }\n}\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027)) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it\u0027s supported.\n     */\n    mapping(bytes4 =\u003e bool) private _supportedInterfaces;\n\n    constructor () {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"},"Events.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Events {\n    event LockedEgg(\n        uint256 eggId,\n        address indexed owner,\n        uint256 startTimestamp,\n        uint256 endTimestamp\n    );\n\n    event OpenedEgg(\n        uint256 eggId,\n        address indexed owner\n    );\n\n    event ClosedEgg(\n        uint256 eggId,\n        address indexed owner\n    );\n\n    event DepositedErc20IntoEgg(\n        uint256 eggId,\n        address indexed owner,\n        address indexed erc20Token,\n        uint256 amount\n    );\n\n    event WithdrewErc20FromEgg(\n        uint256 eggId,\n        address indexed owner,\n        address indexed erc20Token,\n        uint256 amount,\n        address indexed to\n    );\n\n    event SentErc20(\n        uint256 fromEggId,\n        address indexed owner,\n        address indexed erc20Token,\n        uint256 amount,\n        uint256 toEggId\n    );\n\n    event DepositedErc721IntoEgg(\n        uint256 eggId,\n        address indexed owner,\n        address indexed erc721Token,\n        uint256 tokenId\n    );\n\n    event WithdrewErc721FromEgg(\n        uint256 eggId,\n        address indexed owner,\n        address indexed erc721Token,\n        uint256 tokenId,\n        address indexed to\n    );\n\n    event SentErc721(\n        uint256 fromEggId,\n        address indexed owner,\n        address indexed erc721Token,\n        uint256 tokenId,\n        uint256 toEggId\n    );\n\n    event DepositedErc1155IntoEgg(\n        uint256 eggId,\n        address indexed owner,\n        address indexed erc1155Token,\n        uint256 tokenId,\n        uint256 amount\n    );\n\n    event WithdrewErc1155FromEgg(\n        uint256 eggId,\n        address indexed owner,\n        address indexed erc1155Token,\n        uint256 tokenId,\n        uint256 amount,\n        address indexed to\n    );\n\n    event SentErc1155(\n        uint256 fromEggId,\n        address indexed owner,\n        address indexed erc1155Token,\n        uint256 tokenId,\n        uint256 amount,\n        uint256 toEggId\n    );\n\n    event SwapedErc20(\n        address indexed owner,\n        uint256 eggId,\n        address inToken,\n        uint256 inAmount,\n        address outToken,\n        address indexed to\n    );\n\n    event SwapedErc721(\n        address indexed owner,\n        uint256 eggId,\n        address inToken,\n        uint256 inId,\n        address outToken,\n        address indexed to\n    );\n\n    event SwapedErc1155(\n        address indexed owner,\n        uint256 eggId,\n        address inToken,\n        uint256 inId,\n        uint256 inAmount,\n        address outToken,\n        uint256 outId,\n        address indexed to\n    );\n}"},"IERC1155Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"}}