{{
  "language": "Solidity",
  "sources": {
    "contracts/Airdrop/OngoingAirdrop.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"openzeppelin-solidity-2.3.0/contracts/token/ERC20/IERC20.sol\";\nimport \"synthetix-2.43.1/contracts/Owned.sol\";\nimport \"openzeppelin-solidity-2.3.0/contracts/cryptography/MerkleProof.sol\";\nimport \"synthetix-2.43.1/contracts/Pausable.sol\";\nimport \"../interfaces/IEscrowThales.sol\";\n\n/**\n * Contract which implements a merkle airdrop for a given token\n * Based on an account balance snapshot stored in a merkle tree\n */\ncontract OngoingAirdrop is Owned, Pausable {\n    IERC20 public token;\n\n    IEscrowThales public iEscrowThales;\n\n    bytes32 public root; // merkle tree root\n\n    uint256 public startTime;\n\n    address public admin;\n\n    uint256 public period;\n\n    mapping(uint256 => mapping(uint256 => uint256)) public _claimed;\n\n    constructor(\n        address _owner,\n        IERC20 _token,\n        bytes32 _root\n    ) public Owned(_owner) Pausable() {\n        token = _token;\n        root = _root;\n        startTime = block.timestamp;\n        period = 1;\n    }\n\n    // Set root of merkle tree\n    function setRoot(bytes32 _root) public onlyOwner {\n        require(address(iEscrowThales) != address(0), \"Set Escrow Thales address\");\n        root = _root;\n        startTime = block.timestamp; //reset time every period\n        emit NewRoot(_root, block.timestamp, period);\n        period = period + 1;\n    }\n\n    // Set EscrowThales contract address\n    function setEscrow(address _escrowThalesContract) public onlyOwner {\n        if (address(iEscrowThales) != address(0)) {\n            token.approve(address(iEscrowThales), 0);\n        }\n        iEscrowThales = IEscrowThales(_escrowThalesContract);\n        token.approve(_escrowThalesContract, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    }\n\n    // Check if a given reward has already been claimed\n    function claimed(uint256 index) public view returns (uint256 claimedBlock, uint256 claimedMask) {\n        claimedBlock = _claimed[period][index / 256];\n        claimedMask = (uint256(1) << uint256(index % 256));\n        require((claimedBlock & claimedMask) == 0, \"Tokens have already been claimed\");\n    }\n\n    // helper for the dapp\n    function canClaim(uint256 index) external view returns (bool) {\n        uint256 claimedBlock = _claimed[period][index / 256];\n        uint256 claimedMask = (uint256(1) << uint256(index % 256));\n        return ((claimedBlock & claimedMask) == 0);\n    }\n\n    // Get airdrop tokens assigned to address\n    // Requires sending merkle proof to the function\n    function claim(\n        uint256 index,\n        uint256 amount,\n        bytes32[] memory merkleProof\n    ) public notPaused {\n        // Make sure the tokens have not already been redeemed\n        (uint256 claimedBlock, uint256 claimedMask) = claimed(index);\n        _claimed[period][index / 256] = claimedBlock | claimedMask;\n\n        // Compute the merkle leaf from index, recipient and amount\n        bytes32 leaf = keccak256(abi.encodePacked(index, msg.sender, amount));\n        // verify the proof is valid\n        require(MerkleProof.verify(merkleProof, root, leaf), \"Proof is not valid\");\n\n        // Send to EscrowThales contract\n        iEscrowThales.addToEscrow(msg.sender, amount);\n\n        emit Claim(msg.sender, amount, block.timestamp);\n    }\n\n    function _selfDestruct(address payable beneficiary) external onlyOwner {\n        token.transfer(beneficiary, token.balanceOf(address(this)));\n        selfdestruct(beneficiary);\n    }\n\n    event Claim(address claimer, uint256 amount, uint timestamp);\n    event NewRoot(bytes32 root, uint timestamp, uint256 period);\n}\n"
    },
    "openzeppelin-solidity-2.3.0/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "synthetix-2.43.1/contracts/Owned.sol": {
      "content": "pragma solidity ^0.5.16;\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n"
    },
    "openzeppelin-solidity-2.3.0/contracts/cryptography/MerkleProof.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash < proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "synthetix-2.43.1/contracts/Pausable.sol": {
      "content": "pragma solidity ^0.5.16;\n\n// Inheritance\nimport \"./Owned.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    constructor() internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IEscrowThales.sol": {
      "content": "pragma solidity >=0.4.24;\n\ninterface IEscrowThales {\n    /* ========== VIEWS / VARIABLES ========== */\n    function getStakerPeriod(address account, uint index) external view returns (uint);\n\n    function getStakerAmounts(address account, uint index) external view returns (uint);\n\n    function totalAccountEscrowedAmount(address account) external view returns (uint);\n\n    function getStakedEscrowedBalanceForRewards(address account) external view returns (uint);\n\n    function totalEscrowedRewards() external view returns (uint);\n\n    function totalEscrowBalanceNotIncludedInStaking() external view returns (uint);\n\n    function currentVestingPeriod() external view returns (uint);\n\n    function updateCurrentPeriod() external returns (bool);\n\n    function claimable(address account) external view returns (uint);\n\n    function addToEscrow(address account, uint amount) external;\n\n    function vest(uint amount) external returns (bool);\n\n    function addTotalEscrowBalanceNotIncludedInStaking(uint amount) external;\n\n    function subtractTotalEscrowBalanceNotIncludedInStaking(uint amount) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}