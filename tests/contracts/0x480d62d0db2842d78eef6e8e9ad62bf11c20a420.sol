{{
  "language": "Solidity",
  "sources": {
    "contracts/Campaign.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.1;\n\nimport \"./interfaces/ICampaignFactory.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\nimport \"./libraries/Ownable.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/IERC20.sol\";\nimport \"./libraries/Pausable.sol\";\n\ncontract Campaign is Ownable, ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // Token being sold\n    IERC20 public token;\n\n    // Address of factory contract\n    address public factory;\n\n    // Address where funds are collected\n    address public fundingWallet;\n\n    // Timestamp when token started to sell\n    uint256 public openTime = block.timestamp;\n\n    // Timestamp when token stopped to sell\n    uint256 public closeTime;\n\n    // Timestamp when token release is enabled\n    uint256 public releaseTime;\n\n    // Amount of wei raised\n    uint256 public weiRaised = 0;\n\n    // Amount of tokens sold\n    uint256 public tokenSold = 0;\n\n    // Amount of tokens claimed\n    uint256 public tokenClaimed = 0;\n\n    // Name of IDO Campaign\n    string public name;\n\n    // Ether to token conversion rate\n    uint256 private etherConversionRate;\n\n    // Ether to token conversion rate decimals\n    uint256 private etherConversionRateDecimals = 0;\n\n    // Chainlink Price Feed\n    AggregatorV3Interface internal EthPriceFeed;\n\n\n    // Token sold mapping to delivery\n    mapping(address => uint256) private tokenSoldMapping;\n\n    // -----------------------------------------\n    // Lemonade's events\n    // -----------------------------------------\n    event CampaignCreated(\n        string name,\n        address token,\n        uint256 openTime,\n        uint256 closeTime,\n        uint256 releaseTime,\n        uint256 ethRate,\n        uint256 ethRateDecimals,\n        address wallet,\n        address owner\n    );\n    event AllowTokenToTradeWithRate(address token, uint256 rate);\n    event TokenPurchaseByEther(\n        address indexed purchaser,\n        address indexed beneficiary,\n        uint256 value,\n        uint256 amount\n    );\n    event RefundedTokenForIcoWhenEndIco(address wallet, uint256 amount);\n    event TokenClaimed(address wallet, uint256 amount);\n    event CampaignStatsChanged();\n\n    // -----------------------------------------\n    // Constructor\n    // -----------------------------------------\n    constructor() {\n        factory = msg.sender;\n\n        // Kovan Chainlink Address: 0x9326BFA02ADD2366b30bacB125260Af641031331\n        // Rinkeby: 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e\n        // Mainnet: 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        EthPriceFeed = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        );\n    }\n\n    // -----------------------------------------\n    // Lemonade external interface\n    // -----------------------------------------\n\n    /**\n     * @dev fallback function\n     */\n    fallback() external {\n        revert();\n    }\n\n    /**\n     * @dev fallback function\n     */\n    receive() external payable {\n        buyTokenByEther(msg.sender);\n    }\n\n    /**\n     * @param _name Name of ICO Campaign\n     * @param _token Address of the token being sold\n     * @param _duration Duration of ICO Campaign\n     * @param _openTime When ICO Started\n     * @param _ethRate Number of token units a buyer gets per wei\n     * @param _wallet Address where collected funds will be forwarded to\n     */\n    function initialize(\n        string calldata _name,\n        IERC20 _token,\n        uint256 _duration,\n        uint256 _openTime,\n        uint256 _releaseTime,\n        uint256 _ethRate,\n        uint256 _ethRateDecimals,\n        address _wallet\n    ) external {\n        require(msg.sender == factory, \"ICO_CAMPAIGN::UNAUTHORIZED\");\n\n        name = _name;\n        token = _token;\n        openTime = _openTime;\n        closeTime = _openTime.add(_duration);\n        releaseTime = _releaseTime;\n        etherConversionRate = _ethRate;\n        etherConversionRateDecimals = _ethRateDecimals;\n        fundingWallet = _wallet;\n        owner = tx.origin;\n        paused = false;\n\n        emit CampaignCreated(\n            name,\n            address(token),\n            openTime,\n            closeTime,\n            releaseTime,\n            etherConversionRate,\n            etherConversionRateDecimals,\n            fundingWallet,\n            owner\n        );\n    }\n\n    /**\n     * @notice Returns the conversion rate when user buy by eth\n     * @return Returns only a fixed number of rate.\n     */\n    function getEtherConversionRate() public view returns (uint256) {\n        return etherConversionRate;\n    }\n\n    /**\n     * @notice Returns the conversion rate decimals when user buy by eth\n     * @return Returns only a fixed number of decimals.\n     */\n    function getEtherConversionRateDecimals() public view returns (uint256) {\n        return etherConversionRateDecimals;\n    }\n\n    /**\n     * @notice Returns the Buyable tokens of an address\n     * @return Returns amount of tokens the user can buy\n     * @param _address Address to find the amount of tokens\n     */\n    function getBuyableTokens(address _address) public view returns (uint256) {\n        return\n            etherConversionRate\n                .mul(1 ether)\n                .mul(100000000000)\n                .div(getLatestEthPrice())\n                .div(10**etherConversionRateDecimals)\n                .sub(tokenSoldMapping[_address]);\n    }\n\n    /**\n     * @notice Returns the available tokens of Campaign\n     * @return Returns amount of tokens available to buy in the Campaign\n     */\n    function getAvailableTokens() public view returns (uint256) {\n        return token.balanceOf(address(this)).add(tokenClaimed).sub(tokenSold);\n    }\n\n    /**\n     * @notice Returns the total tokens of Campaign\n     * @return Returns amount of tokens need to sold out the Campaign\n     */\n    function totalAvailableTokens() public view returns (uint256) {\n        return token.balanceOf(address(this)).add(tokenClaimed);\n    }\n\n    /**\n     * @notice Returns the Claimable tokens of an address\n     * @return Returns amount of tokens the user can calain\n     * @param _address Address to find the amount of tokens\n     */\n    function getClaimableTokens(address _address)\n        public\n        view\n        returns (uint256)\n    {\n        return tokenSoldMapping[_address];\n    }\n\n    /**\n     * @notice Allows the contract to get the latest value of the ETH/USD price feed\n     * @return Returns the latest ETH/USD price\n     */\n    function getLatestEthPrice() public view returns (uint256) {\n        (, int256 price, , , ) = EthPriceFeed.latestRoundData();\n        return uint256(price);\n    }\n\n    /**\n     * @notice Owner can set the eth conversion rate. Receiver tokens = wei * etherConversionRate / 10 ** etherConversionRateDecimals\n     * @param _rate Fixed number of ether rate\n     */\n    function setEtherConversionRate(uint256 _rate) external onlyOwner {\n        require(etherConversionRate != _rate, \"ICO_CAMPAIGN::RATE_INVALID\");\n        etherConversionRate = _rate;\n        emit CampaignStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the eth conversion rate with decimals\n     * @param _rate Fixed number of ether rate\n     * @param _rateDecimals Fixed number of ether rate decimals\n     */\n    function setEtherConversionRateAndDecimals(uint256 _rate, uint256 _rateDecimals) external onlyOwner {\n        etherConversionRate = _rate;\n        etherConversionRateDecimals = _rateDecimals;\n        emit CampaignStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the eth conversion rate decimals. Receiver tokens = wei * etherConversionRate / 10 ** etherConversionRateDecimals\n     * @param _rateDecimals Fixed number of ether rate decimals\n     */\n    function setEtherConversionRateDecimals(uint256 _rateDecimals)\n        external\n        onlyOwner\n    {\n        etherConversionRateDecimals = _rateDecimals;\n        emit CampaignStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the new Chainlink Price Feed smart contract by address\n     * @param _chainlinkContract Chainlink Price Feed smart contract address\n     */\n    function setChainlinkContract(AggregatorV3Interface _chainlinkContract)\n        external\n        onlyOwner\n    {\n        EthPriceFeed = _chainlinkContract;\n        emit CampaignStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the release time (time in seconds) for claim functionality.\n     * @param _releaseTime Value in uint256 determine when we allow claim to function\n     */\n    function setReleaseTime(uint256 _releaseTime) external onlyOwner() {\n        require(_releaseTime >= block.timestamp, \"ICO_CAMPAIGN::INVALID_TIME\");\n        require(\n            _releaseTime >= closeTime,\n            \"ICO_CAMPAIGN::INVALID_TIME_COMPATIBILITY\"\n        );\n        releaseTime = _releaseTime;\n        emit CampaignStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the close time (time in seconds). User can buy before close time.\n     * @param _closeTime Value in uint256 determine when we stop user to by tokens\n     */\n    function setCloseTime(uint256 _closeTime) external onlyOwner() {\n        require(_closeTime >= block.timestamp, \"ICO_CAMPAIGN::INVALID_TIME\");\n        closeTime = _closeTime;\n        emit CampaignStatsChanged();\n    }\n\n    /**\n     * @notice Owner can set the open time (time in seconds). User can buy after open time.\n     * @param _openTime Value in uint256 determine when we allow user to by tokens\n     */\n    function setOpenTime(uint256 _openTime) external onlyOwner() {\n        openTime = _openTime;\n        emit CampaignStatsChanged();\n    }\n\n    /**\n     * @notice User can buy token by this function when available. tokens = wei * etherConversionRate / 10 ** etherConversionRateDecimals\n     * @dev low level token purchase ***DO NOT OVERRIDE***\n     * @param _beneficiary Address performing the token purchase\n     */\n    function buyTokenByEther(address _beneficiary)\n        public\n        payable\n        whenNotPaused\n        nonReentrant\n    {\n        uint256 weiAmount = msg.value;\n        _preValidatePurchase(_beneficiary, weiAmount);\n        require(_validPurchase(), \"ICO_CAMPAIGN::ENDED\");\n\n        // calculate token amount to be created\n        uint256 tokens = _getEtherToTokenAmount(weiAmount);\n    \n        _updatePurchasingState(_beneficiary, weiAmount, tokens);\n        uint256 platformFee = _payPlatformEtherFee();\n        _forwardFunds(weiAmount.sub(platformFee));\n        emit TokenPurchaseByEther(msg.sender, _beneficiary, weiAmount, tokens);\n    }\n\n    function claimTokens() public whenNotPaused nonReentrant {\n        require(isClaimable(), \"ICO_CAMPAIGN::ICO_NOT_ENDED\");\n\n        uint256 amount = tokenSoldMapping[msg.sender];\n        require(amount > 0, \"ICO_CAMPAIGN::EMPTY_BALANCE\");\n\n        token.transfer(msg.sender, amount);\n        _updateDeliveryState(msg.sender, amount);\n\n        emit TokenClaimed(msg.sender, amount);\n    }\n\n    /**\n     * @notice Return true if campaign has ended\n     * @dev User cannot purchase / trade tokens when isFinalized == true\n     * @return true if the ICO ended.\n     */\n    function isFinalized() public view returns (bool) {\n        return block.timestamp >= closeTime;\n    }\n\n    /**\n     * @notice Return true if campaign has ended and is eneable to claim\n     * @dev User cannot claim tokens when isClaimable == false\n     * @return true if the release time < now.\n     */\n    function isClaimable() public view returns (bool) {\n        return block.timestamp >= releaseTime;\n    }\n\n    /**\n     * @notice Return true if campaign is open\n     * @dev User can purchase / trade tokens when isOpen == true\n     * @return true if the ICO is open.\n     */\n    function isOpen() public view returns (bool) {\n        return (block.timestamp < closeTime) && (block.timestamp > openTime);\n    }\n\n    /**\n     * @notice Owner can receive their remaining tokens when ICO Ended\n     * @dev  Can refund remainning token if the ico ended\n     * @param _wallet Address wallet who receive the remainning tokens when Ico end\n     */\n    function refundTokenForIcoOwner(address _wallet)\n        external\n        onlyOwner\n    {\n        require(isClaimable(), \"ICO_CAMPAIGN::ICO_NOT_ENDED\");\n        require(getAvailableTokens() > 0, \"ICO_CAMPAIGN::EMPTY_BALANCE\");\n        uint256 availableToken = getAvailableTokens();\n        _deliverTokens(_wallet, availableToken);\n        emit RefundedTokenForIcoWhenEndIco(_wallet, availableToken);\n    }\n\n    /**\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n     * @param _beneficiary Address performing the token purchase\n     * @param _weiAmount Value in wei involved in the purchase\n     */\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount)\n        internal\n        pure\n    {\n        require(\n            _beneficiary != address(0),\n            \"ICO_CAMPAIGN::INVALID_BENEFICIARY\"\n        );\n        require(_weiAmount != 0, \"ICO_CAMPAIGN::INVALID_WEI_AMOUNT\");\n    }\n\n    /**\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param _weiAmount Value in wei to be converted into tokens\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n     */\n    function _getEtherToTokenAmount(uint256 _weiAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 rate = getEtherConversionRate();\n        return _weiAmount.mul(rate).div(10**etherConversionRateDecimals);\n    }\n\n    /**\n     * @dev Source of tokens. Transfer / mint\n     * @param _beneficiary Address performing the token purchase\n     * @param _tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount)\n        internal\n    {\n        token.transfer(_beneficiary, _tokenAmount);\n    }\n\n    /**\n     * @dev Determines how ETH is stored/forwarded on purchases.\n     */\n    function _forwardFunds(uint256 _value) internal {\n        address payable wallet = address(uint160(fundingWallet));\n        (bool success, ) = wallet.call{value: _value}(\"\");\n        require(success, \"ICO_CAMPAIGN::WALLET_TRANSFER_FAILED\");\n    }\n\n    /**\n     * @param _beneficiary Address performing the token purchase\n     * @param _tokenAmount Value of sold tokens\n     * @param _weiAmount Value in wei involved in the purchase\n     */\n    function _updatePurchasingState(\n        address _beneficiary,\n        uint256 _weiAmount,\n        uint256 _tokenAmount\n    ) internal {\n        require(\n            tokenSoldMapping[_beneficiary] + _tokenAmount <=\n                etherConversionRate\n                    .mul(1 ether)\n                    .mul(100000000000)\n                    .div(getLatestEthPrice())\n                    .div(10**etherConversionRateDecimals),\n            \"ICO_CAMPAIGN::MAX_1000_USD_TOTAL\"\n        );\n        require(getAvailableTokens() >= _tokenAmount, \"ICO_CAMPAIGN::TOKEN_NOT_ENOUGH\");\n        weiRaised = weiRaised.add(_weiAmount);\n        tokenSold = tokenSold.add(_tokenAmount);\n        tokenSoldMapping[_beneficiary] = tokenSoldMapping[_beneficiary].add(\n            _tokenAmount\n        );\n    }\n\n    /**\n     * @param _beneficiary Address performing the token delivery\n     * @param _tokenAmount Value of delivery tokens\n     */\n    function _updateDeliveryState(address _beneficiary, uint256 _tokenAmount)\n        internal\n    {\n        tokenClaimed = tokenClaimed.add(_tokenAmount);\n        tokenSoldMapping[_beneficiary] = tokenSoldMapping[_beneficiary].sub(\n            _tokenAmount\n        );\n    }\n\n    // @return true if the transaction can buy tokens\n    function _validPurchase() internal view returns (bool) {\n        bool withinPeriod =\n            block.timestamp >= openTime && block.timestamp <= closeTime;\n        return withinPeriod;\n    }\n\n    /**\n     * @notice Pay platform fee when a trade executed in eth\n     * @dev  Only pay when use Lemonade to register ICO Campaign\n     */\n    function _payPlatformEtherFee() private returns (uint256) {\n        address payable platformRevenueAddress =\n            address(uint160(_getPlatformRevenueAddress()));\n        uint256 platformFeeRate = _getPlatformFeeRate();\n        uint256 payment = msg.value;\n        uint256 platformFee = payment.mul(platformFeeRate).div(100);\n\n        (bool success, ) = platformRevenueAddress.call{value: platformFee}(\"\");\n        require(success, \"ICO_CAMPAIGN::PAY_PLATFORM_FEE_FAILED\");\n        return platformFee;\n    }\n\n    /**\n     * @notice Call to factory contract to get Platform Fee\n     * @dev  return a fixed number fee of Platform\n     */\n    function _getPlatformFeeRate() private view returns (uint256) {\n        return ICampaignFactory(factory).getPlatformFeeRate();\n    }\n\n    /**\n     * @notice Call to factory contract to get revenue address\n     * @dev  return address of factory vault\n     */\n    function _getPlatformRevenueAddress() private view returns (address) {\n        return ICampaignFactory(factory).getplatformRevenueAddress();\n    }\n}"
    },
    "contracts/interfaces/ICampaignFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1;\n\ninterface ICampaignFactory {\n    function getPlatformFeeRate() external view returns (uint256);\n    function getplatformRevenueAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n"
    },
    "contracts/libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/libraries/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/libraries/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.1;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused, \"CONTRACT_PAUSED\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused, \"CONTRACT_NOT_PAUSED\");\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}