{"Context.sol":{"content":"// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/GSN/Context.sol\n\npragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"ERC20.sol":{"content":"// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/token/ERC20/ERC20.sol\npragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller\u0027s allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}"},"GenArt721Minter_DoodleLabs_Custom_Sale.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \u0027./GenArt721Minter_DoodleLabs_MultiMinter.sol\u0027;\n\ninterface IGenArt721Minter_DoodleLabs_Config {\n    function getPurchaseManyLimit(uint256 projectId) external view returns (uint256 limit);\n    function getState(uint256 projectId) external view returns (uint256 _state);\n    function setStateFamilyCollectors(uint256 projectId) external;\n    function setStateRedemption(uint256 projectId) external;\n    function setStatePublic(uint256 projectId) external;\n}\n\ninterface IGenArt721Minter_DoodleLabs_WhiteList {\n    function getWhitelisted(uint256 projectId, address user) external view returns (uint256 amount);\n    function addWhitelist(uint256 projectId, address[] calldata users, uint256[] calldata amounts) external;\n    function decreaseAmount(uint256 projectId, address to) external;\n}\n\ncontract GenArt721Minter_DoodleLabs_Custom_Sale is GenArt721Minter_DoodleLabs_MultiMinter {\n    using SafeMath for uint256;\n\n    event Redeem(uint256 projectId);\n\n    // Must match what is on the GenArtMinterV2_State contract\n    enum SaleState {\n        FAMILY_COLLECTORS,\n        REDEMPTION,\n        PUBLIC\n    }\n\n    IGenArt721Minter_DoodleLabs_WhiteList public activeWhitelist;\n    IGenArt721Minter_DoodleLabs_Config public minterState;\n\n    modifier onlyWhitelisted() {\n        require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n        _;\n    }\n\n    modifier notRedemptionState(uint256 projectId) {\n        require(uint256(minterState.getState(projectId)) != uint256(SaleState.REDEMPTION), \"can not purchase in redemption phase\");\n        _;\n    }\n\n    modifier onlyRedemptionState(uint256 projectId) {\n        require(uint256(minterState.getState(projectId)) == uint256(SaleState.REDEMPTION), \"not in redemption phase\");\n        _;\n    }\n\n    constructor(address _genArtCore, address _minterStateAddress) GenArt721Minter_DoodleLabs_MultiMinter(_genArtCore) public {\n        minterState = IGenArt721Minter_DoodleLabs_Config(_minterStateAddress);\n    }\n\n    function setActiveWhitelist(address whitelist) public onlyWhitelisted {\n        activeWhitelist = IGenArt721Minter_DoodleLabs_WhiteList(whitelist);\n    }\n\n    function purchaseMany(uint256 projectId, uint256 amount) public payable notRedemptionState(projectId) returns (uint256[] memory _tokenIds) {\n        require(amount \u003c= minterState.getPurchaseManyLimit(projectId), \u0027Max purchase many limit reached\u0027);\n        return _purchaseMany(projectId, amount);\n    }\n\n    function purchase(uint256 _projectId) public payable notRedemptionState(_projectId) returns (uint256 _tokenId) {\n        if (uint256(minterState.getState(_projectId)) == uint256(SaleState.FAMILY_COLLECTORS) \u0026\u0026 msg.value \u003e 0) {\n            require(false, \u0027ETH not accepted at this time\u0027);\n        }\n        return _purchase(_projectId);\n    }\n\n    function redeemMany(uint256 projectId, uint256 amount) public payable onlyRedemptionState(projectId) returns (uint256[] memory _tokenIds) {\n        require(amount \u003c= minterState.getPurchaseManyLimit(projectId), \u0027Max purchase many limit reached\u0027);\n        uint256[] memory tokenIds = new uint256[](amount);\n        bool isDeferredRefund = false;\n\n        // Refund ETH if user accidentially overpays\n        // This is not needed for ERC20 tokens\n        if (msg.value \u003e 0) {\n            uint256 pricePerTokenInWei = genArtCoreContract.projectIdToPricePerTokenInWei(projectId);\n            uint256 refund = msg.value.sub(pricePerTokenInWei.mul(amount));\n            isDeferredRefund = true;\n\n            if (refund \u003e 0) {\n                msg.sender.transfer(refund);\n            }\n        }\n\n        for (uint256 i = 0; i \u003c amount; i++) {\n            tokenIds[i] = redeemTo(msg.sender, projectId, isDeferredRefund);\n            emit Purchase(projectId);\n        }\n\n        return tokenIds;\n    }\n\n    function redeem(uint256 projectId) public payable onlyRedemptionState(projectId) returns (uint256 _tokenId) {\n        return redeemTo(msg.sender, projectId, false);\n    }\n\n    function redeemTo(address to, uint256 projectId, bool isDeferredRefund) public payable onlyRedemptionState(projectId) returns (uint256 _tokenId) {\n        activeWhitelist.decreaseAmount(projectId, to);\n        emit Redeem(projectId);\n        return purchaseTo(to, projectId, isDeferredRefund);\n    }\n\n}"},"GenArt721Minter_DoodleLabs_MultiMinter.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \u0027./GenArtMinterV2_DoodleLabs.sol\u0027;\nimport \u0027./SafeMath.sol\u0027;\n\ncontract GenArt721Minter_DoodleLabs_MultiMinter is GenArt721Minter_DoodleLabs {\n    using SafeMath for uint256;\n\n    event PurchaseMany(uint256 projectId, uint256 amount);\n    event Purchase(uint256 _projectId);\n\n    constructor(address _genArtCore) GenArt721Minter_DoodleLabs(_genArtCore) internal {}\n\n    function _purchaseMany(uint256 projectId, uint256 amount) internal returns (uint256[] memory _tokenIds) {\n        uint256[] memory tokenIds = new uint256[](amount);\n        bool isDeferredRefund = false;\n\n        // Refund ETH if user accidentially overpays\n        // This is not needed for ERC20 tokens\n        if (msg.value \u003e 0) {\n            uint256 pricePerTokenInWei = genArtCoreContract.projectIdToPricePerTokenInWei(projectId);\n            uint256 refund = msg.value.sub(pricePerTokenInWei.mul(amount));\n            isDeferredRefund = true;\n\n            if (refund \u003e 0) {\n                msg.sender.transfer(refund);\n            }\n        }\n\n        for (uint256 i = 0; i \u003c amount; i++) {\n            tokenIds[i] = purchaseTo(msg.sender, projectId, isDeferredRefund);\n            emit Purchase(projectId);\n        }\n\n        return tokenIds;\n    }\n\n    function _purchase(uint256 _projectId) internal returns (uint256 _tokenId) {\n        emit Purchase(_projectId);\n        return purchaseTo(msg.sender, _projectId, false);\n    }\n}"},"GenArtMinterV2_DoodleLabs.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-10-21\n*/\n\npragma solidity ^0.5.0;\n\nimport \u0027./SafeMath.sol\u0027;\nimport \u0027./Strings.sol\u0027;\nimport \u0027./ERC20.sol\u0027;\nimport \u0027./IGenArt721CoreV2.sol\u0027;\n\ninterface BonusContract {\n  function triggerBonus(address _to) external returns (bool);\n  function bonusIsActive() external view returns (bool);\n}\n\ncontract GenArt721Minter_DoodleLabs {\n  using SafeMath for uint256;\n\n  IGenArt721CoreV2 public genArtCoreContract;\n\n  uint256 constant ONE_MILLION = 1_000_000;\n\n  address payable public ownerAddress;\n  uint256 public ownerPercentage;\n\n  mapping(uint256 =\u003e bool) public projectIdToBonus;\n  mapping(uint256 =\u003e address) public projectIdToBonusContractAddress;\n  mapping(uint256 =\u003e bool) public contractFilterProject;\n  mapping(address =\u003e mapping (uint256 =\u003e uint256)) public projectMintCounter;\n  mapping(uint256 =\u003e uint256) public projectMintLimit;\n  mapping(uint256 =\u003e bool) public projectMaxHasBeenInvoked;\n  mapping(uint256 =\u003e uint256) public projectMaxInvocations;\n\n  constructor(address _genArt721Address) public {\n    genArtCoreContract=IGenArt721CoreV2(_genArt721Address);\n  }\n\n  function getYourBalanceOfProjectERC20(uint256 _projectId) public view returns (uint256){\n    uint256 balance = ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).balanceOf(msg.sender);\n    return balance;\n  }\n\n  function checkYourAllowanceOfProjectERC20(uint256 _projectId) public view returns (uint256){\n    uint256 remaining = ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).allowance(msg.sender, address(this));\n    return remaining;\n  }\n\n  function setProjectMintLimit(uint256 _projectId,uint8 _limit) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    projectMintLimit[_projectId] = _limit;\n  }\n\n  function setProjectMaxInvocations(uint256 _projectId) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    uint256 maxInvocations;\n    uint256 invocations;\n    ( , , invocations, maxInvocations, , , , , ) = genArtCoreContract.projectTokenInfo(_projectId);\n    projectMaxInvocations[_projectId] = maxInvocations;\n    if (invocations \u003c maxInvocations) {\n        projectMaxHasBeenInvoked[_projectId] = false;\n    }\n  }\n\n  function setOwnerAddress(address payable _ownerAddress) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    ownerAddress = _ownerAddress;\n  }\n\n  function setOwnerPercentage(uint256 _ownerPercentage) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    ownerPercentage = _ownerPercentage;\n  }\n\n  function toggleContractFilter(uint256 _projectId) public {\n    require(genArtCoreContract.isWhitelisted(msg.sender), \"can only be set by admin\");\n    contractFilterProject[_projectId]=!contractFilterProject[_projectId];\n  }\n\n  function artistToggleBonus(uint256 _projectId) public {\n    require(msg.sender==genArtCoreContract.projectIdToArtistAddress(_projectId), \"can only be set by artist\");\n    projectIdToBonus[_projectId]=!projectIdToBonus[_projectId];\n  }\n\n  function artistSetBonusContractAddress(uint256 _projectId, address _bonusContractAddress) public {\n    require(msg.sender==genArtCoreContract.projectIdToArtistAddress(_projectId), \"can only be set by artist\");\n    projectIdToBonusContractAddress[_projectId]=_bonusContractAddress;\n  }\n\n  function purchase(uint256 _projectId) public payable returns (uint256 _tokenId) {\n    return purchaseTo(msg.sender, _projectId, false);\n  }\n\n  // Remove `public`` and `payable`` to prevent public use\n  // of the `purchaseTo`` function.\n  function purchaseTo(address _to, uint256 _projectId, bool _isDeferredRefund) internal returns(uint256 _tokenId){\n    require(!projectMaxHasBeenInvoked[_projectId], \"Maximum number of invocations reached\");\n    if (keccak256(abi.encodePacked(genArtCoreContract.projectIdToCurrencySymbol(_projectId))) != keccak256(abi.encodePacked(\"ETH\"))){\n      require(msg.value==0, \"this project accepts a different currency and cannot accept ETH\");\n      require(ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).allowance(msg.sender, address(this)) \u003e= genArtCoreContract.projectIdToPricePerTokenInWei(_projectId), \"Insufficient Funds Approved for TX\");\n      require(ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).balanceOf(msg.sender) \u003e= genArtCoreContract.projectIdToPricePerTokenInWei(_projectId), \"Insufficient balance.\");\n      _splitFundsERC20(_projectId);\n    } else {\n      require(msg.value\u003e=genArtCoreContract.projectIdToPricePerTokenInWei(_projectId), \"Must send minimum value to mint!\");\n      _splitFundsETH(_projectId, _isDeferredRefund);\n    }\n\n    // if contract filter is active prevent calls from another contract\n    if (contractFilterProject[_projectId]) require(msg.sender == tx.origin, \"No Contract Buys\");\n\n    // limit mints per address by project\n    if (projectMintLimit[_projectId] \u003e 0) {\n        require(projectMintCounter[msg.sender][_projectId] \u003c projectMintLimit[_projectId], \"Reached minting limit\");\n        projectMintCounter[msg.sender][_projectId]++;\n    }\n\n    uint256 tokenId = genArtCoreContract.mint(_to, _projectId, msg.sender);\n\n    // What if this overflows, since default value of uint256 is 0?\n    // That is intended, so that by default the minter allows infinite\n    // transactions, allowing the `genArtCoreContract` to stop minting\n    // `uint256 tokenInvocation = tokenId % ONE_MILLION;`\n    if (tokenId % ONE_MILLION == projectMaxInvocations[_projectId]-1){\n        projectMaxHasBeenInvoked[_projectId] = true;\n    }\n\n    if (projectIdToBonus[_projectId]){\n      require(BonusContract(projectIdToBonusContractAddress[_projectId]).bonusIsActive(), \"bonus must be active\");\n      BonusContract(projectIdToBonusContractAddress[_projectId]).triggerBonus(msg.sender);\n    }\n\n    return tokenId;\n  }\n\n  function _splitFundsETH(uint256 _projectId, bool _isDeferredRefund) internal {\n    if (msg.value \u003e 0) {\n      uint256 pricePerTokenInWei = genArtCoreContract.projectIdToPricePerTokenInWei(_projectId);\n      uint256 refund = msg.value.sub(genArtCoreContract.projectIdToPricePerTokenInWei(_projectId));\n      if (!_isDeferredRefund \u0026\u0026 refund \u003e 0) {\n        msg.sender.transfer(refund);\n      }\n      uint256 renderProviderAmount = pricePerTokenInWei.div(100).mul(genArtCoreContract.renderProviderPercentage());\n      if (renderProviderAmount \u003e 0) {\n        genArtCoreContract.renderProviderAddress().transfer(renderProviderAmount);\n      }\n\n      uint256 remainingFunds = pricePerTokenInWei.sub(renderProviderAmount);\n\n      uint256 ownerFunds = remainingFunds.div(100).mul(ownerPercentage);\n      if (ownerFunds \u003e 0) {\n        ownerAddress.transfer(ownerFunds);\n      }\n\n      uint256 projectFunds = pricePerTokenInWei.sub(renderProviderAmount).sub(ownerFunds);\n      uint256 additionalPayeeAmount;\n      if (genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId) \u003e 0) {\n        additionalPayeeAmount = projectFunds.div(100).mul(genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId));\n        if (additionalPayeeAmount \u003e 0) {\n          genArtCoreContract.projectIdToAdditionalPayee(_projectId).transfer(additionalPayeeAmount);\n        }\n      }\n      uint256 creatorFunds = projectFunds.sub(additionalPayeeAmount);\n      if (creatorFunds \u003e 0) {\n        genArtCoreContract.projectIdToArtistAddress(_projectId).transfer(creatorFunds);\n      }\n    }\n  }\n\n  function _splitFundsERC20(uint256 _projectId) internal {\n      uint256 pricePerTokenInWei = genArtCoreContract.projectIdToPricePerTokenInWei(_projectId);\n      uint256 renderProviderAmount = pricePerTokenInWei.div(100).mul(genArtCoreContract.renderProviderPercentage());\n      if (renderProviderAmount \u003e 0) {\n        ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(msg.sender, genArtCoreContract.renderProviderAddress(), renderProviderAmount);\n      }\n      uint256 remainingFunds = pricePerTokenInWei.sub(renderProviderAmount);\n\n      uint256 ownerFunds = remainingFunds.div(100).mul(ownerPercentage);\n      if (ownerFunds \u003e 0) {\n        ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(msg.sender, ownerAddress, ownerFunds);\n      }\n\n      uint256 projectFunds = pricePerTokenInWei.sub(renderProviderAmount).sub(ownerFunds);\n      uint256 additionalPayeeAmount;\n      if (genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId) \u003e 0) {\n        additionalPayeeAmount = projectFunds.div(100).mul(genArtCoreContract.projectIdToAdditionalPayeePercentage(_projectId));\n        if (additionalPayeeAmount \u003e 0) {\n          ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(msg.sender, genArtCoreContract.projectIdToAdditionalPayee(_projectId), additionalPayeeAmount);\n        }\n      }\n      uint256 creatorFunds = projectFunds.sub(additionalPayeeAmount);\n      if (creatorFunds \u003e 0) {\n        ERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId)).transferFrom(msg.sender, genArtCoreContract.projectIdToArtistAddress(_projectId), creatorFunds);\n      }\n    }\n}"},"IERC20.sol":{"content":"// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IGenArt721CoreV2.sol":{"content":"pragma solidity ^0.5.0;\n\ninterface IGenArt721CoreV2 {\n  function isWhitelisted(address sender) external view returns (bool);\n  function projectIdToCurrencySymbol(uint256 _projectId) external view returns (string memory);\n  function projectIdToCurrencyAddress(uint256 _projectId) external view returns (address);\n  function projectIdToArtistAddress(uint256 _projectId) external view returns (address payable);\n  function projectIdToPricePerTokenInWei(uint256 _projectId) external view returns (uint256);\n  function projectIdToAdditionalPayee(uint256 _projectId) external view returns (address payable);\n  function projectIdToAdditionalPayeePercentage(uint256 _projectId) external view returns (uint256);\n  function projectTokenInfo(uint256 _projectId) external view returns (address, uint256, uint256, uint256, bool, address, uint256, string memory, address);\n  function renderProviderAddress() external view returns (address payable);\n  function renderProviderPercentage() external view returns (uint256);\n  function mint(address _to, uint256 _projectId, address _by) external returns (uint256 tokenId);\n}"},"SafeMath.sol":{"content":"// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.4.0/contracts/math/SafeMath.sol\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"},"Strings.sol":{"content":"// File: contracts/Strings.sol\n\npragma solidity ^0.5.0;\n\n//https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\nlibrary Strings {\n\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        uint i = 0;\n        for (i = 0; i \u003c _ba.length; i++) {\n            babcde[k++] = _ba[i];\n        }\n        for (i = 0; i \u003c _bb.length; i++) {\n            babcde[k++] = _bb[i];\n        }\n        for (i = 0; i \u003c _bc.length; i++) {\n            babcde[k++] = _bc[i];\n        }\n        for (i = 0; i \u003c _bd.length; i++) {\n            babcde[k++] = _bd[i];\n        }\n        for (i = 0; i \u003c _be.length; i++) {\n            babcde[k++] = _be[i];\n        }\n        return string(babcde);\n    }\n\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}"}}