{{
  "language": "Solidity",
  "sources": {
    "contracts/collectors/Solos.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../presets/OwnablePausable.sol\";\nimport \"../interfaces/IDepositContract.sol\";\nimport \"../interfaces/IValidators.sol\";\nimport \"../interfaces/ISolos.sol\";\n\n/**\n * @title Solos\n *\n * @dev Users can create standalone validators with their own withdrawal key using this contract.\n * The validator can be registered as soon as deposit is added.\n */\ncontract Solos is ISolos, ReentrancyGuard, OwnablePausable {\n    using Address for address payable;\n    using SafeMath for uint256;\n\n    // @dev Validator deposit amount.\n    uint256 public constant VALIDATOR_DEPOSIT = 32 ether;\n\n    // @dev Maps ID of the solo to its information.\n    mapping(bytes32 => Solo) public override solos;\n\n    // @dev Address of the ETH2 Deposit Contract (deployed by Ethereum).\n    IDepositContract public override validatorRegistration;\n\n    // @dev Solo validator price per month.\n    uint256 public override validatorPrice;\n\n    // @dev Solo validator deposit cancel lock duration.\n    uint256 public override cancelLockDuration;\n\n    // @dev Address of the Validators contract.\n    IValidators private validators;\n\n    /**\n    * @dev Constructor for initializing the Solos contract.\n    * @param _admin - address of the contract admin.\n    * @param _validatorRegistration - address of the VRC (deployed by Ethereum).\n    * @param _validators - address of the Validators contract.\n    * @param _validatorPrice - validator price.\n    * @param _cancelLockDuration - cancel lock duration in seconds.\n    */\n    constructor(\n        address _admin,\n        address _validatorRegistration,\n        address _validators,\n        uint256 _validatorPrice,\n        uint256 _cancelLockDuration\n    )\n        OwnablePausable(_admin)\n    {\n        validatorRegistration = IDepositContract(_validatorRegistration);\n        validators = IValidators(_validators);\n\n        // set validator price\n        validatorPrice = _validatorPrice;\n        emit ValidatorPriceUpdated(_validatorPrice);\n\n        // set cancel lock duration\n        cancelLockDuration = _cancelLockDuration;\n        emit CancelLockDurationUpdated(_cancelLockDuration);\n    }\n\n    /**\n     * @dev See {ISolos-addDeposit}.\n     */\n    function addDeposit(bytes32 _withdrawalCredentials) external payable override whenNotPaused {\n        require(_withdrawalCredentials != \"\" && _withdrawalCredentials[0] == 0x00, \"Solos: invalid credentials\");\n        require(msg.value > 0 && msg.value.mod(VALIDATOR_DEPOSIT) == 0, \"Solos: invalid deposit amount\");\n\n        bytes32 soloId = keccak256(abi.encodePacked(address(this), msg.sender, _withdrawalCredentials));\n        Solo storage solo = solos[soloId];\n\n        // update solo data\n        solo.amount = solo.amount.add(msg.value);\n        if (solo.withdrawalCredentials == \"\") {\n            solo.withdrawalCredentials = _withdrawalCredentials;\n        }\n        // the deposit can be canceled after lock has expired and it was not yet sent for staking\n        // solhint-disable-next-line not-rely-on-time\n        solo.releaseTime = block.timestamp.add(cancelLockDuration);\n\n        // emit event\n        emit DepositAdded(soloId, msg.sender, msg.value, _withdrawalCredentials);\n    }\n\n    /**\n     * @dev See {ISolos-cancelDeposit}.\n     */\n    function cancelDeposit(bytes32 _withdrawalCredentials, uint256 _amount) external override nonReentrant {\n        // update balance\n        bytes32 soloId = keccak256(abi.encodePacked(address(this), msg.sender, _withdrawalCredentials));\n        Solo storage solo = solos[soloId];\n\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp >= solo.releaseTime, \"Solos: too early cancel\");\n\n        uint256 newAmount = solo.amount.sub(_amount, \"Solos: insufficient balance\");\n        require(newAmount.mod(VALIDATOR_DEPOSIT) == 0, \"Solos: invalid cancel amount\");\n\n        // emit event\n        emit DepositCanceled(soloId, msg.sender, _amount, solo.withdrawalCredentials);\n\n        if (newAmount > 0) {\n            solo.amount = newAmount;\n            // solhint-disable-next-line not-rely-on-time\n            solo.releaseTime = block.timestamp.add(cancelLockDuration);\n        } else {\n            delete solos[soloId];\n        }\n\n        // transfer canceled amount to the recipient\n        msg.sender.sendValue(_amount);\n    }\n\n    /**\n     * @dev See {ISolos-setValidatorPrice}.\n     */\n    function setValidatorPrice(uint256 _validatorPrice) external override onlyAdmin {\n        validatorPrice = _validatorPrice;\n        emit ValidatorPriceUpdated(_validatorPrice);\n    }\n\n    /**\n     * @dev See {ISolos-setCancelLockDuration}.\n     */\n    function setCancelLockDuration(uint256 _cancelLockDuration) external override onlyAdmin {\n        cancelLockDuration = _cancelLockDuration;\n        emit CancelLockDurationUpdated(_cancelLockDuration);\n    }\n\n    /**\n     * @dev See {ISolos-registerValidator}.\n     */\n    function registerValidator(Validator calldata _validator) external override whenNotPaused {\n        require(validators.isOperator(msg.sender), \"Solos: access denied\");\n\n        // update solo balance\n        Solo storage solo = solos[_validator.soloId];\n        solo.amount = solo.amount.sub(VALIDATOR_DEPOSIT, \"Solos: insufficient balance\");\n\n        // register validator\n        validators.register(keccak256(abi.encodePacked(_validator.publicKey)));\n        emit ValidatorRegistered(_validator.soloId, _validator.publicKey, validatorPrice, msg.sender);\n\n        validatorRegistration.deposit{value : VALIDATOR_DEPOSIT}(\n            _validator.publicKey,\n            abi.encodePacked(solo.withdrawalCredentials),\n            _validator.signature,\n            _validator.depositDataRoot\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/presets/OwnablePausable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.7.5;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"../interfaces/IOwnablePausable.sol\";\n\n/**\n * @title OwnablePausable\n *\n * @dev Bundles Access Control and Pausable contracts in one.\n *\n */\nabstract contract OwnablePausable is IOwnablePausable, Pausable, AccessControl {\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n    * @dev Modifier for checking whether the caller is an admin.\n    */\n    modifier onlyAdmin() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"OwnablePausable: access denied\");\n        _;\n    }\n\n    /**\n    * @dev Modifier for checking whether the caller is a pauser.\n    */\n    modifier onlyPauser() {\n        require(hasRole(PAUSER_ROLE, msg.sender), \"OwnablePausable: access denied\");\n        _;\n    }\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `PAUSER_ROLE` to the admin account.\n     */\n    constructor(address _admin) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRole(PAUSER_ROLE, _admin);\n    }\n\n    /**\n     * @dev See {IOwnablePausable-isAdmin}.\n     */\n    function isAdmin(address _account) external override view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, _account);\n    }\n\n    /**\n     * @dev See {IOwnablePausable-addAdmin}.\n     */\n    function addAdmin(address _account) external override {\n        grantRole(DEFAULT_ADMIN_ROLE, _account);\n    }\n\n    /**\n     * @dev See {IOwnablePausable-removeAdmin}.\n     */\n    function removeAdmin(address _account) external override {\n        revokeRole(DEFAULT_ADMIN_ROLE, _account);\n    }\n\n    /**\n     * @dev See {IOwnablePausable-isPauser}.\n     */\n    function isPauser(address _account) external override view returns (bool) {\n        return hasRole(PAUSER_ROLE, _account);\n    }\n\n    /**\n     * @dev See {IOwnablePausable-addPauser}.\n     */\n    function addPauser(address _account) external override {\n        grantRole(PAUSER_ROLE, _account);\n    }\n\n    /**\n     * @dev See {IOwnablePausable-removePauser}.\n     */\n    function removePauser(address _account) external override {\n        revokeRole(PAUSER_ROLE, _account);\n    }\n\n    /**\n     * @dev See {IOwnablePausable-pause}.\n     */\n    function pause() external override onlyPauser {\n        _pause();\n    }\n\n    /**\n     * @dev See {IOwnablePausable-unpause}.\n     */\n    function unpause() external override onlyPauser {\n        _unpause();\n    }\n}\n"
    },
    "contracts/interfaces/IDepositContract.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.7.5;\n\n// This interface is designed to be compatible with the Vyper version.\n/// @notice This is the Ethereum 2.0 deposit contract interface.\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\n/// https://github.com/ethereum/eth2.0-specs/blob/dev/solidity_deposit_contract/deposit_contract.sol\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(\n        bytes pubkey,\n        bytes withdrawal_credentials,\n        bytes amount,\n        bytes signature,\n        bytes index\n    );\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/IValidators.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.7.5;\n\n/**\n * @dev Interface of the Validators contract.\n */\ninterface IValidators {\n    /**\n    * @dev Constructor for initializing the Validators contract.\n    * @param _admin - address of the contract admin.\n    * @param _pool - address of the Pool contract.\n    * @param _solos - address of the Solos contract.\n    */\n    function initialize(address _admin, address _pool, address _solos) external;\n\n    /**\n    * @dev Function for checking whether an account has an operator role.\n    * @param _account - account to check.\n    */\n    function isOperator(address _account) external view returns (bool);\n\n    /**\n    * @dev Function for adding an operator role to the account.\n    * Can only be called by an account with an admin role.\n    * @param _account - account to assign an operator role to.\n    */\n    function addOperator(address _account) external;\n\n    /**\n    * @dev Function for removing an operator role from the account.\n    * Can only be called by an account with an admin role.\n    * @param _account - account to remove an operator role from.\n    */\n    function removeOperator(address _account) external;\n\n    /**\n    * @dev Function for checking whether public key was already used.\n    * @param _publicKey - hash of public key to check.\n    */\n    function publicKeys(bytes32 _publicKey) external view returns (bool);\n\n    /**\n    * @dev Function for registering validators. Can only be called by collectors.\n    * @param _validatorId - ID of the validator.\n    */\n    function register(bytes32 _validatorId) external;\n}\n"
    },
    "contracts/interfaces/ISolos.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport \"./IDepositContract.sol\";\n\n/**\n * @dev Interface of the Solos contract.\n */\ninterface ISolos {\n    /**\n    * @dev Structure for storing information about the solo deposits.\n    * @param amount - amount deposited.\n    * @param withdrawalCredentials - withdrawal credentials of the validators.\n    * @param releaseTime - the time when the deposit amount can be canceled.\n    */\n    struct Solo {\n        uint256 amount;\n        bytes32 withdrawalCredentials;\n        uint256 releaseTime;\n    }\n\n    /**\n    * @dev Structure for passing information about new Validator.\n    * @param publicKey - BLS public key of the validator, generated by the operator.\n    * @param signature - BLS signature of the validator, generated by the operator.\n    * @param depositDataRoot - hash tree root of the deposit data, generated by the operator.\n    * @param soloId - ID of the solo to register validator for.\n    */\n    struct Validator {\n        bytes publicKey;\n        bytes signature;\n        bytes32 depositDataRoot;\n        bytes32 soloId;\n    }\n\n    /**\n    * @dev Event for tracking added deposits.\n    * @param soloId - ID of the solo.\n    * @param sender - address of the deposit sender.\n    * @param amount - amount added.\n    * @param withdrawalCredentials - withdrawal credentials submitted by deposit owner.\n    */\n    event DepositAdded(\n        bytes32 indexed soloId,\n        address indexed sender,\n        uint256 amount,\n        bytes32 withdrawalCredentials\n    );\n\n    /**\n    * @dev Event for tracking canceled deposits.\n    * @param soloId - ID of the solo.\n    * @param sender - address of the deposit sender.\n    * @param amount - amount canceled.\n    * @param withdrawalCredentials - withdrawal credentials submitted by deposit owner.\n    */\n    event DepositCanceled(\n        bytes32 indexed soloId,\n        address indexed sender,\n        uint256 amount,\n        bytes32 withdrawalCredentials\n    );\n\n    /**\n    * @dev Event for tracking new cancel lock duration time.\n    * @param cancelLockDuration - new cancel lock duration for solo deposits.\n    */\n    event CancelLockDurationUpdated(uint256 cancelLockDuration);\n\n    /**\n    * @dev Event for tracking solo validator price updates.\n    * @param validatorPrice - new price for the solo validators.\n    */\n    event ValidatorPriceUpdated(uint256 validatorPrice);\n\n    /**\n    * @dev Event for tracking registered validators.\n    * @param soloId - ID of the solo where the deposit was accumulated.\n    * @param publicKey - validator public key.\n    * @param price - validator monthly price.\n    * @param operator - address of the validator operator.\n    */\n    event ValidatorRegistered(bytes32 indexed soloId, bytes publicKey, uint256 price, address operator);\n\n    /**\n    * @dev Function for getting solo's details.\n    * @param _soloId - ID of the solo to retrieve data for.\n    */\n    function solos(bytes32 _soloId) external view returns (\n        uint256 amount,\n        bytes32 withdrawalCredentials,\n        uint256 releaseTime\n    );\n\n    /**\n    * @dev Function for retrieving the validator registration contract address.\n    */\n    function validatorRegistration() external view returns (IDepositContract);\n\n    /**\n    * @dev Function for getting solo validator price per month.\n    */\n    function validatorPrice() external view returns (uint256);\n\n    /**\n    * @dev Function for updating solo validator price.\n    * @param _validatorPrice - new validator price.\n    */\n    function setValidatorPrice(uint256 _validatorPrice) external;\n\n    /**\n    * @dev Function for getting cancel lock duration in seconds.\n    */\n    function cancelLockDuration() external view returns (uint256);\n\n    /**\n    * @dev Function for updating cancel lock duration in seconds.\n    * @param newCancelLockDuration - new cancel lock duration in seconds.\n    */\n    function setCancelLockDuration(uint256 newCancelLockDuration) external;\n\n    /**\n    * @dev Function for adding solo deposits.\n    * The deposit amount must be divisible by the validator deposit amount.\n    * @param _withdrawalCredentials - withdrawal credentials for performing validator withdrawal.\n    */\n    function addDeposit(bytes32 _withdrawalCredentials) external payable;\n\n    /**\n    * @dev Function for canceling solo deposits.\n    * The deposit amount can only be canceled before it will be registered as a validator.\n    * @param _withdrawalCredentials - withdrawal credentials of solo validators.\n    * @param _amount - amount to cancel.\n    */\n    function cancelDeposit(bytes32 _withdrawalCredentials, uint256 _amount) external;\n\n    /**\n    * @dev Function for registering new solo validator.\n    * @param _validator - validator to register.\n    */\n    function registerValidator(Validator calldata _validator) external;\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/interfaces/IOwnablePausable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.7.5;\n\n/**\n * @dev Interface of the OwnablePausableUpgradeable and OwnablePausable contracts.\n */\ninterface IOwnablePausable {\n    /**\n    * @dev Function for checking whether an account has an admin role.\n    * @param _account - account to check.\n    */\n    function isAdmin(address _account) external view returns (bool);\n\n    /**\n    * @dev Function for assigning an admin role to the account.\n    * Can only be called by an account with an admin role.\n    * @param _account - account to assign an admin role to.\n    */\n    function addAdmin(address _account) external;\n\n    /**\n    * @dev Function for removing an admin role from the account.\n    * Can only be called by an account with an admin role.\n    * @param _account - account to remove an admin role from.\n    */\n    function removeAdmin(address _account) external;\n\n    /**\n    * @dev Function for checking whether an account has a pauser role.\n    * @param _account - account to check.\n    */\n    function isPauser(address _account) external view returns (bool);\n\n    /**\n    * @dev Function for adding a pauser role to the account.\n    * Can only be called by an account with an admin role.\n    * @param _account - account to assign a pauser role to.\n    */\n    function addPauser(address _account) external;\n\n    /**\n    * @dev Function for removing a pauser role from the account.\n    * Can only be called by an account with an admin role.\n    * @param _account - account to remove a pauser role from.\n    */\n    function removePauser(address _account) external;\n\n    /**\n    * @dev Function for pausing the contract.\n    */\n    function pause() external;\n\n    /**\n    * @dev Function for unpausing the contract.\n    */\n    function unpause() external;\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}