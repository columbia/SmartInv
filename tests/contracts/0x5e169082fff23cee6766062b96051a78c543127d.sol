{{
  "language": "Solidity",
  "sources": {
    "/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/contracts/FlattenedRouter01.sol": {
      "content": "// File: contracts\\interfaces\\IRouter01.sol\n\npragma solidity >=0.5.0;\r\n\r\ninterface IRouter01 {\r\n\tfunction factory() external pure returns (address);\r\n\tfunction bDeployer() external pure returns (address);\r\n\tfunction cDeployer() external pure returns (address);\r\n\tfunction WETH() external pure returns (address);\r\n\t\r\n\tfunction mint(address poolToken, uint amount, address to, uint deadline) external returns (uint tokens);\r\n\tfunction mintETH(address poolToken, address to, uint deadline) external payable returns (uint tokens);\r\n\tfunction mintCollateral(address poolToken, uint amount, address to, uint deadline, bytes calldata permitData) external returns (uint tokens);\r\n\t\r\n\tfunction redeem(address poolToken, uint tokens, address to, uint deadline, bytes calldata permitData) external returns (uint amount);\r\n\tfunction redeemETH(address poolToken, uint tokens, address to, uint deadline, bytes calldata permitData) external returns (uint amountETH);\r\n\r\n\tfunction borrow(address borrowable, uint amount, address to, uint deadline, bytes calldata permitData) external;\r\n\tfunction borrowETH(address borrowable, uint amountETH, address to, uint deadline, bytes calldata permitData) external;\r\n\t\r\n\tfunction repay(address borrowable, uint amountMax, address borrower, uint deadline) external returns (uint amount);\r\n\tfunction repayETH(address borrowable, address borrower, uint deadline) external payable returns (uint amountETH);\r\n\r\n\tfunction liquidate(address borrowable, uint amountMax, address borrower, address to, uint deadline) external returns (uint amount, uint seizeTokens);\r\n\tfunction liquidateETH(address borrowable, address borrower, address to, uint deadline) external payable returns (uint amountETH, uint seizeTokens);\r\n\t\r\n\tfunction leverage(\r\n\t\taddress uniswapV2Pair, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin,\r\n\t\taddress to, uint deadline, bytes calldata permitDataA, bytes calldata permitDataB\r\n\t) external;\r\n\tfunction deleverage(\r\n\t\taddress uniswapV2Pair, uint redeemTokens, uint amountAMin, uint amountBMin, uint deadline, bytes calldata permitData\r\n\t) external;\r\n\t\r\n\tfunction getBorrowable(address uniswapV2Pair, uint8 index) external view returns (address borrowable);\r\n\tfunction getCollateral(address uniswapV2Pair) external view returns (address collateral);\r\n\tfunction getLendingPool(address uniswapV2Pair) external view returns (address collateral, address borrowableA, address borrowableB);\r\n}\n\n// File: contracts\\interfaces\\IPoolToken.sol\n\npragma solidity >=0.5.0;\r\n\r\ninterface IPoolToken {\r\n\r\n\t/*** Impermax ERC20 ***/\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\t\r\n\tfunction name() external pure returns (string memory);\r\n\tfunction symbol() external pure returns (string memory);\r\n\tfunction decimals() external pure returns (uint8);\r\n\tfunction totalSupply() external view returns (uint);\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t/*** Pool Token ***/\r\n\t\r\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\r\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\r\n\tevent Sync(uint totalBalance);\r\n\t\r\n\tfunction underlying() external view returns (address);\r\n\tfunction factory() external view returns (address);\r\n\tfunction totalBalance() external view returns (uint);\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n\tfunction exchangeRate() external returns (uint);\r\n\tfunction mint(address minter) external returns (uint mintTokens);\r\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\r\n\tfunction skim(address to) external;\r\n\tfunction sync() external;\r\n\t\r\n\tfunction _setFactory() external;\r\n}\n\n// File: contracts\\interfaces\\IBorrowable.sol\n\npragma solidity >=0.5.0;\r\n\r\ninterface IBorrowable {\r\n\r\n\t/*** Impermax ERC20 ***/\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\t\r\n\tfunction name() external pure returns (string memory);\r\n\tfunction symbol() external pure returns (string memory);\r\n\tfunction decimals() external pure returns (uint8);\r\n\tfunction totalSupply() external view returns (uint);\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t/*** Pool Token ***/\r\n\t\r\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\r\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\r\n\tevent Sync(uint totalBalance);\r\n\t\r\n\tfunction underlying() external view returns (address);\r\n\tfunction factory() external view returns (address);\r\n\tfunction totalBalance() external view returns (uint);\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n\tfunction exchangeRate() external returns (uint);\r\n\tfunction mint(address minter) external returns (uint mintTokens);\r\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\r\n\tfunction skim(address to) external;\r\n\tfunction sync() external;\r\n\t\r\n\tfunction _setFactory() external;\r\n\t\r\n\t/*** Borrowable ***/\r\n\r\n\tevent BorrowApproval(address indexed owner, address indexed spender, uint value);\r\n\tevent Borrow(address indexed sender, address indexed borrower, address indexed receiver, uint borrowAmount, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\tevent Liquidate(address indexed sender, address indexed borrower, address indexed liquidator, uint seizeTokens, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\t\r\n\tfunction BORROW_FEE() external pure returns (uint);\r\n\tfunction collateral() external view returns (address);\r\n\tfunction reserveFactor() external view returns (uint);\r\n\tfunction exchangeRateLast() external view returns (uint);\r\n\tfunction borrowIndex() external view returns (uint);\r\n\tfunction totalBorrows() external view returns (uint);\r\n\tfunction borrowAllowance(address owner, address spender) external view returns (uint);\r\n\tfunction borrowBalance(address borrower) external view returns (uint);\t\r\n\tfunction borrowTracker() external view returns (address);\r\n\t\r\n\tfunction BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction borrowApprove(address spender, uint256 value) external returns (bool);\r\n\tfunction borrowPermit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\tfunction borrow(address borrower, address receiver, uint borrowAmount, bytes calldata data) external;\r\n\tfunction liquidate(address borrower, address liquidator) external returns (uint seizeTokens);\r\n\tfunction trackBorrow(address borrower) external;\r\n\t\r\n\t/*** Borrowable Interest Rate Model ***/\r\n\r\n\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\tevent CalculateKink(uint kinkRate);\r\n\tevent CalculateBorrowRate(uint borrowRate);\r\n\t\r\n\tfunction KINK_BORROW_RATE_MAX() external pure returns (uint);\r\n\tfunction KINK_BORROW_RATE_MIN() external pure returns (uint);\r\n\tfunction KINK_MULTIPLIER() external pure returns (uint);\r\n\tfunction borrowRate() external view returns (uint);\r\n\tfunction kinkBorrowRate() external view returns (uint);\r\n\tfunction kinkUtilizationRate() external view returns (uint);\r\n\tfunction adjustSpeed() external view returns (uint);\r\n\tfunction rateUpdateTimestamp() external view returns (uint32);\r\n\tfunction accrualTimestamp() external view returns (uint32);\r\n\t\r\n\tfunction accrueInterest() external;\r\n\t\r\n\t/*** Borrowable Setter ***/\r\n\r\n\tevent NewReserveFactor(uint newReserveFactor);\r\n\tevent NewKinkUtilizationRate(uint newKinkUtilizationRate);\r\n\tevent NewAdjustSpeed(uint newAdjustSpeed);\r\n\tevent NewBorrowTracker(address newBorrowTracker);\r\n\r\n\tfunction RESERVE_FACTOR_MAX() external pure returns (uint);\r\n\tfunction KINK_UR_MIN() external pure returns (uint);\r\n\tfunction KINK_UR_MAX() external pure returns (uint);\r\n\tfunction ADJUST_SPEED_MIN() external pure returns (uint);\r\n\tfunction ADJUST_SPEED_MAX() external pure returns (uint);\r\n\t\r\n\tfunction _initialize (\r\n\t\tstring calldata _name, \r\n\t\tstring calldata _symbol,\r\n\t\taddress _underlying, \r\n\t\taddress _collateral\r\n\t) external;\r\n\tfunction _setReserveFactor(uint newReserveFactor) external;\r\n\tfunction _setKinkUtilizationRate(uint newKinkUtilizationRate) external;\r\n\tfunction _setAdjustSpeed(uint newAdjustSpeed) external;\r\n\tfunction _setBorrowTracker(address newBorrowTracker) external;\r\n}\n\n// File: contracts\\interfaces\\ICollateral.sol\n\npragma solidity >=0.5.0;\r\n\r\ninterface ICollateral {\r\n\r\n\t/*** Impermax ERC20 ***/\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\t\r\n\tfunction name() external pure returns (string memory);\r\n\tfunction symbol() external pure returns (string memory);\r\n\tfunction decimals() external pure returns (uint8);\r\n\tfunction totalSupply() external view returns (uint);\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t/*** Pool Token ***/\r\n\t\r\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\r\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\r\n\tevent Sync(uint totalBalance);\r\n\t\r\n\tfunction underlying() external view returns (address);\r\n\tfunction factory() external view returns (address);\r\n\tfunction totalBalance() external view returns (uint);\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n\tfunction exchangeRate() external returns (uint);\r\n\tfunction mint(address minter) external returns (uint mintTokens);\r\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\r\n\tfunction skim(address to) external;\r\n\tfunction sync() external;\r\n\t\r\n\tfunction _setFactory() external;\r\n\t\r\n\t/*** Collateral ***/\r\n\t\r\n\tfunction borrowable0() external view returns (address);\r\n\tfunction borrowable1() external view returns (address);\r\n\tfunction simpleUniswapOracle() external view returns (address);\r\n\tfunction safetyMarginSqrt() external view returns (uint);\r\n\tfunction liquidationIncentive() external view returns (uint);\r\n\t\r\n\tfunction getPrices() external returns (uint price0, uint price1);\r\n\tfunction tokensUnlocked(address from, uint value) external returns (bool);\r\n\tfunction accountLiquidityAmounts(address account, uint amount0, uint amount1) external returns (uint liquidity, uint shortfall);\r\n\tfunction accountLiquidity(address account) external returns (uint liquidity, uint shortfall);\r\n\tfunction canBorrow(address account, address borrowable, uint accountBorrows) external returns (bool);\r\n\tfunction seize(address liquidator, address borrower, uint repayAmount) external returns (uint seizeTokens);\r\n\tfunction flashRedeem(address redeemer, uint redeemAmount, bytes calldata data) external;\r\n\t\r\n\t/*** Collateral Setter ***/\r\n\t\r\n\tevent NewSafetyMargin(uint newSafetyMarginSqrt);\r\n\tevent NewLiquidationIncentive(uint newLiquidationIncentive);\r\n\r\n\tfunction SAFETY_MARGIN_SQRT_MIN() external pure returns (uint);\r\n\tfunction SAFETY_MARGIN_SQRT_MAX() external pure returns (uint);\r\n\tfunction LIQUIDATION_INCENTIVE_MIN() external pure returns (uint);\r\n\tfunction LIQUIDATION_INCENTIVE_MAX() external pure returns (uint);\r\n\t\r\n\tfunction _initialize (\r\n\t\tstring calldata _name, \r\n\t\tstring calldata _symbol,\r\n\t\taddress _underlying, \r\n\t\taddress _borrowable0, \r\n\t\taddress _borrowable1\r\n\t) external;\r\n\tfunction _setSafetyMarginSqrt(uint newSafetyMarginSqrt) external;\r\n\tfunction _setLiquidationIncentive(uint newLiquidationIncentive) external;\r\n}\n\n// File: contracts\\interfaces\\IImpermaxCallee.sol\n\npragma solidity >=0.5.0;\r\n\r\ninterface IImpermaxCallee {\r\n    function impermaxBorrow(address sender, address borrower, uint borrowAmount, bytes calldata data) external;\r\n    function impermaxRedeem(address sender, uint redeemAmount, bytes calldata data) external;\r\n}\n\n// File: contracts\\interfaces\\IERC20.sol\n\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n// File: contracts\\interfaces\\IWETH.sol\n\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\n\n// File: contracts\\interfaces\\IUniswapV2Pair.sol\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n// File: contracts\\libraries\\SafeMath.sol\n\npragma solidity =0.6.6;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts\\libraries\\TransferHelper.sol\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity =0.6.6;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n\n// File: contracts\\libraries\\UniswapV2Library.sol\n\npragma solidity >=0.5.0;\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n\n// File: contracts\\Router01.sol\n\npragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ncontract Router01 is IRouter01, IImpermaxCallee {\n\tusing SafeMath for uint;\n\n\taddress public immutable override factory;\n\taddress public immutable override bDeployer;\n\taddress public immutable override cDeployer;\n\taddress public immutable override WETH;\n\n\tmodifier ensure(uint deadline) {\n\t\trequire(deadline >= block.timestamp, \"ImpermaxRouter: EXPIRED\");\n\t\t_;\n\t}\n\n\tmodifier checkETH(address poolToken) {\n\t\trequire(WETH == IPoolToken(poolToken).underlying(), \"ImpermaxRouter: NOT_WETH\");\n\t\t_;\n\t}\n\n\tconstructor(address _factory, address _bDeployer, address _cDeployer, address _WETH) public {\n\t\tfactory = _factory;\n\t\tbDeployer = _bDeployer;\n\t\tcDeployer = _cDeployer;\n\t\tWETH = _WETH;\n\t}\n\n\treceive() external payable {\n\t\tassert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n\t}\n\n\t/*** Mint ***/\n\t\n\tfunction _mint(\n\t\taddress poolToken, \n\t\taddress underlying, \n\t\tuint amount,\n\t\taddress from,\n\t\taddress to\n\t) internal virtual returns (uint tokens) {\n\t\tif (from == address(this)) TransferHelper.safeTransfer(underlying, poolToken, amount);\n\t\telse TransferHelper.safeTransferFrom(underlying, from, poolToken, amount);\n\t\ttokens = IPoolToken(poolToken).mint(to);\n\t}\n\tfunction mint(\n\t\taddress poolToken, \n\t\tuint amount,\n\t\taddress to,\n\t\tuint deadline\n\t) external virtual override ensure(deadline) returns (uint tokens) {\n\t\treturn _mint(poolToken, IPoolToken(poolToken).underlying(), amount, msg.sender, to);\n\t}\n\tfunction mintETH(\n\t\taddress poolToken, \n\t\taddress to,\n\t\tuint deadline\n\t) external virtual override payable ensure(deadline) checkETH(poolToken) returns (uint tokens) {\n\t\tIWETH(WETH).deposit{value: msg.value}();\n\t\treturn _mint(poolToken, WETH, msg.value, address(this), to);\n\t}\n\tfunction mintCollateral(\n\t\taddress poolToken, \n\t\tuint amount,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbytes calldata permitData\n\t) external virtual override ensure(deadline) returns (uint tokens) {\n\t\taddress uniswapV2Pair = IPoolToken(poolToken).underlying();\n\t\t_permitUniswapV2Pair(uniswapV2Pair, amount, deadline, permitData);\n\t\treturn _mint(poolToken, uniswapV2Pair, amount, msg.sender, to);\n\t}\n\t\n\t/*** Redeem ***/\n\t\n\tfunction redeem(\n\t\taddress poolToken,\n\t\tuint tokens,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbytes memory permitData\n\t) public virtual override ensure(deadline) returns (uint amount) {\n\t\t_permit(poolToken, tokens, deadline, permitData);\n\t\tIPoolToken(poolToken).transferFrom(msg.sender, poolToken, tokens);\n\t\tamount = IPoolToken(poolToken).redeem(to);\n\t}\n\tfunction redeemETH(\n\t\taddress poolToken, \n\t\tuint tokens,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbytes memory permitData\n\t) public virtual override ensure(deadline) checkETH(poolToken) returns (uint amountETH) {\n\t\tamountETH = redeem(poolToken, tokens, address(this), deadline, permitData);\n\t\tIWETH(WETH).withdraw(amountETH);\n\t\tTransferHelper.safeTransferETH(to, amountETH);\n\t}\n\t\t\t\n\t/*** Borrow ***/\n\n\tfunction borrow(\n\t\taddress borrowable, \n\t\tuint amount,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbytes memory permitData\n\t) public virtual override ensure(deadline) {\n\t\t_borrowPermit(borrowable, amount, deadline, permitData);\n\t\tIBorrowable(borrowable).borrow(msg.sender, to, amount, new bytes(0));\n\t}\n\tfunction borrowETH(\n\t\taddress borrowable, \n\t\tuint amountETH,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbytes memory permitData\n\t) public virtual override ensure(deadline) checkETH(borrowable) {\n\t\tborrow(borrowable, amountETH, address(this), deadline, permitData);\n\t\tIWETH(WETH).withdraw(amountETH);\n\t\tTransferHelper.safeTransferETH(to, amountETH);\n\t}\n\t\n\t/*** Repay ***/\n\t\n\tfunction _repayAmount(\n\t\taddress borrowable, \n\t\tuint amountMax,\n\t\taddress borrower\n\t) internal virtual returns (uint amount) {\n\t\tIBorrowable(borrowable).accrueInterest();\n\t\tuint borrowedAmount = IBorrowable(borrowable).borrowBalance(borrower);\n\t\tamount = amountMax < borrowedAmount ? amountMax : borrowedAmount;\n\t}\n\tfunction repay(\n\t\taddress borrowable, \n\t\tuint amountMax,\n\t\taddress borrower,\n\t\tuint deadline\n\t) external virtual override ensure(deadline) returns (uint amount) {\n\t\tamount = _repayAmount(borrowable, amountMax, borrower);\n\t\tTransferHelper.safeTransferFrom(IBorrowable(borrowable).underlying(), msg.sender, borrowable, amount);\n\t\tIBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\n\t}\n\tfunction repayETH(\n\t\taddress borrowable, \n\t\taddress borrower,\n\t\tuint deadline\n\t) external virtual override payable ensure(deadline) checkETH(borrowable) returns (uint amountETH) {\n\t\tamountETH = _repayAmount(borrowable, msg.value, borrower);\n\t\tIWETH(WETH).deposit{value: amountETH}();\n\t\tassert(IWETH(WETH).transfer(borrowable, amountETH));\n\t\tIBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\n\t\t// refund surpluss eth, if any\n\t\tif (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n\t}\n\t\n\t/*** Liquidate ***/\n\n\tfunction liquidate(\n\t\taddress borrowable, \n\t\tuint amountMax,\n\t\taddress borrower,\n\t\taddress to,\n\t\tuint deadline\n\t) external virtual override ensure(deadline) returns (uint amount, uint seizeTokens) {\n\t\tamount = _repayAmount(borrowable, amountMax, borrower);\n\t\tTransferHelper.safeTransferFrom(IBorrowable(borrowable).underlying(), msg.sender, borrowable, amount);\n\t\tseizeTokens = IBorrowable(borrowable).liquidate(borrower, to);\n\t}\n\tfunction liquidateETH(\n\t\taddress borrowable, \n\t\taddress borrower,\n\t\taddress to,\n\t\tuint deadline\n\t) external virtual override payable ensure(deadline) checkETH(borrowable) returns (uint amountETH, uint seizeTokens) {\n\t\tamountETH = _repayAmount(borrowable, msg.value, borrower);\n\t\tIWETH(WETH).deposit{value: amountETH}();\n\t\tassert(IWETH(WETH).transfer(borrowable, amountETH));\n\t\tseizeTokens = IBorrowable(borrowable).liquidate(borrower, to);\n\t\t// refund surpluss eth, if any\n\t\tif (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n\t}\n\t\t\n\t/*** Leverage LP Token ***/\n\t\n\tfunction _leverage(\n\t\taddress uniswapV2Pair, \n\t\tuint amountA,\n\t\tuint amountB,\n\t\taddress to\n\t) internal virtual {\n\t\taddress borrowableA = getBorrowable(uniswapV2Pair, 0);\n\t\t// mint collateral\n\t\tbytes memory borrowBData = abi.encode(CalleeData({\n\t\t\tcallType: CallType.ADD_LIQUIDITY_AND_MINT,\n\t\t\tuniswapV2Pair: uniswapV2Pair,\n\t\t\tborrowableIndex: 1,\n\t\t\tdata: abi.encode(AddLiquidityAndMintCalldata({\n\t\t\t\tamountA: amountA,\n\t\t\t\tamountB: amountB,\n\t\t\t\tto: to\n\t\t\t}))\n\t\t}));\t\n\t\t// borrow borrowableB\n\t\tbytes memory borrowAData = abi.encode(CalleeData({\n\t\t\tcallType: CallType.BORROWB,\n\t\t\tuniswapV2Pair: uniswapV2Pair,\n\t\t\tborrowableIndex: 0,\n\t\t\tdata: abi.encode(BorrowBCalldata({\n\t\t\t\tborrower: msg.sender,\n\t\t\t\treceiver: address(this),\n\t\t\t\tborrowAmount: amountB,\n\t\t\t\tdata: borrowBData\n\t\t\t}))\n\t\t}));\n\t\t// borrow borrowableA\n\t\tIBorrowable(borrowableA).borrow(msg.sender, address(this), amountA, borrowAData);\t\n\t}\n\tfunction leverage(\n\t\taddress uniswapV2Pair,  \n\t\tuint amountADesired,\n\t\tuint amountBDesired,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbytes calldata permitDataA,\n\t\tbytes calldata permitDataB\n\t) external virtual override ensure(deadline) {\n\t\t_borrowPermit(getBorrowable(uniswapV2Pair, 0), amountADesired, deadline, permitDataA);\n\t\t_borrowPermit(getBorrowable(uniswapV2Pair, 1), amountBDesired, deadline, permitDataB);\n\t\t(uint amountA, uint amountB) = _optimalLiquidity(uniswapV2Pair, amountADesired, amountBDesired, amountAMin, amountBMin);\n\t\t_leverage(uniswapV2Pair, amountA, amountB, to);\n\t}\n\n\tfunction _addLiquidityAndMint(\n\t\taddress uniswapV2Pair, \n\t\tuint amountA,\n\t\tuint amountB,\n\t\taddress to\n\t) internal virtual {\n\t\t(address collateral, address borrowableA, address borrowableB) = getLendingPool(uniswapV2Pair);\n\t\t// add liquidity to uniswap pair\n\t\tTransferHelper.safeTransfer(IBorrowable(borrowableA).underlying(), uniswapV2Pair, amountA);\n\t\tTransferHelper.safeTransfer(IBorrowable(borrowableB).underlying(), uniswapV2Pair, amountB);\n\t\tIUniswapV2Pair(uniswapV2Pair).mint(collateral);\n\t\t// mint collateral\n\t\tICollateral(collateral).mint(to);\n\t}\n\t\t\n\t/*** Deleverage LP Token ***/\n\t\n\tfunction deleverage(\n\t\taddress uniswapV2Pair,  \n\t\tuint redeemTokens,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\tuint deadline,\n\t\tbytes calldata permitData\n\t) external virtual override ensure(deadline) {\n\t\taddress collateral = getCollateral(uniswapV2Pair);\n\t\tuint exchangeRate = ICollateral(collateral).exchangeRate();\n\t\trequire(redeemTokens > 0, \"ImpermaxRouter: REDEEM_ZERO\");\t\t\n\t\tuint redeemAmount = (redeemTokens - 1).mul(exchangeRate).div(1e18);\n\t\t_permit(collateral, redeemTokens, deadline, permitData);\n\t\tbytes memory redeemData = abi.encode(CalleeData({\n\t\t\tcallType: CallType.REMOVE_LIQ_AND_REPAY,\n\t\t\tuniswapV2Pair: uniswapV2Pair,\n\t\t\tborrowableIndex: 0,\n\t\t\tdata: abi.encode(RemoveLiqAndRepayCalldata({\n\t\t\t\tborrower: msg.sender,\n\t\t\t\tredeemTokens: redeemTokens,\n\t\t\t\tredeemAmount: redeemAmount,\n\t\t\t\tamountAMin: amountAMin,\n\t\t\t\tamountBMin: amountBMin\n\t\t\t}))\n\t\t}));\n\t\t// flashRedeem\n\t\tICollateral(collateral).flashRedeem(address(this), redeemAmount, redeemData);\n\t}\n\n\tfunction _removeLiqAndRepay(\n\t\taddress uniswapV2Pair,\n\t\taddress borrower,\n\t\tuint redeemTokens,\n\t\tuint redeemAmount,\n\t\tuint amountAMin,\n\t\tuint amountBMin\n\t) internal virtual {\n\t\t(address collateral, address borrowableA, address borrowableB) = getLendingPool(uniswapV2Pair);\n\t\taddress tokenA = IBorrowable(borrowableA).underlying();\n\t\taddress tokenB = IBorrowable(borrowableB).underlying();\n\t\t// removeLiquidity\n\t\tTransferHelper.safeTransfer(uniswapV2Pair, uniswapV2Pair, redeemAmount);\n\t\t(uint amountAMax, uint amountBMax) = IUniswapV2Pair(uniswapV2Pair).burn(address(this));\n\t\trequire(amountAMax >= amountAMin, \"ImpermaxRouter: INSUFFICIENT_A_AMOUNT\");\n\t\trequire(amountBMax >= amountBMin, \"ImpermaxRouter: INSUFFICIENT_B_AMOUNT\");\n\t\t// repay and refund\n\t\t_repayAndRefund(borrowableA, tokenA, borrower, amountAMax);\n\t\t_repayAndRefund(borrowableB, tokenB, borrower, amountBMax);\n\t\t// repay flash redeem\n\t\tICollateral(collateral).transferFrom(borrower, collateral, redeemTokens);\n\t}\n\t\n\tfunction _repayAndRefund(\n\t\taddress borrowable,\n\t\taddress token,\n\t\taddress borrower,\n\t\tuint amountMax\n\t) internal virtual {\n\t\t//repay\n\t\tuint amount = _repayAmount(borrowable, amountMax, borrower);\n\t\tTransferHelper.safeTransfer(token, borrowable, amount);\n\t\tIBorrowable(borrowable).borrow(borrower, address(0), 0, new bytes(0));\t\t\n\t\t// refund excess\n\t\tif (amountMax > amount) {\n\t\t\tuint refundAmount = amountMax - amount;\n\t\t\tif (token == WETH) {\t\t\n\t\t\t\tIWETH(WETH).withdraw(refundAmount);\n\t\t\t\tTransferHelper.safeTransferETH(borrower, refundAmount);\n\t\t\t}\n\t\t\telse TransferHelper.safeTransfer(token, borrower, refundAmount);\n\t\t}\n\t}\n\t\n\t/*** Impermax Callee ***/\n\t\t\n\tenum CallType {ADD_LIQUIDITY_AND_MINT, BORROWB, REMOVE_LIQ_AND_REPAY}\n\tstruct CalleeData {\n\t\tCallType callType;\n\t\taddress uniswapV2Pair;\n\t\tuint8 borrowableIndex;\n\t\tbytes data;\t\t\n\t}\n\tstruct AddLiquidityAndMintCalldata {\n\t\tuint amountA;\n\t\tuint amountB;\n\t\taddress to;\n\t}\n\tstruct BorrowBCalldata {\n\t\taddress borrower; \n\t\taddress receiver;\n\t\tuint borrowAmount;\n\t\tbytes data;\n\t}\n\tstruct RemoveLiqAndRepayCalldata {\n\t\taddress borrower;\n\t\tuint redeemTokens;\n\t\tuint redeemAmount;\n\t\tuint amountAMin;\n\t\tuint amountBMin;\n\t}\n\t\n\tfunction impermaxBorrow(address sender, address borrower, uint borrowAmount, bytes calldata data) external virtual override {\n\t\tborrower; borrowAmount;\n\t\tCalleeData memory calleeData = abi.decode(data, (CalleeData));\n\t\taddress declaredCaller = getBorrowable(calleeData.uniswapV2Pair, calleeData.borrowableIndex);\n\t\t// only succeeds if called by a borrowable and if that borrowable has been called by the router\n\t\trequire(sender == address(this), \"ImpermaxRouter: SENDER_NOT_ROUTER\");\n\t\trequire(msg.sender == declaredCaller, \"ImpermaxRouter: UNAUTHORIZED_CALLER\");\n\t\tif (calleeData.callType == CallType.ADD_LIQUIDITY_AND_MINT) {\n\t\t\tAddLiquidityAndMintCalldata memory d = abi.decode(calleeData.data, (AddLiquidityAndMintCalldata));\n\t\t\t_addLiquidityAndMint(calleeData.uniswapV2Pair, d.amountA, d.amountB, d.to);\n\t\t}\n\t\telse if (calleeData.callType == CallType.BORROWB) {\n\t\t\tBorrowBCalldata memory d = abi.decode(calleeData.data, (BorrowBCalldata));\n\t\t\taddress borrowableB = getBorrowable(calleeData.uniswapV2Pair, 1);\n\t\t\tIBorrowable(borrowableB).borrow(d.borrower, d.receiver, d.borrowAmount, d.data);\n\t\t}\n\t\telse revert();\n\t}\n\t\n\tfunction impermaxRedeem(address sender, uint redeemAmount, bytes calldata data) external virtual override {\n\t\tredeemAmount;\n\t\tCalleeData memory calleeData = abi.decode(data, (CalleeData));\n\t\taddress declaredCaller = getCollateral(calleeData.uniswapV2Pair);\n\t\t// only succeeds if called by a collateral and if that collateral has been called by the router\n\t\trequire(sender == address(this), \"ImpermaxRouter: SENDER_NOT_ROUTER\");\n\t\trequire(msg.sender == declaredCaller, \"ImpermaxRouter: UNAUTHORIZED_CALLER\");\n\t\tif (calleeData.callType == CallType.REMOVE_LIQ_AND_REPAY) {\n\t\t\tRemoveLiqAndRepayCalldata memory d = abi.decode(calleeData.data, (RemoveLiqAndRepayCalldata));\n\t\t\t_removeLiqAndRepay(calleeData.uniswapV2Pair, d.borrower, d.redeemTokens, d.redeemAmount, d.amountAMin, d.amountBMin);\n\t\t}\n\t\telse revert();\n\t}\n\t\t\n\t/*** Utilities ***/\n\t\n\tfunction _permit(\n\t\taddress poolToken, \n\t\tuint amount, \n\t\tuint deadline,\n\t\tbytes memory permitData\n\t) internal virtual {\n\t\tif (permitData.length == 0) return;\n\t\t(bool approveMax, uint8 v, bytes32 r, bytes32 s) = abi.decode(permitData, (bool, uint8, bytes32, bytes32));\n\t\tuint value = approveMax ? uint(-1) : amount;\n\t\tIPoolToken(poolToken).permit(msg.sender, address(this), value, deadline, v, r, s);\n\t}\n\tfunction _permitUniswapV2Pair(\n\t\taddress uniswapV2Pair, \n\t\tuint amount, \n\t\tuint deadline,\n\t\tbytes memory permitData\n\t) internal virtual {\n\t\tif (permitData.length == 0) return;\n\t\t(bool approveMax, uint8 v, bytes32 r, bytes32 s) = abi.decode(permitData, (bool, uint8, bytes32, bytes32));\n\t\tuint value = approveMax ? uint(-1) : amount;\n\t\tIUniswapV2Pair(uniswapV2Pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n\t}\n\tfunction _borrowPermit(\n\t\taddress borrowable, \n\t\tuint amount, \n\t\tuint deadline,\n\t\tbytes memory permitData\n\t) internal virtual {\n\t\tif (permitData.length == 0) return;\n\t\t(bool approveMax, uint8 v, bytes32 r, bytes32 s) = abi.decode(permitData, (bool, uint8, bytes32, bytes32));\n\t\tuint value = approveMax ? uint(-1) : amount;\n\t\tIBorrowable(borrowable).borrowPermit(msg.sender, address(this), value, deadline, v, r, s);\n\t}\n\t\n\tfunction _optimalLiquidity(\n\t\taddress uniswapV2Pair,\n\t\tuint amountADesired,\n\t\tuint amountBDesired,\n\t\tuint amountAMin,\n\t\tuint amountBMin\n\t) public virtual view returns (uint amountA, uint amountB) {\n\t\t(uint reserveA, uint reserveB,) = IUniswapV2Pair(uniswapV2Pair).getReserves();\n\t\tuint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n\t\tif (amountBOptimal <= amountBDesired) {\n\t\t\trequire(amountBOptimal >= amountBMin, \"ImpermaxRouter: INSUFFICIENT_B_AMOUNT\");\n\t\t\t(amountA, amountB) = (amountADesired, amountBOptimal);\n\t\t} else {\n\t\t\tuint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n\t\t\tassert(amountAOptimal <= amountADesired);\n\t\t\trequire(amountAOptimal >= amountAMin, \"ImpermaxRouter: INSUFFICIENT_A_AMOUNT\");\n\t\t\t(amountA, amountB) = (amountAOptimal, amountBDesired);\n\t\t}\n\t}\n\t\n\tfunction getBorrowable(address uniswapV2Pair, uint8 index) public virtual override view returns (address borrowable) {\n\t\trequire(index < 2, \"ImpermaxRouter: INDEX_TOO_HIGH\");\n\t\tborrowable = address(uint(keccak256(abi.encodePacked(\n\t\t\thex\"ff\",\n\t\t\tbDeployer,\n\t\t\tkeccak256(abi.encodePacked(factory, uniswapV2Pair, index)),\n\t\t\thex\"605ba1db56496978613939baf0ae31dccceea3f5ca53dfaa76512bc880d7bb8f\" // Borrowable bytecode keccak256\n\t\t))));\n\t}\n\tfunction getCollateral(address uniswapV2Pair) public virtual override view returns (address collateral) {\n\t\tcollateral = address(uint(keccak256(abi.encodePacked(\n\t\t\thex\"ff\",\n\t\t\tcDeployer,\n\t\t\tkeccak256(abi.encodePacked(factory, uniswapV2Pair)),\n\t\t\thex\"4b8788d8761647e6330407671d3c6c80afaed3d047800dba0e0e3befde047767\" // Collateral bytecode keccak256\n\t\t))));\n\t}\n\tfunction getLendingPool(address uniswapV2Pair) public virtual override view returns (address collateral, address borrowableA, address borrowableB) {\n\t\tcollateral = getCollateral(uniswapV2Pair);\n\t\tborrowableA = getBorrowable(uniswapV2Pair, 0);\n\t\tborrowableB = getBorrowable(uniswapV2Pair, 1);\n\t}\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "evmVersion": "istanbul",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}