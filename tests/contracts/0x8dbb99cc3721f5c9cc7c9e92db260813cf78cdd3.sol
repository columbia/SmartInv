{"CertifiedPartners.sol":{"content":"/*\n* SPDX-License-Identifier: UNLICENSED\n* Copyright Â© 2021 Blocksquare d.o.o.\n*/\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./Ownable.sol\";\n\ninterface CertifiedPartnersHelpers {\n    function hasSystemAdminRights(address addr) external view returns (bool);\n\n    function isCPAdminOf(address account, bytes32 cpBytes) external view returns (bool);\n\n    function getSpecialWallet() external view returns (address);\n}\n\n// @title Certified Partners\ncontract CertifiedPartners is Ownable {\n    struct CertifiedPartner {\n        bool canDistributeRent;\n        bool isCP;\n        mapping(bytes32 =\u003e bool) whitelistedUsers;\n    }\n\n    CertifiedPartnersHelpers private _roles;\n\n    mapping(bytes32 =\u003e CertifiedPartner) private _certifiedPartner;\n    mapping(address =\u003e bytes32) _associatedWallets;\n\n    address private _dataProxy;\n\n\n    event AddedCertifiedPartner(bytes32 indexed cpBytes, string cp);\n    event AddedWallet(bytes32 indexed cp, address wallet, string cpName);\n    event RemovedWallet(bytes32 indexed cp, address wallet);\n    event AddedWhitelisted(bytes32 indexed cp, string[] users, string cpName);\n    event RemovedWhitelisted(bytes32 indexed cp, string[] users, string cpName);\n\n    modifier onlySystemAdmin {\n        require(_roles.hasSystemAdminRights(_msgSender()), \"CertifiedPartners: You need to have system admin rights!\");\n        _;\n    }\n\n\n    modifier onlySystemAdminOrSpecialWallet {\n        require(_roles.hasSystemAdminRights(_msgSender()) || CertifiedPartnersHelpers(_dataProxy).getSpecialWallet() == _msgSender(), \"CertifiedPartners: You don\u0027t have rights!\");\n        _;\n    }\n\n    modifier onlyCPAdmin(string memory cp) {\n        bytes32 cpBytes = getUserBytes(cp);\n        require(_roles.isCPAdminOf(_msgSender(), cpBytes) || CertifiedPartnersHelpers(_dataProxy).getSpecialWallet() == _msgSender(), \"CertifiedPartners: You need to be admin of this CP!\");\n        _;\n    }\n\n    modifier onlyCPOrManager(string memory cp) {\n        bytes32 cpBytes = getUserBytes(cp);\n        require(_roles.isCPAdminOf(_msgSender(), cpBytes) || _associatedWallets[_msgSender()] == cpBytes || CertifiedPartnersHelpers(_dataProxy).getSpecialWallet() == _msgSender(), \"CertifiedPartners: You need to have CP admin rights or you have to be CP!\");\n        _;\n    }\n\n    constructor(address roles) public {\n        _roles = CertifiedPartnersHelpers(roles);\n    }\n\n    function changeRolesAddress(address newRoles) public onlyOwner {\n        _roles = CertifiedPartnersHelpers(newRoles);\n    }\n\n    function changeDataProxy(address dataProxy) public onlyOwner {\n        _dataProxy = dataProxy;\n    }\n\n    /// @notice added new Certified Partner\n    /// @param cp Certified Partner identifier\n    function addCertifiedPartner(string memory cp) public onlySystemAdmin {\n        bytes32 cpBytes = getUserBytes(cp);\n        _certifiedPartner[cpBytes] = CertifiedPartner({canDistributeRent : true, isCP : true});\n        emit AddedCertifiedPartner(cpBytes, cp);\n    }\n\n    /// @notice add wallets to Certified Partner\n    /// @param cp Certified Partner identifier\n    /// @param wallets Array of wallet address\n    function addWalletsToCP(string memory cp, address[] memory wallets) public onlyCPAdmin(cp) {\n        bytes32 cpBytes = getUserBytes(cp);\n        require(_certifiedPartner[cpBytes].isCP, \"CertifiedPartners: Not a certified partner\");\n        for (uint256 i = 0; i \u003c wallets.length; i++) {\n            _associatedWallets[wallets[i]] = cpBytes;\n            emit AddedWallet(cpBytes, wallets[i], cp);\n        }\n    }\n\n    /// @notice add wallet to Certified Partner\n    /// @param cp Certified Partner identifier\n    /// @param wallet Wallet address\n    function addCPAndWallet(string memory cp, address wallet) public onlySystemAdmin {\n        bytes32 cpBytes = getUserBytes(cp);\n        addCertifiedPartner(cp);\n        _associatedWallets[wallet] = cpBytes;\n        emit AddedWallet(cpBytes, wallet, cp);\n    }\n\n    /// @notice remove wallets\n    /// @param wallets Array of wallet addresses\n    function removeWallets(address[] memory wallets) public onlySystemAdminOrSpecialWallet {\n        bytes32 cpBytes = _associatedWallets[wallets[0]];\n        for (uint256 i = 0; i \u003c wallets.length; i++) {\n            delete _associatedWallets[wallets[i]];\n            emit RemovedWallet(cpBytes, wallets[i]);\n        }\n    }\n\n    /// @notice change whether Certified Partner can distribute revenue\n    /// @param cp Certified Partner identifier\n    function changeCanDistributeRent(string memory cp) public onlyCPAdmin(cp) {\n        bytes32 cpBytes = getUserBytes(cp);\n        _certifiedPartner[cpBytes].canDistributeRent = !_certifiedPartner[cpBytes].canDistributeRent;\n    }\n\n    /// @notice whitelist users to Certified Partner allowing them to trade Certified Partner\u0027s properties\n    /// @param cp Certified Partner identifier\n    /// @param users Array of user identifiers\n    function addWhitelisted(string memory cp, string[] memory users) public onlyCPOrManager(cp) {\n        bytes32 cpBytes = getUserBytes(cp);\n        for (uint256 i = 0; i \u003c users.length; i++) {\n            bytes32 userBytes = getUserBytes(users[i]);\n            _certifiedPartner[cpBytes].whitelistedUsers[userBytes] = true;\n        }\n        emit AddedWhitelisted(cpBytes, users, cp);\n    }\n\n    /// @notice remove users from Certified Partner\u0027s whitelist\n    /// @param cp Certified Partner identifier\n    /// @param users Array of user identifiers\n    function removeWhitelisted(string memory cp, string[] memory users) public onlyCPOrManager(cp) {\n        bytes32 cpBytes = getUserBytes(cp);\n        for (uint256 i = 0; i \u003c users.length; i++) {\n            bytes32 userBytes = getUserBytes(users[i]);\n            _certifiedPartner[cpBytes].whitelistedUsers[userBytes] = false;\n        }\n        emit RemovedWhitelisted(cpBytes, users, cp);\n    }\n\n    /// @notice check if Certified Partner identifier is registered\n    /// @param name Identifier to check\n    /// @return true if name is a registered Certified Partner otherwise false\n    function isCertifiedPartnerName(string memory name) public view returns (bool) {\n        bytes32 nameBytes = getUserBytes(name);\n        return _certifiedPartner[nameBytes].isCP;\n    }\n\n    /// @notice check if addr belongs to a registered Certified Partner\n    /// @param addr Wallet address to check\n    /// @return true if addr belongs to a registered Certified Partner\n    function isCertifiedPartner(address addr) public view returns (bool) {\n        return _certifiedPartner[_associatedWallets[addr]].isCP;\n    }\n\n    /// @notice check if Certified Partner with wallet addr can distribute revenue\n    /// @param addr Wallet address of Certified Partner\n    /// @return true if Certified Partner with wallet addr can distribute revenue otherwise false\n    function canCertifiedPartnerDistributeRent(address addr) public view returns (bool) {\n        return _certifiedPartner[_associatedWallets[addr]].canDistributeRent;\n    }\n\n    /// @notice check if user is whitelisted for cp\n    /// @param cp Certified Partner identifier\n    /// @param user User identifier\n    /// @return true if user is whitelisted for cp otherwise false\n    function isUserWhitelistedByName(string memory cp, string memory user) public view returns (bool) {\n        bytes32 cpBytes = getUserBytes(cp);\n        return _certifiedPartner[cpBytes].whitelistedUsers[getUserBytes(user)];\n    }\n\n    /// @notice if admin is admin of cp based on wallet addresses\n    /// @param admin Wallet address of admin\n    /// @param cp Wallet address of Certified Partner\n    /// @return true if admin is admin of cp otherwise false\n    function isCPAdmin(address admin, address cp) external view returns (bool) {\n        return _roles.isCPAdminOf(admin, _associatedWallets[cp]);\n    }\n\n    /// @notice check if user whitelisted for cp based on bytes\n    /// @param cp Keccak256 hash of Certified Partner identifier\n    /// @param user Keccak256 hash of user identifier\n    /// @return true if user is whitelisted for cp otherwise false\n    function isUserWhitelisted(bytes32 cp, bytes32 user) external view returns (bool) {\n        return _certifiedPartner[cp].whitelistedUsers[user];\n    }\n\n    /// @notice get keccak256 hash of string\n    /// @param user User or Certified Partner identifier\n    /// @return keccak256 hash\n    function getUserBytes(string memory user) public pure returns (bytes32) {\n        return keccak256(abi.encode(user));\n    }\n\n    /// @notice retrieves keccak256 hash of Certified Partner based on wallet\n    /// @param wallet Wallet address of Certified Partner\n    /// @return keccak256 hash\n    function getCPBytesFromWallet(address wallet) public view returns (bytes32) {\n        return _associatedWallets[wallet];\n    }\n}\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"}}