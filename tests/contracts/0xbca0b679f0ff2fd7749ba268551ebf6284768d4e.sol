{{
  "language": "Solidity",
  "sources": {
    "contracts/JaduStaking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"./interfaces/IERC721Custom.sol\";\n\ncontract JaduStaking is Context {\n    //uint256 private tokenId;\n\n    using Counters for Counters.Counter;\n    Counters.Counter private _itemIds;\n    Counters.Counter private _itemsUnstaked;\n\n    address payable owner;\n\n    constructor() {\n        owner = payable(_msgSender());\n    }\n\n    struct StakeItem {\n        uint256 itemId;\n        address nftContract;\n        uint256[] tokenId;\n        address owner;\n        uint256 time;\n    }\n\n    mapping(address => mapping(uint256 => bool)) private NFTexist;\n    mapping(uint256 => StakeItem) private idToStakeItem;\n    mapping(address => mapping(uint256 => bool)) public revealedIDs;\n\n    function stake(address nftContract, uint256[] memory tokenId)\n        public\n        payable\n        returns (uint256)\n    {\n        require(tokenId.length <= 2, \"Cannot stake more than 2 NFTs in combo.\");\n\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            require(\n                NFTexist[nftContract][tokenId[i]] == false,\n                \"NFT already staked.\"\n            );\n\n            require(\n                revealedIDs[nftContract][tokenId[i]] == false,\n                \"NFT was staked for 30 days either in single staking or combination staking.\"\n            );\n\n            NFTexist[nftContract][tokenId[i]] = true;\n        }\n\n        _itemIds.increment();\n        uint256 itemId = _itemIds.current();\n\n        idToStakeItem[itemId] = StakeItem(\n            itemId,\n            nftContract,\n            tokenId,\n            _msgSender(),\n            block.timestamp\n        );\n\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            IERC721Custom(nftContract).transferFrom(\n                _msgSender(),\n                address(this),\n                tokenId[i]\n            );\n        }\n\n        return itemId;\n    }\n\n    function unStake(address nftContract, uint256 itemId)\n        public\n        payable\n        returns (uint256[] memory)\n    {\n        uint256[] memory tokenId = idToStakeItem[itemId].tokenId;\n        require(\n            idToStakeItem[itemId].owner == _msgSender(),\n            \"You are not the owner of staked NFT.\"\n        );\n\n        if (block.timestamp > idToStakeItem[itemId].time + 30 days) {\n            for (uint256 i = 0; i < tokenId.length; i++) {\n                doReveal(nftContract, tokenId[i]);\n            }\n        }\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            uint256 id = tokenId[i];\n            IERC721Custom(nftContract).transferFrom(\n                address(this),\n                idToStakeItem[itemId].owner,\n                id\n            );\n            NFTexist[nftContract][id] = false;\n        }\n        delete idToStakeItem[itemId];\n        _itemsUnstaked.increment();\n        return tokenId;\n    }\n\n    function doReveal(address nftContract, uint256 tokenId) private {\n        revealedIDs[nftContract][tokenId] = true;\n    }\n\n    function multiUnStake(address nftContract, uint256[] calldata itemIds)\n        public\n        payable\n        returns (bool)\n    {\n        for (uint256 i = 0; i < itemIds.length; i++) {\n            unStake(nftContract, itemIds[i]);\n        }\n        return true;\n    }\n\n    function fetchMyNFTs(address account)\n        public\n        view\n        returns (StakeItem[] memory)\n    {\n        uint256 totalItemCount = _itemIds.current();\n        uint256 itemCount = 0;\n        uint256 currentIndex = 0;\n\n        for (uint256 i = 0; i < totalItemCount; i++) {\n            if (idToStakeItem[i + 1].owner == account) {\n                itemCount += 1;\n            }\n        }\n\n        StakeItem[] memory items = new StakeItem[](itemCount);\n        for (uint256 i = 0; i < totalItemCount; i++) {\n            if (idToStakeItem[i + 1].owner == account) {\n                uint256 currentId = i + 1;\n                StakeItem storage currentItem = idToStakeItem[currentId];\n                items[currentIndex] = currentItem;\n                currentIndex += 1;\n            }\n        }\n        return items;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/IERC721Custom.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IERC721Custom is IERC165 {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    function revealTokenURI(uint256 id) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}