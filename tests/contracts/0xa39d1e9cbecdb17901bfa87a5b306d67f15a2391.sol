{"ACOAssetHelper.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nlibrary ACOAssetHelper {\r\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @dev Internal function to get if the address is for Ethereum (0x0).\r\n     * @param _address Address to be checked.\r\n     * @return Whether the address is for Ethereum.\r\n     */ \r\n    function _isEther(address _address) internal pure returns(bool) {\r\n        return _address == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to approve ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param spender Authorized address.\r\n     * @param amount Amount to authorize.\r\n     */\r\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\r\n        require(success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \"approve\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to transfer ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\r\n        require(success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \"transfer\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to call transferFrom on ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param sender Address of the sender.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\r\n        require(success \u0026\u0026 (returndata.length == 0 || abi.decode(returndata, (bool))), \"transferFrom\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset symbol.\r\n     * @param asset Address of the asset.\r\n     * @return The asset symbol.\r\n     */\r\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"ETH\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\r\n            require(success, \"symbol\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset decimals.\r\n     * @param asset Address of the asset.\r\n     * @return The asset decimals.\r\n     */\r\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\r\n        if (_isEther(asset)) {\r\n            return uint8(18);\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\r\n            require(success, \"decimals\");\r\n            return abi.decode(returndata, (uint8));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to the asset name.\r\n     * @param asset Address of the asset.\r\n     * @return The asset name.\r\n     */\r\n    function _getAssetName(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"Ethereum\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\r\n            require(success, \"name\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset balance of an account.\r\n     * @param asset Address of the asset.\r\n     * @param account Address of the account.\r\n     * @return The account balance.\r\n     */\r\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return account.balance;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\r\n            require(success, \"balanceOf\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset allowance between two addresses.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @return The owner allowance for the spender.\r\n     */\r\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return 0;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\r\n            require(success, \"allowance\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer an asset. \r\n     * @param asset Address of the asset to be transferred.\r\n     * @param to Address of the destination.\r\n     * @param amount The amount to be transferred.\r\n     */\r\n    function _transferAsset(address asset, address to, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            (bool success,) = to.call{value:amount}(new bytes(0));\r\n            require(success, \"send\");\r\n        } else {\r\n            _callTransferERC20(asset, to, amount);\r\n        }\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to receive an asset. \r\n     * @param asset Address of the asset to be received.\r\n     * @param amount The amount to be received.\r\n     */\r\n    function _receiveAsset(address asset, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            require(msg.value == amount, \"Invalid ETH amount\");\r\n        } else {\r\n            require(msg.value == 0, \"No payable\");\r\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @param amount Amount to check allowance.\r\n     */\r\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\r\n        if (_getAssetAllowance(asset, owner, spender) \u003c amount) {\r\n            _callApproveERC20(asset, spender, MAX_UINT);\r\n        }\r\n    }\r\n}"},"ACODistributor.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nimport \u0027./Ownable.sol\u0027;\r\nimport \u0027./ACOAssetHelper.sol\u0027;\r\n\r\ncontract ACODistributor is Ownable {\r\n\r\n    event Claim(bytes32 indexed id, address indexed account, address indexed aco, uint256 amount);\r\n    event WithdrawToken(address indexed token, uint256 amount, address destination);\r\n    event Halt(bool previousHalted, bool newHalted);\r\n\t\r\n    address immutable public signer;\r\n    \r\n    address[] public acos;\r\n    mapping(address =\u003e uint256) public acosAmount;\r\n    \r\n    bool public halted;\r\n    \r\n    mapping(bytes32 =\u003e bool) public claimed;\r\n    \r\n    modifier isValidMessage(bytes32 id, address account, uint256 amount, uint8 v, bytes32 r, bytes32 s) {\r\n\t\trequire(signer == ecrecover(\r\n\t\t    keccak256(abi.encodePacked(\r\n\t            \"\\x19Ethereum Signed Message:\\n32\", \r\n\t            keccak256(abi.encodePacked(address(this), id, account, amount))\r\n            )), v, r, s), \"Invalid arguments\");\r\n\t\t_;\r\n\t}\r\n    \r\n    constructor (address _signer, address[] memory _acos) public {\r\n        super.init();\r\n        \r\n        signer = _signer;\r\n        halted = false;\r\n        \r\n        for (uint256 i = 0; i \u003c _acos.length; ++i) {\r\n            acos.push(_acos[i]);\r\n        }\r\n    }\r\n    \r\n    function withdrawToken(address token, uint256 amount, address destination) onlyOwner external {\r\n        uint256 _balance = ACOAssetHelper._getAssetBalanceOf(token, address(this));\r\n        if (_balance \u003c amount) {\r\n            amount = _balance;\r\n        }\r\n        if (acosAmount[token] \u003e 0) {\r\n            acosAmount[token] = _balance - amount;    \r\n        }\r\n        ACOAssetHelper._transferAsset(token, destination, amount);\r\n        emit WithdrawToken(token, amount, destination);\r\n    }\r\n\r\n    function setAcoBalances() onlyOwner external {\r\n        for (uint256 i = 0; i \u003c acos.length; ++i) {\r\n            acosAmount[acos[i]] = ACOAssetHelper._getAssetBalanceOf(acos[i], address(this));\r\n        }\r\n    }\r\n\r\n    function setHalt(bool _halted) onlyOwner external {\r\n        emit Halt(halted, _halted);\r\n        halted = _halted;\r\n    }\r\n    \r\n    function acosLength() view external returns(uint256) {\r\n        return acos.length;\r\n    }\r\n    \r\n    function getClaimableAcos(uint256 amount) view external returns(address[] memory _acos, uint256[] memory _amounts) {\r\n        uint256 qty = 0;\r\n        uint256 remaining = amount;\r\n        for (uint256 i = 0; i \u003c acos.length; ++i) {\r\n            address _aco = acos[i];\r\n            uint256 available = acosAmount[_aco];\r\n            if (available \u003e 0) {\r\n                ++qty;\r\n                if (available \u003e= remaining) {\r\n                    break;\r\n                } else {\r\n                    remaining = remaining - available;\r\n                }\r\n            }\r\n        }\r\n\r\n        _acos = new address[](qty);\r\n        _amounts = new uint256[](qty);\r\n        \r\n        if (qty \u003e 0) {\r\n            uint256 index = 0;\r\n            remaining = amount;\r\n            for (uint256 i = 0; i \u003c acos.length; ++i) {\r\n                address _aco = acos[i];\r\n                uint256 available = acosAmount[_aco];\r\n                if (available \u003e 0) {\r\n                    _acos[index] = _aco;\r\n                    if (available \u003e= remaining) {\r\n                        _amounts[index] = remaining;\r\n                        break;\r\n                    } else {\r\n                        remaining = remaining - available;\r\n                        _amounts[index] = available;\r\n                    }\r\n                    ++index;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function claim(\r\n        bytes32 id, \r\n        address account, \r\n        uint256 amount, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) isValidMessage(id, account, amount, v, r, s) external {\r\n        require(!halted, \"Halted\");\r\n        require(!claimed[id], \"Claimed\");\r\n        \r\n        claimed[id] = true;\r\n        _claim(id, account, amount);\r\n    }\r\n    \r\n    function _claim(bytes32 id, address account, uint256 amount) internal {\r\n        for (uint256 i = 0; i \u003c acos.length; ++i) {\r\n            address _aco = acos[i];\r\n            uint256 available = acosAmount[_aco];\r\n            if (available \u003e 0) {\r\n                if (available \u003e= amount) {\r\n                    acosAmount[_aco] = available - amount;\r\n                    ACOAssetHelper._callTransferERC20(_aco, account, amount);\r\n\t\t            emit Claim(id, account, _aco, amount);\r\n                    break;\r\n                } else {\r\n                    amount = amount - available;\r\n                    acosAmount[_aco] = 0;\r\n                    ACOAssetHelper._callTransferERC20(_aco, account, available);\r\n\t\t            emit Claim(id, account, _aco, available);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Adapted from OpenZeppelin\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function init() internal {\r\n        require(_owner == address(0), \"Ownable: Contract initialized\");\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"}}