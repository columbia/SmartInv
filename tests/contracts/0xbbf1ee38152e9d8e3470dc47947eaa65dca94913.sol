{{
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@maverick/contracts/contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/IPosition.sol\";\n\ninterface IFactory {\n    event PoolCreated(\n        address poolAddress,\n        uint256 fee,\n        uint256 tickSpacing,\n        int32 activeTick,\n        int256 lookback,\n        uint64 protocolFeeRatio,\n        IERC20 tokenA,\n        IERC20 tokenB\n    );\n    event SetFactoryProtocolFeeRatio(uint64 protocolFeeRatio);\n    event SetFactoryOwner(address owner);\n\n    /// @notice creates new pool\n    /// @param _fee is a rate in prbmath 60x18 decimal format\n    /// @param _tickSpacing  1.0001^tickSpacing is the bin width\n    /// @param _activeTick initial activeTick of the pool\n    /// @param _lookback TWAP lookback in whole seconds\n    /// @param _tokenA ERC20 token\n    /// @param _tokenB ERC20 token\n    function create(\n        uint256 _fee,\n        uint256 _tickSpacing,\n        int256 _lookback,\n        int32 _activeTick,\n        IERC20 _tokenA,\n        IERC20 _tokenB\n    ) external returns (IPool);\n\n    function lookup(\n        uint256 fee,\n        uint256 tickSpacing,\n        int256 lookback,\n        IERC20 tokenA,\n        IERC20 tokenB\n    ) external view returns (IPool);\n\n    function owner() external view returns (address);\n\n    function position() external view returns (IPosition);\n\n    /// @notice protocolFeeRatio ratio of the swap fee that is kept for the\n    //protocol\n    function protocolFeeRatio() external view returns (uint64);\n\n    /// @notice lookup table for whether a pool is owned by the factory\n    function isFactoryPool(IPool pool) external view returns (bool);\n}\n",
      "keccak256": "0x1de0c0b1e87069b5ad385bdaa8203b17a19f59d9a7d20aa9a21f739de63305c1"
    },
    "@maverick/contracts/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IFactory.sol\";\n\ninterface IPool {\n    event Swap(\n        address sender,\n        address recipient,\n        bool tokenAIn,\n        bool exactOutput,\n        uint256 amountIn,\n        uint256 amountOut,\n        int32 activeTick\n    );\n\n    event AddLiquidity(address indexed sender, uint256 indexed tokenId, BinDelta[] binDeltas);\n\n    event MigrateBinsUpStack(address indexed sender, uint128 binId, uint32 maxRecursion);\n\n    event TransferLiquidity(uint256 fromTokenId, uint256 toTokenId, RemoveLiquidityParams[] params);\n\n    event RemoveLiquidity(\n        address indexed sender,\n        address indexed recipient,\n        uint256 indexed tokenId,\n        BinDelta[] binDeltas\n    );\n\n    event BinMerged(uint128 indexed binId, uint128 reserveA, uint128 reserveB, uint128 mergeId);\n\n    event BinMoved(uint128 indexed binId, int128 previousTick, int128 newTick);\n\n    event ProtocolFeeCollected(uint256 protocolFee, bool isTokenA);\n\n    event SetProtocolFeeRatio(uint256 protocolFee);\n\n    /// @notice return parameters for Add/Remove liquidity\n    /// @param binId of the bin that changed\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\n    /// @param isActive bool to indicate whether the bin is still active\n    /// @param lowerTick is the lower price tick of the bin in its current state\n    /// @param deltaA amount of A token that has been added or removed\n    /// @param deltaB amount of B token that has been added or removed\n    /// @param deltaLpToken amount of LP balance that has increase (add) or decreased (remove)\n    struct BinDelta {\n        uint128 deltaA;\n        uint128 deltaB;\n        uint256 deltaLpBalance;\n        uint128 binId;\n        uint8 kind;\n        int32 lowerTick;\n        bool isActive;\n    }\n\n    /// @notice time weighted average state\n    /// @param twa the twa at the last update instant\n    /// @param value the new value that was passed in at the last update\n    /// @param lastTimestamp timestamp of the last update in seconds\n    /// @param lookback time in seconds\n    struct TwaState {\n        int96 twa;\n        int96 value;\n        uint64 lastTimestamp;\n    }\n\n    /// @notice bin state parameters\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\n    /// @param lowerTick is the lower price tick of the bin in its current state\n    /// @param mergeId binId of the bin that this bin has merged in to\n    /// @param reserveA amount of A token in bin\n    /// @param reserveB amount of B token in bin\n    /// @param totalSupply total amount of LP tokens in this bin\n    /// @param mergeBinBalance LP token balance that this bin posseses of the merge bin\n    struct BinState {\n        uint128 reserveA;\n        uint128 reserveB;\n        uint128 mergeBinBalance;\n        uint128 mergeId;\n        uint128 totalSupply;\n        uint8 kind;\n        int32 lowerTick;\n    }\n\n    /// @notice Parameters for each bin that will get new liquidity\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\n    /// @param pos bin position\n    /// @param isDelta bool that indicates whether the bin position is relative\n    //to the current bin or an absolute position\n    /// @param deltaA amount of A token to add\n    /// @param deltaB amount of B token to add\n    struct AddLiquidityParams {\n        uint8 kind;\n        int32 pos;\n        bool isDelta;\n        uint128 deltaA;\n        uint128 deltaB;\n    }\n\n    /// @notice Parameters for each bin that will have liquidity removed\n    /// @param binId index of the bin losing liquidity\n    /// @param amount LP balance amount to remove\n    struct RemoveLiquidityParams {\n        uint128 binId;\n        uint128 amount;\n    }\n\n    /// @notice State of the pool\n    /// @param activeTick  current bin position that contains the active bins\n    /// @param status pool status.  e.g. locked or unlocked; status values\n    //defined in Pool.sol\n    /// @param binCounter index of the last bin created\n    /// @param protocolFeeRatio ratio of the swap fee that is kept for the\n    //protocol\n    struct State {\n        int32 activeTick;\n        uint8 status;\n        uint128 binCounter;\n        uint64 protocolFeeRatio;\n    }\n\n    /// @notice fee for pool in 18 decimal format\n    function fee() external view returns (uint256);\n\n    /// @notice tickSpacing of pool where 1.0001^tickSpacing is the bin width\n    function tickSpacing() external view returns (uint256);\n\n    /// @notice address of token A\n    function tokenA() external view returns (IERC20);\n\n    /// @notice address of token B\n    function tokenB() external view returns (IERC20);\n\n    /// @notice address of Factory\n    function factory() external view returns (IFactory);\n\n    /// @notice bitmap of active bins\n    function binMap(int32 tick) external view returns (uint256);\n\n    /// @notice mapping of tick/kind to binId\n    function binPositions(int32 tick, uint256 kind) external view returns (uint128);\n\n    /// @notice internal accounting of the sum tokenA balance across bins\n    function binBalanceA() external view returns (uint128);\n\n    /// @notice internal accounting of the sum tokenB balance across bins\n    function binBalanceB() external view returns (uint128);\n\n    /// @notice log_binWidth of the time weighted average price\n    function getTwa() external view returns (TwaState memory);\n\n    /// @notice pool state\n    function getState() external view returns (State memory);\n\n    /// @notice Add liquidity to a pool.\n    /// @param tokenId NFT token ID that will hold the position\n    /// @param params array of AddLiquidityParams that specify the mode and\n    //position of the liquidity\n    /// @param data callback function that addLiquidity will call so that the\n    //caller can transfer tokens\n    function addLiquidity(\n        uint256 tokenId,\n        AddLiquidityParams[] calldata params,\n        bytes calldata data\n    )\n        external\n        returns (\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            BinDelta[] memory binDeltas\n        );\n\n    /// @notice Transfer liquidity in an array of bins from one nft tokenId\n    //to another\n    /// @param fromTokenId NFT token ID that holds the position being transferred\n    /// @param toTokenId NFT token ID that is receiving liquidity\n    /// @param params array of binIds and amounts to transfer\n    function transferLiquidity(\n        uint256 fromTokenId,\n        uint256 toTokenId,\n        RemoveLiquidityParams[] calldata params\n    ) external;\n\n    /// @notice Remove liquidity from a pool.\n    /// @param recipient address that will receive the removed tokens\n    /// @param tokenId NFT token ID that holds the position being removed\n    /// @param params array of RemoveLiquidityParams that specify the bins,\n    //and amounts\n    function removeLiquidity(\n        address recipient,\n        uint256 tokenId,\n        RemoveLiquidityParams[] calldata params\n    )\n        external\n        returns (\n            uint256 tokenAOut,\n            uint256 tokenBOut,\n            BinDelta[] memory binDeltas\n        );\n\n    /// @notice Migrate bins up the linked list of merged bins so that its\n    //mergeId is the currrent active bin.\n    /// @param binId is an array of the binIds to be migrated\n    /// @param maxRecursion is the maximum recursion depth of the migration. set to\n    //zero to recurse until the active bin is found.\n    function migrateBinUpStack(uint128 binId, uint32 maxRecursion) external;\n\n    /// @notice swap tokens\n    /// @param recipient address that will receive the output tokens\n    /// @param amount amount of token that is either the input if exactOutput\n    //is false or the output if exactOutput is true\n    /// @param tokenAIn bool indicating whether tokenA is the input\n    /// @param exactOutput bool indicating whether the amount specified is the\n    //exact output amount (true)\n    /// @param sqrtPriceLimit limiting sqrt price of the swap.  A value of 0\n    //indicates no limit.  Limit is only engaged for exactOutput=false.  If the\n    //limit is reached only part of the input amount will be swapped and the\n    //callback will only require that amount of the swap to be paid.\n    /// @param data callback function that swap will call so that the\n    //caller can transfer tokens\n    function swap(\n        address recipient,\n        uint256 amount,\n        bool tokenAIn,\n        bool exactOutput,\n        uint256 sqrtPriceLimit,\n        bytes calldata data\n    ) external returns (uint256 amountIn, uint256 amountOut);\n\n    /// @notice bin information for a given binId\n    function getBin(uint128 binId) external view returns (BinState memory bin);\n\n    /// @notice LP token balance for a given tokenId at a given binId\n    function balanceOf(uint256 tokenId, uint128 binId) external view returns (uint256 lpToken);\n\n    /// @notice tokenA scale value\n    /// @dev msb is a flag to indicate whether tokenA has more or less than 18\n    //decimals.  Scale is used in conjuction with Math.toScale/Math.fromScale\n    //functions to convert from token amounts to D18 scale internal pool\n    //accounting.\n    function tokenAScale() external view returns (uint256);\n\n    /// @notice tokenB scale value\n    /// @dev msb is a flag to indicate whether tokenA has more or less than 18\n    //decimals.  Scale is used in conjuction with Math.toScale/Math.fromScale\n    //functions to convert from token amounts to D18 scale internal pool\n    //accounting.\n    function tokenBScale() external view returns (uint256);\n}\n",
      "keccak256": "0xac88f7c32581b772dcb06b379416584d0447e12e0e7ea16aea468706ee8aa9bd"
    },
    "@maverick/contracts/contracts/interfaces/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport \"../interfaces/IPositionMetadata.sol\";\n\ninterface IPosition is IERC721Enumerable {\n    event SetMetadata(IPositionMetadata metadata);\n\n    /// @notice mint new position NFT\n    function mint(address to) external returns (uint256 tokenId);\n\n    /// @notice mint new position NFT\n    function tokenOfOwnerByIndexExists(address owner, uint256 index) external view returns (bool);\n}\n",
      "keccak256": "0x1eec809637e2f4d7f9a771776123936c5f33e74e475902ea03f4dfd13f4bc3a1"
    },
    "@maverick/contracts/contracts/interfaces/IPositionMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPositionMetadata {\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n",
      "keccak256": "0x1a485e349bcc8e9760dd96b0cf1ba947cf3a2055a9fce673552b919cf855055e"
    },
    "@maverick/contracts/contracts/interfaces/ISwapCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISwapCallback {\n    function swapCallback(\n        uint256 amountIn,\n        uint256 amountOut,\n        bytes calldata data\n    ) external;\n}\n",
      "keccak256": "0xe866e81f6d83b4a5f06db41f6f81af60be8040cb8120fc53b05035f1dbd419b2"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n",
      "keccak256": "0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n",
      "keccak256": "0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n",
      "keccak256": "0xed6a749c5373af398105ce6ee3ac4763aa450ea7285d268c85d9eeca809cdb1f"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n",
      "keccak256": "0xd1556954440b31c97a142c6ba07d5cade45f96fafd52091d33a14ebe365aecbf"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n",
      "keccak256": "0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1"
    },
    "contracts/Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@maverick/contracts/contracts/interfaces/IPool.sol\";\nimport \"@maverick/contracts/contracts/interfaces/IFactory.sol\";\nimport \"@maverick/contracts/contracts/interfaces/IPosition.sol\";\n\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/external/IWETH9.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./libraries/Path.sol\";\nimport \"./libraries/Deadline.sol\";\nimport \"./libraries/Multicall.sol\";\nimport \"./libraries/SelfPermit.sol\";\n\ncontract Router is IRouter, Multicall, SelfPermit, Deadline {\n    using Path for bytes;\n    /// @dev Used as the placeholder value for amountInCached, because the\n    //computed amount in for an exact output swap / can never actually be this\n    //value\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\n\n    /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.\n    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\n\n    struct AddLiquidityCallbackData {\n        IERC20 tokenA;\n        IERC20 tokenB;\n        IPool pool;\n        address payer;\n    }\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n        bool exactOutput;\n    }\n\n    /// @inheritdoc IRouter\n    IFactory public immutable factory;\n    /// @inheritdoc IRouter\n    IPosition public immutable position;\n    /// @inheritdoc ISlimRouter\n    IWETH9 public immutable WETH9;\n\n    constructor(IFactory _factory, IWETH9 _WETH9) {\n        factory = _factory;\n        position = _factory.position();\n        WETH9 = _WETH9;\n    }\n\n    receive() external payable {\n        require(IWETH9(msg.sender) == WETH9, \"Not WETH9\");\n    }\n\n    /// @inheritdoc ISlimRouter\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable override {\n        uint256 balanceWETH9 = WETH9.balanceOf(address(this));\n        require(balanceWETH9 >= amountMinimum, \"Insufficient WETH9\");\n\n        if (balanceWETH9 > 0) {\n            WETH9.withdraw(balanceWETH9);\n            TransferHelper.safeTransferETH(recipient, balanceWETH9);\n        }\n    }\n\n    /// @inheritdoc ISlimRouter\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) public payable {\n        uint256 balanceToken = token.balanceOf(address(this));\n        require(balanceToken >= amountMinimum, \"Insufficient token\");\n\n        if (balanceToken > 0) {\n            TransferHelper.safeTransfer(address(token), recipient, balanceToken);\n        }\n    }\n\n    /// @inheritdoc ISlimRouter\n    function refundETH() external payable override {\n        if (address(this).balance > 0)\n            TransferHelper.safeTransferETH(msg.sender, address(this).balance);\n    }\n\n    /// @param token The token to pay\n    /// @param payer The entity that must pay\n    /// @param recipient The entity that will receive payment\n    /// @param value The amount to pay\n    function pay(IERC20 token, address payer, address recipient, uint256 value) internal {\n        if (IWETH9(address(token)) == WETH9 && address(this).balance >= value) {\n            WETH9.deposit{value: value}();\n            WETH9.transfer(recipient, value);\n        } else if (payer == address(this)) {\n            TransferHelper.safeTransfer(address(token), recipient, value);\n        } else {\n            TransferHelper.safeTransferFrom(address(token), payer, recipient, value);\n        }\n    }\n\n    function swapCallback(uint256 amountToPay, uint256 amountOut, bytes calldata _data) external {\n        require(amountToPay > 0 && amountOut > 0, \"In or Out Amount is Zero\");\n        require(factory.isFactoryPool(IPool(msg.sender)), \"Must call from a Factory Pool\");\n\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (IERC20 tokenIn, IERC20 tokenOut, IPool pool) = data.path.decodeFirstPool();\n\n        require(msg.sender == address(pool));\n\n        if (data.exactOutput) {\n            if (data.path.hasMultiplePools()) {\n                data.path = data.path.skipToken();\n                exactOutputInternal(amountToPay, msg.sender, data);\n            } else {\n                amountInCached = amountToPay;\n                pay(tokenOut, data.payer, msg.sender, amountToPay);\n            }\n        } else {\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\n        }\n    }\n\n    function exactInputInternal(\n        uint256 amountIn,\n        address recipient,\n        uint256 sqrtPriceLimitD18,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountOut) {\n        if (recipient == address(0)) recipient = address(this);\n\n        (IERC20 tokenIn, IERC20 tokenOut, IPool pool) = data.path.decodeFirstPool();\n\n        bool tokenAIn = tokenIn < tokenOut;\n\n        (, amountOut) = pool.swap(\n            recipient,\n            amountIn,\n            tokenAIn,\n            false,\n            sqrtPriceLimitD18,\n            abi.encode(data)\n        );\n    }\n\n    /// @inheritdoc ISlimRouter\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\n        bool tokenAIn = params.tokenIn < params.tokenOut;\n\n        (, amountOut) = params.pool.swap(\n            (params.recipient == address(0)) ? address(this) : params.recipient,\n            params.amountIn,\n            tokenAIn,\n            false,\n            params.sqrtPriceLimitD18,\n            abi.encode(\n                SwapCallbackData({\n                    path: abi.encodePacked(params.tokenIn, params.pool, params.tokenOut),\n                    payer: msg.sender,\n                    exactOutput: false\n                })\n            )\n        );\n        require(amountOut >= params.amountOutMinimum, \"Too little received\");\n    }\n\n    /// @inheritdoc IRouter\n    function exactInput(\n        ExactInputParams memory params\n    ) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\n        address payer = msg.sender;\n\n        while (true) {\n            bool stillMultiPoolSwap = params.path.hasMultiplePools();\n\n            params.amountIn = exactInputInternal(\n                params.amountIn,\n                stillMultiPoolSwap ? address(this) : params.recipient,\n                0,\n                SwapCallbackData({\n                    path: params.path.getFirstPool(),\n                    payer: payer,\n                    exactOutput: false\n                })\n            );\n\n            if (stillMultiPoolSwap) {\n                payer = address(this);\n                params.path = params.path.skipToken();\n            } else {\n                amountOut = params.amountIn;\n                break;\n            }\n        }\n\n        require(amountOut >= params.amountOutMinimum, \"Too little received\");\n    }\n\n    /// @dev Performs a single exact output swap\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        SwapCallbackData memory data\n    ) private returns (uint256 amountIn) {\n        if (recipient == address(0)) recipient = address(this);\n\n        (IERC20 tokenOut, IERC20 tokenIn, IPool pool) = data.path.decodeFirstPool();\n\n        bool tokenAIn = tokenIn < tokenOut;\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = pool.swap(\n            recipient,\n            amountOut,\n            tokenAIn,\n            true,\n            0,\n            abi.encode(data)\n        );\n        require(amountOutReceived == amountOut, \"Requested amount not available\");\n    }\n\n    /// @inheritdoc ISlimRouter\n    function exactOutputSingle(\n        ExactOutputSingleParams calldata params\n    ) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\n        bool tokenAIn = params.tokenIn < params.tokenOut;\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = params.pool.swap(\n            (params.recipient == address(0)) ? address(this) : params.recipient,\n            params.amountOut,\n            tokenAIn,\n            true,\n            0,\n            abi.encode(\n                SwapCallbackData({\n                    path: abi.encodePacked(params.tokenOut, params.pool, params.tokenIn),\n                    payer: msg.sender,\n                    exactOutput: true\n                })\n            )\n        );\n        require(amountOutReceived == params.amountOut, \"Requested amount not available\");\n        require(amountIn <= params.amountInMaximum, \"Too much requested\");\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\n    }\n\n    /// @inheritdoc IRouter\n    function exactOutput(\n        ExactOutputParams calldata params\n    ) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\n        exactOutputInternal(\n            params.amountOut,\n            params.recipient,\n            SwapCallbackData({path: params.path, payer: msg.sender, exactOutput: true})\n        );\n\n        amountIn = amountInCached;\n        require(amountIn <= params.amountInMaximum, \"Too much requested\");\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\n    }\n\n    // Liqudity\n\n    function addLiquidityCallback(uint256 amountA, uint256 amountB, bytes calldata _data) external {\n        AddLiquidityCallbackData memory data = abi.decode(_data, (AddLiquidityCallbackData));\n        require(factory.isFactoryPool(IPool(msg.sender)));\n        require(msg.sender == address(data.pool));\n        if (amountA != 0) {\n            pay(data.tokenA, data.payer, msg.sender, amountA);\n        }\n        if (amountB != 0) {\n            pay(data.tokenB, data.payer, msg.sender, amountB);\n        }\n    }\n\n    function addLiquidity(\n        IPool pool,\n        uint256 tokenId,\n        IPool.AddLiquidityParams[] calldata params,\n        uint256 minTokenAAmount,\n        uint256 minTokenBAmount\n    )\n        private\n        returns (\n            uint256 receivingTokenId,\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            IPool.BinDelta[] memory binDeltas\n        )\n    {\n        if (tokenId == 0) {\n            if (IPosition(position).tokenOfOwnerByIndexExists(msg.sender, 0)) {\n                tokenId = IPosition(position).tokenOfOwnerByIndex(msg.sender, 0);\n            } else {\n                tokenId = IPosition(position).mint(msg.sender);\n            }\n        }\n        receivingTokenId = tokenId;\n\n        AddLiquidityCallbackData memory data = AddLiquidityCallbackData({\n            tokenA: pool.tokenA(),\n            tokenB: pool.tokenB(),\n            pool: pool,\n            payer: msg.sender\n        });\n        (tokenAAmount, tokenBAmount, binDeltas) = pool.addLiquidity(\n            tokenId,\n            params,\n            abi.encode(data)\n        );\n\n        require(\n            tokenAAmount >= minTokenAAmount && tokenBAmount >= minTokenBAmount,\n            \"Too little added\"\n        );\n    }\n\n    /// @inheritdoc IRouter\n    function addLiquidityToPool(\n        IPool pool,\n        uint256 tokenId,\n        IPool.AddLiquidityParams[] calldata params,\n        uint256 minTokenAAmount,\n        uint256 minTokenBAmount,\n        uint256 deadline\n    )\n        external\n        payable\n        checkDeadline(deadline)\n        returns (\n            uint256 receivingTokenId,\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            IPool.BinDelta[] memory binDeltas\n        )\n    {\n        return addLiquidity(pool, tokenId, params, minTokenAAmount, minTokenBAmount);\n    }\n\n    /// @inheritdoc IRouter\n    function addLiquidityWTickLimits(\n        IPool pool,\n        uint256 tokenId,\n        IPool.AddLiquidityParams[] calldata params,\n        uint256 minTokenAAmount,\n        uint256 minTokenBAmount,\n        int32 minActiveTick,\n        int32 maxActiveTick,\n        uint256 deadline\n    )\n        external\n        payable\n        checkDeadline(deadline)\n        returns (\n            uint256 receivingTokenId,\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            IPool.BinDelta[] memory binDeltas\n        )\n    {\n        int32 activeTick = pool.getState().activeTick;\n\n        require(\n            activeTick >= minActiveTick && activeTick <= maxActiveTick,\n            \"activeTick not in range\"\n        );\n\n        return addLiquidity(pool, tokenId, params, minTokenAAmount, minTokenBAmount);\n    }\n\n    function getOrCreatePool(PoolParams calldata poolParams) private returns (IPool pool) {\n        {\n            pool = IFactory(factory).lookup(\n                poolParams.fee,\n                poolParams.tickSpacing,\n                poolParams.lookback,\n                poolParams.tokenA,\n                poolParams.tokenB\n            );\n        }\n        if (address(pool) == address(0)) {\n            pool = IFactory(factory).create(\n                poolParams.fee,\n                poolParams.tickSpacing,\n                poolParams.lookback,\n                poolParams.activeTick,\n                poolParams.tokenA,\n                poolParams.tokenB\n            );\n        }\n    }\n\n    /// @inheritdoc IRouter\n    function getOrCreatePoolAndAddLiquidity(\n        PoolParams calldata poolParams,\n        uint256 tokenId,\n        IPool.AddLiquidityParams[] calldata addParams,\n        uint256 minTokenAAmount,\n        uint256 minTokenBAmount,\n        uint256 deadline\n    )\n        external\n        payable\n        checkDeadline(deadline)\n        returns (\n            uint256 receivingTokenId,\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            IPool.BinDelta[] memory binDeltas\n        )\n    {\n        IPool pool = getOrCreatePool(poolParams);\n        return addLiquidity(pool, tokenId, addParams, minTokenAAmount, minTokenBAmount);\n    }\n\n    /// @inheritdoc IRouter\n    function migrateBinsUpStack(\n        IPool pool,\n        uint128[] calldata binIds,\n        uint32 maxRecursion,\n        uint256 deadline\n    ) external checkDeadline(deadline) {\n        for (uint256 i = 0; i < binIds.length; i++) {\n            pool.migrateBinUpStack(binIds[i], maxRecursion);\n        }\n    }\n\n    /// @inheritdoc IRouter\n    function removeLiquidity(\n        IPool pool,\n        address recipient,\n        uint256 tokenId,\n        IPool.RemoveLiquidityParams[] calldata params,\n        uint256 minTokenAAmount,\n        uint256 minTokenBAmount,\n        uint256 deadline\n    )\n        external\n        checkDeadline(deadline)\n        returns (uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas)\n    {\n        require(msg.sender == position.ownerOf(tokenId), \"P\");\n\n        if (recipient == address(0)) recipient = address(this);\n        (tokenAAmount, tokenBAmount, binDeltas) = pool.removeLiquidity(recipient, tokenId, params);\n\n        require(\n            tokenAAmount >= minTokenAAmount && tokenBAmount >= minTokenBAmount,\n            \"Too little removed\"\n        );\n    }\n}\n",
      "keccak256": "0xebbf00d0bee84148b6867e625251c1573050742b7da9c9331248309229eec90c"
    },
    "contracts/interfaces/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n",
      "keccak256": "0xa8f9d0061ee730a522dc4bae6bd5cabb3e997e2c5983da183e912bdca93dfa7b"
    },
    "contracts/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@maverick/contracts/contracts/interfaces/IFactory.sol\";\nimport \"@maverick/contracts/contracts/interfaces/IPool.sol\";\nimport \"@maverick/contracts/contracts/interfaces/IPosition.sol\";\nimport \"@maverick/contracts/contracts/interfaces/ISwapCallback.sol\";\nimport \"./external/IWETH9.sol\";\nimport \"./ISlimRouter.sol\";\n\ninterface IRouter is ISlimRouter {\n    /// @return Returns the address of the factory\n    function factory() external view returns (IFactory);\n\n    /// @return Returns the address of the Position NFT\n    function position() external view returns (IPosition);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of\n    //another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded\n    //as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(\n        ExactInputParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of\n    //another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded\n    //as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(\n        ExactOutputParams calldata params\n    ) external payable returns (uint256 amountIn);\n\n    struct PoolParams {\n        uint256 fee;\n        uint256 tickSpacing;\n        int256 lookback;\n        int32 activeTick;\n        IERC20 tokenA;\n        IERC20 tokenB;\n    }\n\n    /// @notice create a pool and add liquidity to it\n    /// @param poolParams paramters of a pool\n    /// @param tokenId nft id of token that will hold lp balance, use 0 to mint a new token\n    /// @param addParams paramters of liquidity addition\n    /// @param minTokenAAmount minimum amount of token A to add, revert if not met\n    /// @param minTokenBAmount minimum amount of token B to add, revert if not met\n    /// @param deadline epoch timestamp in seconds\n    function getOrCreatePoolAndAddLiquidity(\n        PoolParams calldata poolParams,\n        uint256 tokenId,\n        IPool.AddLiquidityParams[] calldata addParams,\n        uint256 minTokenAAmount,\n        uint256 minTokenBAmount,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 receivingTokenId,\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            IPool.BinDelta[] memory binDeltas\n        );\n\n    /// @notice add liquidity to a pool\n    /// @param pool pool to add liquidity to\n    /// @param tokenId nft id of token that will hold lp balance, use 0 to mint a new token\n    /// @param params paramters of liquidity addition\n    /// @param minTokenAAmount minimum amount of token A to add, revert if not met\n    /// @param minTokenBAmount minimum amount of token B to add, revert if not met\n    /// @param deadline epoch timestamp in seconds\n    function addLiquidityToPool(\n        IPool pool,\n        uint256 tokenId,\n        IPool.AddLiquidityParams[] calldata params,\n        uint256 minTokenAAmount,\n        uint256 minTokenBAmount,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 receivingTokenId,\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            IPool.BinDelta[] memory binDeltas\n        );\n\n    /// @notice add liquidity to a pool with active tick limits\n    /// @param pool pool to add liquidity to\n    /// @param tokenId nft id of token that will hold lp balance, use 0 to mint a new token\n    /// @param params paramters of liquidity addition\n    /// @param minTokenAAmount minimum amount of token A to add, revert if not met\n    /// @param minTokenBAmount minimum amount of token B to add, revert if not met\n    /// @param minActiveTick lowest activeTick (inclusive) of pool that will permit transaction to pass\n    /// @param maxActiveTick highest activeTick (inclusive) of pool that will permit transaction to pass\n    /// @param deadline epoch timestamp in seconds\n    function addLiquidityWTickLimits(\n        IPool pool,\n        uint256 tokenId,\n        IPool.AddLiquidityParams[] calldata params,\n        uint256 minTokenAAmount,\n        uint256 minTokenBAmount,\n        int32 minActiveTick,\n        int32 maxActiveTick,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 receivingTokenId,\n            uint256 tokenAAmount,\n            uint256 tokenBAmount,\n            IPool.BinDelta[] memory binDeltas\n        );\n\n    /// @notice moves the head of input merged bins to the active bin\n    /// @param pool to remove from\n    /// @param binIds array of bin Ids to migrate\n    /// @param maxRecursion maximum recursion depth before returning; 0=no max\n    /// @param deadline epoch timestamp in seconds\n    function migrateBinsUpStack(\n        IPool pool,\n        uint128[] calldata binIds,\n        uint32 maxRecursion,\n        uint256 deadline\n    ) external;\n\n    /// @notice remove liquidity from pool and receive WETH if one of the tokens is WETH\n    /// @dev router must be approved for the withdrawing tokenId: Position.approve(router, tokenId)\n    /// @param pool pool to remove from\n    /// @param recipient address where proceeds are sent; use zero or router address to leave tokens in router\n    /// @param tokenId ID of position NFT that holds liquidity\n    /// @param params paramters of liquidity removal\n    /// @param minTokenAAmount minimum amount of token A to receive, revert if not met\n    /// @param minTokenBAmount minimum amount of token B to receive, revert if not met\n    /// @param deadline epoch timestamp in seconds\n    function removeLiquidity(\n        IPool pool,\n        address recipient,\n        uint256 tokenId,\n        IPool.RemoveLiquidityParams[] calldata params,\n        uint256 minTokenAAmount,\n        uint256 minTokenBAmount,\n        uint256 deadline\n    )\n        external\n        returns (uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas);\n}\n",
      "keccak256": "0xf5de513b92193d2fc4f58cda11a145ae0f9f4b784877a4f8a80c727ed561114c"
    },
    "contracts/interfaces/ISelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Self Permit\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\ninterface ISelfPermit {\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n}\n",
      "keccak256": "0xe1a1c072855e687c90317c15b9b6ce81cc683723f73d70e47b40f2f9bad0c2be"
    },
    "contracts/interfaces/ISlimRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@maverick/contracts/contracts/interfaces/IFactory.sol\";\nimport \"@maverick/contracts/contracts/interfaces/IPool.sol\";\nimport \"@maverick/contracts/contracts/interfaces/IPosition.sol\";\nimport \"@maverick/contracts/contracts/interfaces/ISwapCallback.sol\";\nimport \"./external/IWETH9.sol\";\n\ninterface ISlimRouter is ISwapCallback {\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (IWETH9);\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        IPool pool;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint256 sqrtPriceLimitD18;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of\n    //another token\n    /// @param params The parameters necessary for the swap, encoded as\n    //`ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        IPool pool;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of\n    //another token\n    /// @param params The parameters necessary for the swap, encoded as\n    //`ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(\n        ExactOutputSingleParams calldata params\n    ) external payable returns (uint256 amountIn);\n\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) external payable;\n}\n",
      "keccak256": "0x861795502e06a618b156523df18ee57c2b71cbed5899df0eeaf048f03926431c"
    },
    "contracts/interfaces/external/IERC20PermitAllowed.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Interface for permit\n/// @notice Interface used by DAI/CHAI for permit\ninterface IERC20PermitAllowed {\n    /// @notice Approve the spender to spend some tokens via the holder signature\n    /// @dev This is the permit interface used by DAI and CHAI\n    /// @param holder The address of the token holder, the token owner\n    /// @param spender The address of the token spender\n    /// @param nonce The holder's nonce, increases at each call to permit\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n",
      "keccak256": "0x8c4c1b8e724e0a78cb691d703dd37cd91b8bd6600537fb227807a194025a792d"
    },
    "contracts/interfaces/external/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n",
      "keccak256": "0x50083bcaca6c1a8d12c79116fab4f6d8cd452a510cb3f00c4a8bc3a54678efb7"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity ^0.8.0;\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3, \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n",
      "keccak256": "0xfbd2da7da8a75012a19d7970a7a2f0427b6922c012390e4984842f99b31677b8"
    },
    "contracts/libraries/Deadline.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nabstract contract Deadline {\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \"Transaction too old\");\n        _;\n    }\n}\n",
      "keccak256": "0x9ae88c9d33494b5931bedbb909b390d21c0207e849929dc8ff6f2ea1625705a7"
    },
    "contracts/libraries/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../interfaces/IMulticall.sol\";\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall is IMulticall {\n    /// @inheritdoc IMulticall\n    function multicall(\n        bytes[] calldata data\n    ) public payable override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n",
      "keccak256": "0x12a584ce562da68d3f38bafd34411db3fd2e3a55107d1c746a1c9ce16afaee3a"
    },
    "contracts/libraries/Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@maverick/contracts/contracts/interfaces/IPool.sol\";\n\nimport \"./BytesLib.sol\";\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n\n    /// @dev The offset of a single token address and pool address\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + ADDR_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenIn The input in a path\n    /// @return tokenOut The output in a path\n    /// @return pool The pool\n    function decodeFirstPool(\n        bytes memory path\n    ) internal pure returns (IERC20 tokenIn, IERC20 tokenOut, IPool pool) {\n        tokenIn = IERC20(path.toAddress(0));\n        pool = IPool(path.toAddress(ADDR_SIZE));\n        tokenOut = IERC20(path.toAddress(NEXT_OFFSET));\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + pool element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + pool elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}\n",
      "keccak256": "0x39ba686097dcece00a1d9813cfee42f17cdbec3ddc002d79906ece77676d79aa"
    },
    "contracts/libraries/SelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\nimport \"../interfaces/ISelfPermit.sol\";\nimport \"../interfaces/external/IERC20PermitAllowed.sol\";\n\n/// @title Self Permit\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\n/// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function\n/// that requires an approval in a single transaction.\nabstract contract SelfPermit is ISelfPermit {\n    /// @inheritdoc ISelfPermit\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable override {\n        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\n    }\n\n    /// @inheritdoc ISelfPermit\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        if (IERC20(token).allowance(msg.sender, address(this)) < value)\n            selfPermit(token, value, deadline, v, r, s);\n    }\n\n    /// @inheritdoc ISelfPermit\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable override {\n        IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n    }\n\n    /// @inheritdoc ISelfPermit\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max)\n            selfPermitAllowed(token, nonce, expiry, v, r, s);\n    }\n}\n",
      "keccak256": "0x0bf534ff6e0d7796e0ce464901a439dfa46f402e055f1c2312aee37ed8275910"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"STF\");\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ST\");\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SA\");\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"STE\");\n    }\n}\n",
      "keccak256": "0xd591cf98031866a700e960d2c5f392ef1f8357c1643049c37ec71e5dc97801c5"
    }
  },
  "language": "Solidity"
}}