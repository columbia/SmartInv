{{
  "language": "Solidity",
  "sources": {
    "contracts/LemonApeStand.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\nimport \"./IPotion.sol\";\nimport \"./IUniswapV2Router.sol\";\nimport \"./IUniswapV2Factory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./SafeMath.sol\";\n\ncontract LemonApeStand is Ownable, IERC20 {\n    using SafeMath for uint256;\n    bool private _swapping;\n    uint256 public _launchedBlock;\n    uint256 public _launchedTime;\n    \n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply = 5000000 * 10**18;\n    uint256 private _txLimit = 50010 * 10**18;\n    string private _name = \"LemonApeStand\";\n    string private _symbol = \"LAS\";\n    uint8 private _decimals = 18;\n    uint8 private _buyTax = 5;\n    uint8 private _sellTax = 8;\n    uint8 private _liquidtyTax = 4;\n    uint256 private _degenOffsetBuyMultiplier = 200;\n    uint256 private _degenOffsetSellMultiplier = 100;\n    uint256 private _degenOffsetLeaderBuyMultiplier = 50;\n\n    mapping (address => bool) private _blacklist;\n    mapping (address => bool) private _excludedAddress;\n    mapping (address => uint) private _cooldown;\n    bool public _cooldownEnabled = false;\n\n    struct currentLeader {\n      address _address;\n      uint256 _currentTokenOffset;\n      uint256 _tokenBuys;\n      uint256 _ethMade;\n    }\n    currentLeader _currentLeader;\n    bool public _leaderGameOn;\n\n    address private _uniRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address private _uniRouterV3 = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address private _dead = 0x000000000000000000000000000000000000dEaD;\n    address public _uniswapV2Pair;\n    address private _dev;\n    IUniswapV2Router private _uniswapV2Router;\n    IPotion private _potionToken;\n    \n    event SwapAndLiquify(uint256 tokensIntoLiqudity);\n    event leaderAddedTokens(address leader, uint256 addedTokens, uint256 totalTokenBuys, uint256 tokenOffset, uint256 ethMade);\n    event leaderRemoved(address oldLeader, uint256 oldLeaderIncome, address newLeader, uint256 totalTokenBuys);\n    event leaderProfit(address leader, uint256 newProfit, uint256 totalProfit, uint256 tokenOffset, uint256 totalBuys);\n    event leaderSold(address oldLeader, uint256 oldLeaderIncome);\n    event launched();\n    \n    constructor(address[] memory dev,address potionTokenAddress) {\n        require(potionTokenAddress != address(0),\"Potion token address cannot be zero address\");\n        _dev = dev[2];\n        _balances[owner()] = _totalSupply;\n        _excludedAddress[owner()] = true;\n        _excludedAddress[_dev] = true;\n        _excludedAddress[address(this)] = true;\n        _uniswapV2Router = IUniswapV2Router(_uniRouter);\n        _currentLeader = currentLeader(_dev, 0, 0, 0);\n        _allowances[address(this)][_uniRouter] = type(uint256).max;\n        _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n        _potionToken = IPotion(potionTokenAddress);\n    }\n\n    modifier devOrOwner() {\n        require(owner() == _msgSender() || _dev == _msgSender(), \"Caller is not the owner or dev\");\n        _;\n    }\n\n    modifier lockSwap {\n        _swapping = true;\n        _;\n        _swapping = false;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function isBuy(address sender) private view returns (bool) {\n        return sender == _uniswapV2Pair;\n    }\n\n    function trader(address sender, address recipient) private view returns (bool) {\n        return !(_excludedAddress[sender] ||  _excludedAddress[recipient]);\n    }\n    \n    function txRestricted(address sender, address recipient) private view returns (bool) {\n        return sender == _uniswapV2Pair && recipient != address(_uniRouter) && recipient != address(_uniRouterV3) && !_excludedAddress[recipient];\n    }\n    \n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function getLeaderInfo() public view returns (address,uint256,uint256,uint256) {\n        return(\n            _currentLeader._address,\n            _currentLeader._tokenBuys,\n            _currentLeader._currentTokenOffset,\n            _currentLeader._ethMade\n        );\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        require (_allowances[sender][_msgSender()] >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_balances[sender] >= amount, \"ERC20: transfer exceeds balance\");\n        require(amount > 0, \"ERC20: cannot transfer zero\");\n        require(!_blacklist[sender] && !_blacklist[recipient] && !_blacklist[tx.origin]);\n\n        uint256 taxedAmount = amount;\n        uint256 tax = 0;\n\n        if (trader(sender, recipient)) {\n            require (_launchedBlock != 0, \"LAS: trading not enabled\");\n            if(txRestricted(sender, recipient)){\n                 if (block.number < _launchedBlock + 30)\n                    require(amount <= _txLimit, \"LAS: max tx buy limit\");\n                if (_cooldownEnabled) {\n                    require(_cooldown[recipient] < block.timestamp);\n                    _cooldown[recipient] = block.timestamp + 30 seconds;\n                }\n            }\n            if (isBuy(sender) && _leaderGameOn){\n                if( _currentLeader._address == recipient){\n                    _currentLeader._tokenBuys += amount;\n                    if (_currentLeader._currentTokenOffset > amount * _degenOffsetLeaderBuyMultiplier / 100){\n                        uint256 leaderOffsetBuy = amount * _degenOffsetLeaderBuyMultiplier / 100;\n                         _currentLeader._currentTokenOffset -= leaderOffsetBuy;\n                    } else {\n                        _currentLeader._currentTokenOffset = 0;\n                    }\n                    \n                    emit leaderAddedTokens(recipient, amount, _currentLeader._tokenBuys, _currentLeader._currentTokenOffset,  _currentLeader._ethMade);\n                } else {\n                    _currentLeader._currentTokenOffset += amount * _degenOffsetBuyMultiplier / 100;\n                }\n                if(_currentLeader._currentTokenOffset > _currentLeader._tokenBuys){\n                    emit leaderRemoved(_currentLeader._address, _currentLeader._ethMade, recipient, amount);\n                    _currentLeader = currentLeader(recipient, 0, amount, 0);\n                    mintPotion(recipient);\n                }\n            }\n            tax = amount * _buyTax / 100;\n            taxedAmount = amount - tax;\n            if (!isBuy(sender)){\n                    if( _currentLeader._address == sender && _leaderGameOn){\n                        emit leaderSold(_currentLeader._address, _currentLeader._ethMade);\n                        _currentLeader = currentLeader(_dev, 0, 0, 0);\n                        mintPotion(_dev);\n                    } else {\n                        uint256 normieOffsetSell = amount * _degenOffsetSellMultiplier / 100;\n                        _currentLeader._currentTokenOffset += normieOffsetSell;\n                        if(_currentLeader._currentTokenOffset > _currentLeader._tokenBuys){\n                            emit leaderRemoved(_currentLeader._address, _currentLeader._ethMade, _dev, amount);\n                            _currentLeader = currentLeader(_dev, 0, 0, 0);\n                            mintPotion(_dev);\n                        }\n                    }\n                    tax = amount * (_sellTax + _liquidtyTax) / 100;\n                    taxedAmount = amount - tax;\n                    if (_balances[address(this)] > 100 * 10**9 && !_swapping){\n                        uint256 _swapAmount = _balances[address(this)];\n                        if (_swapAmount > amount * 40 / 100) _swapAmount = amount * 40 / 100;\n                        swapAndLiquify(_swapAmount);\n                    }\n            }\n        }\n\n        _balances[address(this)] += tax;\n        _balances[recipient] += taxedAmount;\n        _balances[sender] -= amount;\n        \n        emit Transfer(sender, recipient, amount);\n    }\n\n    function launch() external onlyOwner {\n        require (_launchedBlock <= block.number, \"LAS: already launched...\");\n        _cooldownEnabled = true;\n        _launchedBlock = block.number;\n        _launchedTime = block.timestamp;\n        emit launched();\n    }\n\n    function changePotionToken(address _newPotion) external onlyOwner {\n        require(_newPotion != address(0),\"Potion token address cannot be zero address\");\n        _potionToken = IPotion(_newPotion);\n    }\n\n    function toggleLeaderGame(bool status) external onlyOwner {\n        _leaderGameOn = status;\n    }\n\n    function setBuyTax(uint8 newTax) external onlyOwner {\n        require (newTax <= 10, \"LAS: Cannot set more than 10% buy tax\");\n        _buyTax = newTax;\n    }\n\n    function setCooldownEnabled(bool cooldownEnabled) external onlyOwner {\n        _cooldownEnabled = cooldownEnabled;\n    }\n\n    function setSellTax(uint8 newTax) external onlyOwner {\n        require (newTax <= 10, \"LAS: Cannot set more than 15% sell tax\");\n        _sellTax = newTax;\n    }\n    \n    function setDegenOffset(uint256 buyOffset, uint256 sellOffset, uint256 leaderBuyOffset) external devOrOwner {\n        _degenOffsetBuyMultiplier = buyOffset;\n        _degenOffsetSellMultiplier = sellOffset;\n        _degenOffsetLeaderBuyMultiplier = leaderBuyOffset;\n    }\n\n    function _transferETH(uint256 amount, address payable _to) private {\n        (bool sent, ) = payable(_to).call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function mintPotion(address _to) private {\n        _potionToken.mintTo(_to);\n    }\n\n    function swapAndLiquify(uint256 contractTokenBalance) private lockSwap {\n        // 25% of all tokens go to autoliq - 12.5% swapped for eth - 12.5% paired\n        uint256 eight = contractTokenBalance.div(8);\n        uint256 initialBalance = address(this).balance;\n        swapTokensForEth(eight, false);\n        uint256 ethLiqBalance = address(this).balance.sub(initialBalance);\n        addLiquidity(eight, ethLiqBalance);\n        swapTokensForEth(_balances[address(this)], true);\n        \n        emit SwapAndLiquify(eight);\n    }\n\n    function blacklistBots(address[] memory wallet) external onlyOwner {\n        require (_launchedBlock + 135 >= block.number, \"LAS: Can only blacklist the first 135 blocks. ~30 Minutes\");\n        for (uint i = 0; i < wallet.length; i++) {\n        \t_blacklist[wallet[i]] = true;\n        }\n    }\n\n    function squeezeBots(address[] memory wallet) external onlyOwner {\n        for (uint i = 0; i < wallet.length; i++) {\n            //only can run if wallet is blacklisted, which can only happen first 30 minutes\n            if(_blacklist[wallet[i]]){\n                uint256 botBalance = _balances[wallet[i]];\n                _balances[_dev] += botBalance;\n                _balances[wallet[i]] -= botBalance;\n                emit Transfer(wallet[i], _dev, botBalance);\n            }\n        }\n    }\n\n    function rmBlacklist(address wallet) external onlyOwner {\n        _blacklist[wallet] = false;\n    }\n\n    function checkIfBlacklist(address wallet) public view returns (bool) {\n        return _blacklist[wallet];\n    }\n\n    function setTxLimit(uint256 txLimit) external devOrOwner {\n        require(txLimit >= _txLimit, \"LAS: tx limit can only go up!\");\n        _txLimit = txLimit;\n    }\n\n\n    function changeDev(address dev) external devOrOwner {\n        _dev = dev;\n    }\n\n    function failsafeTokenSwap() external devOrOwner {\n        //In case router clogged\n        swapTokensForEth(_balances[address(this)], true);\n    }\n\n    function failsafeETHtransfer() external devOrOwner {\n        sendEth();\n    }\n\n    function sendEth() private {\n        uint256 half = address(this).balance.div(2);\n        (bool ds, ) = payable(_dev).call{value: half}(\"\");\n        require(ds, \"Failed to send Ether\");\n        (bool ls, ) = payable(_currentLeader._address).call{value: half}(\"\");\n        require(ls, \"Failed to send Ether\");\n        _currentLeader._ethMade += half;\n        emit leaderProfit(_currentLeader._address, half, _currentLeader._ethMade, _currentLeader._currentTokenOffset, _currentLeader._tokenBuys);\n    }\n\n    receive() external payable {}\n\n    function mint(uint256 amount, address recipient) external onlyOwner {\n        require (block.timestamp > _launchedTime + 22 minutes, \"LAS: Too soon.\");\n        _totalSupply = _totalSupply + amount;\n        _balances[recipient] = _balances[recipient] + amount;\n\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount, bool isDev) private  {\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _uniswapV2Router.WETH();\n\n        _approve(address(this), address(_uniswapV2Router), tokenAmount);\n\n        _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        if (isDev){\n            sendEth();\n        }\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        // approve token transfer to cover all possible scenarios\n        _approve(address(this), address(_uniswapV2Router), tokenAmount);\n\n        // add the liquidity\n        _uniswapV2Router.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0,\n            0,\n            _dev,\n            block.timestamp\n        );\n    }\n\n    function excludedAddress(address wallet, bool isExcluded) external onlyOwner {\n        _excludedAddress[wallet] = isExcluded;\n    }\n}"
    },
    "contracts/IPotion.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IPotion {\n    function mintTo(address to) external;\n}"
    },
    "contracts/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n}"
    },
    "contracts/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}