{"ClaimBigSB.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n// Rzucam worki w tłum w tłum .. kto łapie ten jara ... XD\n\n/**\nApes Together Strong!\n\nAbout BigShortBets DeFi project:\n\nWe are creating a social\u0026trading p2p platform that guarantees encrypted interaction between investors.\nLogging in is possible via a cryptocurrency wallet (e.g. Metamask).\nThe security level is one comparable to the Tor network.\n\nhttps://bigsb.io/ - Our Tool\nhttps://bigshortbets.com - Project\u0026Team info\n\nVideo explainer:\nhttps://youtu.be/wbhUo5IvKdk\n\nZaorski, You Son of a bitch I’m in …\n*/\n\npragma solidity 0.8.7;\nimport \"./interfaces.sol\";\nimport \"./owned.sol\";\n\n/**\nBigShortBets.com BigSB token claiming contract\nContract need tokens on its address to send them to owners\n\n*/\ncontract ClaimBigSB is Owned {\n    // presale contracts\n    address public immutable presale1;\n    address public immutable presale2;\n    address public immutable sale;\n\n    // BigSB token contract\n    address public immutable token;\n\n    // 1-year claiming window after which Owner can sweep remaining tokens\n    uint256 public immutable claimDateLimit;\n\n    // claiming process need to be enabled\n    bool public claimStarted;\n\n    // Presale2 is bugged in handling multiple ETH deposits\n    // we need handle that\n    mapping(address =\u003e uint256) internal buggedTokens;\n\n    // mark users that already claim tokens\n    mapping(address =\u003e bool) public isClaimed;\n\n    // handle ETH/tokens send from exchanges\n    mapping(address =\u003e address) internal _morty;\n\n    // AML-ed users address-\u003etokens\n    mapping(address =\u003e uint256) internal _aml;\n\n    // events\n    event TokensClaimed(\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n\n    // useful constant\n    address internal constant ZERO = address(0x0);\n\n    uint256 internal immutable startRate;\n\n    /**\n    @dev contract constructor\n    @param _presale1 address of presale1 contract\n    @param _presale2 address of presale2 contract\n    @param _sale address of final sale contract\n    @param _token address of BigSB token contract\n     */\n    constructor(\n        address _presale1,\n        address _presale2,\n        address _sale,\n        address _token\n    ) {\n        presale1 = _presale1;\n        presale2 = _presale2;\n        sale = _sale;\n        token = _token;\n        claimDateLimit = block.timestamp + 365 days; //max 1 year to take tokens\n        startRate = IReflect(_token).getRate();\n    }\n\n    // count tokens from all pre/sale contracts\n    function _allTokens(address user) internal view returns (uint256) {\n        // presale2 need manual handle because of \"multiple ETH send\" error\n        // \"tokensBoughtOf\" is also flawed, so we do all math there\n        uint256 amt = buggedTokens[user];\n        if (amt == 0) {\n            // calculate tokens at sale price $2630/ETH, $0.95/token\n            // function is returning ETH value in wei\n            amt = (IPresale2(presale2).ethDepositOf(user) * 2630 * 100) / 95;\n            // calculate tokens for USD at $0.95/token\n            // contract is returning USD with 0 decimals\n            amt += (IPresale2(presale2).usdDepositOf(user) * 100 ether) / 95;\n        }\n\n        // presale1 reader is returning ETH amount in wei, $0.65 / token, $1530/ETH\n        // yes, there is a typo in function name\n        amt += (IPresale1(presale1).blanceOf(user) * 1530 * 100) / 65;\n\n        // sale returning tokens, $1/token, ETH price from oracle at buy time\n        amt += ISale(sale).tokensBoughtOf(user);\n\n        return amt;\n    }\n\n    /**\n    Reader that can check how many tokens can be claimed by given address\n    @param user address to check\n    @return number of tokens (18 decimals)\n    */\n    function canClaim(address user) external view returns (uint256) {\n        return _recalculate(_allTokens(user));\n    }\n\n    // recalculate amount of tokens via start rate\n    function _recalculate(uint256 tokens) internal view returns (uint256) {\n        uint256 rate = IReflect(token).getRate();\n        return (tokens * rate) / startRate;\n    }\n\n    /**\n    @dev claim BigSB tokens bought on any pre/sale\n     */\n    function claim() external {\n        require(_morty[msg.sender] == ZERO, \"Use claimFrom\");\n        _claim(msg.sender, msg.sender);\n    }\n\n    /// Claim tokens from AMLed list\n    function claimAML() external {\n        uint256 amt = _aml[msg.sender];\n        require(amt \u003e 0, \"Not on AML list\");\n        _aml[msg.sender] = 0;\n        amt = _recalculate(amt);\n        IERC20(token).transfer(msg.sender, amt);\n        emit TokensClaimed(msg.sender, msg.sender, amt);\n    }\n\n    /**\n    @dev Claim BigSB tokens bought on any pre/sale to different address\n    @param to address to which tokens will be claimed\n     */\n    function claimTo(address to) external {\n        require(_morty[msg.sender] == ZERO, \"Use claimFromTo\");\n        _claim(msg.sender, to);\n    }\n\n    /**\n    @dev Claim BigSB tokens bought on any pre/sale from exchange\n    @param from sender address that ETH was send to pre/sale contract\n     */\n    function claimFrom(address from) external {\n        address to = _morty[from];\n        require(msg.sender == to, \"Wrong Morty\");\n        _claim(from, to);\n    }\n\n    /**\n    @dev Claim BigSB tokens by ETH send from exchange to another address\n    @param from sender address that ETH was send\n    @param to address to which send claimed tokens\n     */\n    function claimFromTo(address from, address to) external {\n        require(msg.sender == _morty[from], \"Wrong Morty\");\n        _claim(from, to);\n    }\n\n    // internal claim function, validate claim and send tokens to given address\n    function _claim(address from, address to)\n        internal\n        claimStart\n        notZeroAddress(to)\n    {\n        require(!isClaimed[from], \"Already claimed!\");\n        isClaimed[from] = true;\n        uint256 amt = _recalculate(_allTokens(from));\n        require(IERC20(token).transfer(to, amt), \"Token transfer failed\");\n        emit TokensClaimed(from, to, amt);\n    }\n\n    //\n    // viewers\n    //\n    function isReplacedBy(address user) external view returns (address) {\n        return _morty[user];\n    }\n\n    //\n    // useful modifiers\n    //\n    modifier notZeroAddress(address user) {\n        require(user != ZERO, \"Can not use address 0x0\");\n        _;\n    }\n    modifier claimStart() {\n        require(claimStarted, \"Claiming process not started!\");\n        _;\n    }\n    modifier claimNotStarted() {\n        require(!claimStarted, \"Claiming process already started!\");\n        _;\n    }\n\n    //\n    // Rick mode\n    //\n\n    /**\n    @dev add single address that need to be changed in claim process\n    @param bad address to replace\n    @param good new address that can claim tokens bought by \"bad\" address\n     */\n    function addMorty(address bad, address good)\n        external\n        onlyOwner\n        claimNotStarted\n    {\n        _addMorty(bad, good);\n    }\n\n    /// internal add replacement address function used in singe and multi add function\n    function _addMorty(address bad, address good)\n        internal\n        notZeroAddress(good)\n    {\n        require(_morty[bad] == ZERO, \"Morty already on list\");\n        _morty[bad] = good;\n    }\n\n    /**\n    @dev add addresses that need to be replaced in claiming precess, ie send ETH from exchange\n    @param bad list of wrong send addresses\n    @param good list of address replacements\n     */\n    function addMortys(address[] calldata bad, address[] calldata good)\n        external\n        onlyOwner\n        claimNotStarted\n    {\n        uint256 dl = bad.length;\n        require(dl == good.length, \"Data size mismatch\");\n        uint256 i;\n        for (i; i \u003c dl; i++) {\n            _addMorty(bad[i], good[i]);\n        }\n    }\n\n    /**\n    @dev add single \"bugged\" user\n    @param user affected user address\n    @param tokens counted tokens for user from presale2\n     */\n    function addBugged(address user, uint256 tokens)\n        external\n        onlyOwner\n        claimNotStarted\n    {\n        buggedTokens[user] = tokens;\n    }\n\n    /**\n    @dev add list of users affected by \"many ETH send\" bug via list\n    @param user list of users\n    @param amt list of corresponding tokens amount\n     */\n    function addBuggedList(address[] calldata user, uint256[] calldata amt)\n        external\n        onlyOwner\n        claimNotStarted\n    {\n        uint256 dl = user.length;\n        require(dl == amt.length, \"Data size mismatch\");\n        uint256 i;\n        for (i; i \u003c dl; i++) {\n            buggedTokens[user[i]] = amt[i];\n        }\n    }\n\n    // add data to ALMed user list\n    function addAML(address[] calldata user, uint256[] calldata tokens)\n        external\n        onlyOwner\n        claimNotStarted\n    {\n        uint256 dl = user.length;\n        require(dl == tokens.length, \"Data size mismatch\");\n        uint256 i;\n        for (i; i \u003c dl; i++) {\n            _aml[user[i]] = tokens[i];\n        }\n    }\n\n    /// Enable claiming process\n    function enableClaim() external onlyOwner claimNotStarted {\n        claimStarted = true;\n    }\n\n    /**\n    @dev Function to recover accidentally send ERC20 tokens\n    @param erc20 ERC20 token address\n    */\n    function rescueERC20(address erc20) external onlyOwner {\n        if (erc20 == token) {\n            require(block.timestamp \u003e claimDateLimit, \"Too soon\");\n        }\n        uint256 amt = IERC20(erc20).balanceOf(address(this));\n        require(amt \u003e 0, \"Nothing to rescue\");\n        IUsdt(erc20).transfer(owner, amt);\n    }\n\n    /**\n    @dev Function to recover any ETH send to contract\n    */\n    function rescueETH() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n}\n\n//This is fine!\n"},"interfaces.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// Reflection\ninterface IReflect {\n    function tokenFromReflection(uint256 rAmount)\n        external\n        view\n        returns (uint256);\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\n        external\n        view\n        returns (uint256);\n\n    function getRate() external view returns (uint256);\n}\n\n/// ChainLink ETH/USD oracle\ninterface IChainLink {\n    // chainlink ETH/USD oracle\n    // answer|int256 :  216182781556 - 8 decimals\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/// USDT is not ERC-20 compliant, not returning true on transfers\ninterface IUsdt {\n    function transfer(address, uint256) external;\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\n// Check ETH send to first presale\n// Yes, there is a typo\ninterface IPresale1 {\n    function blanceOf(address user) external view returns (uint256 amt);\n}\n\n// Check tokens bought in second presale\n// There is bug in ETH deposits, we need handle it\n// Also \"tokensBoughtOf\" calculation is broken, so we do all math\ninterface IPresale2 {\n    function ethDepositOf(address user) external view returns (uint256 amt);\n\n    function usdDepositOf(address user) external view returns (uint256 amt);\n}\n\n// Check final sale tokens bought\ninterface ISale {\n    function tokensBoughtOf(address user) external view returns (uint256 amt);\n}\n\ninterface IClaimSale {\n    function addLock(\n        address user,\n        uint256 reflection,\n        uint256 locktime\n    ) external;\n}\n"},"owned.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipChanged(address from, address to);\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipChanged(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    // owner can give super-rights to someone\n    function giveOwnership(address user) external onlyOwner {\n        require(user != address(0), \"User renounceOwnership\");\n        newOwner = user;\n    }\n\n    // new owner need to accept\n    function acceptOwnership() external {\n        require(msg.sender == newOwner, \"Only NewOwner\");\n        emit OwnershipChanged(owner, newOwner);\n        owner = msg.sender;\n        delete newOwner;\n    }\n}\n"}}