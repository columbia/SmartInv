{"Airdrop.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/*\n                 .\u0027cdO0000OO00KKNNNXKOkdc\u0027.                 \n              \u0027cooolc;;lc\u0027,l:\u0027\u0027:lloxO000KKOdc\u0027              \n           \u0027ldoll;.\u0027c..;; .:\u0027  \u0027:..::;cxKKxccddl\u0027           \n         ;ddlc\u0027.:;                 ,..;c,cdxddk0Ox:.        \n       ;ddc..:,                       ...,::xOo;;lkk;       \n     .dx;.;;                             \u0027\u0027.,lk0xlodkd\u0027     \n    ;kl;c.                                 .c\u0027.okc,,cO0:    \n   ckc\u0027..        .cxd,       \u0027ldOd\u0027          .c:c00ollokl   \n  cO;\u0027c.        .dWMMX:     ,0MMMM0\u0027          .\u0027.cko;;;xKl  \n ;Ol;,          ;KMMMMO.    oWMMMMWl           .c\u0027cKkcccdO: \n.ko.,\u0027          :NMMMMK,   .dMMMMMMd            .,;dx.   lk\u0027\nlk;:,           ,KMMMMO.    lWMMMMWo             ;,,OklllxKl\nko.\u0027.           .oWMMNl     .OWMMM0\u0027             .:;dO;...dO\n0:;:             .ckk:.      .:okd\u0027               ,.cO:...c0\n0;\u0027.     .;.                            \u0027:c.      ;::0kllldK\nO;c;     cXNOo\u0027                      .cONNx.      ..;Oc   \u0027O\n0;..      lW0d,                      .;o0K,       ;::Ol...;0\n0c;;      cNl                          .xK,       \u0027.:0xlllkK\nko.,.     ;Xx.                         \u00270O.      .c;dk.   lO\nlk::.     .xX:                         oNl       \u0027.,0Oc::lOo\n.ko.:\u0027     \u0027O0,                       cXx.      .::dkc::cOO\u0027\n :Ol,\u0027      \u0027OKc.                   .oKx.      \u0027:.:KkcccdO: \n  cO;,c.     .oKO;.               .cOKc.       \u0027,cko;;:xKl  \n   ckc.\u0027,      \u0027d0Oo;..      ...:d0Ol.       .c,:00olldOl.  \n    ;kl:;.       .;okOkkxddxkOOOko;.       .;.\u0027oOl;;:k0:    \n     .dx,\u0027c\u0027         .\u0027,::::;\u0027..         ..\u0027:cxkdlok0x\u0027     \n       ;xd:.\u0027c.                       ...c;;xXkc:cdx:       \n        .;ddl:..c. .              .\u0027..c,.:ddlcdKXk:.        \n           \u0027ldooc..:, .c. \u0027;..\u0027:, \u0027c,,cokK0xdddl,           \n              \u0027cooolc;:l,.:c,,:cccldO0Okxkkdc\u0027.             \n                 .,lxO000OOO00KKNNNNX0Oxl,.                 \n*/\n\n// BETTER Airdrop\n\nimport \"./Ownable.sol\";\nimport \"./IERC20.sol\";\nimport \"./IERC721.sol\";\n\ncontract Airdrop is Ownable {\n    address public signerAddress;\n    IERC20 internal better;\n    IERC20 internal holdingToken;\n    uint256 public tokenMinHold;\n    IERC721 internal holdingNFT;\n    uint256 public nftMinHold;\n\n    mapping(string =\u003e bool) public usedIP;\n    mapping(address =\u003e bool) public usedAddresses;\n\n    uint256 public totalDropLimit;\n    uint256 public userDropLimit;\n    uint256 public totalDropped;\n    \n    event AirDropped(\n        address indexed userAddress,\n        uint256 amount\n    );\n\n    event DropLimitUpdated( uint256 newLimit );\n    event TokenHoldingLimitUpdated(uint256 newTokenLimit);\n    event NFTHoldingLimitUpdated(uint256 newNFTLimit);\n    event UserDropLimitUpdated(uint256 newLimit);\n\n    constructor(address _signerAddress, address _tokenAddress, uint256 userdropLimit_, uint256  totalDropLimit_) {\n        require(\n            _signerAddress != address(0),\n            \"Signer Address could not be empty\"\n        );\n        require(\n            _tokenAddress != address(0),\n            \"Token Address could not be empty\"\n        );\n\n        signerAddress = _signerAddress;\n        better = IERC20(_tokenAddress);\n        userDropLimit = userdropLimit_;\n        totalDropLimit = totalDropLimit_;\n    }\n\n    /**\n     * @dev public function to get Better token airdrop.\n     * takes userIp address and verified signature value as input. \n     */\n    function getAirdrop(\n        string memory userIP_,\n        bytes memory signature_\n    ) public returns (bool) {\n        require(totalDropped + userDropLimit \u003c= totalDropLimit, \"Airdrop max Limit reached\");\n        require(!usedIP[userIP_], \"Ip already used\");\n        require(!usedAddresses[msg.sender], \"Address already used\");\n\n        if (tokenMinHold \u003e 0){\n            require(holdingToken.balanceOf(msg.sender) \u003e= tokenMinHold, \"Not enough token holdings\");\n        }\n        if (nftMinHold \u003e 0){\n            require(holdingNFT.balanceOf(msg.sender) \u003e= nftMinHold, \"Not enough NFT holdings\");\n        }\n\n        address recoveredAddress = recoverSigner(\n            keccak256(abi.encodePacked(msg.sender, userIP_, userDropLimit)),\n            signature_\n        );\n\n        require(recoveredAddress == signerAddress, \"Invalid signature\");\n        usedAddresses[msg.sender] = true;\n        usedIP[userIP_] = true;\n        totalDropped += userDropLimit;\n\n        better.transfer(msg.sender, userDropLimit);\n        \n        emit AirDropped(msg.sender, userDropLimit);\n        return true;\n    }\n\n//  ================= Admin functions ========================\n    function updateTotalDropLimit(uint256 newLimit_)public onlyOwner returns(bool){\n        require (newLimit_ \u003e 0, \"Limit can not be zero\");\n        totalDropLimit = newLimit_;\n        emit DropLimitUpdated(newLimit_);\n        return true;\n    }\n\n    function updateUserDropLimit(uint256 newLimit_)public onlyOwner returns(bool){\n        require (newLimit_ \u003e 0, \"Limit can not be zero\");\n        userDropLimit = newLimit_;\n        emit UserDropLimitUpdated(newLimit_);\n        return true;\n    }\n\n//   admin functions to withdraw better tokens out of the contract.\n    function adminWithdrawal(address userAddress, uint256 amount)public onlyOwner {\n        require(userAddress != address(0), \"User Address could not be empty\");\n        require(amount \u003e 0, \"Amount cannot be zero\");\n\n        better.transfer(userAddress, amount);\n    }\n\n// admin function to update the contract address of holding token\n    function updateHoldingTokenAddress(address _tokenAddress) public onlyOwner {\n        require(_tokenAddress != address(0), \"Invalid token address\");\n        holdingToken = IERC20(_tokenAddress);\n    }\n\n    function updateHoldingTokenAmount(uint256 _amount) public onlyOwner {\n        tokenMinHold = _amount;\n        emit TokenHoldingLimitUpdated(tokenMinHold);\n    }\n\n// admin function to update the contract address of holding NFT token\n    function updateHoldingNFTAddress(address _nftAddress) public onlyOwner {\n        require(_nftAddress != address(0), \"Invalid contract address\");\n        holdingNFT = IERC721(_nftAddress);\n    }\n\n    function updateHoldingNFTAmount(uint256 _amount) public onlyOwner {\n        nftMinHold = _amount;\n        emit NFTHoldingLimitUpdated(nftMinHold);\n    }\n\n// admin function to update the address of message signer.\n    function updateSignerAddress(address _signerAddress) public onlyOwner {\n        require(\n            _signerAddress != address(0),\n            \"Signer Address could not be empty\"\n        );\n        signerAddress = _signerAddress;\n    }\n\n    // ============= helper functions ======================\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        message = prefixed(message);\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n\n        (v, r, s) = splitSignature(sig);\n        return ecrecover(message, v, r, s);\n    }\n\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n            );\n    }\n\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        )\n    {\n        require(sig.length == 65);\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n}\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n"}}