{{
  "language": "Solidity",
  "sources": {
    "lib/Staking-v0.1/src/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IERC20, SafeERC20} from \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {TypeAndVersionInterface} from \"./interfaces/TypeAndVersionInterface.sol\";\nimport {Pausable} from \"openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {Ownable} from \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport {IERC165} from \"openzeppelin-contracts/contracts/interfaces/IERC165.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {IStaking} from \"./interfaces/IStaking.sol\";\nimport {IStakingOwner} from \"./interfaces/IStakingOwner.sol\";\nimport {INodeStaking} from \"./interfaces/INodeStaking.sol\";\nimport {IMigratable} from \"./interfaces/IMigratable.sol\";\nimport {StakingPoolLib} from \"./libraries/StakingPoolLib.sol\";\nimport {RewardLib, SafeCast} from \"./libraries/RewardLib.sol\";\nimport {IMigrationTarget} from \"./interfaces/IMigrationTarget.sol\";\n\ncontract Staking is IStaking, IStakingOwner, INodeStaking, IMigratable, Ownable, TypeAndVersionInterface, Pausable {\n    using StakingPoolLib for StakingPoolLib.Pool;\n    using RewardLib for RewardLib.Reward;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice This struct defines the params required by the Staking contract's\n    /// constructor.\n    struct PoolConstructorParams {\n        /// @notice The ARPA Token\n        IERC20 arpa;\n        /// @notice The initial maximum total stake amount across all stakers\n        uint256 initialMaxPoolSize;\n        /// @notice The initial maximum stake amount for a single community staker\n        uint256 initialMaxCommunityStakeAmount;\n        /// @notice The minimum stake amount that a community staker can stake\n        uint256 minCommunityStakeAmount;\n        /// @notice The stake amount that an operator should stake\n        uint256 operatorStakeAmount;\n        /// @notice The minimum number of node operators required to initialize the\n        /// staking pool.\n        uint256 minInitialOperatorCount;\n        /// @notice The minimum reward duration after pool config updates and pool\n        /// reward extensions\n        uint256 minRewardDuration;\n        /// @notice Used to calculate delegated stake amount\n        /// = amount / delegation rate denominator = 100% / 100 = 1%\n        uint256 delegationRateDenominator;\n        /// @notice The freezing duration for stakers after unstaking\n        uint256 unstakeFreezingDuration;\n    }\n\n    IERC20 internal immutable _arpa;\n    StakingPoolLib.Pool internal _pool;\n    RewardLib.Reward internal _reward;\n    /// @notice The address of the controller contract\n    address internal _controller;\n    /// @notice The proposed address stakers will migrate funds to\n    address internal _proposedMigrationTarget;\n    /// @notice The timestamp of when the migration target was proposed at\n    uint256 internal _proposedMigrationTargetAt;\n    /// @notice The address stakers can migrate their funds to\n    address internal _migrationTarget;\n\n    /// @notice The stake amount that a node operator should stake\n    uint256 internal immutable _operatorStakeAmount;\n    /// @notice The minimum stake amount that a community staker can stake\n    uint256 internal immutable _minCommunityStakeAmount;\n    /// @notice The minimum number of node operators required to initialize the\n    /// staking pool.\n    uint256 internal immutable _minInitialOperatorCount;\n    /// @notice The minimum reward duration after pool config updates and pool\n    /// reward extensions\n    uint256 internal immutable _minRewardDuration;\n    /// @notice Used to calculate delegated stake amount\n    /// = amount / delegation rate denominator = 100% / 100 = 1%\n    uint256 internal immutable _delegationRateDenominator;\n    /// @notice The freeze duration for stakers after unstaking\n    uint256 internal immutable _unstakeFreezingDuration;\n\n    event StakingConfigSet(\n        address arpaAddress,\n        uint256 initialMaxPoolSize,\n        uint256 initialMaxCommunityStakeAmount,\n        uint256 minCommunityStakeAmount,\n        uint256 operatorStakeAmount,\n        uint256 minInitialOperatorCount,\n        uint256 minRewardDuration,\n        uint256 delegationRateDenominator,\n        uint256 unstakeFreezingDuration\n    );\n\n    constructor(PoolConstructorParams memory params) {\n        if (address(params.arpa) == address(0)) revert InvalidZeroAddress();\n        if (params.delegationRateDenominator == 0) revert InvalidDelegationRate();\n        if (RewardLib.REWARD_PRECISION % params.delegationRateDenominator > 0) {\n            revert InvalidDelegationRate();\n        }\n        if (params.operatorStakeAmount == 0) {\n            revert InvalidOperatorStakeAmount();\n        }\n        if (params.minCommunityStakeAmount > params.initialMaxCommunityStakeAmount) {\n            revert InvalidMinCommunityStakeAmount();\n        }\n\n        _pool._setConfig(params.initialMaxPoolSize, params.initialMaxCommunityStakeAmount);\n        _arpa = params.arpa;\n        _operatorStakeAmount = params.operatorStakeAmount;\n        _minCommunityStakeAmount = params.minCommunityStakeAmount;\n        _minInitialOperatorCount = params.minInitialOperatorCount;\n        _minRewardDuration = params.minRewardDuration;\n        _delegationRateDenominator = params.delegationRateDenominator;\n        _unstakeFreezingDuration = params.unstakeFreezingDuration;\n\n        emit StakingConfigSet(\n            address(params.arpa),\n            params.initialMaxPoolSize,\n            params.initialMaxCommunityStakeAmount,\n            params.minCommunityStakeAmount,\n            params.operatorStakeAmount,\n            params.minInitialOperatorCount,\n            params.minRewardDuration,\n            params.delegationRateDenominator,\n            params.unstakeFreezingDuration\n        );\n    }\n\n    // =======================\n    // TypeAndVersionInterface\n    // =======================\n\n    /// @inheritdoc TypeAndVersionInterface\n    function typeAndVersion() external pure override returns (string memory) {\n        return \"Staking 0.1.0\";\n    }\n\n    // =============\n    // IStakingOwner\n    // =============\n\n    /// @inheritdoc IStakingOwner\n    function setController(address controller) external override(IStakingOwner) onlyOwner {\n        if (controller == address(0)) revert InvalidZeroAddress();\n        _controller = controller;\n\n        emit ControllerSet(controller);\n    }\n\n    /// @inheritdoc IStakingOwner\n    function setPoolConfig(uint256 maxPoolSize, uint256 maxCommunityStakeAmount)\n        external\n        override(IStakingOwner)\n        onlyOwner\n        whenActive\n    {\n        _pool._setConfig(maxPoolSize, maxCommunityStakeAmount);\n    }\n\n    /// @inheritdoc IStakingOwner\n    function start(uint256 amount, uint256 rewardDuration) external override(IStakingOwner) onlyOwner {\n        if (_reward.startTimestamp != 0) revert AlreadyInitialized();\n\n        _pool._open(_minInitialOperatorCount);\n\n        // We need to transfer ARPA balance before we initialize the reward to\n        // calculate the new reward expiry timestamp.\n        _arpa.safeTransferFrom(msg.sender, address(this), amount);\n\n        _reward._initialize(_minRewardDuration, amount, rewardDuration);\n    }\n\n    /// @inheritdoc IStakingOwner\n    function newReward(uint256 amount, uint256 rewardDuration)\n        external\n        override(IStakingOwner)\n        onlyOwner\n        whenInactive\n    {\n        _reward._accumulateBaseRewards(getTotalCommunityStakedAmount());\n        _reward._accumulateDelegationRewards(getTotalDelegatedAmount(), getTotalCommunityStakedAmount());\n\n        _arpa.safeTransferFrom(msg.sender, address(this), amount);\n\n        _reward._initialize(_minRewardDuration, amount, rewardDuration);\n    }\n\n    /// @inheritdoc IStakingOwner\n    function addReward(uint256 amount, uint256 rewardDuration) external override(IStakingOwner) onlyOwner whenActive {\n        _reward._accumulateBaseRewards(getTotalCommunityStakedAmount());\n        _reward._accumulateDelegationRewards(getTotalDelegatedAmount(), getTotalCommunityStakedAmount());\n\n        _arpa.safeTransferFrom(msg.sender, address(this), amount);\n\n        _reward._updateReward(amount, rewardDuration, _minRewardDuration);\n\n        emit RewardLib.RewardAdded(amount, block.timestamp + rewardDuration);\n    }\n\n    /// @dev Required conditions for adding operators:\n    /// - Operators can only be added to the pool if they have no prior stake.\n    /// - Operators cannot be added to the pool after staking ends.\n    /// @inheritdoc IStakingOwner\n    function addOperators(address[] calldata operators) external override(IStakingOwner) onlyOwner {\n        // If reward was initialized (meaning the pool was active) but the pool is\n        // no longer active we want to prevent adding new operators.\n        if (_reward.startTimestamp > 0 && !isActive()) {\n            revert StakingPoolLib.InvalidPoolStatus(false, true);\n        }\n\n        _pool._addOperators(operators);\n    }\n\n    /// @inheritdoc IStakingOwner\n    function emergencyPause() external override(IStakingOwner) onlyOwner {\n        _pause();\n    }\n\n    /// @inheritdoc IStakingOwner\n    function emergencyUnpause() external override(IStakingOwner) onlyOwner {\n        _unpause();\n    }\n\n    // ===========\n    // IMigratable\n    // ===========\n\n    /// @inheritdoc IMigratable\n    function getMigrationTarget() external view override(IMigratable) returns (address) {\n        return _migrationTarget;\n    }\n\n    /// @inheritdoc IMigratable\n    function proposeMigrationTarget(address migrationTarget) external override(IMigratable) onlyOwner {\n        if (\n            migrationTarget.code.length == 0 || migrationTarget == address(this)\n                || _proposedMigrationTarget == migrationTarget || _migrationTarget == migrationTarget\n                || !IERC165(migrationTarget).supportsInterface(IMigrationTarget.migrateFrom.selector)\n        ) {\n            revert InvalidMigrationTarget();\n        }\n\n        _migrationTarget = address(0);\n        _proposedMigrationTarget = migrationTarget;\n        _proposedMigrationTargetAt = block.timestamp;\n        emit MigrationTargetProposed(migrationTarget);\n    }\n\n    /// @inheritdoc IMigratable\n    function acceptMigrationTarget() external override(IMigratable) onlyOwner {\n        if (_proposedMigrationTarget == address(0)) {\n            revert InvalidMigrationTarget();\n        }\n\n        if (block.timestamp < (uint256(_proposedMigrationTargetAt) + 7 days)) {\n            revert AccessForbidden();\n        }\n\n        _migrationTarget = _proposedMigrationTarget;\n        _proposedMigrationTarget = address(0);\n        emit MigrationTargetAccepted(_migrationTarget);\n    }\n\n    /// @inheritdoc IMigratable\n    function migrate(bytes calldata data) external override(IMigratable) whenInactive {\n        if (_migrationTarget == address(0)) revert InvalidMigrationTarget();\n\n        (uint256 amount, uint256 baseReward, uint256 delegationReward) = _exit(msg.sender);\n\n        _arpa.safeTransfer(_migrationTarget, uint256(amount + baseReward + delegationReward));\n\n        // call migrate function\n        IMigrationTarget(_migrationTarget).migrateFrom(\n            uint256(amount + baseReward + delegationReward), abi.encode(msg.sender, data)\n        );\n\n        emit Migrated(msg.sender, amount, baseReward, delegationReward, data);\n    }\n\n    // ========\n    // INodeStaking\n    // ========\n\n    /// @inheritdoc INodeStaking\n    function lock(address staker, uint256 amount) external override(INodeStaking) onlyController {\n        StakingPoolLib.Staker storage stakerAccount = _pool.stakers[staker];\n        if (!stakerAccount.isOperator) {\n            revert StakingPoolLib.OperatorDoesNotExist(staker);\n        }\n        if (stakerAccount.stakedAmount < amount) {\n            revert StakingPoolLib.InsufficientStakeAmount(amount);\n        }\n        stakerAccount.lockedStakeAmount += amount._toUint96();\n        emit Locked(staker, amount);\n    }\n\n    /// @inheritdoc INodeStaking\n    function unlock(address staker, uint256 amount) external override(INodeStaking) onlyController {\n        StakingPoolLib.Staker storage stakerAccount = _pool.stakers[staker];\n        if (!stakerAccount.isOperator) {\n            revert StakingPoolLib.OperatorDoesNotExist(staker);\n        }\n        if (stakerAccount.lockedStakeAmount < amount) {\n            revert INodeStaking.InadequateOperatorLockedStakingAmount(stakerAccount.lockedStakeAmount);\n        }\n        stakerAccount.lockedStakeAmount -= amount._toUint96();\n        emit Unlocked(staker, amount);\n    }\n\n    /// @inheritdoc INodeStaking\n    function slashDelegationReward(address staker, uint256 amount) external override(INodeStaking) onlyController {\n        StakingPoolLib.Staker memory stakerAccount = _pool.stakers[staker];\n        if (!stakerAccount.isOperator) {\n            revert StakingPoolLib.OperatorDoesNotExist(staker);\n        }\n        uint256 earnedRewards = _reward._getOperatorEarnedDelegatedRewards(\n            staker, getTotalDelegatedAmount(), getTotalCommunityStakedAmount()\n        );\n        // max capped by earnings\n        uint256 slashedRewards = Math.min(amount, earnedRewards);\n        _reward.missed[staker].delegated += slashedRewards._toUint96();\n\n        _arpa.safeTransfer(owner(), slashedRewards);\n\n        emit DelegationRewardSlashed(staker, slashedRewards);\n    }\n\n    /// @inheritdoc INodeStaking\n    function getLockedAmount(address staker) external view override(INodeStaking) returns (uint256) {\n        return _pool.stakers[staker].lockedStakeAmount;\n    }\n\n    // ========\n    // IStaking\n    // ========\n\n    /// @inheritdoc IStaking\n    function stake(uint256 amount) external override(IStaking) whenNotPaused {\n        if (amount < RewardLib.REWARD_PRECISION) {\n            revert StakingPoolLib.InsufficientStakeAmount(RewardLib.REWARD_PRECISION);\n        }\n\n        // Round down input amount to avoid cumulative rounding errors.\n        uint256 remainder = amount % RewardLib.REWARD_PRECISION;\n        if (remainder > 0) {\n            amount -= remainder;\n        }\n\n        if (_pool._isOperator(msg.sender)) {\n            _stakeAsOperator(msg.sender, amount);\n        } else {\n            _stakeAsCommunityStaker(msg.sender, amount);\n        }\n\n        _arpa.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /// @inheritdoc IStaking\n    function unstake(uint256 amount) external override(IStaking) whenNotPaused {\n        // Round down unstake amount to avoid cumulative rounding errors.\n        uint256 remainder = amount % RewardLib.REWARD_PRECISION;\n        if (remainder > 0) {\n            amount -= remainder;\n        }\n\n        (uint256 baseReward, uint256 delegationReward) = _exit(msg.sender, amount, false);\n\n        _arpa.safeTransfer(msg.sender, baseReward + delegationReward);\n\n        emit Unstaked(msg.sender, amount, baseReward, delegationReward);\n    }\n\n    /// @inheritdoc IStaking\n    function claim() external override(IStaking) whenNotPaused {\n        claimReward();\n        if (_pool.stakers[msg.sender].frozenPrincipals.length > 0) {\n            claimFrozenPrincipal();\n        }\n    }\n\n    /// @inheritdoc IStaking\n    function claimReward() public override(IStaking) whenNotPaused {\n        StakingPoolLib.Staker memory stakerAccount = _pool.stakers[msg.sender];\n        if (stakerAccount.isOperator) {\n            revert StakingPoolLib.NoBaseRewardForOperator();\n        }\n\n        uint256 accruedReward = _reward._calculateAccruedBaseRewards(\n            RewardLib._getNonDelegatedAmount(stakerAccount.stakedAmount, _delegationRateDenominator),\n            getTotalCommunityStakedAmount()\n        );\n\n        uint256 claimingReward = accruedReward - uint256(_reward.missed[msg.sender].base);\n\n        _reward.missed[msg.sender].base = accruedReward._toUint96();\n\n        _arpa.safeTransfer(msg.sender, claimingReward);\n\n        emit RewardClaimed(msg.sender, claimingReward);\n    }\n\n    /// @inheritdoc IStaking\n    function claimFrozenPrincipal() public override(IStaking) whenNotPaused {\n        StakingPoolLib.FrozenPrincipal[] storage frozenPrincipals = _pool.stakers[msg.sender].frozenPrincipals;\n        if (frozenPrincipals.length == 0) revert StakingPoolLib.FrozenPrincipalDoesNotExist(msg.sender);\n\n        uint256 claimingPrincipal = 0;\n        uint256 popCount = 0;\n        for (uint256 i = 0; i < frozenPrincipals.length; i++) {\n            StakingPoolLib.FrozenPrincipal storage frozenPrincipal = frozenPrincipals[i];\n            if (frozenPrincipals[i].unlockTimestamp <= block.timestamp) {\n                claimingPrincipal += frozenPrincipal.amount;\n                _pool.totalFrozenAmount -= frozenPrincipal.amount;\n                popCount++;\n            } else {\n                break;\n            }\n        }\n        if (popCount > 0) {\n            for (uint256 i = 0; i < frozenPrincipals.length - popCount; i++) {\n                frozenPrincipals[i] = frozenPrincipals[i + popCount];\n            }\n            for (uint256 i = 0; i < popCount; i++) {\n                frozenPrincipals.pop();\n            }\n        }\n\n        if (claimingPrincipal > 0) {\n            _arpa.safeTransfer(msg.sender, claimingPrincipal);\n        }\n\n        emit FrozenPrincipalClaimed(msg.sender, claimingPrincipal);\n    }\n\n    /// @inheritdoc IStaking\n    function getStake(address staker) public view override(IStaking) returns (uint256) {\n        return _pool.stakers[staker].stakedAmount;\n    }\n\n    /// @inheritdoc IStaking\n    function isOperator(address staker) external view override(IStaking) returns (bool) {\n        return _pool._isOperator(staker);\n    }\n\n    /// @inheritdoc IStaking\n    function isActive() public view override(IStaking) returns (bool) {\n        return _pool.state.isOpen && !_reward._isDepleted();\n    }\n\n    /// @inheritdoc IStaking\n    function getMaxPoolSize() external view override(IStaking) returns (uint256) {\n        return uint256(_pool.limits.maxPoolSize);\n    }\n\n    /// @inheritdoc IStaking\n    function getCommunityStakerLimits() external view override(IStaking) returns (uint256, uint256) {\n        return (_minCommunityStakeAmount, uint256(_pool.limits.maxCommunityStakeAmount));\n    }\n\n    /// @inheritdoc IStaking\n    function getOperatorLimit() external view override(IStaking) returns (uint256) {\n        return _operatorStakeAmount;\n    }\n\n    /// @inheritdoc IStaking\n    function getRewardTimestamps() external view override(IStaking) returns (uint256, uint256) {\n        return (uint256(_reward.startTimestamp), uint256(_reward.endTimestamp));\n    }\n\n    /// @inheritdoc IStaking\n    function getRewardRate() external view override(IStaking) returns (uint256) {\n        return uint256(_reward.rate);\n    }\n\n    /// @inheritdoc IStaking\n    function getDelegationRateDenominator() external view override(IStaking) returns (uint256) {\n        return _delegationRateDenominator;\n    }\n\n    /// @inheritdoc IStaking\n    function getAvailableReward() public view override(IStaking) returns (uint256) {\n        return _arpa.balanceOf(address(this)) - getTotalStakedAmount() - _pool.totalFrozenAmount;\n    }\n\n    /// @inheritdoc IStaking\n    function getBaseReward(address staker) public view override(IStaking) returns (uint256) {\n        uint256 stakedAmount = _pool.stakers[staker].stakedAmount;\n        if (stakedAmount == 0) return 0;\n\n        if (_pool._isOperator(staker)) {\n            return 0;\n        }\n\n        return _reward._calculateAccruedBaseRewards(\n            RewardLib._getNonDelegatedAmount(stakedAmount, _delegationRateDenominator), getTotalCommunityStakedAmount()\n        ) - uint256(_reward.missed[staker].base);\n    }\n\n    /// @inheritdoc IStaking\n    function getDelegationReward(address staker) public view override(IStaking) returns (uint256) {\n        StakingPoolLib.Staker memory stakerAccount = _pool.stakers[staker];\n        if (!stakerAccount.isOperator) return 0;\n        if (stakerAccount.stakedAmount == 0) return 0;\n        return _reward._getOperatorEarnedDelegatedRewards(\n            staker, getTotalDelegatedAmount(), getTotalCommunityStakedAmount()\n        );\n    }\n\n    /// @inheritdoc IStaking\n    function getTotalDelegatedAmount() public view override(IStaking) returns (uint256) {\n        return RewardLib._getDelegatedAmount(_pool.state.totalCommunityStakedAmount, _delegationRateDenominator);\n    }\n\n    /// @inheritdoc IStaking\n    function getDelegatesCount() external view override(IStaking) returns (uint256) {\n        return uint256(_reward.delegated.delegatesCount);\n    }\n\n    function getCommunityStakersCount() external view returns (uint256) {\n        return uint256(_reward.base.communityStakersCount);\n    }\n\n    /// @inheritdoc IStaking\n    function getTotalStakedAmount() public view override(IStaking) returns (uint256) {\n        return _pool._getTotalStakedAmount();\n    }\n\n    /// @inheritdoc IStaking\n    function getTotalCommunityStakedAmount() public view override(IStaking) returns (uint256) {\n        return _pool.state.totalCommunityStakedAmount;\n    }\n\n    /// @inheritdoc IStaking\n    function getTotalFrozenAmount() external view override(IStaking) returns (uint256) {\n        return _pool.totalFrozenAmount;\n    }\n\n    /// @inheritdoc IStaking\n    function getFrozenPrincipal(address staker)\n        external\n        view\n        override(IStaking)\n        returns (uint96[] memory amounts, uint256[] memory unlockTimestamps)\n    {\n        StakingPoolLib.FrozenPrincipal[] memory frozenPrincipals = _pool.stakers[staker].frozenPrincipals;\n        amounts = new uint96[](frozenPrincipals.length);\n        unlockTimestamps = new uint256[](frozenPrincipals.length);\n        for (uint256 i = 0; i < frozenPrincipals.length; i++) {\n            amounts[i] = frozenPrincipals[i].amount;\n            unlockTimestamps[i] = frozenPrincipals[i].unlockTimestamp;\n        }\n    }\n\n    /// @inheritdoc IStaking\n    function getClaimablePrincipalAmount(address) external view returns (uint256 claimingPrincipal) {\n        StakingPoolLib.FrozenPrincipal[] storage frozenPrincipals = _pool.stakers[msg.sender].frozenPrincipals;\n        if (frozenPrincipals.length == 0) return 0;\n\n        for (uint256 i = 0; i < frozenPrincipals.length; i++) {\n            StakingPoolLib.FrozenPrincipal storage frozenPrincipal = frozenPrincipals[i];\n            if (frozenPrincipals[i].unlockTimestamp <= block.timestamp) {\n                claimingPrincipal += frozenPrincipal.amount;\n            } else {\n                break;\n            }\n        }\n    }\n\n    /// @inheritdoc IStaking\n    function getArpaToken() public view override(IStaking) returns (address) {\n        return address(_arpa);\n    }\n\n    /// @inheritdoc IStaking\n    function getController() external view override(IStaking) returns (address) {\n        return _controller;\n    }\n\n    // =======\n    // Internal\n    // =======\n\n    /// @notice Helper function for when a community staker enters the pool\n    /// @param staker The staker address\n    /// @param amount The amount of principal staked\n    function _stakeAsCommunityStaker(address staker, uint256 amount) internal whenActive {\n        uint256 currentStakedAmount = _pool.stakers[staker].stakedAmount;\n        uint256 newStakedAmount = currentStakedAmount + amount;\n        // Check that the amount is greater than or equal to the minimum required\n        if (newStakedAmount < _minCommunityStakeAmount) {\n            revert StakingPoolLib.InsufficientStakeAmount(_minCommunityStakeAmount);\n        }\n\n        // Check that the amount is less than or equal to the maximum allowed\n        uint256 maxCommunityStakeAmount = uint256(_pool.limits.maxCommunityStakeAmount);\n        if (newStakedAmount > maxCommunityStakeAmount) {\n            revert StakingPoolLib.ExcessiveStakeAmount(maxCommunityStakeAmount - currentStakedAmount);\n        }\n\n        // Check if the amount supplied increases the total staked amount above\n        // the maximum pool size\n        uint256 remainingPoolSpace = _pool._getRemainingPoolSpace();\n        if (amount > remainingPoolSpace) {\n            revert StakingPoolLib.ExcessiveStakeAmount(remainingPoolSpace);\n        }\n\n        _reward._accumulateBaseRewards(getTotalCommunityStakedAmount());\n        _reward._accumulateDelegationRewards(getTotalDelegatedAmount(), getTotalCommunityStakedAmount());\n\n        // On first stake\n        if (currentStakedAmount == 0) {\n            _reward.base.communityStakersCount += 1;\n        }\n\n        uint256 extraNonDelegatedAmount = RewardLib._getNonDelegatedAmount(amount, _delegationRateDenominator);\n        _reward.missed[staker].base +=\n            _reward._calculateAccruedBaseRewards(extraNonDelegatedAmount, getTotalCommunityStakedAmount())._toUint96();\n        _pool.state.totalCommunityStakedAmount += amount._toUint96();\n        _pool.stakers[staker].stakedAmount = newStakedAmount._toUint96();\n        emit Staked(staker, amount, newStakedAmount);\n    }\n\n    /// @notice Helper function for when an operator enters the pool\n    /// @param staker The staker address\n    /// @param amount The amount of principal staked\n    function _stakeAsOperator(address staker, uint256 amount) internal {\n        StakingPoolLib.Staker storage operator = _pool.stakers[staker];\n        uint256 currentStakedAmount = operator.stakedAmount;\n        uint256 newStakedAmount = currentStakedAmount + amount;\n\n        // Check that the amount is greater than or less than the required\n        if (newStakedAmount < _operatorStakeAmount) {\n            revert StakingPoolLib.InsufficientStakeAmount(_operatorStakeAmount);\n        }\n        if (newStakedAmount > _operatorStakeAmount) {\n            revert StakingPoolLib.ExcessiveStakeAmount(newStakedAmount - _operatorStakeAmount);\n        }\n\n        // On first stake\n        if (currentStakedAmount == 0) {\n            _reward._accumulateDelegationRewards(getTotalDelegatedAmount(), getTotalCommunityStakedAmount());\n            uint8 delegatesCount = _reward.delegated.delegatesCount;\n\n            // Prior to the first operator staking, we reset the accumulated value\n            // so it doesn't count towards missed rewards.\n            if (delegatesCount == 0) {\n                delete _reward.delegated.cumulativePerDelegate;\n            }\n\n            _reward.delegated.delegatesCount = delegatesCount + 1;\n\n            _reward.missed[staker].delegated = _reward.delegated.cumulativePerDelegate;\n        }\n\n        _pool.state.totalOperatorStakedAmount += amount._toUint96();\n        _pool.stakers[staker].stakedAmount = newStakedAmount._toUint96();\n        emit Staked(staker, amount, newStakedAmount);\n    }\n\n    /// @notice Helper function when staker exits the pool\n    /// @param staker The staker address\n    function _exit(address staker) internal returns (uint256, uint256, uint256) {\n        StakingPoolLib.Staker memory stakerAccount = _pool.stakers[staker];\n        if (stakerAccount.stakedAmount == 0) {\n            revert StakingPoolLib.StakeNotFound(staker);\n        }\n        if (stakerAccount.lockedStakeAmount > 0) {\n            revert StakingPoolLib.ExistingLockedStakeFound(staker);\n        }\n        (uint256 baseReward, uint256 delegationReward) = _exit(staker, stakerAccount.stakedAmount, true);\n        return (stakerAccount.stakedAmount, baseReward, delegationReward);\n    }\n\n    /// @notice Helper function when staker exits the pool\n    /// @param staker The staker address\n    function _exit(address staker, uint256 amount, bool isMigrate) internal returns (uint256, uint256) {\n        StakingPoolLib.Staker memory stakerAccount = _pool.stakers[staker];\n        if (amount == 0) {\n            revert StakingPoolLib.UnstakeWithZeroAmount(staker);\n        }\n        if (stakerAccount.stakedAmount < amount) {\n            revert StakingPoolLib.InadequateStakingAmount(stakerAccount.stakedAmount);\n        }\n\n        _reward._accumulateBaseRewards(getTotalCommunityStakedAmount());\n        _reward._accumulateDelegationRewards(getTotalDelegatedAmount(), getTotalCommunityStakedAmount());\n\n        if (stakerAccount.isOperator) {\n            if (amount != _operatorStakeAmount) {\n                revert StakingPoolLib.UnstakeOperatorWithPartialAmount(staker);\n            }\n\n            if (stakerAccount.lockedStakeAmount > 0) {\n                revert StakingPoolLib.ExistingLockedStakeFound(staker);\n            }\n\n            uint256 delegationReward = _reward._getOperatorEarnedDelegatedRewards(\n                staker, getTotalDelegatedAmount(), getTotalCommunityStakedAmount()\n            );\n\n            _pool.state.totalOperatorStakedAmount -= amount._toUint96();\n            _pool.stakers[staker].stakedAmount -= amount._toUint96();\n\n            if (!isMigrate) {\n                _pool.totalFrozenAmount += amount._toUint96();\n                _pool.stakers[staker].frozenPrincipals.push(\n                    StakingPoolLib.FrozenPrincipal(amount._toUint96(), block.timestamp + _unstakeFreezingDuration)\n                );\n            }\n            _reward.delegated.delegatesCount -= 1;\n\n            _reward.missed[staker].delegated = _reward.delegated.cumulativePerDelegate;\n\n            return (0, delegationReward);\n        } else {\n            uint256 baseReward = _reward._calculateAccruedBaseRewards(\n                RewardLib._getNonDelegatedAmount(stakerAccount.stakedAmount, _delegationRateDenominator),\n                getTotalCommunityStakedAmount()\n            ) - uint256(_reward.missed[staker].base);\n\n            _pool.state.totalCommunityStakedAmount -= amount._toUint96();\n            _pool.stakers[staker].stakedAmount -= amount._toUint96();\n\n            if (_pool.stakers[staker].stakedAmount == 0) {\n                _reward.base.communityStakersCount -= 1;\n            }\n\n            if (!isMigrate) {\n                _pool.totalFrozenAmount += amount._toUint96();\n                _pool.stakers[staker].frozenPrincipals.push(\n                    StakingPoolLib.FrozenPrincipal(amount._toUint96(), block.timestamp + _unstakeFreezingDuration)\n                );\n            }\n\n            _reward.missed[staker].base = _reward._calculateAccruedBaseRewards(\n                RewardLib._getNonDelegatedAmount(_pool.stakers[staker].stakedAmount, _delegationRateDenominator),\n                getTotalCommunityStakedAmount()\n            )._toUint96();\n\n            return (baseReward, 0);\n        }\n    }\n\n    // =========\n    // Modifiers\n    // =========\n\n    /// @dev Having a private function for the modifer saves on the contract size\n    function _isActive() private view {\n        if (!isActive()) revert StakingPoolLib.InvalidPoolStatus(false, true);\n    }\n\n    /// @dev Reverts if the staking pool is inactive (not open for staking or\n    /// expired)\n    modifier whenActive() {\n        _isActive();\n\n        _;\n    }\n\n    /// @dev Reverts if the staking pool is active (open for staking)\n    modifier whenInactive() {\n        if (isActive()) revert StakingPoolLib.InvalidPoolStatus(true, false);\n\n        _;\n    }\n\n    /// @dev Reverts if not sent from the LINK token\n    modifier onlyController() {\n        if (msg.sender != _controller) revert SenderNotController();\n\n        _;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "lib/Staking-v0.1/src/interfaces/TypeAndVersionInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nabstract contract TypeAndVersionInterface {\n    function typeAndVersion() external pure virtual returns (string memory);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "lib/Staking-v0.1/src/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IStaking {\n    /// @notice This event is emitted when the controller is set.\n    /// @param controller Controller address\n    event ControllerSet(address controller);\n\n    /// @notice This event is emitted when a staker adds stake to the pool.\n    /// @param staker Staker address\n    /// @param newStake New principal amount staked\n    /// @param totalStake Total principal amount staked\n    event Staked(address staker, uint256 newStake, uint256 totalStake);\n    /// @notice This event is emitted when a staker exits the pool.\n    /// @param staker Staker address\n    /// @param principal Principal amount frozen after unstaking\n    /// @param baseReward base reward earned\n    /// @param delegationReward delegation reward earned, if any\n    event Unstaked(address staker, uint256 principal, uint256 baseReward, uint256 delegationReward);\n\n    /// @notice This event is emitted when a staker claims base reward.\n    /// @param staker Staker address\n    /// @param baseReward Base reward amount claimed\n    event RewardClaimed(address staker, uint256 baseReward);\n\n    /// @notice This event is emitted when a staker claims frozen principal.\n    /// @param staker Staker address\n    /// @param principal Principal amount claimed\n    event FrozenPrincipalClaimed(address staker, uint256 principal);\n\n    /// @notice This error is thrown whenever an address does not have access\n    /// to successfully execute a transaction\n    error AccessForbidden();\n\n    /// @notice This error is thrown whenever a zero-address is supplied when\n    /// a non-zero address is required\n    error InvalidZeroAddress();\n\n    /// @notice This error is thrown whenever the sender is not controller contract\n    error SenderNotController();\n\n    /// @notice This function allows stakers to stake.\n    function stake(uint256 amount) external;\n\n    /// @notice This function allows stakers to unstake.\n    /// It returns base and delegation rewards, and makes principle frozen for later claiming.\n    function unstake(uint256 amount) external;\n\n    /// @notice This function allows community stakers to claim base rewards and frozen principals(if any).\n    function claim() external;\n\n    /// @notice This function allows stakers to claim base rewards.\n    function claimReward() external;\n\n    /// @notice This function allows stakers to claim frozen principals.\n    function claimFrozenPrincipal() external;\n\n    /// @return address ARPA token contract's address that is used by the pool\n    function getArpaToken() external view returns (address);\n\n    /// @param staker address\n    /// @return uint256 staker's staked principal amount\n    function getStake(address staker) external view returns (uint256);\n\n    /// @notice Returns true if an address is an operator\n    function isOperator(address staker) external view returns (bool);\n\n    /// @notice The staking pool starts closed and only allows\n    /// stakers to stake once it's opened\n    /// @return bool pool status\n    function isActive() external view returns (bool);\n\n    /// @return uint256 current maximum staking pool size\n    function getMaxPoolSize() external view returns (uint256);\n\n    /// @return uint256 minimum amount that can be staked by a community staker\n    /// @return uint256 maximum amount that can be staked by a community staker\n    function getCommunityStakerLimits() external view returns (uint256, uint256);\n\n    /// @return uint256 amount that should be staked by an operator\n    function getOperatorLimit() external view returns (uint256);\n\n    /// @return uint256 reward initialization timestamp\n    /// @return uint256 reward expiry timestamp\n    function getRewardTimestamps() external view returns (uint256, uint256);\n\n    /// @return uint256 current reward rate, expressed in arpa weis per second\n    function getRewardRate() external view returns (uint256);\n\n    /// @return uint256 current delegation rate\n    function getDelegationRateDenominator() external view returns (uint256);\n\n    /// @return uint256 total amount of ARPA tokens made available for rewards in\n    /// ARPA wei\n    /// @dev This reflects how many rewards were made available over the\n    /// lifetime of the staking pool.\n    function getAvailableReward() external view returns (uint256);\n\n    /// @return uint256 amount of base rewards earned by a staker in ARPA wei\n    function getBaseReward(address) external view returns (uint256);\n\n    /// @return uint256 amount of delegation rewards earned by an operator in ARPA wei\n    function getDelegationReward(address) external view returns (uint256);\n\n    /// @notice Total delegated amount is calculated by dividing the total\n    /// community staker staked amount by the delegation rate, i.e.\n    /// totalDelegatedAmount = pool.totalCommunityStakedAmount / delegationRateDenominator\n    /// @return uint256 staked amount that is used when calculating delegation rewards in ARPA wei\n    function getTotalDelegatedAmount() external view returns (uint256);\n\n    /// @notice Delegates count increases after an operator is added to the list\n    /// of operators and stakes the required amount.\n    /// @return uint256 number of staking operators that are eligible for delegation rewards\n    function getDelegatesCount() external view returns (uint256);\n\n    /// @notice This count all community stakers that have a staking balance greater than 0.\n    /// @return uint256 number of staking community stakers that are eligible for base rewards\n    function getCommunityStakersCount() external view returns (uint256);\n\n    /// @return uint256 total amount staked by community stakers and operators in ARPA wei\n    function getTotalStakedAmount() external view returns (uint256);\n\n    /// @return uint256 total amount staked by community stakers in ARPA wei\n    function getTotalCommunityStakedAmount() external view returns (uint256);\n\n    /// @return uint256 the sum of frozen operator principals that have not been\n    /// withdrawn from the staking pool in ARPA wei.\n    /// @dev Used to make sure that contract's balance is correct.\n    /// total staked amount + total frozen amount + available rewards = current balance\n    function getTotalFrozenAmount() external view returns (uint256);\n\n    /// @return amounts total amounts of ARPA wei that is currently frozen by the staker\n    /// @return unlockTimestamps timestamps when the frozen principal can be withdrawn\n    function getFrozenPrincipal(address)\n        external\n        view\n        returns (uint96[] memory amounts, uint256[] memory unlockTimestamps);\n\n    /// @return uint256 amount of ARPA wei that can be claimed as frozen principal by a staker\n    function getClaimablePrincipalAmount(address) external view returns (uint256);\n\n    /// @return address controller contract's address that is used by the pool\n    function getController() external view returns (address);\n}\n"
    },
    "lib/Staking-v0.1/src/interfaces/IStakingOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @notice Owner functions restricted to the setup and maintenance\n/// of the staking contract by the owner.\ninterface IStakingOwner {\n    /// @notice This error is thrown when an zero delegation rate is supplied\n    error InvalidDelegationRate();\n\n    /// @notice This error is thrown when an invalid operator stake amount is\n    /// supplied\n    error InvalidOperatorStakeAmount();\n\n    /// @notice This error is thrown when an invalid min community stake amount\n    /// is supplied\n    error InvalidMinCommunityStakeAmount();\n\n    /// @notice This error is thrown when the reward is already initialized\n    error AlreadyInitialized();\n\n    /// @notice Adds one or more operators to a list of operators\n    /// @dev Should only callable by the Owner\n    /// @param operators A list of operator addresses to add\n    function addOperators(address[] calldata operators) external;\n\n    /// @notice This function can be called to add rewards to the pool when the reward is depleted\n    /// @dev Should only callable by the Owner\n    /// @param amount The amount of rewards to add to the pool\n    /// @param rewardDuration The duration of the reward\n    function newReward(uint256 amount, uint256 rewardDuration) external;\n\n    /// @notice This function can be called to add rewards to the pool when the reward is not depleted\n    /// @dev Should only be callable by the owner\n    /// @param amount The amount of rewards to add to the pool\n    /// @param rewardDuration The duration of the reward\n    function addReward(uint256 amount, uint256 rewardDuration) external;\n\n    /// @notice Set the pool config\n    /// @param maxPoolSize The max amount of staked ARPA by community stakers allowed in the pool\n    /// @param maxCommunityStakeAmount The max amount of ARPA a community staker can stake\n    function setPoolConfig(uint256 maxPoolSize, uint256 maxCommunityStakeAmount) external;\n\n    /// @notice Set controller contract address\n    /// @dev Should only be callable by the owner\n    /// @param controller The address of the controller contract\n    function setController(address controller) external;\n\n    /// @notice Transfers ARPA tokens and initializes the reward\n    /// @dev Uses ERC20 approve + transferFrom flow\n    /// @param amount rewards amount in ARPA\n    /// @param rewardDuration rewards duration in seconds\n    function start(uint256 amount, uint256 rewardDuration) external;\n\n    /// @notice This function pauses staking\n    /// @dev Sets the pause flag to true\n    function emergencyPause() external;\n\n    /// @notice This function unpauses staking\n    /// @dev Sets the pause flag to false\n    function emergencyUnpause() external;\n}\n"
    },
    "lib/Staking-v0.1/src/interfaces/INodeStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface INodeStaking {\n    /// @notice This event is emitted when a node locks stake in the pool.\n    /// @param staker Staker address\n    /// @param newLock New principal amount locked\n    event Locked(address staker, uint256 newLock);\n\n    /// @notice This event is emitted when a node unlocks stake in the pool.\n    /// @param staker Staker address\n    /// @param newUnlock New principal amount unlocked\n    event Unlocked(address staker, uint256 newUnlock);\n\n    /// @notice This event is emitted when a node gets delegation reward slashed.\n    /// @param staker Staker address\n    /// @param amount Amount slashed\n    event DelegationRewardSlashed(address staker, uint256 amount);\n\n    /// @notice This error is raised when attempting to unlock with more than the current locked staking amount\n    /// @param currentLockedStakingAmount Current locked staking amount\n    error InadequateOperatorLockedStakingAmount(uint256 currentLockedStakingAmount);\n\n    /// @notice This function allows controller to lock staking amount for a node.\n    /// @param staker Node address\n    /// @param amount Amount to lock\n    function lock(address staker, uint256 amount) external;\n\n    /// @notice This function allows controller to unlock staking amount for a node.\n    /// @param staker Node address\n    /// @param amount Amount to unlock\n    function unlock(address staker, uint256 amount) external;\n\n    /// @notice This function allows controller to slash delegation reward of a node.\n    /// @param staker Node address\n    /// @param amount Amount to slash\n    function slashDelegationReward(address staker, uint256 amount) external;\n\n    /// @notice This function returns the locked amount of a node.\n    /// @param staker Node address\n    function getLockedAmount(address staker) external view returns (uint256);\n}\n"
    },
    "lib/Staking-v0.1/src/interfaces/IMigratable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IMigratable {\n    /// @notice This event is emitted when a migration target is proposed by the contract owner.\n    /// @param migrationTarget Contract address to migrate stakes to.\n    event MigrationTargetProposed(address migrationTarget);\n    /// @notice This event is emitted after a 7 day period has passed since a migration target is proposed, and the target is accepted.\n    /// @param migrationTarget Contract address to migrate stakes to.\n    event MigrationTargetAccepted(address migrationTarget);\n    /// @notice This event is emitted when a staker migrates their stake to the migration target.\n    /// @param staker Staker address\n    /// @param principal Principal amount deposited\n    /// @param baseReward Amount of base rewards withdrawn\n    /// @param delegationReward Amount of delegation rewards withdrawn (if applicable)\n    /// @param data Migration payload\n    event Migrated(address staker, uint256 principal, uint256 baseReward, uint256 delegationReward, bytes data);\n\n    /// @notice This error is raised when the contract owner supplies a non-contract migration target.\n    error InvalidMigrationTarget();\n\n    /// @notice This function returns the migration target contract address\n    function getMigrationTarget() external view returns (address);\n\n    /// @notice This function allows the contract owner to set a proposed\n    /// migration target address. If the migration target is valid it renounces\n    /// the previously accepted migration target (if any).\n    /// @param migrationTarget Contract address to migrate stakes to.\n    function proposeMigrationTarget(address migrationTarget) external;\n\n    /// @notice This function allows the contract owner to accept a proposed migration target address after a waiting period.\n    function acceptMigrationTarget() external;\n\n    /// @notice This function allows stakers to migrate funds to a new staking pool.\n    /// @param data Migration path details\n    function migrate(bytes calldata data) external;\n}\n"
    },
    "lib/Staking-v0.1/src/libraries/StakingPoolLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\nlibrary StakingPoolLib {\n    using SafeCast for uint256;\n\n    /// @notice This event is emitted when the staking pool is opened for stakers\n    event PoolOpened();\n    /// @notice This event is emitted when the staking pool's maximum size is\n    /// increased\n    /// @param maxPoolSize the new maximum pool size\n    event PoolSizeIncreased(uint256 maxPoolSize);\n    /// @notice This event is emitted when the maximum stake amount\n    // for community stakers is increased\n    /// @param maxStakeAmount the new maximum stake amount\n    event MaxCommunityStakeAmountIncreased(uint256 maxStakeAmount);\n    /// @notice This event is emitted when an operator is added\n    /// @param operator address of the operator that was added to the staking pool\n    event OperatorAdded(address operator);\n\n    /// @notice Surfaces the required pool status to perform an operation\n    /// (true if open / false if closed)\n    /// @param currentStatus current status of the pool\n    /// @param requiredStatus required status of the pool to proceed\n    error InvalidPoolStatus(bool currentStatus, bool requiredStatus);\n    /// @notice This error is raised when attempting to decrease maximum pool size.\n    /// @param maxPoolSize the current maximum pool size\n    error InvalidPoolSize(uint256 maxPoolSize);\n    /// @notice This error is raised when attempting to decrease maximum stake amount\n    /// for community stakers or node operators\n    /// @param maxStakeAmount the current maximum stake amount\n    error InvalidMaxStakeAmount(uint256 maxStakeAmount);\n    /// @param requiredAmount minimum required stake amount\n    error InsufficientStakeAmount(uint256 requiredAmount);\n    /// @notice This error is raised when stakers attempt to stake past pool limits.\n    /// @param remainingAmount maximum remaining amount that can be staked. This is\n    /// the difference between the existing staked amount and the individual and global limits.\n    error ExcessiveStakeAmount(uint256 remainingAmount);\n    /// @notice This error is raised when stakers attempt to exit the pool.\n    /// @param staker address of the staker who attempted to withdraw funds\n    error StakeNotFound(address staker);\n    /// @notice This error is raised when addresses with existing stake is added as an operator.\n    /// @param staker address of the staker who is being added as an operator\n    error ExistingStakeFound(address staker);\n    /// @notice This error is raised when an address is duplicated in the supplied list of operators.\n    /// This can happen in addOperators and setFeedOperators functions.\n    /// @param operator address of the operator\n    error OperatorAlreadyExists(address operator);\n    /// @notice This error is raised when lock/unlock/slash is called on an operator that does not exist.\n    /// @param operator address of the operator\n    error OperatorDoesNotExist(address operator);\n    /// @notice This error is raised when attempting to claim rewards by an operator.\n    error NoBaseRewardForOperator();\n    /// @notice This error is raised when attempting to start staking with less\n    /// than the minimum required node operators\n    /// @param currentOperatorsCount The current number of operators in the staking pool\n    /// @param minInitialOperatorsCount The minimum required number of operators\n    /// in the staking pool before opening\n    error InadequateInitialOperatorsCount(uint256 currentOperatorsCount, uint256 minInitialOperatorsCount);\n    /// @notice This error is raised when attempting to unstake with more than the current staking amount.\n    error InadequateStakingAmount(uint256 currentStakingAmount);\n    /// @notice This error is raised when attempting to claim frozen principal that does not exist.\n    error FrozenPrincipalDoesNotExist(address staker);\n    /// @notice This error is raised when attempting to unstake with zero amount.\n    error UnstakeWithZeroAmount(address staker);\n    /// @notice This error is raised when attempting to unstake with partial amount by an operator.\n    error UnstakeOperatorWithPartialAmount(address operator);\n    /// @notice This error is raised when attempting to unstake with existing locked staking amount.\n    error ExistingLockedStakeFound(address operator);\n\n    struct PoolLimits {\n        // The max amount of staked ARPA by community stakers allowed in the pool\n        uint96 maxPoolSize;\n        // The max amount of ARPA a community staker can stake\n        uint96 maxCommunityStakeAmount;\n    }\n\n    struct PoolState {\n        // Flag that signals if the staking pool is open for staking\n        bool isOpen;\n        // Total number of operators added to the staking pool\n        uint8 operatorsCount;\n        // Total amount of ARPA staked by community stakers\n        uint96 totalCommunityStakedAmount;\n        // Total amount of ARPA staked by operators\n        uint96 totalOperatorStakedAmount;\n    }\n\n    struct FrozenPrincipal {\n        // Amount of ARPA frozen after unstaking\n        uint96 amount;\n        // Timestamp when the principal is unlocked\n        uint256 unlockTimestamp;\n    }\n\n    struct Staker {\n        // Flag that signals whether a staker is an operator\n        bool isOperator;\n        // Amount of ARPA staked by a staker\n        uint96 stakedAmount;\n        // Frozen principals of a staker\n        FrozenPrincipal[] frozenPrincipals;\n        // Locked staking amount of an operator\n        uint96 lockedStakeAmount;\n    }\n\n    struct Pool {\n        mapping(address => Staker) stakers;\n        PoolState state;\n        PoolLimits limits;\n        // Sum of frozen principals that have not been withdrawn.\n        // Used to make sure that contract's balance is correct.\n        // total staked amount + total frozen amount + available rewards = current balance\n        uint256 totalFrozenAmount;\n    }\n\n    /// @notice Sets staking pool parameters\n    /// @param maxPoolSize Maximum total stake amount across all stakers\n    /// @param maxCommunityStakeAmount Maximum stake amount for a single community staker\n    function _setConfig(Pool storage pool, uint256 maxPoolSize, uint256 maxCommunityStakeAmount) internal {\n        if (pool.limits.maxPoolSize > maxPoolSize) {\n            revert InvalidPoolSize(maxPoolSize);\n        }\n        if (pool.limits.maxCommunityStakeAmount > maxCommunityStakeAmount) {\n            revert InvalidMaxStakeAmount(maxCommunityStakeAmount);\n        }\n\n        if (pool.limits.maxPoolSize != maxPoolSize) {\n            pool.limits.maxPoolSize = maxPoolSize._toUint96();\n            emit PoolSizeIncreased(maxPoolSize);\n        }\n        if (pool.limits.maxCommunityStakeAmount != maxCommunityStakeAmount) {\n            pool.limits.maxCommunityStakeAmount = maxCommunityStakeAmount._toUint96();\n            emit MaxCommunityStakeAmountIncreased(maxCommunityStakeAmount);\n        }\n    }\n\n    /// @notice Opens the staking pool\n    function _open(Pool storage pool, uint256 minInitialOperatorCount) internal {\n        if (uint256(pool.state.operatorsCount) < minInitialOperatorCount) {\n            revert InadequateInitialOperatorsCount(pool.state.operatorsCount, minInitialOperatorCount);\n        }\n        pool.state.isOpen = true;\n        emit PoolOpened();\n    }\n\n    /// @notice Returns true if a supplied staker address is in the operators list\n    /// @param staker Address of a staker\n    /// @return bool\n    function _isOperator(Pool storage pool, address staker) internal view returns (bool) {\n        return pool.stakers[staker].isOperator;\n    }\n\n    /// @notice Returns the sum of all principal staked in the pool\n    /// @return totalStakedAmount\n    function _getTotalStakedAmount(Pool storage pool) internal view returns (uint256) {\n        StakingPoolLib.PoolState memory poolState = pool.state;\n        return uint256(poolState.totalCommunityStakedAmount) + uint256(poolState.totalOperatorStakedAmount);\n    }\n\n    /// @notice Returns the amount of remaining space available in the pool for\n    /// community stakers. Community stakers can only stake up to this amount\n    /// even if they are within their individual limits.\n    /// @return remainingPoolSpace\n    function _getRemainingPoolSpace(Pool storage pool) internal view returns (uint256) {\n        StakingPoolLib.PoolState memory poolState = pool.state;\n        return uint256(pool.limits.maxPoolSize) - uint256(poolState.totalCommunityStakedAmount);\n    }\n\n    /// @dev Required conditions for adding operators:\n    /// - Operators can only been added to the pool if they have no prior stake.\n    /// - Operators cannot be added to the pool after staking ends.\n    function _addOperators(Pool storage pool, address[] calldata operators) internal {\n        for (uint256 i; i < operators.length; i++) {\n            if (pool.stakers[operators[i]].isOperator) {\n                revert OperatorAlreadyExists(operators[i]);\n            }\n            if (pool.stakers[operators[i]].stakedAmount > 0) {\n                revert ExistingStakeFound(operators[i]);\n            }\n            pool.stakers[operators[i]].isOperator = true;\n            emit OperatorAdded(operators[i]);\n        }\n\n        // Safely update operators count with respect to the maximum of 255 operators\n        pool.state.operatorsCount = pool.state.operatorsCount + operators.length._toUint8();\n    }\n}\n"
    },
    "lib/Staking-v0.1/src/libraries/RewardLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {StakingPoolLib} from \"./StakingPoolLib.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\nlibrary RewardLib {\n    using SafeCast for uint256;\n\n    /// @notice emitted when the reward is initialized for the first time\n    /// @param available the amount of rewards available for distribution in the\n    /// staking pool\n    /// @param startTimestamp the start timestamp when rewards are started\n    /// @param endTimestamp the timestamp when the reward will run out\n    event RewardInitialized(uint256 available, uint256 startTimestamp, uint256 endTimestamp);\n    /// @notice emitted when owner adds more rewards to the pool\n    /// @param amountAdded the amount of ARPA rewards added to the pool\n    /// @param endTimestamp the timestamp when the reward will run out\n    event RewardAdded(uint256 amountAdded, uint256 endTimestamp);\n    /// @notice emitted when owner withdraws leftover rewards\n    /// @param amount the amount of rewards withdrawn\n    event RewardWithdrawn(uint256 amount);\n    /// @notice emitted when an  operator gets slashed.\n    /// Node operators are not slashed more than the amount of rewards they\n    /// have earned.\n    event RewardSlashed(address[] operator, uint256[] slashedDelegatedRewards);\n\n    /// @notice This error is thrown when the updated reward duration is too short\n    error RewardDurationTooShort();\n\n    /// @notice This is the reward calculation precision variable. ARPA token has the\n    /// 1e18 multiplier which means that rewards are floored after 6 decimals\n    /// points. Micro ARPA is the smallest unit that is eligible for rewards.\n    uint256 internal constant REWARD_PRECISION = 1e12;\n\n    struct DelegatedRewards {\n        // Count of delegates who are eligible for a share of a reward\n        uint8 delegatesCount;\n        // Tracks base reward amounts that goes to an operator as delegation rewards.\n        // Used to correctly account for any changes in operator count, delegated amount, or reward rate.\n        uint96 cumulativePerDelegate;\n        // Timestamp of the last time accumulate was called\n        // `startTimestamp` <= `delegated.lastAccumulateTimestamp`\n        uint32 lastAccumulateTimestamp;\n    }\n\n    struct BaseRewards {\n        // Count of community stakers who are eligible for a share of a reward\n        uint32 communityStakersCount;\n        // The cumulative ARPA accrued per stake from past reward rates\n        // expressed in ARPA wei per micro ARPA\n        uint96 cumulativePerShare;\n        // Timestamp of the last time the base reward rate was accumulated\n        uint32 lastAccumulateTimestamp;\n    }\n\n    struct MissedRewards {\n        // Tracks missed base rewards that are deducted from late stakers\n        uint96 base;\n        // Tracks missed delegation rewards that are deducted from late delegates\n        uint96 delegated;\n    }\n\n    struct Reward {\n        mapping(address => MissedRewards) missed;\n        DelegatedRewards delegated;\n        BaseRewards base;\n        // Reward rate expressed in arpa weis per second\n        uint80 rate;\n        // Timestamp when the reward stops accumulating. Has to support a very long\n        // duration for scenarios with low reward rate.\n        // `endTimestamp` >= `startTimestamp`\n        uint32 endTimestamp;\n        // Timestamp when the reward comes into effect\n        // `startTimestamp` <= `endTimestamp`\n        uint32 startTimestamp;\n    }\n\n    /// @notice initializes the reward with the defined parameters\n    /// @param minRewardDuration the minimum duration rewards need to last for\n    /// @param newReward the amount of rewards to be added to the pool\n    /// @param rewardDuration the duration for which the reward will be distributed\n    function _initialize(Reward storage reward, uint256 minRewardDuration, uint256 newReward, uint256 rewardDuration)\n        internal\n    {\n        uint32 blockTimestamp = block.timestamp._toUint32();\n        reward.startTimestamp = blockTimestamp;\n\n        reward.delegated.lastAccumulateTimestamp = blockTimestamp;\n        reward.base.lastAccumulateTimestamp = blockTimestamp;\n\n        _updateReward(reward, newReward, rewardDuration, minRewardDuration);\n\n        emit RewardInitialized(newReward, reward.startTimestamp, reward.endTimestamp);\n    }\n\n    /// @return bool true if the reward is expired (end <= now)\n    function _isDepleted(Reward storage reward) internal view returns (bool) {\n        return reward.endTimestamp <= block.timestamp;\n    }\n\n    /// @notice Helper function to accumulate base rewards\n    /// Accumulate reward per micro ARPA before changing reward rate.\n    /// This keeps rewards prior to rate change unaffected.\n    function _accumulateBaseRewards(Reward storage reward, uint256 totalStakedAmount) internal {\n        reward.base.cumulativePerShare = _calculateCumulativeBaseRewards(reward, totalStakedAmount)._toUint96();\n        reward.base.lastAccumulateTimestamp = _getCappedTimestamp(reward)._toUint32();\n    }\n\n    /// @notice Helper function to accumulate delegation rewards\n    /// @dev This function is necessary to correctly account for any changes in\n    /// eligible operators, delegated amount or reward rate.\n    function _accumulateDelegationRewards(\n        Reward storage reward,\n        uint256 totalDelegatedAmount,\n        uint256 totalStakedAmount\n    ) internal {\n        reward.delegated.cumulativePerDelegate =\n            _calculateCumulativeDelegatedRewards(reward, totalDelegatedAmount, totalStakedAmount)._toUint96();\n        reward.delegated.lastAccumulateTimestamp = _getCappedTimestamp(reward)._toUint32();\n    }\n\n    function _calculateCumulativeBaseRewards(Reward storage reward, uint256 totalStakedAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        if (totalStakedAmount == 0) return reward.base.cumulativePerShare;\n        uint256 elapsedDurationSinceLastAccumulate = _isDepleted(reward)\n            ? (uint256(reward.endTimestamp) - uint256(reward.base.lastAccumulateTimestamp))\n            : block.timestamp - uint256(reward.base.lastAccumulateTimestamp);\n\n        return reward.base.cumulativePerShare\n            + (uint256(reward.rate) * elapsedDurationSinceLastAccumulate * REWARD_PRECISION / totalStakedAmount)._toUint96();\n    }\n\n    function _calculateCumulativeDelegatedRewards(\n        Reward storage reward,\n        uint256 totalDelegatedAmount,\n        uint256 totalStakedAmount\n    ) internal view returns (uint256) {\n        if (totalStakedAmount == 0) return reward.delegated.cumulativePerDelegate;\n        uint256 elapsedDurationSinceLastAccumulate = _isDepleted(reward)\n            ? uint256(reward.endTimestamp) - uint256(reward.delegated.lastAccumulateTimestamp)\n            : block.timestamp - uint256(reward.delegated.lastAccumulateTimestamp);\n\n        return reward.delegated.cumulativePerDelegate\n            + (\n                uint256(reward.rate) * elapsedDurationSinceLastAccumulate * totalDelegatedAmount / totalStakedAmount\n                    / Math.max(uint256(reward.delegated.delegatesCount), 1)\n            )._toUint96();\n    }\n\n    /// @notice Calculates the amount of delegated rewards accumulated so far.\n    /// @dev This function takes into account the amount of delegated\n    /// rewards accumulated from previous delegate counts and amounts and\n    /// the latest additional value.\n    function _calculateAccruedDelegatedRewards(\n        Reward storage reward,\n        uint256 totalDelegatedAmount,\n        uint256 totalStakedAmount\n    ) internal view returns (uint256) {\n        return _calculateCumulativeDelegatedRewards(reward, totalDelegatedAmount, totalStakedAmount);\n    }\n\n    /// @notice Calculates the amount of rewards accrued so far.\n    /// @dev This function takes into account the amount of\n    /// rewards accumulated from previous rates in addition to\n    /// the rewards that will be accumulated based off the current rate\n    /// over a given duration.\n    function _calculateAccruedBaseRewards(Reward storage reward, uint256 amount, uint256 totalStakedAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return amount * _calculateCumulativeBaseRewards(reward, totalStakedAmount) / REWARD_PRECISION;\n    }\n\n    /// @notice calculates an amount that community stakers have to delegate to operators\n    /// @param amount base staked amount to calculate delegated amount against\n    /// @param delegationRateDenominator Delegation rate used to calculate delegated stake amount\n    function _getDelegatedAmount(uint256 amount, uint256 delegationRateDenominator) internal pure returns (uint256) {\n        return amount / delegationRateDenominator;\n    }\n\n    /// @notice calculates the amount of stake that remains after accounting for delegation requirement\n    /// @param amount base staked amount to calculate non-delegated amount against\n    /// @param delegationRateDenominator Delegation rate used to calculate delegated stake amount\n    function _getNonDelegatedAmount(uint256 amount, uint256 delegationRateDenominator)\n        internal\n        pure\n        returns (uint256)\n    {\n        return amount - _getDelegatedAmount(amount, delegationRateDenominator);\n    }\n\n    /// @notice This function is called when the staking pool is initialized,\n    /// rewards are added, TODO and an alert is raised\n    /// @param newReward new reward amount\n    /// @param rewardDuration duration of the reward\n    function _updateReward(Reward storage reward, uint256 newReward, uint256 rewardDuration, uint256 minRewardDuration)\n        internal\n    {\n        uint256 remainingRewards =\n            (_isDepleted(reward) ? 0 : (reward.rate * (uint256(reward.endTimestamp) - block.timestamp))) + newReward;\n\n        // Validate that the new reward duration is at least the min reward duration.\n        // This is a safety mechanism to guard against operational mistakes.\n        if (rewardDuration < minRewardDuration) {\n            revert RewardDurationTooShort();\n        }\n\n        reward.endTimestamp = (block.timestamp + rewardDuration)._toUint32();\n        reward.rate = (remainingRewards / rewardDuration)._toUint80();\n    }\n\n    /// @return The amount of delegated rewards an operator\n    /// has earned.\n    function _getOperatorEarnedDelegatedRewards(\n        Reward storage reward,\n        address operator,\n        uint256 totalDelegatedAmount,\n        uint256 totalStakedAmount\n    ) internal view returns (uint256) {\n        return _calculateAccruedDelegatedRewards(reward, totalDelegatedAmount, totalStakedAmount)\n            - uint256(reward.missed[operator].delegated);\n    }\n\n    /// @return The current timestamp or, if the current timestamp has passed reward\n    /// end timestamp, reward end timestamp.\n    /// @dev This is necessary to ensure that rewards are calculated correctly\n    /// after the reward is depleted.\n    function _getCappedTimestamp(Reward storage reward) internal view returns (uint256) {\n        return Math.min(uint256(reward.endTimestamp), block.timestamp);\n    }\n}\n"
    },
    "lib/Staking-v0.1/src/interfaces/IMigrationTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IMigrationTarget {\n    /// @notice This function allows stakers to migrate funds from an old staking pool.\n    /// @param amount Amount of tokens to migrate\n    /// @param data Migration path details\n    function migrateFrom(uint256 amount, bytes calldata data) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/Staking-v0.1/src/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary SafeCast {\n    error CastError();\n\n    /// @notice This is used to safely case timestamps to uint8\n    uint256 private constant MAX_UINT_8 = type(uint8).max;\n    /// @notice This is used to safely case timestamps to uint32\n    uint256 private constant MAX_UINT_32 = type(uint32).max;\n    /// @notice This is used to safely case timestamps to uint80\n    uint256 private constant MAX_UINT_80 = type(uint80).max;\n    /// @notice This is used to safely case timestamps to uint96\n    uint256 private constant MAX_UINT_96 = type(uint96).max;\n\n    function _toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > MAX_UINT_8) revert CastError();\n        return uint8(value);\n    }\n\n    function _toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > MAX_UINT_32) revert CastError();\n        return uint32(value);\n    }\n\n    function _toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > MAX_UINT_80) revert CastError();\n        return uint80(value);\n    }\n\n    function _toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > MAX_UINT_96) revert CastError();\n        return uint96(value);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "Staking-v0.1/=lib/Staking-v0.1/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "metadata": {
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {
      "src/libraries/BLS.sol": {
        "BLS": "0x25e627ED5C1102C4a130e8B846aA24867898Eb78"
      },
      "src/libraries/GroupLib.sol": {
        "GroupLib": "0xDa08c1Be1519C3AdF6a71b4b0634208e02eccDC9"
      }
    }
  }
}}