{{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IAaveDistributionManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\n\ninterface IAaveDistributionManager {\n  function configureAssets(DistributionTypes.AssetConfigInput[] calldata assetsConfigInput) external;\n}\n"
    },
    "contracts/lib/DistributionTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nlibrary DistributionTypes {\n  struct AssetConfigInput {\n    uint128 emissionPerSecond;\n    uint256 totalStaked;\n    address underlyingAsset;\n  }\n\n  struct UserStakeInput {\n    address underlyingAsset;\n    uint256 stakedByUser;\n    uint256 totalStaked;\n  }\n}\n"
    },
    "contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IAaveIncentivesController {\n  function handleAction(\n    address asset,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) external;\n\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    returns (uint256);\n\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to,\n    bool stake\n  ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAToken.sol": {
      "content": "pragma solidity ^0.6.12;\n\ninterface IAToken {\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport {IERC20} from './IERC20.sol';\n\n/**\n * @dev Interface for ERC20 including metadata\n **/\ninterface IERC20Detailed is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IStakedAave.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\ninterface IStakedAave {\n  function stake(address to, uint256 amount) external;\n\n  function redeem(address to, uint256 amount) external;\n\n  function cooldown() external;\n\n  function claimRewards(address to, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/ITransferHook.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\ninterface ITransferHook {\n    function onTransfer(address from, address to, uint256 amount) external;\n}"
    },
    "contracts/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Collection of functions related to the address type\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, 'Address: insufficient balance');\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}('');\n        require(success, 'Address: unable to send value, recipient may have reverted');\n    }\n}\n"
    },
    "contracts/lib/BaseAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport './UpgradeabilityProxy.sol';\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev From https://github.com/OpenZeppelin/openzeppelin-sdk/tree/solc-0.6/packages/lib/contracts/upgradeability \n * This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n     * @dev Emitted when the administration has been transferred.\n     * @param previousAdmin Address of the previous admin.\n     * @param newAdmin Address of the new admin.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n\n    bytes32\n        internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier to check whether the `msg.sender` is the admin.\n     * If it is, it will run the function. Otherwise, it will delegate the call\n     * to the implementation.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @return The address of the proxy admin.\n     */\n    function admin() external ifAdmin returns (address) {\n        return _admin();\n    }\n\n    /**\n     * @return The address of the implementation.\n     */\n    function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     * Only the current admin can call this function.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n    function changeAdmin(address newAdmin) external ifAdmin {\n        require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address');\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param newImplementation Address of the new implementation.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        ifAdmin\n    {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @return adm The admin slot.\n     */\n    function _admin() internal view returns (address adm) {\n        bytes32 slot = ADMIN_SLOT;\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the proxy admin.\n     * @param newAdmin Address of the new proxy admin.\n     */\n    function _setAdmin(address newAdmin) internal {\n        bytes32 slot = ADMIN_SLOT;\n\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Only fall back when the sender is not the admin.\n     */\n    function _willFallback() internal virtual override {\n        require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin');\n        super._willFallback();\n    }\n}\n"
    },
    "contracts/lib/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport './BaseUpgradeabilityProxy.sol';\n\n/**\n * @title UpgradeabilityProxy\n * @dev From https://github.com/OpenZeppelin/openzeppelin-sdk/tree/solc-0.6/packages/lib/contracts/upgradeability\n * Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n     * @dev Contract constructor.\n     * @param _logic Address of the initial implementation.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(\n            IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n        );\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n}\n"
    },
    "contracts/lib/BaseUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport './Proxy.sol';\nimport './Address.sol';\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev From https://github.com/OpenZeppelin/openzeppelin-sdk/tree/solc-0.6/packages/lib/contracts/upgradeability\n * This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     * @param implementation Address of the new implementation.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32\n        internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation.\n     * @return impl Address of the current implementation\n     */\n    function _implementation() internal override view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION_SLOT;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation address of the proxy.\n     * @param newImplementation Address of the new implementation.\n     */\n    function _setImplementation(address newImplementation) internal {\n        require(\n            Address.isContract(newImplementation),\n            'Cannot set a proxy implementation to a non-contract address'\n        );\n\n        bytes32 slot = IMPLEMENTATION_SLOT;\n\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "contracts/lib/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @title Proxy\n * @dev From https://github.com/OpenZeppelin/openzeppelin-sdk/tree/solc-0.6/packages/lib/contracts/upgradeability\n * Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n    /**\n     * @dev Fallback function.\n     * Implemented entirely in `_fallback`.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @return The Address of the implementation.\n     */\n    function _implementation() internal virtual view returns (address);\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * This is a low level function that doesn't return to its internal call site.\n     * It will return to the external caller whatever the implementation returns.\n     * @param implementation Address to delegate.\n     */\n    function _delegate(address implementation) internal {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    /**\n     * @dev Function that is run as the first thing in the fallback function.\n     * Can be redefined in derived contracts to add functionality.\n     * Redefinitions must call super._willFallback().\n     */\n    function _willFallback() internal virtual {}\n\n    /**\n     * @dev fallback implementation.\n     * Extracted to enable manual triggering.\n     */\n    function _fallback() internal {\n        _willFallback();\n        _delegate(_implementation());\n    }\n}\n"
    },
    "contracts/lib/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\n * Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal virtual view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal virtual view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/lib/ERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport {Context} from './Context.sol';\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {IERC20Detailed} from '../interfaces/IERC20Detailed.sol';\nimport {SafeMath} from './SafeMath.sol';\n\n/**\n * @title ERC20\n * @notice Basic ERC20 implementation\n * @author Aave\n **/\ncontract ERC20 is Context, IERC20, IERC20Detailed {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) private _balances;\n  mapping(address => mapping(address => uint256)) private _allowances;\n  uint256 private _totalSupply;\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) public {\n    _name = name;\n    _symbol = symbol;\n    _decimals = decimals;\n  }\n\n  /**\n   * @return the name of the token\n   **/\n  function name() public override view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @return the symbol of the token\n   **/\n  function symbol() public override view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @return the decimals of the token\n   **/\n  function decimals() public override view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @return the total supply of the token\n   **/\n  function totalSupply() public override view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @return the balance of the token\n   **/\n  function balanceOf(address account) public override view returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev executes a transfer of tokens from msg.sender to recipient\n   * @param recipient the recipient of the tokens\n   * @param amount the amount of tokens being transferred\n   * @return true if the transfer succeeds, false otherwise\n   **/\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev returns the allowance of spender on the tokens owned by owner\n   * @param owner the owner of the tokens\n   * @param spender the user allowed to spend the owner's tokens\n   * @return the amount of owner's tokens spender is allowed to spend\n   **/\n  function allowance(address owner, address spender)\n    public\n    virtual\n    override\n    view\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev allows spender to spend the tokens owned by msg.sender\n   * @param spender the user allowed to spend msg.sender tokens\n   * @return true\n   **/\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev executes a transfer of token from sender to recipient, if msg.sender is allowed to do so\n   * @param sender the owner of the tokens\n   * @param recipient the recipient of the tokens\n   * @param amount the amount of tokens being transferred\n   * @return true if the transfer succeeds, false otherwise\n   **/\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\n    );\n    return true;\n  }\n\n  /**\n   * @dev increases the allowance of spender to spend msg.sender tokens\n   * @param spender the user allowed to spend on behalf of msg.sender\n   * @param addedValue the amount being added to the allowance\n   * @return true\n   **/\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev decreases the allowance of spender to spend msg.sender tokens\n   * @param spender the user allowed to spend on behalf of msg.sender\n   * @param subtractedValue the amount being subtracted to the allowance\n   * @return true\n   **/\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        'ERC20: decreased allowance below zero'\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: mint to the zero address');\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: burn from the zero address');\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _setName(string memory newName) internal {\n    _name = newName;\n  }\n\n  function _setSymbol(string memory newSymbol) internal {\n    _symbol = newSymbol;\n  }\n\n  function _setDecimals(uint8 newDecimals) internal {\n    _decimals = newDecimals;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\n/**\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\n * Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, 'SafeMath: addition overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, 'SafeMath: subtraction overflow');\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, 'SafeMath: multiplication overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, 'SafeMath: division by zero');\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, 'SafeMath: modulo by zero');\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/lib/ERC20WithSnapshot.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport {ERC20} from '../lib/ERC20.sol';\nimport {ITransferHook} from '../interfaces/ITransferHook.sol';\n\n/**\n * @title ERC20WithSnapshot\n * @notice ERC20 including snapshots of balances on transfer-related actions\n * @author Aave\n **/\ncontract ERC20WithSnapshot is ERC20 {\n\n    /// @dev snapshot of a value on a specific block, used for balances\n    struct Snapshot {\n        uint128 blockNumber;\n        uint128 value;\n    }\n\n    mapping (address => mapping (uint256 => Snapshot)) public _snapshots;\n    mapping (address => uint256) public _countsSnapshots;\n    /// @dev reference to the Aave governance contract to call (if initialized) on _beforeTokenTransfer\n    /// !!! IMPORTANT The Aave governance is considered a trustable contract, being its responsibility\n    /// to control all potential reentrancies by calling back the this contract\n    ITransferHook public _aaveGovernance;\n\n    event SnapshotDone(address owner, uint128 oldValue, uint128 newValue);\n\n    constructor(string memory name, string memory symbol, uint8 decimals) public ERC20(name, symbol, decimals) {}\n\n    function _setAaveGovernance(ITransferHook aaveGovernance) internal virtual {\n        _aaveGovernance = aaveGovernance;\n    }\n\n    /**\n    * @dev Writes a snapshot for an owner of tokens\n    * @param owner The owner of the tokens\n    * @param oldValue The value before the operation that is gonna be executed after the snapshot\n    * @param newValue The value after the operation\n    */\n    function _writeSnapshot(address owner, uint128 oldValue, uint128 newValue) internal virtual {\n        uint128 currentBlock = uint128(block.number);\n\n        uint256 ownerCountOfSnapshots = _countsSnapshots[owner];\n        mapping (uint256 => Snapshot) storage snapshotsOwner = _snapshots[owner];\n\n        // Doing multiple operations in the same block\n        if (ownerCountOfSnapshots != 0 && snapshotsOwner[ownerCountOfSnapshots.sub(1)].blockNumber == currentBlock) {\n            snapshotsOwner[ownerCountOfSnapshots.sub(1)].value = newValue;\n        } else {\n            snapshotsOwner[ownerCountOfSnapshots] = Snapshot(currentBlock, newValue);\n            _countsSnapshots[owner] = ownerCountOfSnapshots.add(1);\n        }\n\n        emit SnapshotDone(owner, oldValue, newValue);\n    }\n\n    /**\n    * @dev Writes a snapshot before any operation involving transfer of value: _transfer, _mint and _burn\n    * - On _transfer, it writes snapshots for both \"from\" and \"to\"\n    * - On _mint, only for _to\n    * - On _burn, only for _from\n    * @param from the from address\n    * @param to the to address\n    * @param amount the amount to transfer\n    */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        if (from == to) {\n            return;\n        }\n\n        if (from != address(0)) {\n            uint256 fromBalance = balanceOf(from);\n            _writeSnapshot(from, uint128(fromBalance), uint128(fromBalance.sub(amount)));\n        }\n        if (to != address(0)) {\n            uint256 toBalance = balanceOf(to);\n            _writeSnapshot(to, uint128(toBalance), uint128(toBalance.add(amount)));\n        }\n\n        // caching the aave governance address to avoid multiple state loads\n        ITransferHook aaveGovernance = _aaveGovernance;\n        if (aaveGovernance != ITransferHook(0)) {\n            aaveGovernance.onTransfer(from, to, amount);\n        }\n    }\n}"
    },
    "contracts/lib/InitializableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport './BaseAdminUpgradeabilityProxy.sol';\nimport './InitializableUpgradeabilityProxy.sol';\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev From https://github.com/OpenZeppelin/openzeppelin-sdk/tree/solc-0.6/packages/lib/contracts/upgradeability \n * Extends from BaseAdminUpgradeabilityProxy with an initializer for\n * initializing the implementation, admin, and init data.\n */\ncontract InitializableAdminUpgradeabilityProxy is\n    BaseAdminUpgradeabilityProxy,\n    InitializableUpgradeabilityProxy\n{\n    /**\n     * Contract initializer.\n     * @param _logic address of the initial implementation.\n     * @param _admin Address of the proxy administrator.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    function initialize(\n        address _logic,\n        address _admin,\n        bytes memory _data\n    ) public payable {\n        require(_implementation() == address(0));\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n        _setAdmin(_admin);\n    }\n\n    /**\n     * @dev Only fall back when the sender is not the admin.\n     */\n    function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n        BaseAdminUpgradeabilityProxy._willFallback();\n    }\n}\n"
    },
    "contracts/lib/InitializableUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport './BaseUpgradeabilityProxy.sol';\n\n/**\n * @title InitializableUpgradeabilityProxy\n * @dev From https://github.com/OpenZeppelin/openzeppelin-sdk/tree/solc-0.6/packages/lib/contracts/upgradeability\n * Extends BaseUpgradeabilityProxy with an initializer for initializing\n * implementation and init data.\n */\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n    /**\n     * @dev Contract initializer.\n     * @param _logic Address of the initial implementation.\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n     */\n    function initialize(address _logic, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        assert(\n            IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n        );\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }\n}\n"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\nimport {Address} from \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\n * Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    \n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/mocks/ATokenMock.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {IAToken} from '../interfaces/IAToken.sol';\n\ncontract ATokenMock is IAToken {\n  IAaveIncentivesController public _aic;\n  uint256 internal _userBalance;\n  uint256 internal _totalSupply;\n\n  // hack to be able to test event from EI properly\n  event RewardsAccrued(address indexed user, uint256 amount);\n\n  // hack to be able to test event from Distribution manager properly\n  event AssetConfigUpdated(address indexed asset, uint256 emission);\n  event AssetIndexUpdated(address indexed asset, uint256 index);\n  event UserIndexUpdated(address indexed user, address indexed asset, uint256 index);\n\n  constructor(IAaveIncentivesController aic) public {\n    _aic = aic;\n  }\n\n  function handleActionOnAic(\n    address user,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) external {\n    _aic.handleAction(user, userBalance, totalSupply);\n  }\n\n  function setUserBalanceAndSupply(uint256 userBalance, uint256 totalSupply) public {\n    _userBalance = userBalance;\n    _totalSupply = totalSupply;\n  }\n\n  function getScaledUserBalanceAndSupply(address user)\n    external\n    override\n    view\n    returns (uint256, uint256)\n  {\n    return (_userBalance, _totalSupply);\n  }\n\n  function cleanUserState() external {\n    _userBalance = 0;\n    _totalSupply = 0;\n  }\n}\n"
    },
    "contracts/mocks/MockTransferHook.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport {ITransferHook} from \"../interfaces/ITransferHook.sol\";\n\ncontract MockTransferHook is ITransferHook {\n    event MockHookEvent();\n\n    function onTransfer(address from, address to, uint256 amount) external override {\n        emit MockHookEvent();\n    }\n}"
    },
    "contracts/stake/AaveDistributionManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '../lib/SafeMath.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {IAaveDistributionManager} from '../interfaces/IAaveDistributionManager.sol';\n\n/**\n * @title AaveDistributionManager\n * @notice Accounting contract to manage multiple staking distributions\n * @author Aave\n **/\ncontract AaveDistributionManager is IAaveDistributionManager {\n  using SafeMath for uint256;\n\n  struct AssetData {\n    uint128 emissionPerSecond;\n    uint128 lastUpdateTimestamp;\n    uint256 index;\n    mapping(address => uint256) users;\n  }\n\n  uint256 public immutable DISTRIBUTION_END;\n\n  address public immutable EMISSION_MANAGER;\n\n  uint8 public constant PRECISION = 18;\n\n  mapping(address => AssetData) public assets;\n\n  event AssetConfigUpdated(address indexed asset, uint256 emission);\n  event AssetIndexUpdated(address indexed asset, uint256 index);\n  event UserIndexUpdated(address indexed user, address indexed asset, uint256 index);\n\n  constructor(address emissionManager, uint256 distributionDuration) public {\n    DISTRIBUTION_END = block.timestamp.add(distributionDuration);\n    EMISSION_MANAGER = emissionManager;\n  }\n\n  /**\n   * @dev Configures the distribution of rewards for a list of assets\n   * @param assetsConfigInput The list of configurations to apply\n   **/\n  function configureAssets(DistributionTypes.AssetConfigInput[] calldata assetsConfigInput) external override {\n    require(msg.sender == EMISSION_MANAGER, 'ONLY_EMISSION_MANAGER');\n\n    for (uint256 i = 0; i < assetsConfigInput.length; i++) {\n      AssetData storage assetConfig = assets[assetsConfigInput[i].underlyingAsset];\n\n      _updateAssetStateInternal(\n        assetsConfigInput[i].underlyingAsset,\n        assetConfig,\n        assetsConfigInput[i].totalStaked\n      );\n\n      assetConfig.emissionPerSecond = assetsConfigInput[i].emissionPerSecond;\n\n      emit AssetConfigUpdated(\n        assetsConfigInput[i].underlyingAsset,\n        assetsConfigInput[i].emissionPerSecond\n      );\n    }\n  }\n\n  /**\n   * @dev Updates the state of one distribution, mainly rewards index and timestamp\n   * @param underlyingAsset The address used as key in the distribution, for example sAAVE or the aTokens addresses on Aave\n   * @param assetConfig Storage pointer to the distribution's config\n   * @param totalStaked Current total of staked assets for this distribution\n   * @return The new distribution index\n   **/\n  function _updateAssetStateInternal(\n    address underlyingAsset,\n    AssetData storage assetConfig,\n    uint256 totalStaked\n  ) internal returns (uint256) {\n    uint256 oldIndex = assetConfig.index;\n    uint128 lastUpdateTimestamp = assetConfig.lastUpdateTimestamp;\n\n    if (block.timestamp == lastUpdateTimestamp) {\n      return oldIndex;\n    }\n\n    uint256 newIndex = _getAssetIndex(\n      oldIndex,\n      assetConfig.emissionPerSecond,\n      lastUpdateTimestamp,\n      totalStaked\n    );\n\n    if (newIndex != oldIndex) {\n      assetConfig.index = newIndex;\n      emit AssetIndexUpdated(underlyingAsset, newIndex);\n    }\n\n    assetConfig.lastUpdateTimestamp = uint128(block.timestamp);\n\n    return newIndex;\n  }\n\n  /**\n   * @dev Updates the state of an user in a distribution\n   * @param user The user's address\n   * @param asset The address of the reference asset of the distribution\n   * @param stakedByUser Amount of tokens staked by the user in the distribution at the moment\n   * @param totalStaked Total tokens staked in the distribution\n   * @return The accrued rewards for the user until the moment\n   **/\n  function _updateUserAssetInternal(\n    address user,\n    address asset,\n    uint256 stakedByUser,\n    uint256 totalStaked\n  ) internal returns (uint256) {\n    AssetData storage assetData = assets[asset];\n    uint256 userIndex = assetData.users[user];\n    uint256 accruedRewards = 0;\n\n    uint256 newIndex = _updateAssetStateInternal(asset, assetData, totalStaked);\n\n    if (userIndex != newIndex) {\n      if (stakedByUser != 0) {\n        accruedRewards = _getRewards(stakedByUser, newIndex, userIndex);\n      }\n\n      assetData.users[user] = newIndex;\n      emit UserIndexUpdated(user, asset, newIndex);\n    }\n\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Used by \"frontend\" stake contracts to update the data of an user when claiming rewards from there\n   * @param user The address of the user\n   * @param stakes List of structs of the user data related with his stake\n   * @return The accrued rewards for the user until the moment\n   **/\n  function _claimRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\n    internal\n    returns (uint256)\n  {\n    uint256 accruedRewards = 0;\n\n    for (uint256 i = 0; i < stakes.length; i++) {\n      accruedRewards = accruedRewards.add(\n        _updateUserAssetInternal(\n          user,\n          stakes[i].underlyingAsset,\n          stakes[i].stakedByUser,\n          stakes[i].totalStaked\n        )\n      );\n    }\n\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Return the accrued rewards for an user over a list of distribution\n   * @param user The address of the user\n   * @param stakes List of structs of the user data related with his stake\n   * @return The accrued rewards for the user until the moment\n   **/\n  function _getUnclaimedRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 accruedRewards = 0;\n\n    for (uint256 i = 0; i < stakes.length; i++) {\n      AssetData storage assetConfig = assets[stakes[i].underlyingAsset];\n      uint256 assetIndex = _getAssetIndex(\n        assetConfig.index,\n        assetConfig.emissionPerSecond,\n        assetConfig.lastUpdateTimestamp,\n        stakes[i].totalStaked\n      );\n\n      accruedRewards = accruedRewards.add(\n        _getRewards(stakes[i].stakedByUser, assetIndex, assetConfig.users[user])\n      );\n    }\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Internal function for the calculation of user's rewards on a distribution\n   * @param principalUserBalance Amount staked by the user on a distribution\n   * @param reserveIndex Current index of the distribution\n   * @param userIndex Index stored for the user, representation his staking moment\n   * @return The rewards\n   **/\n  function _getRewards(\n    uint256 principalUserBalance,\n    uint256 reserveIndex,\n    uint256 userIndex\n  ) internal pure returns (uint256) {\n    return principalUserBalance.mul(reserveIndex.sub(userIndex)).div(10**uint256(PRECISION));\n  }\n\n  /**\n   * @dev Calculates the next value of an specific distribution index, with validations\n   * @param currentIndex Current index of the distribution\n   * @param emissionPerSecond Representing the total rewards distributed per second per asset unit, on the distribution\n   * @param lastUpdateTimestamp Last moment this distribution was updated\n   * @param totalBalance of tokens considered for the distribution\n   * @return The new index.\n   **/\n  function _getAssetIndex(\n    uint256 currentIndex,\n    uint256 emissionPerSecond,\n    uint128 lastUpdateTimestamp,\n    uint256 totalBalance\n  ) internal view returns (uint256) {\n    if (\n      emissionPerSecond == 0 ||\n      totalBalance == 0 ||\n      lastUpdateTimestamp == block.timestamp ||\n      lastUpdateTimestamp >= DISTRIBUTION_END\n    ) {\n      return currentIndex;\n    }\n\n    uint256 currentTimestamp = block.timestamp > DISTRIBUTION_END\n      ? DISTRIBUTION_END\n      : block.timestamp;\n    uint256 timeDelta = currentTimestamp.sub(lastUpdateTimestamp);\n    return\n      emissionPerSecond.mul(timeDelta).mul(10**uint256(PRECISION)).div(totalBalance).add(\n        currentIndex\n      );\n  }\n\n  /**\n   * @dev Returns the data of an user on a distribution\n   * @param user Address of the user\n   * @param asset The address of the reference asset of the distribution\n   * @return The new index\n   **/\n  function getUserAssetData(address user, address asset) public view returns (uint256) {\n    return assets[asset].users[user];\n  }\n}\n"
    },
    "contracts/stake/AaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\n\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {IAToken} from '../interfaces/IAToken.sol';\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\nimport {IStakedAave} from '../interfaces/IStakedAave.sol';\nimport {VersionedInitializable} from '../utils/VersionedInitializable.sol';\nimport {AaveDistributionManager} from './AaveDistributionManager.sol';\n\n/**\n * @title AaveIncentivesController\n * @notice Distributor contract for rewards to the Aave protocol\n * @author Aave\n **/\ncontract AaveIncentivesController is\n  IAaveIncentivesController,\n  VersionedInitializable,\n  AaveDistributionManager\n{\n  uint256 public constant REVISION = 1;\n\n  IStakedAave public immutable PSM;\n\n  IERC20 public immutable REWARD_TOKEN;\n  address public immutable REWARDS_VAULT;\n  uint256 public immutable EXTRA_PSM_REWARD;\n\n  mapping(address => uint256) internal _usersUnclaimedRewards;\n\n  event RewardsAccrued(address indexed user, uint256 amount);\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\n\n  constructor(\n    IERC20 rewardToken,\n    address rewardsVault,\n    IStakedAave psm,\n    uint256 extraPsmReward,\n    address emissionManager,\n    uint128 distributionDuration\n  ) public AaveDistributionManager(emissionManager, distributionDuration) {\n    REWARD_TOKEN = rewardToken;\n    REWARDS_VAULT = rewardsVault;\n    PSM = psm;\n    EXTRA_PSM_REWARD = extraPsmReward;\n  }\n\n  /**\n   * @dev Called by the proxy contract. Not used at the moment, but for the future\n   **/\n  function initialize() external initializer {\n    // to unlock possibility to stake on behalf of the user\n    REWARD_TOKEN.approve(address(PSM), type(uint256).max);\n  }\n\n  /**\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\n   * @param user The address of the user\n   * @param userBalance The balance of the user of the asset in the lending pool\n   * @param totalSupply The total supply of the asset in the lending pool\n   **/\n  function handleAction(\n    address user,\n    uint256 userBalance,\n    uint256 totalSupply\n  ) external override {\n    uint256 accruedRewards = _updateUserAssetInternal(user, msg.sender, userBalance, totalSupply);\n    if (accruedRewards != 0) {\n      _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n  }\n\n  /**\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n   * @param user The address of the user\n   * @return The rewards\n   **/\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    override\n    view\n    returns (uint256)\n  {\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState = new DistributionTypes.UserStakeInput[](\n      assets.length\n    );\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IAToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n    unclaimedRewards = unclaimedRewards.add(_getUnclaimedRewards(user, userState));\n    return unclaimedRewards;\n  }\n\n  /**\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n   * @param amount Amount of rewards to claim\n   * @param to Address that will be receiving the rewards\n   * @param stake Boolean flag to determined if the claimed rewards should be staked in the Safety Module or not\n   * @return Rewards claimed\n   **/\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to,\n    bool stake\n  ) external override returns (uint256) {\n    if (amount == 0) {\n      return 0;\n    }\n    address user = msg.sender;\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState = new DistributionTypes.UserStakeInput[](\n      assets.length\n    );\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IAToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n\n    uint256 accruedRewards = _claimRewards(user, userState);\n    if (accruedRewards != 0) {\n      unclaimedRewards = unclaimedRewards.add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n\n    if (unclaimedRewards == 0) {\n      return 0;\n    }\n\n    uint256 amountToClaim = amount > unclaimedRewards ? unclaimedRewards : amount;\n    _usersUnclaimedRewards[user] = unclaimedRewards - amountToClaim; // Safe due to the previous line\n\n    if (stake) {\n      amountToClaim = amountToClaim.add(amountToClaim.mul(EXTRA_PSM_REWARD).div(100));\n      REWARD_TOKEN.transferFrom(REWARDS_VAULT, address(this), amountToClaim);\n      PSM.stake(to, amountToClaim);\n    } else {\n      REWARD_TOKEN.transferFrom(REWARDS_VAULT, to, amountToClaim);\n    }\n    emit RewardsClaimed(msg.sender, to, amountToClaim);\n\n    return amountToClaim;\n  }\n\n  /**\n   * @dev returns the unclaimed rewards of the user\n   * @param _user the address of the user\n   * @return the unclaimed user rewards\n   */\n  function getUserUnclaimedRewards(address _user) external view returns (uint256) {\n    return _usersUnclaimedRewards[_user];\n  }\n\n  /**\n   * @dev returns the revision of the implementation contract\n   */\n  function getRevision() internal override pure returns (uint256) {\n    return REVISION;\n  }\n}\n"
    },
    "contracts/utils/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n */\nabstract contract VersionedInitializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    uint256 internal lastInitializedRevision = 0;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        uint256 revision = getRevision();\n        require(\n            revision > lastInitializedRevision,\n            'Contract instance has already been initialized'\n        );\n\n        lastInitializedRevision = revision;\n\n        _;\n    }\n\n    /// @dev returns the revision number of the contract.\n    /// Needs to be defined in the inherited class as a constant.\n    function getRevision() internal virtual pure returns (uint256);\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n"
    },
    "contracts/stake/StakedAave.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {StakedToken} from './StakedToken.sol';\n\n/**\n * @title StakedAave\n * @notice StakedToken with AAVE token as staked token\n * @author Aave\n **/\ncontract StakedAave is StakedToken {\n  string internal constant NAME = 'Staked Aave';\n  string internal constant SYMBOL = 'stkAAVE';\n  uint8 internal constant DECIMALS = 18;\n  \n  constructor(\n    IERC20 stakedToken,\n    IERC20 rewardToken,\n    uint256 cooldownSeconds,\n    uint256 unstakeWindow,\n    address rewardsVault,\n    address emissionManager,\n    uint128 distributionDuration\n  ) public StakedToken(\n    stakedToken,\n    rewardToken,\n    cooldownSeconds,\n    unstakeWindow,\n    rewardsVault,\n    emissionManager,\n    distributionDuration,\n    NAME,\n    SYMBOL,\n    DECIMALS) {}\n}\n"
    },
    "contracts/stake/StakedToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {IStakedAave} from '../interfaces/IStakedAave.sol';\nimport {ITransferHook} from '../interfaces/ITransferHook.sol';\nimport {ERC20WithSnapshot} from '../lib/ERC20WithSnapshot.sol';\nimport {SafeERC20} from '../lib/SafeERC20.sol';\nimport {VersionedInitializable} from '../utils/VersionedInitializable.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {AaveDistributionManager} from './AaveDistributionManager.sol';\n\n/**\n * @title StakedToken\n * @notice Contract to stake Aave token, tokenize the position and get rewards, inheriting from a distribution manager contract\n * @author Aave\n **/\ncontract StakedToken is IStakedAave, ERC20WithSnapshot, VersionedInitializable, AaveDistributionManager {\n  using SafeERC20 for IERC20;\n\n  uint256 public constant REVISION = 1;\n\n  IERC20 public immutable STAKED_TOKEN;\n  IERC20 public immutable REWARD_TOKEN;\n  uint256 public immutable COOLDOWN_SECONDS;\n\n  /// @notice Seconds available to redeem once the cooldown period is fullfilled\n  uint256 public immutable UNSTAKE_WINDOW;\n\n  /// @notice Address to pull from the rewards, needs to have approved this contract\n  address public immutable REWARDS_VAULT;\n\n  mapping(address => uint256) public stakerRewardsToClaim;\n  mapping(address => uint256) public stakersCooldowns;\n\n  event Staked(address indexed from, address indexed onBehalfOf, uint256 amount);\n  event Redeem(address indexed from, address indexed to, uint256 amount);\n\n  event RewardsAccrued(address user, uint256 amount);\n  event RewardsClaimed(address indexed from, address indexed to, uint256 amount);\n\n  event Cooldown(address indexed user);\n\n  constructor(\n    IERC20 stakedToken,\n    IERC20 rewardToken,\n    uint256 cooldownSeconds,\n    uint256 unstakeWindow,\n    address rewardsVault,\n    address emissionManager,\n    uint128 distributionDuration,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) public ERC20WithSnapshot(name, symbol, decimals) AaveDistributionManager(emissionManager, distributionDuration) {\n    STAKED_TOKEN = stakedToken;\n    REWARD_TOKEN = rewardToken;\n    COOLDOWN_SECONDS = cooldownSeconds;\n    UNSTAKE_WINDOW = unstakeWindow;\n    REWARDS_VAULT = rewardsVault;\n  }\n\n  /**\n   * @dev Called by the proxy contract\n   **/\n  function initialize(ITransferHook aaveGovernance, string calldata name, string calldata symbol, uint8 decimals) external initializer {\n    _setName(name);\n    _setSymbol(symbol);\n    _setDecimals(decimals);\n    _setAaveGovernance(aaveGovernance);\n  }\n\n  function stake(address onBehalfOf, uint256 amount) external override {\n    require(amount != 0, 'INVALID_ZERO_AMOUNT');\n    uint256 balanceOfUser = balanceOf(onBehalfOf);\n\n    uint256 accruedRewards = _updateUserAssetInternal(\n      onBehalfOf,\n      address(this),\n      balanceOfUser,\n      totalSupply()\n    );\n    if (accruedRewards != 0) {\n      emit RewardsAccrued(onBehalfOf, accruedRewards);\n      stakerRewardsToClaim[onBehalfOf] = stakerRewardsToClaim[onBehalfOf].add(accruedRewards);\n    }\n\n    stakersCooldowns[onBehalfOf] = getNextCooldownTimestamp(0, amount, onBehalfOf, balanceOfUser);\n\n    _mint(onBehalfOf, amount);\n    IERC20(STAKED_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\n\n    emit Staked(msg.sender, onBehalfOf, amount);\n  }\n\n  /**\n   * @dev Redeems staked tokens, and stop earning rewards\n   * @param to Address to redeem to\n   * @param amount Amount to redeem\n   **/\n  function redeem(address to, uint256 amount) external override {\n    require(amount != 0, 'INVALID_ZERO_AMOUNT');\n    //solium-disable-next-line\n    uint256 cooldownStartTimestamp = stakersCooldowns[msg.sender];\n    require(\n      block.timestamp > cooldownStartTimestamp.add(COOLDOWN_SECONDS),\n      'INSUFFICIENT_COOLDOWN'\n    );\n    require(\n      block.timestamp.sub(cooldownStartTimestamp.add(COOLDOWN_SECONDS)) <= UNSTAKE_WINDOW,\n      'UNSTAKE_WINDOW_FINISHED'\n    );\n    uint256 balanceOfMessageSender = balanceOf(msg.sender);\n\n    uint256 amountToRedeem = (amount > balanceOfMessageSender) ? balanceOfMessageSender : amount;\n\n    _updateCurrentUnclaimedRewards(msg.sender, balanceOfMessageSender, true);\n\n    _burn(msg.sender, amountToRedeem);\n\n    if (balanceOfMessageSender.sub(amountToRedeem) == 0) {\n      stakersCooldowns[msg.sender] = 0;\n    }\n\n    IERC20(STAKED_TOKEN).safeTransfer(to, amountToRedeem);\n\n    emit Redeem(msg.sender, to, amountToRedeem);\n  }\n\n  /**\n   * @dev Activates the cooldown period to unstake\n   * - It can't be called if the user is not staking\n   **/\n  function cooldown() external override {\n    require(balanceOf(msg.sender) != 0, \"INVALID_BALANCE_ON_COOLDOWN\");\n    //solium-disable-next-line\n    stakersCooldowns[msg.sender] = block.timestamp;\n\n    emit Cooldown(msg.sender);\n  }\n\n  /**\n   * @dev Claims an `amount` of `REWARD_TOKEN` to the address `to`\n   * @param to Address to stake for\n   * @param amount Amount to stake\n   **/\n  function claimRewards(address to, uint256 amount) external override {\n    uint256 newTotalRewards = _updateCurrentUnclaimedRewards(\n      msg.sender,\n      balanceOf(msg.sender),\n      false\n    );\n    uint256 amountToClaim = (amount == type(uint256).max) ? newTotalRewards : amount;\n\n    stakerRewardsToClaim[msg.sender] = newTotalRewards.sub(amountToClaim, \"INVALID_AMOUNT\");\n\n    REWARD_TOKEN.safeTransferFrom(REWARDS_VAULT, to, amountToClaim);\n\n    emit RewardsClaimed(msg.sender, to, amountToClaim);\n  }\n\n  /**\n   * @dev Internal ERC20 _transfer of the tokenized staked tokens\n   * @param from Address to transfer from\n   * @param to Address to transfer to\n   * @param amount Amount to transfer\n   **/\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override {\n    uint256 balanceOfFrom = balanceOf(from);\n    // Sender\n    _updateCurrentUnclaimedRewards(from, balanceOfFrom, true);\n\n    // Recipient\n    if (from != to) {\n      uint256 balanceOfTo = balanceOf(to);\n      _updateCurrentUnclaimedRewards(to, balanceOfTo, true);\n\n      uint256 previousSenderCooldown = stakersCooldowns[from];\n      stakersCooldowns[to] = getNextCooldownTimestamp(previousSenderCooldown, amount, to, balanceOfTo);\n      // if cooldown was set and whole balance of sender was transferred - clear cooldown\n      if (balanceOfFrom == amount && previousSenderCooldown != 0) {\n        stakersCooldowns[from] = 0;\n      }\n    }\n\n    super._transfer(from, to, amount);\n  }\n\n  /**\n   * @dev Updates the user state related with his accrued rewards\n   * @param user Address of the user\n   * @param userBalance The current balance of the user\n   * @param updateStorage Boolean flag used to update or not the stakerRewardsToClaim of the user\n   * @return The unclaimed rewards that were added to the total accrued\n   **/\n  function _updateCurrentUnclaimedRewards(\n    address user,\n    uint256 userBalance,\n    bool updateStorage\n  ) internal returns (uint256) {\n    uint256 accruedRewards = _updateUserAssetInternal(\n      user,\n      address(this),\n      userBalance,\n      totalSupply()\n    );\n    uint256 unclaimedRewards = stakerRewardsToClaim[user].add(accruedRewards);\n\n    if (accruedRewards != 0) {\n      if (updateStorage) {\n        stakerRewardsToClaim[user] = unclaimedRewards;\n      }\n      emit RewardsAccrued(user, accruedRewards);\n    }\n\n    return unclaimedRewards;\n  }\n\n  /**\n   * @dev Calculates the how is gonna be a new cooldown timestamp depending on the sender/receiver situation\n   *  - If the timestamp of the sender is \"better\" or the timestamp of the recipient is 0, we take the one of the recipient\n   *  - Weighted average of from/to cooldown timestamps if:\n   *    # The sender doesn't have the cooldown activated (timestamp 0).\n   *    # The sender timestamp is expired\n   *    # The sender has a \"worse\" timestamp\n   *  - If the receiver's cooldown timestamp expired (too old), the next is 0\n   * @param fromCooldownTimestamp Cooldown timestamp of the sender\n   * @param amountToReceive Amount\n   * @param toAddress Address of the recipient\n   * @param toBalance Current balance of the receiver\n   * @return The new cooldown timestamp\n   **/\n  function getNextCooldownTimestamp(\n    uint256 fromCooldownTimestamp,\n    uint256 amountToReceive,\n    address toAddress,\n    uint256 toBalance\n  ) public returns (uint256) {\n    uint256 toCooldownTimestamp = stakersCooldowns[toAddress];\n    if (toCooldownTimestamp == 0) {\n      return 0;\n    }\n\n    uint256 minimalValidCooldownTimestamp = block.timestamp.sub(COOLDOWN_SECONDS).sub(\n      UNSTAKE_WINDOW\n    );\n\n    if (minimalValidCooldownTimestamp > toCooldownTimestamp) {\n      toCooldownTimestamp = 0;\n    } else {\n      uint256 fromCooldownTimestamp = (minimalValidCooldownTimestamp > fromCooldownTimestamp)\n        ? block.timestamp\n        : fromCooldownTimestamp;\n\n      if (fromCooldownTimestamp < toCooldownTimestamp) {\n        return toCooldownTimestamp;\n      } else {\n        toCooldownTimestamp = (\n          amountToReceive.mul(fromCooldownTimestamp).add(toBalance.mul(toCooldownTimestamp))\n        )\n          .div(amountToReceive.add(toBalance));\n      }\n    }\n    stakersCooldowns[toAddress] = toCooldownTimestamp;\n\n    return toCooldownTimestamp;\n  }\n\n  /**\n   * @dev Return the total rewards pending to claim by an staker\n   * @param staker The staker address\n   * @return The rewards\n   */\n  function getTotalRewardsBalance(address staker) external view returns (uint256) {\n\n      DistributionTypes.UserStakeInput[] memory userStakeInputs\n     = new DistributionTypes.UserStakeInput[](1);\n    userStakeInputs[0] = DistributionTypes.UserStakeInput({\n      underlyingAsset: address(this),\n      stakedByUser: balanceOf(staker),\n      totalStaked: totalSupply()\n    });\n    return stakerRewardsToClaim[staker].add(_getUnclaimedRewards(staker, userStakeInputs));\n  }\n\n  /**\n   * @dev returns the revision of the implementation contract\n   * @return The revision\n   */\n  function getRevision() internal override pure returns (uint256) {\n    return REVISION;\n  }\n}\n"
    },
    "contracts/utils/MintableErc20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport '../lib/ERC20.sol';\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract MintableErc20 is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) public ERC20(name, symbol, decimals) {}\n\n    /**\n     * @dev Function to mint tokens\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(uint256 value) public returns (bool) {\n        _mint(msg.sender, value);\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "istanbul",
    "libraries": {}
  }
}}