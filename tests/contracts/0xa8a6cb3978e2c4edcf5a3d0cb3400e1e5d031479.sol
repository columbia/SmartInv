{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\u0027t, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * \u003e To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * \u003e a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"ERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./Address.sol\";\nimport \"./Context.sol\";\nimport \"./Strings.sol\";\nimport \"./ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 =\u003e address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address =\u003e uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 =\u003e address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\u0027s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``\u0027s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IERC2981.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Called with the sale price to determine how much royalty is owed and to whom.\n     * @param tokenId - the NFT asset queried for royalty information\n     * @param salePrice - the sale price of the NFT asset specified by `tokenId`\n     * @return receiver - address of who should be sent the royalty payment\n     * @return royaltyAmount - the royalty payment amount for `salePrice`\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"},"IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"},"IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"},"IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"ImmutablesArt.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n// All Rights Reserved\r\n\r\n// Contract is not audited.\r\n// Use authorized deployments of this contract at your own risk.\r\n\r\n/*\r\n██╗███╗   ███╗███╗   ███╗██╗   ██╗████████╗ █████╗ ██████╗ ██╗     ███████╗███████╗    █████╗ ██████╗ ████████╗\r\n██║████╗ ████║████╗ ████║██║   ██║╚══██╔══╝██╔══██╗██╔══██╗██║     ██╔════╝██╔════╝   ██╔══██╗██╔══██╗╚══██╔══╝\r\n██║██╔████╔██║██╔████╔██║██║   ██║   ██║   ███████║██████╔╝██║     █████╗  ███████╗   ███████║██████╔╝   ██║\r\n██║██║╚██╔╝██║██║╚██╔╝██║██║   ██║   ██║   ██╔══██║██╔══██╗██║     ██╔══╝  ╚════██║   ██╔══██║██╔══██╗   ██║\r\n██║██║ ╚═╝ ██║██║ ╚═╝ ██║╚██████╔╝   ██║   ██║  ██║██████╔╝███████╗███████╗███████║██╗██║  ██║██║  ██║   ██║\r\n╚═╝╚═╝     ╚═╝╚═╝     ╚═╝ ╚═════╝    ╚═╝   ╚═╝  ╚═╝╚═════╝ ╚══════╝╚══════╝╚══════╝╚═╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Strings.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./ERC721.sol\";\r\nimport \"./IERC2981.sol\";\r\nimport \"./SafeERC20.sol\";\r\nimport \"./Clones.sol\";\r\nimport \"./Address.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\nimport \"./ImmutablesArtRoyaltyManager.sol\";\r\n\r\n/// @author Gutenblock.eth\r\n/// @title ImmutablesAdmin\r\ncontract ImmutablesAdmin is Ownable, ReentrancyGuard {\r\n  using Address for address payable;\r\n\r\n  /// @dev Address of a third party curator.\r\n  address public curator;\r\n  /// @dev basis point (1/10,000th) share of third party curator on payout.\r\n  uint16 public curatorPercent;\r\n\r\n  /// @dev Address of a third party beneficiary.\r\n  address public beneficiary;\r\n  /// @dev basis point (1/10,000th) share of third party beneficiary on payout.\r\n  uint16 public beneficiaryPercent;\r\n\r\n  /// @dev Teammember administration mapping\r\n  mapping(address =\u003e bool) public isTeammember;\r\n\r\n  /// @dev MODIFIERS\r\n\r\n  modifier onlyTeammember() {\r\n      require(isTeammember[msg.sender], \"team\");\r\n      _;\r\n  }\r\n\r\n  /// @dev EVENTS\r\n\r\n  event AdminModifiedTeammembers(\r\n    address indexed user,\r\n    bool isTeammember\r\n  );\r\n\r\n  /** @dev Allows the contract owner to add a teammember.\r\n    * @param _address of teammember to add.\r\n    */\r\n  function contractOwnerAddTeammember(address _address) external onlyOwner() {\r\n      isTeammember[_address] = true;\r\n      emit AdminModifiedTeammembers(_address, true);\r\n  }\r\n\r\n  /** @dev Allows the contract owner to remove a teammember.\r\n    * @param _address of teammember to remove.\r\n    */\r\n  function contractOwnerRemoveTeammember(address _address) external onlyOwner() {\r\n      isTeammember[_address] = false;\r\n      emit AdminModifiedTeammembers(_address, false);\r\n  }\r\n\r\n  /// @dev FINANCIAL\r\n\r\n  /** @dev Allows the contract owner to set a curator address and percentage.\r\n    * @dev Force payout of any curator that was previously set\r\n    * @dev so that funds paid with a curator set are paid out as promised.\r\n    * @param _newCurator address of a curator teammember.\r\n    * @param _newPercent the basis point (1/10,000th) share of contract revenue for the curator.\r\n    */\r\n  function contractOwnerUpdateCuratorAddressAndPercent(address _newCurator, uint16 _newPercent) external onlyOwner() {\r\n    require(_newPercent \u003c= (10000-beneficiaryPercent));\r\n    withdraw();\r\n    isTeammember[curator] = false;\r\n    emit AdminModifiedTeammembers(curator, false);\r\n    isTeammember[_newCurator] = true;\r\n    emit AdminModifiedTeammembers(_newCurator, true);\r\n    curator = _newCurator;\r\n    curatorPercent = _newPercent;\r\n  }\r\n\r\n  /** @dev Allows the contract owner to set a beneficiary address and percentage.\r\n    * @dev Force payout of any beneficiary that was previously set\r\n    * @dev so that funds paid with a beneficiary set are paid out as promised.\r\n    * @param _newBeneficiary address of a beneficiary.\r\n    * @param _newPercent the basis point (1/10,000th) share of contract revenue for the beneficiary.\r\n    */\r\n  function contractOwnerUpdateBeneficiaryAddressAndPercent(address _newBeneficiary, uint16 _newPercent) external onlyOwner() {\r\n    require(_newPercent \u003c= (10000-curatorPercent));\r\n    withdraw();\r\n    beneficiary = _newBeneficiary;\r\n    beneficiaryPercent = _newPercent;\r\n  }\r\n\r\n  /** @dev Allows the withdraw of funds.\r\n    * @dev Everyone is paid and the contract balance is zeroed out.\r\n    */\r\n  function withdraw() public nonReentrant() {\r\n    // checks\r\n    // effects\r\n    uint256 _startingBalance = address(this).balance;\r\n    uint256 _curatorValue = _startingBalance * curatorPercent / 10000;\r\n    uint256 _beneficiaryValue = _startingBalance * beneficiaryPercent / 10000;\r\n    uint256 _contractValue = _startingBalance - _curatorValue - _beneficiaryValue;\r\n\r\n    // interactions\r\n    payable(this.owner()).sendValue(_contractValue);\r\n    payable(curator).sendValue(_curatorValue);\r\n    payable(beneficiary).sendValue(_beneficiaryValue);\r\n  }\r\n\r\n  /** @dev Allows the withdraw of funds.\r\n    * @dev Everyone is paid and the contract balance is zeroed out.\r\n    */\r\n  function withdrawERC20(IERC20 token) external nonReentrant() {\r\n    // checks\r\n    uint256 _startingBalance = token.balanceOf(address(this));\r\n    require(_startingBalance \u003e 0, \"no tokens\");\r\n\r\n    // effects\r\n    uint256 _curatorValue = _startingBalance * curatorPercent / 10000;\r\n    uint256 _beneficiaryValue = _startingBalance * beneficiaryPercent / 10000;\r\n    uint256 _contractValue = _startingBalance - _curatorValue - _beneficiaryValue;\r\n\r\n    // interactions\r\n    SafeERC20.safeTransfer(token, this.owner(), _contractValue);\r\n    if(curator != address(0) \u0026\u0026 _curatorValue \u003e 0) {\r\n      SafeERC20.safeTransfer(token, curator, _curatorValue);\r\n    }\r\n    if(beneficiary != address(0) \u0026\u0026 _beneficiaryValue \u003e 0) {\r\n      SafeERC20.safeTransfer(token, beneficiary, _beneficiaryValue);\r\n    }\r\n  }\r\n}\r\n\r\n/// @author Gutenblock.eth\r\n/// @title ImmutablesAdminProject\r\ncontract ImmutablesAdminProject is ImmutablesAdmin {\r\n  /// @dev The fee paid to the contract to create a project.\r\n  uint256 public projectFee;\r\n  /// @dev The last projectId created.\r\n  uint256 public currentProjectId;\r\n  /// @dev Featured project.\r\n  uint256 public featuredProjectId;\r\n\r\n  /// @dev basis point (1/10,000th) share the artist receives of each sale.\r\n  uint16 public artistPercent;\r\n  /// @dev whether or not artists need to be pre-screened.\r\n  bool public artistScreeningEnabled = false;\r\n\r\n  /// @dev Template Cloneable Royalty Manager Contract\r\n  ImmutablesArtRoyaltyManager public implementation;\r\n\r\n  struct Project {\r\n    // Name of the project and the corresponding Immutables.co page name.\r\n    string name;\r\n    // Name of the artist.\r\n    string artist;\r\n    // Project description.\r\n    string description;\r\n\r\n    // Current highest minted edition number.\r\n    uint256 currentEditionId;\r\n    // Maximum number of editions that can be minted.\r\n    uint256 maxEditions;\r\n\r\n    // The maximum number of editions to display at once in the grid view.\r\n    // For works that are easier to generate many may be shown at once.\r\n    // For more processor intensive works the artist may want to limit the\r\n    // number on screen at any given time to reduce lag.\r\n    uint8 maxGridDimension;\r\n\r\n    // The Immutables.co Post transaction hash containing the generative art\r\n    // script to run.\r\n    string scriptTransactionHash;\r\n    // The type of script that is referenced in the transaction hash.\r\n    // Used to tell Grid what type of Cell to use for the script.\r\n    string scriptType;\r\n\r\n    // A category that can be assigned by a Teammember for curation.\r\n    string category;\r\n\r\n    // Whether the project is Active and available for third parties to view.\r\n    bool active;\r\n    // Whether the project minting is paused to the public.\r\n    bool paused;\r\n    // Whether or not the main project attributes are locked from editing.\r\n    bool locked;\r\n  }\r\n\r\n  /// @dev Mappings between the page string and tokenId.\r\n  mapping(uint256 =\u003e Project) public projects;\r\n\r\n  /// @dev Mappings between the projectId, Price, and Artist Payees\r\n  mapping(uint256 =\u003e address) public projectIdToArtistAddress;\r\n  mapping(uint256 =\u003e uint256) public projectIdToPricePerEditionInWei;\r\n  mapping(uint256 =\u003e address) public projectIdToAdditionalPayee;\r\n  mapping(uint256 =\u003e uint16) public projectIdToAdditionalPayeePercent;\r\n\r\n  /// @dev Allow for a per-project royalty address\r\n  mapping(uint256 =\u003e address) public projectIdToRoyaltyAddress;\r\n\r\n  /// @dev EIP2981 royaltyInfo basis point (1/10,000th) share of secondary\r\n  ///      sales (for all projects).\r\n  uint16 public secondaryRoyaltyPercent;\r\n\r\n  /// @dev A mapping from a project to a base URL like a IPFS CAR file CID\r\n  ///     (e.g., that can be obtained from from nft.storage)\r\n  mapping(uint256 =\u003e string) public projectIdToImageURLBase;\r\n  /// @dev The file extension for the individual items in the CAR file\r\n  ///      (e.g., \".png\")\r\n  mapping(uint256 =\u003e string) public projectIdToImageURLExt;\r\n  /// @dev Whether to use the Image URL in the Grid View instead of live render.\r\n  mapping(uint256 =\u003e bool) public projectIdUseImageURLInGridView;\r\n\r\n  /// @dev Mapping of artists authorized to use the platform\r\n  ///      if artist screening is enabled.\r\n  mapping(address =\u003e bool) public isAuthorizedArtist;\r\n\r\n  /// @dev MODIFIERS\r\n\r\n  modifier onlyUnlocked(uint256 _projectId) {\r\n      require(!projects[_projectId].locked, \"locked\");\r\n      _;\r\n  }\r\n\r\n  modifier onlyArtist(uint256 _projectId) {\r\n    require(msg.sender == projectIdToArtistAddress[_projectId], \"artist\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyArtistOrTeammember(uint256 _projectId) {\r\n      require(isTeammember[msg.sender] || msg.sender == projectIdToArtistAddress[_projectId], \"artistTeam\");\r\n      _;\r\n  }\r\n\r\n  modifier onlyAuthorizedArtist() {\r\n    if(artistScreeningEnabled) {\r\n      require(isAuthorizedArtist[msg.sender], \"auth\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  /// @dev EVENTS\r\n\r\n  event AddressCreatedProject(\r\n    address indexed artist,\r\n    uint256 indexed projectId,\r\n    string projectName\r\n  );\r\n\r\n  event AdminUpdatedAuthorizedArtist(\r\n    address indexed user,\r\n    bool isAuthorizedArtist\r\n  );\r\n\r\n  event AdminUpdatedProjectCategory(\r\n      uint256 indexed projectId,\r\n      string category\r\n  );\r\n\r\n  event CreatedImmutablesArtRoyaltyManagerForProjectId(\r\n      address indexed royaltyManager,\r\n      uint256 indexed projectId\r\n  );\r\n\r\n  /// @dev CONSTRUCTOR\r\n\r\n  constructor() {\r\n    implementation = new ImmutablesArtRoyaltyManager();\r\n    implementation.initialize(address(this), 1, address(this), artistPercent, address(0), 0);\r\n  }\r\n\r\n  /** @dev Allows the teammember to add an artist.\r\n    * @param _address of artist to add\r\n    */\r\n  function teamAddAuthorizedArtist(address _address) external onlyTeammember() {\r\n      isAuthorizedArtist[_address] = true;\r\n      emit AdminUpdatedAuthorizedArtist(_address, true);\r\n  }\r\n\r\n  /** @dev Allows the teammember to remove an artist.\r\n    * @param _address of artist to remove\r\n    */\r\n  function teamRemoveAuthorizedArtist(address _address) external onlyTeammember() {\r\n      isAuthorizedArtist[_address] = false;\r\n      emit AdminUpdatedAuthorizedArtist(_address, false);\r\n  }\r\n\r\n  /** @dev Allows the teammember to set a featured project id\r\n    * @param _projectId of featured project\r\n    */\r\n  function teamUpdateFeaturedProject(uint256 _projectId) external onlyTeammember() {\r\n    require(_projectId \u003c= currentProjectId);\r\n    featuredProjectId = _projectId;\r\n  }\r\n\r\n  /** @dev Allows the contract owner to update the project fee.\r\n    * @param _newProjectFee The new project fee in Wei.\r\n    */\r\n  function contractOwnerUpdateProjectFee(uint256 _newProjectFee) external onlyOwner() {\r\n    projectFee = _newProjectFee;\r\n  }\r\n\r\n  /** @dev Allows the contract owner to update the artist cut of sales.\r\n    * @param _percent The new artist percentage\r\n    */\r\n  function contractOwnerUpdateArtistPercent(uint16 _percent) external onlyOwner() {\r\n    require(_percent \u003e= 5000, \"\u003e=5000\");   // minimum amount an artist should get 50.00%\r\n    require(_percent \u003c= 10000, \"\u003c=10000\"); // maximum amount artists should get 100.00%\r\n    artistPercent = _percent;\r\n  }\r\n\r\n  /** @dev Allows the contract owner to unlock a project.\r\n    * @param _projectId of the project to unlock\r\n    */\r\n  function contractOwnerUnlockProject(uint256 _projectId) external onlyOwner() {\r\n    projects[_projectId].locked = false;\r\n  }\r\n\r\n  /** @dev Allows the contract owner to set the royalty percent.\r\n    * @param _newPercent royalty percent\r\n    */\r\n  function contractOwnerUpdateGlobalSecondaryRoyaltyPercent(uint16 _newPercent) external onlyOwner() {\r\n    secondaryRoyaltyPercent = _newPercent;\r\n  }\r\n\r\n  /// @dev ANYONE - CREATING A PROJECT AND PROJECT ADMINISTRATION\r\n\r\n  /** @dev Allows anyone to create a project _projectName, with _pricePerTokenInWei and _maxEditions.\r\n    * @param _projectName A name of a project\r\n    * @param _pricePerTokenInWei The price for each mint\r\n    * @param _maxEditions The total number of editions for this project\r\n    */\r\n  function anyoneCreateProject(\r\n    string calldata _projectName,\r\n    string calldata _artistName,\r\n    string calldata _description,\r\n    uint256 _pricePerTokenInWei,\r\n    uint256 _maxEditions,\r\n    string calldata _scriptTransactionHash,\r\n    string calldata _scriptType\r\n  ) external payable onlyAuthorizedArtist() {\r\n      require(msg.value \u003e= projectFee, \"project fee\");\r\n      require(bytes(_projectName).length \u003e 0);\r\n      require(bytes(_artistName).length \u003e 0);\r\n      require(_maxEditions \u003e 0 \u0026\u0026 _maxEditions \u003c= 1000000);\r\n\r\n      currentProjectId++;\r\n      uint256 _projectId = currentProjectId;\r\n      projects[_projectId].name = _projectName;\r\n      projects[_projectId].artist = _artistName;\r\n      projects[_projectId].description = _description;\r\n\r\n      projectIdToArtistAddress[_projectId] = msg.sender;\r\n      projectIdToPricePerEditionInWei[_projectId] = _pricePerTokenInWei;\r\n      projects[_projectId].currentEditionId = 0;\r\n      projects[_projectId].maxEditions = _maxEditions;\r\n\r\n      projects[_projectId].maxGridDimension = 10;\r\n\r\n      projects[_projectId].scriptTransactionHash = _scriptTransactionHash;\r\n      projects[_projectId].scriptType = _scriptType;\r\n\r\n      projects[_projectId].active = false;\r\n      projects[_projectId].paused = true;\r\n      projects[_projectId].locked = false;\r\n\r\n      setupImmutablesArtRoyaltyManagerForProjectId(_projectId);\r\n\r\n      emit AddressCreatedProject(msg.sender, _projectId, _projectName);\r\n  }\r\n\r\n  /** @dev Clones a Royalty Manager Contract for a new Project ID\r\n    * @param _projectId the projectId.\r\n    */\r\n  function setupImmutablesArtRoyaltyManagerForProjectId(uint256 _projectId) internal {\r\n      // checks\r\n      require(projectIdToRoyaltyAddress[_projectId] == address(0), \"royalty manager already exists for _projectId\");\r\n\r\n      // effects\r\n      address _newManager = Clones.clone(address(implementation));\r\n      projectIdToRoyaltyAddress[_projectId] = address(_newManager);\r\n\r\n      // interactions\r\n      ImmutablesArtRoyaltyManager(payable(_newManager)).initialize(address(this), _projectId, projectIdToArtistAddress[_projectId], artistPercent, address(0), 0);\r\n      emit CreatedImmutablesArtRoyaltyManagerForProjectId(address(_newManager), _projectId);\r\n  }\r\n\r\n  /** @dev Releases funds from a Royalty Manager for a Project Id\r\n    * @param _projectId the projectId.\r\n    */\r\n  function releaseRoyaltiesForProject(uint256 _projectId) external {\r\n      ImmutablesArtRoyaltyManager(payable(projectIdToRoyaltyAddress[_projectId])).release();\r\n  }\r\n\r\n  /// @dev ARTIST UPDATE FUNCTIONS\r\n\r\n  /** @dev Allows the artist to update the artist\u0027s Eth address in the contract, and in the Royalty Manager.\r\n    * @param _projectId the projectId.\r\n    * @param _newArtistAddress the new Eth address for the artist.\r\n    */\r\n  function artistUpdateProjectArtistAddress(uint256 _projectId, address _newArtistAddress) external onlyArtist(_projectId) {\r\n      projectIdToArtistAddress[_projectId] = _newArtistAddress;\r\n      ImmutablesArtRoyaltyManager(payable(projectIdToRoyaltyAddress[_projectId])).artistUpdateAddress(_newArtistAddress);\r\n  }\r\n\r\n  /** @dev Allows the artist to update project additional payee info.\r\n    * @param _projectId the projectId.\r\n    * @param _additionalPayee the additional payee address.\r\n    * @param _additionalPayeePercent the basis point (1/10,000th) share of project for the _additionalPayee up to artistPercent (e.g., 5000 = 50.0%).\r\n    */\r\n  function artistUpdateProjectAdditionalPayeeInfo(uint256 _projectId, address _additionalPayee, uint16 _additionalPayeePercent) external onlyArtist(_projectId)  {\r\n      // effects\r\n      projectIdToAdditionalPayee[_projectId] = _additionalPayee;\r\n      projectIdToAdditionalPayeePercent[_projectId] = _additionalPayeePercent;\r\n\r\n      // interactions\r\n      ImmutablesArtRoyaltyManager(payable(projectIdToRoyaltyAddress[_projectId])).artistUpdateAdditionalPayeeInfo(_additionalPayee, _additionalPayeePercent);\r\n  }\r\n\r\n  // ARTIST OR TEAMMEMBER UPDATE FUNCTIONS\r\n\r\n  /** @dev Allows the artist or team to update the price per token in wei for a project.\r\n    * @param _projectId the projectId.\r\n    * @param _pricePerTokenInWei new price per token for projectId\r\n    */\r\n  function artistTeamUpdateProjectPricePerTokenInWei(uint256 _projectId, uint256 _pricePerTokenInWei) external onlyArtistOrTeammember(_projectId) {\r\n      projectIdToPricePerEditionInWei[_projectId] = _pricePerTokenInWei;\r\n  }\r\n\r\n  /** @dev Allows the artist or team to update the maximum number of editions\r\n    * @dev to display at once in the grid view.\r\n    * @param _projectId the projectId.\r\n    * @param _maxGridDimension the maximum number of editions per side of Grid View Square.\r\n    */\r\n  function artistTeamUpdateProjectMaxGridDimension(uint256 _projectId, uint8 _maxGridDimension) external onlyArtistOrTeammember(_projectId) {\r\n      require(_maxGridDimension \u003e 0);\r\n      require(_maxGridDimension \u003c= 255);\r\n      projects[_projectId].maxGridDimension = _maxGridDimension;\r\n  }\r\n\r\n  /** @dev Allows the artist or team to update the maximum number of editions\r\n    * @dev that can be minted for a project.\r\n    * @param _projectId the projectId.\r\n    * @param _maxEditions the maximum number of editions for a project.\r\n    */\r\n  function artistTeamUpdateProjectMaxEditions(uint256 _projectId, uint256 _maxEditions) onlyUnlocked(_projectId) external onlyArtistOrTeammember(_projectId) {\r\n      require(_maxEditions \u003e= projects[_projectId].currentEditionId);\r\n      require(_maxEditions \u003c= 1000000);\r\n      projects[_projectId].maxEditions = _maxEditions;\r\n  }\r\n\r\n  /** @dev Allows the artist or team to update the project name.\r\n    * @param _projectId the projectId.\r\n    * @param _projectName the new project name.\r\n    */\r\n  function artistTeamUpdateProjectName(uint256 _projectId, string memory _projectName) onlyUnlocked(_projectId) external onlyArtistOrTeammember(_projectId) {\r\n      projects[_projectId].name = _projectName;\r\n  }\r\n\r\n  /** @dev Allows the artist or team to update the artist\u0027s name.\r\n    * @param _projectId the projectId.\r\n    * @param _artistName the new artist name.\r\n    */\r\n  function artistTeamUpdateArtistName(uint256 _projectId, string memory _artistName) onlyUnlocked(_projectId) external onlyArtistOrTeammember(_projectId) {\r\n      projects[_projectId].artist = _artistName;\r\n  }\r\n\r\n  /** @dev Allows the artist or team update project description.\r\n    * @param _projectId the projectId.\r\n    * @param _description the description for the project.\r\n    */\r\n  function artistTeamUpdateProjectDescription(uint256 _projectId, string calldata _description) onlyUnlocked(_projectId) external onlyArtistOrTeammember(_projectId) {\r\n      projects[_projectId].description = _description;\r\n  }\r\n\r\n  /** @dev Allows the artist or team to update the project code transaction\r\n    * @dev hash. The project code should be added to the referenced Immutables\r\n    * @dev page as a Post starting with a line contaning three tick marks ```\r\n    * @dev and ending with a line consisting of three tick marks ```.  The code\r\n    * @dev will then be stored in a Post that has an Eth transaction hash.\r\n    * @dev Add the transaction hash for the code Post to the project using this\r\n    * @dev function. The code will then be pulled from this transaction hash\r\n    * @dev for each render associated with this project.\r\n    * @param _projectId the projectId.\r\n    * @param _scriptTransactionHash the Ethereum transaction hash storing the code.\r\n    */\r\n  function artistTeamUpdateProjectScriptTransactionHash(uint256 _projectId, string memory _scriptTransactionHash) external onlyUnlocked(_projectId) onlyArtistOrTeammember(_projectId) {\r\n      projects[_projectId].scriptTransactionHash = _scriptTransactionHash;\r\n  }\r\n\r\n  /** @dev Allows the artist or team to update the project script type.\r\n    * @dev The code contained in the transaction hash will be interpreted\r\n    * @dev by the front end based on the script type.\r\n    * @param _projectId the projectId.\r\n    * @param _scriptType the script type (e.g., p5js)\r\n    */\r\n  function artistTeamUpdateProjectScriptType(uint256 _projectId, string memory _scriptType) external onlyUnlocked(_projectId) onlyArtistOrTeammember(_projectId) {\r\n         projects[_projectId].scriptType = _scriptType;\r\n  }\r\n\r\n  /** @dev Allows the artist or team toggle whether the project is paused.\r\n    * @dev A paused project can only be minted by the artist or team.\r\n    * @param _projectId the projectId.\r\n    */\r\n  function artistTeamToggleProjectIsPaused(uint256 _projectId) external onlyArtistOrTeammember(_projectId) {\r\n      projects[_projectId].paused = !projects[_projectId].paused;\r\n  }\r\n\r\n  /** @dev Allows the artist or team to set an image URL and file extension.\r\n    * @dev Once project editions are minted, an IPFS CAR file can be created.\r\n    * @dev The CAR file can contain image files with filenames corresponding to\r\n    * @dev the Immutables.art tokenIds for the project. The CAR file can be\r\n    * @dev stored on IPFS, the conract updated with the _newImageURLBase and\r\n    * @dev _newFileExtension and then token images can be found by going to:\r\n    * @dev _newImageBase = ipfs://[cid for the car file]/\r\n    * @dev _newImageURLExt = \".png\"\r\n    * @dev Resulting URL = ipfs://[cid for the car file]/[tokenId].png\r\n    * @param _projectId the projectId.\r\n    * @param _newImageURLBase the base for the image url (e.g., \"ipfs://[cid]/\" )\r\n    * @param _newImageURLExt the file extension for the image file (e.g., \".png\" , \".gif\" , etc.).\r\n    * @param _useImageURLInGridView bool whether to use the ImageURL in the Grid instead of a live render.\r\n    */\r\n  function artistTeamUpdateProjectImageURLInfo(uint256 _projectId,\r\n                                      string calldata _newImageURLBase,\r\n                                      string calldata _newImageURLExt,\r\n                                      bool _useImageURLInGridView)\r\n                                      external onlyArtistOrTeammember(_projectId) {\r\n    projectIdToImageURLBase[_projectId] = _newImageURLBase;\r\n    projectIdToImageURLExt[_projectId] = _newImageURLExt;\r\n    projectIdUseImageURLInGridView[_projectId] = _useImageURLInGridView;\r\n  }\r\n\r\n  /** @dev Allows the artist or team to lock a project.\r\n    * @dev Projects that are locked cannot have certain attributes modified.\r\n    * @param _projectId the projectId.\r\n    */\r\n  function artistTeamLockProject(uint256 _projectId) external onlyUnlocked(_projectId) onlyArtistOrTeammember(_projectId) {\r\n      projects[_projectId].locked = true;\r\n  }\r\n\r\n  // TEAMMEMBER ONLY UPDATE FUNCTIONS\r\n\r\n  /** @dev Allows the team to set a category for a project.\r\n    * @param _projectId the projectId.\r\n    * @param _category string category name for the project.\r\n    */\r\n  function teamUpdateProjectCategory(uint256 _projectId, string calldata _category) external onlyTeammember() {\r\n      projects[_projectId].category = _category;\r\n      emit AdminUpdatedProjectCategory(_projectId, _category);\r\n  }\r\n\r\n  /** @dev Allows the team toggle whether the project is active.\r\n    * @dev Only active projects are visible to the public.\r\n    * @param _projectId the projectId.\r\n    */\r\n  function teamToggleProjectIsActive(uint256 _projectId) external onlyTeammember() {\r\n      projects[_projectId].active = !projects[_projectId].active;\r\n  }\r\n\r\n  /** @dev Allows the team to toggle whether or not only approved artists are\r\n    * @dev allowed to create projects.\r\n    */\r\n  function teamToggleArtistScreeningEnabled() external onlyTeammember() {\r\n      artistScreeningEnabled = !artistScreeningEnabled;\r\n  }\r\n}\r\n\r\n/// @author Gutenblock.eth\r\n/// @title ImmutablesOptionalMetadataServer\r\ncontract ImmutablesOptionalMetadataServer is Ownable {\r\n    /// @dev Stores the base web address for the Immutables web server.\r\n    string public immutablesWEB;\r\n    /// @dev Stores the base URI for the Immutables Metadata server.\r\n    string public immutablesURI;\r\n    /// @dev Whether to serve metadata from the server, or from the contract.\r\n    bool public useMetadataServer;\r\n\r\n    constructor () {\r\n      immutablesWEB = \"http://immutables.art/#/\";\r\n      immutablesURI = \"http://nft.immutables.art/\";\r\n      useMetadataServer = false;\r\n    }\r\n\r\n    /** @dev Allows the contract owner to update the website URL.\r\n      * @param _newImmutablesWEB The new website URL as a string.\r\n      */\r\n    function contractOwnerUpdateWebsite(string calldata _newImmutablesWEB) external onlyOwner() {\r\n      immutablesWEB = _newImmutablesWEB;\r\n    }\r\n\r\n    /** @dev Allows the contract owner to update the metadata server URL.\r\n      * @param _newImmutablesURI The new metadata server url as a string.\r\n      */\r\n    function contractOwnerUpdateAPIURL(string calldata _newImmutablesURI) external onlyOwner() {\r\n      immutablesURI = _newImmutablesURI;\r\n    }\r\n\r\n    /** @dev Allows the contract owner to set the metadata source.\r\n      * @param _shouldUseMetadataServer true or false\r\n      */\r\n    function contractOwnerUpdateUseMetadataServer(bool _shouldUseMetadataServer) external onlyOwner() {\r\n      useMetadataServer = _shouldUseMetadataServer;\r\n    }\r\n}\r\n\r\n/// @author Gutenblock.eth\r\n/// @title ImmutablesArt\r\ncontract ImmutablesArt is ImmutablesAdminProject, ImmutablesOptionalMetadataServer, ERC721, IERC2981 {\r\n    using Strings for uint256;\r\n    using Address for address payable;\r\n\r\n    /// @dev GLOBAL VARIABLES\r\n\r\n    /// @dev The total suppliy of tokens (Editions of all Projects).\r\n    uint256 public maxTotalSupply;\r\n    /// @dev The last tokenId minted.\r\n    uint256 public currentTokenId;\r\n\r\n    /// @dev Mappings between the tokenId, projectId, editionIds, and Hashes\r\n    mapping(uint256 =\u003e uint256) public tokenIdToProjectId;\r\n    mapping(uint256 =\u003e uint256) public tokenIdToEditionId;\r\n    mapping(uint256 =\u003e uint256[]) public projectIdToTokenIds;\r\n\r\n    /// @dev MODIFIERS\r\n\r\n    modifier onlyOwnerOfToken(uint256 _tokenId) {\r\n      require(msg.sender == ownerOf(_tokenId), \"must own\");\r\n      _;\r\n    }\r\n\r\n    modifier onlyArtistOrOwnerOfToken(uint256 _tokenId) {\r\n      require(msg.sender == ownerOf(_tokenId) || msg.sender == projectIdToArtistAddress[tokenIdToProjectId[_tokenId]], \"artistOwner\");\r\n      _;\r\n    }\r\n\r\n    /// @dev EVENTS\r\n\r\n    event PaymentReceived(address from, uint256 amount);\r\n\r\n    event AddressMintedProjectEditionAsToken(\r\n      address indexed purchaser,\r\n      uint256 indexed projectId,\r\n      uint256 editionId,\r\n      uint256 indexed tokenId\r\n    );\r\n\r\n    event TokenUpdatedWithMessage(\r\n      address indexed user,\r\n      uint256 indexed tokenId,\r\n      string message\r\n    );\r\n\r\n    /// @dev CONTRACT CONSTRUCTOR\r\n\r\n    constructor () ERC721(\"Immutables.art\", \"][art\") ImmutablesOptionalMetadataServer() {\r\n      projectFee = 0 ether;\r\n\r\n      maxTotalSupply = ~uint256(0);\r\n      currentTokenId = 0;\r\n\r\n      currentProjectId = 0;\r\n\r\n      artistScreeningEnabled = false;\r\n      artistPercent = 9000; // 90.00%\r\n\r\n      curator = address(0);\r\n      curatorPercent = 0;\r\n\r\n      beneficiary = address(0);\r\n      beneficiaryPercent = 0;\r\n\r\n      secondaryRoyaltyPercent = 1000; // 10.00%\r\n\r\n      isTeammember[msg.sender] = true;\r\n\r\n      emit AdminModifiedTeammembers(msg.sender, true);\r\n    }\r\n\r\n    /// @dev FINANCIAL\r\n\r\n    receive() external payable virtual {\r\n        emit PaymentReceived(_msgSender(), msg.value);\r\n    }\r\n\r\n    /// @dev HELPER FUNCTIONS\r\n\r\n    /** @dev Returns a list of tokenIds for a given projectId.\r\n      * @param _projectId the projectId.\r\n      * @return _tokenIds an array of tokenIds for the given project.\r\n      */\r\n    function getTokenIdsForProjectId(uint256 _projectId) external view returns (uint256[] memory _tokenIds) {\r\n        return projectIdToTokenIds[_projectId];\r\n    }\r\n\r\n    /** @dev Used if a web2.0 style metadata server is required for more full\r\n      * @dev featured legacy marketplace compatability.\r\n      * @return _ the metadata server baseURI if a metadata server is used.\r\n      */\r\n    function _baseURI() internal view override returns (string memory) {\r\n      return immutablesURI;\r\n    }\r\n\r\n    /** @dev Returns a string from a uint256\r\n      * @param value uint256 data type string\r\n      * @return _ string data type.\r\n      */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n            if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /** @dev Returns an image reference for a tokenId.\r\n      * @param _tokenId the tokenId.\r\n      * @return _ an IPFS url to an image, or an SVG image if there is no IPFS image.\r\n      */\r\n    function getImageForTokenId(uint256 _tokenId) internal view returns (string memory) {\r\n      string memory _base = projectIdToImageURLBase[tokenIdToProjectId[_tokenId]];\r\n      string memory _ext = projectIdToImageURLExt[tokenIdToProjectId[_tokenId]];\r\n      if(bytes(_base).length \u003e 0 \u0026\u0026 bytes(_ext).length \u003e 0) {\r\n        return string(abi.encodePacked(_base,toString(_tokenId),_ext));\r\n      } else {\r\n        return string(abi.encodePacked(\"data:image/svg+xml;base64,\", Base64.encode(bytes(getSVGForTokenId(_tokenId)))));\r\n      }\r\n    }\r\n\r\n    /** @dev Returns an SVG string for a tokenId.\r\n      * @param _tokenId the tokenId.\r\n      * @return _ a SVG image string.\r\n      */\r\n    function getSVGForTokenId(uint256 _tokenId) public view returns (string memory) {\r\n      string memory output = \u0027\u003csvg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\"\u003e\u003cstyle\u003e .edition { fill: #ffffff; font-family: Open Sans; font-size: 12px; } .base { fill: #ffffff; font-family: Open Sans; font-size: 180px; } \u003c/style\u003e \u003crect width=\"100%\" height=\"100%\" fill=\"#9400D3\" /\u003e \u003ctext class=\"edition\" x=\"50%\" y=\"5%\" dominant-baseline=\"middle\" text-anchor=\"middle\"\u003e\u0027;\r\n      output = string(abi.encodePacked(output, projects[tokenIdToProjectId[_tokenId]].name, \u0027 # \u0027, toString(tokenIdToEditionId[_tokenId])));\r\n      output = string(abi.encodePacked(output,\u0027\u003c/text\u003e\u003ctext class=\"edition\" x=\"50%\" y=\"10%\" dominant-baseline=\"middle\" text-anchor=\"middle\"\u003e][art # \u0027, toString(_tokenId)));\r\n      output = string(abi.encodePacked(output,\u0027\u003c/text\u003e\u003ctext class=\"base\" x=\"50%\" y = \"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\"\u003e][\u003c/text\u003e\u003c/svg\u003e\u0027));\r\n      return output;\r\n    }\r\n\r\n    /** @dev Returns a metadata attributes string for a tokenId.\r\n      * @param _tokenId the tokenId.\r\n      * @return _ a metadata attributes string.\r\n      */\r\n    function getMetadataAttributesStringForTokenId(uint256 _tokenId) internal view returns (string memory) {\r\n      uint256 _projectId = tokenIdToProjectId[_tokenId];\r\n      string memory output = string(\r\n        abi.encodePacked(\r\n          \u0027\"attributes\": [\u0027,\r\n                \u0027{\"trait_type\": \"Project\", \"value\": \"\u0027, projects[_projectId].name,\u0027\"},\u0027,\r\n                \u0027{\"trait_type\": \"Artist\", \"value\": \"\u0027, projects[_projectId].artist,\u0027\"},\u0027,\r\n                \u0027{\"trait_type\": \"Category\",\"value\": \"\u0027, projects[_projectId].category,\u0027\"}\u0027,\r\n          \u0027]\u0027\r\n        )\r\n      );\r\n      return output;\r\n    }\r\n\r\n    /** @dev Returns a metadata string for a tokenId.\r\n      * @param _tokenId the tokenId.\r\n      * @return _ a metadata string.\r\n      */\r\n    function getMetadataStringForTokenId(uint256 _tokenId) internal view returns (string memory) {\r\n      uint256 _projectId = tokenIdToProjectId[_tokenId];\r\n      string memory _url = string(abi.encodePacked(immutablesWEB, toString(_projectId), \u0027/\u0027, toString(tokenIdToEditionId[_tokenId])));\r\n      //string memory _collection = string(abi.encodePacked(projects[_projectId].name, \" by \", projects[_projectId].artist));\r\n      string memory output = string(\r\n        abi.encodePacked(\r\n          \u0027{\"name\": \"\u0027, projects[_projectId].name, \u0027 # \u0027, toString(tokenIdToEditionId[_tokenId]),\r\n          \u0027\", \"description\": \"\u0027, projects[_projectId].description,\r\n          \u0027\", \"external_url\": \"\u0027, _url,\r\n          \u0027\", \u0027, getMetadataAttributesStringForTokenId(_tokenId)\r\n        )\r\n      );\r\n      return output;\r\n    }\r\n\r\n    /** @dev Returns a tokenURI URL or Metadata string depending on useMetadataServer\r\n      * @param _tokenId the _tokenId.\r\n      * @return _ String of a URI or Base64 encoded metadata and image string.\r\n      */\r\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\r\n      require(_exists(_tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n      if(useMetadataServer) { // IF THE METADATA SERVER IS IN USE RETURN A URL\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, _tokenId.toString())) : \"\";\r\n      } else { // ELSE WE ARE SERVERLESS AND RETURN METADATA DIRECTLY h/t DEAFBEEF FIRST NFT\r\n        string memory json = Base64.encode(\r\n          bytes(\r\n            string(\r\n              abi.encodePacked(\r\n                getMetadataStringForTokenId(_tokenId),\r\n                \u0027, \"image\": \"\u0027,\r\n                getImageForTokenId(_tokenId),\r\n                \u0027\"}\u0027\r\n              )\r\n            )\r\n          )\r\n        );\r\n        json = string(abi.encodePacked(\u0027data:application/json;base64,\u0027, json));\r\n        return json;\r\n      }\r\n    }\r\n\r\n    /// @dev royaltiesAddress - IERC2981\r\n\r\n    /** @dev Returns the ERC2981 royaltyInfo.\r\n      * @param _tokenId the _tokenId.\r\n      * @param _salePrice the sales price to use for the royalty calculation.\r\n      * @return receiver the recipient of the royalty payment.\r\n      * @return royaltyAmount the calcualted royalty amount.\r\n      */\r\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view override returns (address receiver, uint256 royaltyAmount) {\r\n      require(_tokenId \u003c= currentTokenId, \"tokenId\");\r\n      return (projectIdToRoyaltyAddress[tokenIdToProjectId[_tokenId]], _salePrice * secondaryRoyaltyPercent / 10000);\r\n    }\r\n\r\n    /// @dev CONTRACT ADMINISTRATION\r\n\r\n    /** @dev The artist or owner of a token can post a message associated with\r\n      * @dev an edition of the project.\r\n      * @param _tokenId the tokenId.\r\n      * @param _message the message to add to the token.\r\n      */\r\n    function artistOwnerUpdateTokenWithMessage(uint256 _tokenId, string calldata _message) external onlyArtistOrOwnerOfToken(_tokenId) {\r\n      require(bytes(_message).length \u003e 0);\r\n      emit TokenUpdatedWithMessage(msg.sender, _tokenId, _message);\r\n    }\r\n\r\n    /// @dev ANYONE - MINTING AN EDITION\r\n\r\n    /** @dev Anyone can mint an edition of a project.\r\n      * @param _projectId the projectId of the project to mint.\r\n      */\r\n    function anyoneMintProjectEdition(uint256 _projectId) external payable {\r\n      // checks\r\n      require(msg.value \u003e= projectIdToPricePerEditionInWei[_projectId], \"mint fee\");\r\n      require(projects[_projectId].currentEditionId \u003c projects[_projectId].maxEditions, \"sold out\");\r\n      // require project to be active or the artist or teammember to be trying to mint\r\n      require(projects[_projectId].active || msg.sender == projectIdToArtistAddress[_projectId] || isTeammember[msg.sender], \"not active\");\r\n      // require project to be unpaused or the artist or teammember to be trying to mint\r\n      require(!projects[_projectId].paused || msg.sender == projectIdToArtistAddress[_projectId] || isTeammember[msg.sender], \"paused\");\r\n\r\n      // effects\r\n      uint256 _newTokenId = ++currentTokenId;\r\n      uint256 _newEditionId = ++projects[_projectId].currentEditionId;\r\n\r\n      tokenIdToProjectId[_newTokenId] = _projectId;\r\n      tokenIdToEditionId[_newTokenId] = _newEditionId;\r\n      projectIdToTokenIds[_projectId].push(_newTokenId);\r\n\r\n      // interactions\r\n      _mint(msg.sender, _newTokenId);\r\n      //(bool success, ) = payable(projectIdToRoyaltyAddress[_projectId]).call{value:msg.value}(\"\");\r\n      //require(success, \"Transfer to Royalty Manager contract failed.\");\r\n      payable(projectIdToRoyaltyAddress[_projectId]).sendValue(msg.value);\r\n\r\n      emit AddressMintedProjectEditionAsToken(msg.sender, _projectId, _newEditionId, _newTokenId);\r\n    }\r\n}\r\n\r\n/// [MIT License]\r\n/// @title Base64\r\n/// @notice Provides a function for encoding some bytes in base64\r\n/// @author Brecht Devos \u003cbrecht@loopring.org\u003e\r\nlibrary Base64 {\r\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /// @notice Encodes some bytes to the base64 representation\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        uint256 len = data.length;\r\n        if (len == 0) return \"\";\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n        // Add some extra buffer at the end\r\n        bytes memory result = new bytes(encodedLen + 32);\r\n\r\n        bytes memory table = TABLE;\r\n\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n            let resultPtr := add(result, 32)\r\n\r\n            for {\r\n                let i := 0\r\n            } lt(i, len) {\r\n\r\n            } {\r\n                i := add(i, 3)\r\n                let input := and(mload(add(data, i)), 0xffffff)\r\n\r\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\r\n                out := shl(224, out)\r\n\r\n                mstore(resultPtr, out)\r\n\r\n                resultPtr := add(resultPtr, 4)\r\n            }\r\n\r\n            switch mod(len, 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n\r\n            mstore(result, encodedLen)\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n}\r\n"},"ImmutablesArtRoyaltyManager.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n// All Rights Reserved\r\n\r\n// Contract is not audited.\r\n// Use authorized deployments of this contract at your own risk.\r\n\r\n/*\r\n$$$$$$\\ $$\\      $$\\ $$\\      $$\\ $$\\   $$\\ $$$$$$$$\\  $$$$$$\\  $$$$$$$\\  $$\\       $$$$$$$$\\  $$$$$$\\       $$$$$$\\  $$$$$$$\\ $$$$$$$$\\\r\n\\_$$  _|$$$\\    $$$ |$$$\\    $$$ |$$ |  $$ |\\__$$  __|$$  __$$\\ $$  __$$\\ $$ |      $$  _____|$$  __$$\\     $$  __$$\\ $$  __$$\\\\__$$  __|\r\n  $$ |  $$$$\\  $$$$ |$$$$\\  $$$$ |$$ |  $$ |   $$ |   $$ /  $$ |$$ |  $$ |$$ |      $$ |      $$ /  \\__|    $$ /  $$ |$$ |  $$ |  $$ |\r\n  $$ |  $$\\$$\\$$ $$ |$$\\$$\\$$ $$ |$$ |  $$ |   $$ |   $$$$$$$$ |$$$$$$$\\ |$$ |      $$$$$\\    \\$$$$$$\\      $$$$$$$$ |$$$$$$$  |  $$ |\r\n  $$ |  $$ \\$$$  $$ |$$ \\$$$  $$ |$$ |  $$ |   $$ |   $$  __$$ |$$  __$$\\ $$ |      $$  __|    \\____$$\\     $$  __$$ |$$  __$$\u003c   $$ |\r\n  $$ |  $$ |\\$  /$$ |$$ |\\$  /$$ |$$ |  $$ |   $$ |   $$ |  $$ |$$ |  $$ |$$ |      $$ |      $$\\   $$ |    $$ |  $$ |$$ |  $$ |  $$ |\r\n$$$$$$\\ $$ | \\_/ $$ |$$ | \\_/ $$ |\\$$$$$$  |   $$ |   $$ |  $$ |$$$$$$$  |$$$$$$$$\\ $$$$$$$$\\ \\$$$$$$  |$$\\ $$ |  $$ |$$ |  $$ |  $$ |\r\n\\______|\\__|     \\__|\\__|     \\__| \\______/    \\__|   \\__|  \\__|\\_______/ \\________|\\________| \\______/ \\__|\\__|  \\__|\\__|  \\__|  \\__|\r\n$$$$$$$\\   $$$$$$\\ $$\\     $$\\  $$$$$$\\  $$\\    $$$$$$$$\\ $$\\     $$\\\r\n$$  __$$\\ $$  __$$\\\\$$\\   $$  |$$  __$$\\ $$ |   \\__$$  __|\\$$\\   $$  |\r\n$$ |  $$ |$$ /  $$ |\\$$\\ $$  / $$ /  $$ |$$ |      $$ |    \\$$\\ $$  /\r\n$$$$$$$  |$$ |  $$ | \\$$$$  /  $$$$$$$$ |$$ |      $$ |     \\$$$$  /\r\n$$  __$$\u003c $$ |  $$ |  \\$$  /   $$  __$$ |$$ |      $$ |      \\$$  /\r\n$$ |  $$ |$$ |  $$ |   $$ |    $$ |  $$ |$$ |      $$ |       $$ |\r\n$$ |  $$ | $$$$$$  |   $$ |    $$ |  $$ |$$$$$$$$\\ $$ |       $$ |\r\n\\__|  \\__| \\______/    \\__|    \\__|  \\__|\\________|\\__|       \\__|\r\n$$\\      $$\\  $$$$$$\\  $$\\   $$\\  $$$$$$\\   $$$$$$\\  $$$$$$$$\\ $$$$$$$\\\r\n$$$\\    $$$ |$$  __$$\\ $$$\\  $$ |$$  __$$\\ $$  __$$\\ $$  _____|$$  __$$\\\r\n$$$$\\  $$$$ |$$ /  $$ |$$$$\\ $$ |$$ /  $$ |$$ /  \\__|$$ |      $$ |  $$ |\r\n$$\\$$\\$$ $$ |$$$$$$$$ |$$ $$\\$$ |$$$$$$$$ |$$ |$$$$\\ $$$$$\\    $$$$$$$  |\r\n$$ \\$$$  $$ |$$  __$$ |$$ \\$$$$ |$$  __$$ |$$ |\\_$$ |$$  __|   $$  __$$\u003c\r\n$$ |\\$  /$$ |$$ |  $$ |$$ |\\$$$ |$$ |  $$ |$$ |  $$ |$$ |      $$ |  $$ |\r\n$$ | \\_/ $$ |$$ |  $$ |$$ | \\$$ |$$ |  $$ |\\$$$$$$  |$$$$$$$$\\ $$ |  $$ |\r\n\\__|     \\__|\\__|  \\__|\\__|  \\__|\\__|  \\__| \\______/ \\________|\\__|  \\__|\r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @author Gutenblock.eth\r\n * @title ImmutablesArtRoyaltyManager\r\n * @dev This contract allows to split Ether royalty payments between the\r\n * Immutables.art contract and an Immutables.art project artist.\r\n *\r\n * `ImmutablesArtRoyaltyManager` follows a _pull payment_ model. This means that payments\r\n * are not automatically forwarded to the accounts but kept in this contract,\r\n * and the actual transfer is triggered as a separate step by calling the\r\n * {release} function.\r\n *\r\n * The contract is written to serve as an implementation for minimal proxy clones.\r\n */\r\n\r\nimport \"./Context.sol\";\r\nimport \"./Address.sol\";\r\nimport \"./SafeERC20.sol\";\r\nimport \"./Initializable.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\ncontract ImmutablesArtRoyaltyManager is Context, Initializable, ReentrancyGuard {\r\n    using Address for address payable;\r\n\r\n    /// @dev The address of the ImmutablesArt contract.\r\n    address public immutablesArtContract;\r\n    /// @dev The projectId of the associated ImmutablesArt project.\r\n    uint256 public immutablesArtProjectId;\r\n\r\n    /// @dev The address of the artist.\r\n    address public artist;\r\n    /// @dev The address of the additionalPayee set by the artist.\r\n    address public additionalPayee;\r\n    /// @dev The artist\u0027s percentage of the total expressed in basis points\r\n    ///      (1/10,000ths).  The artist can allot up to all of this to\r\n    ///      an additionalPayee.\r\n    uint16 public artistPercent;\r\n    /// @dev The artist\u0027s percentage, after additional payee,\r\n    ///      of the total expressed as basis points (1/10,000ths).\r\n    uint16 public artistPercentMinusAdditionalPayeePercent;\r\n    /// @dev The artist\u0027s additional payee percentae of the total\r\n    /// @dev expressed in basis points (1/10,000ths).  Valid from 0 to artistPercent.\r\n    uint16 public additionalPayeePercent;\r\n\r\n    /// EVENTS\r\n\r\n    event PayeeAdded(address indexed account, uint256 percent);\r\n    event PayeeRemoved(address indexed account, uint256 percent);\r\n    event PaymentReleased(address indexed to, uint256 amount);\r\n    event PaymentReleasedERC20(IERC20 indexed token, address indexed to, uint256 amount);\r\n    event PaymentReceived(address indexed from, uint256 amount);\r\n\r\n    /**\r\n     * @dev Creates an uninitialized instance of `ImmutablesArtRoyaltyManager`.\r\n     */\r\n    constructor() { }\r\n\r\n    /**\r\n     * @dev Initialized an instance of `ImmutablesArtRoyaltyManager`\r\n     */\r\n    function initialize(address _immutablesArtContract, uint256 _immutablesArtProjectId,\r\n                        address _artist, uint16 _artistPercent,\r\n                        address _additionalPayee, uint16 _additionalPayeePercent\r\n                        ) public initializer() {\r\n        immutablesArtContract = _immutablesArtContract;\r\n        immutablesArtProjectId = _immutablesArtProjectId;\r\n\r\n        artist = _artist;\r\n        artistPercent = _artistPercent;\r\n        additionalPayee = _additionalPayee;\r\n        additionalPayeePercent = _additionalPayeePercent;\r\n        artistPercentMinusAdditionalPayeePercent = _artistPercent - _additionalPayeePercent;\r\n\r\n        emit PayeeAdded(immutablesArtContract, 10000 - artistPercent);\r\n        emit PayeeAdded(artist, artistPercentMinusAdditionalPayeePercent);\r\n        if(additionalPayee != address(0)) {\r\n          emit PayeeAdded(additionalPayee, additionalPayeePercent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\r\n     * reliable: it\u0027s possible for a contract to receive Ether without triggering this function. This only affects the\r\n     * reliability of the events, and not the actual splitting of Ether.\r\n     *\r\n     * To learn more about this see the Solidity documentation for\r\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\r\n     * functions].\r\n     */\r\n    receive() external payable virtual {\r\n        emit PaymentReceived(_msgSender(), msg.value);\r\n    }\r\n\r\n    function artistUpdateAddress(address _newArtistAddress) public {\r\n        // only the parent contract and the artist can call this function.\r\n        // the parent contract only calls this function at the request of the artist.\r\n        require(_msgSender() == immutablesArtContract || _msgSender() == artist, \"auth\");\r\n\r\n        // update the artist address\r\n        emit PayeeRemoved(artist, artistPercentMinusAdditionalPayeePercent);\r\n        artist = _newArtistAddress;\r\n        emit PayeeAdded(artist, artistPercentMinusAdditionalPayeePercent);\r\n    }\r\n\r\n    function artistUpdateAdditionalPayeeInfo(address _newAdditionalPayee, uint16 _newPercent) public {\r\n        // only the parent contract and the artist can call this function.\r\n        // the parent contract only calls this function at the request of the artist.\r\n        require(_msgSender() == immutablesArtContract || _msgSender() == artist, \"auth\");\r\n\r\n        // the maximum amount the artist can give to an additional payee is\r\n        // the current artistPercent plus the current additionalPayeePercent.\r\n        require(_newPercent \u003c= artistPercent, \"percent too big\");\r\n\r\n        // Before changing the additional payee information,\r\n        // payout ETH to everyone as indicated when prior payments were made.\r\n        // since we won\u0027t know what ERC20 token addresses if any are held,\r\n        // by the contract, we cant force payout on additional payee change.\r\n        release();\r\n\r\n        // Change the additional payee and relevant percentages.\r\n        emit PayeeRemoved(artist, artistPercentMinusAdditionalPayeePercent);\r\n        if(additionalPayee != address(0)) {\r\n          emit PayeeRemoved(additionalPayee, additionalPayeePercent);\r\n        }\r\n\r\n        additionalPayee = _newAdditionalPayee;\r\n        additionalPayeePercent = _newPercent;\r\n        artistPercentMinusAdditionalPayeePercent = artistPercent - _newPercent;\r\n\r\n        emit PayeeAdded(artist, artistPercentMinusAdditionalPayeePercent);\r\n        if(additionalPayee != address(0)) {\r\n          emit PayeeAdded(additionalPayee, additionalPayeePercent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers payout of all ETH royalties.\r\n     */\r\n    function release() public virtual nonReentrant() {\r\n        // checks\r\n        uint256 _startingBalance = address(this).balance;\r\n\r\n        // Since this is called when there is a payee change,\r\n        // we do not want to use require and cause a revert\r\n        // if there is no balance.\r\n        if(_startingBalance \u003e 0) {\r\n            // effects\r\n            uint256 _artistAmount = _startingBalance * artistPercentMinusAdditionalPayeePercent / 10000;\r\n            uint256 _additionalPayeeAmount = _startingBalance * additionalPayeePercent / 10000;\r\n            uint256 _contractAmount = _startingBalance - _artistAmount - _additionalPayeeAmount;\r\n\r\n            // interactions\r\n            payable(immutablesArtContract).sendValue(_contractAmount);\r\n            emit PaymentReleased(immutablesArtContract, _contractAmount);\r\n            if(artist != address(0) \u0026\u0026 _artistAmount \u003e 0) {\r\n              payable(artist).sendValue(_artistAmount);\r\n              emit PaymentReleased(artist, _artistAmount);\r\n            }\r\n            if(additionalPayee != address(0) \u0026\u0026 _additionalPayeeAmount \u003e 0) {\r\n              payable(additionalPayee).sendValue(_additionalPayeeAmount);\r\n              emit PaymentReleased(additionalPayee, _additionalPayeeAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers payout of all ERC20 royalties.\r\n     */\r\n    function releaseERC20(IERC20 token) public virtual nonReentrant() {\r\n        // checks\r\n        uint256 _startingBalance = token.balanceOf(address(this));\r\n        require(_startingBalance \u003e 0, \"no tokens\");\r\n\r\n        // effects\r\n        uint256 _artistAmount = _startingBalance * artistPercentMinusAdditionalPayeePercent / 10000;\r\n        uint256 _additionalPayeeAmount = _startingBalance * additionalPayeePercent / 10000;\r\n        uint256 _contractAmount = _startingBalance - _artistAmount - _additionalPayeeAmount;\r\n\r\n        // interactions\r\n        SafeERC20.safeTransfer(token, immutablesArtContract, _contractAmount);\r\n        emit PaymentReleasedERC20(token, immutablesArtContract, _contractAmount);\r\n        if(artist != address(0) \u0026\u0026 _artistAmount \u003e 0) {\r\n          SafeERC20.safeTransfer(token, artist, _artistAmount);\r\n          emit PaymentReleasedERC20(token, artist, _artistAmount);\r\n        }\r\n        if(additionalPayee != address(0) \u0026\u0026 _additionalPayeeAmount \u003e 0) {\r\n          SafeERC20.safeTransfer(token, additionalPayee, _additionalPayeeAmount);\r\n          emit PaymentReleasedERC20(token, additionalPayee, _additionalPayeeAmount);\r\n        }\r\n    }\r\n}\r\n"},"Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can\u0027t have a constructor, it\u0027s common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp \u003e\u003e= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\n            value \u003e\u003e= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"}}