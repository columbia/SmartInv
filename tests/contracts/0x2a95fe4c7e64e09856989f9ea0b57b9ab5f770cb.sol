{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.2 \u003c0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"AddressAliasHelper.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n"},"ArbSys.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity \u003e=0.4.21 \u003c0.7.0;\n\n/**\n* @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\n */\ninterface ArbSys {\n    /**\n    * @notice Get internal version number identifying an ArbOS build\n    * @return version number as int\n     */\n    function arbOSVersion() external pure returns (uint);\n\n    function arbChainID() external view returns(uint);\n\n    /**\n    * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n    * @return block number as int\n     */ \n    function arbBlockNumber() external view returns (uint);\n\n    /** \n    * @notice Send given amount of Eth to dest from sender.\n    * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\n    * @param destination recipient address on L1\n    * @return unique identifier for this L2-to-L1 transaction.\n    */\n    function withdrawEth(address destination) external payable returns(uint);\n\n    /** \n    * @notice Send a transaction to L1\n    * @param destination recipient address on L1 \n    * @param calldataForL1 (optional) calldata for L1 contract call\n    * @return a unique identifier for this L2-to-L1 transaction.\n    */\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns(uint);\n\n    /** \n    * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\n    * @param account target account\n    * @return the number of transactions issued by the given external account or the account sequence number of the given contract\n    */\n    function getTransactionCount(address account) external view returns(uint256);\n\n    /**  \n    * @notice get the value of target L2 storage slot \n    * This function is only callable from address 0 to prevent contracts from being able to call it\n    * @param account target account\n    * @param index target index of storage slot \n    * @return stotage value for the given account at the given index\n    */\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\n\n    /**\n    * @notice check if current call is coming from l1\n    * @return true if the caller of this was called directly from L1\n    */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller\u0027s address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller\u0027s caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param dest destination address\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns(address);\n\n    /**\n     * @notice get the caller\u0027s amount of available storage gas\n     * @return amount of storage gas available to the caller\n     */\n    function getStorageGasAvailable() external returns(uint);\n\n    event L2ToL1Transaction(address caller, address indexed destination, uint indexed uniqueId,\n                            uint indexed batchNumber, uint indexInBatch,\n                            uint arbBlockNum, uint ethBlockNum, uint timestamp,\n                            uint callvalue, bytes data);\n}\n\n"},"BytesLib.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá \u003cgoncalo.sa@consensys.net\u003e\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity ^0.6.11;\n\n/* solhint-disable no-inline-assembly */\nlibrary BytesLib {\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length \u003e= (_start + 20), \"Read out of bounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length \u003e= (_start + 1), \"Read out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length \u003e= (_start + 32), \"Read out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length \u003e= (_start + 32), \"Read out of bounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n}\n/* solhint-enable no-inline-assembly */\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"Create2.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as \u0027counterfactual interactions\u0027.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance \u003e= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract\u0027s address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint160(uint256(_data)));\n    }\n}\n"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"},"GatewayMessageHandler.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\n/// @notice this library manages encoding and decoding of gateway communication\nlibrary GatewayMessageHandler {\n    // these are for communication from L1 to L2 gateway\n\n    function encodeToL2GatewayMsg(bytes memory gatewayData, bytes memory callHookData)\n        internal\n        pure\n        returns (bytes memory res)\n    {\n        res = abi.encode(gatewayData, callHookData);\n    }\n\n    function parseFromL1GatewayMsg(bytes calldata _data)\n        internal\n        pure\n        returns (bytes memory gatewayData, bytes memory callHookData)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        (gatewayData, callHookData) = abi.decode(_data, (bytes, bytes));\n    }\n\n    // these are for communication from L2 to L1 gateway\n\n    function encodeFromL2GatewayMsg(uint256 exitNum, bytes memory callHookData)\n        internal\n        pure\n        returns (bytes memory res)\n    {\n        res = abi.encode(exitNum, callHookData);\n    }\n\n    function parseToL1GatewayMsg(bytes calldata _data)\n        internal\n        pure\n        returns (uint256 exitNum, bytes memory callHookData)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        (exitNum, callHookData) = abi.decode(_data, (uint256, bytes));\n    }\n\n    // these are for communication from router to gateway\n\n    function encodeFromRouterToGateway(address _from, bytes calldata _data)\n        internal\n        pure\n        returns (bytes memory res)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        return abi.encode(_from, _data);\n    }\n\n    function parseFromRouterToGateway(bytes calldata _data)\n        internal\n        pure\n        returns (address, bytes memory res)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        return abi.decode(_data, (address, bytes));\n    }\n}\n"},"GatewayRouter.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./ProxyUtil.sol\";\nimport \"./Address.sol\";\nimport \"./TokenGateway.sol\";\nimport \"./GatewayMessageHandler.sol\";\n\n/**\n * @title Common interface for L1 and L2 Gateway Routers\n */\nabstract contract GatewayRouter is TokenGateway {\n    using Address for address;\n\n    address internal constant ZERO_ADDR = address(0);\n    address internal constant DISABLED = address(1);\n\n    mapping(address =\u003e address) public l1TokenToGateway;\n    address public defaultGateway;\n\n    event TransferRouted(\n        address indexed token,\n        address indexed _userFrom,\n        address indexed _userTo,\n        address gateway\n    );\n\n    event GatewaySet(address indexed l1Token, address indexed gateway);\n    event DefaultGatewayUpdated(address newDefaultGateway);\n\n    function postUpgradeInit() external {\n        // it is assumed the L2 Arbitrum Gateway contract is behind a Proxy controlled by a proxy admin\n        // this function can only be called by the proxy admin contract\n        address proxyAdmin = ProxyUtil.getProxyAdmin();\n        require(msg.sender == proxyAdmin, \"NOT_FROM_ADMIN\");\n        // this has no other logic since the current upgrade doesn\u0027t require this logic\n    }\n\n    function _initialize(\n        address _counterpartGateway,\n        address _router,\n        address _defaultGateway\n    ) internal {\n        // if you are a router, you can\u0027t have a router\n        require(_router == address(0), \"BAD_ROUTER\");\n        TokenGateway._initialize(_counterpartGateway, _router);\n        // default gateway can have 0 address\n        defaultGateway = _defaultGateway;\n    }\n\n    function finalizeInboundTransfer(\n        address, /* _token */\n        address, /* _from */\n        address, /* _to */\n        uint256, /* _amount */\n        bytes calldata /* _data */\n    ) external payable virtual override {\n        revert(\"ONLY_OUTBOUND_ROUTER\");\n    }\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable virtual override returns (bytes memory) {\n        address gateway = getGateway(_token);\n        bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(\n            msg.sender,\n            _data\n        );\n\n        emit TransferRouted(_token, msg.sender, _to, gateway);\n        return\n            ITokenGateway(gateway).outboundTransfer{ value: msg.value }(\n                _token,\n                _to,\n                _amount,\n                _maxGas,\n                _gasPriceBid,\n                gatewayData\n            );\n    }\n\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view virtual override returns (bytes memory) {\n        address gateway = getGateway(_token);\n        return TokenGateway(gateway).getOutboundCalldata(_token, _from, _to, _amount, _data);\n    }\n\n    function getGateway(address _token) public view virtual returns (address gateway) {\n        gateway = l1TokenToGateway[_token];\n\n        if (gateway == ZERO_ADDR) {\n            // if no gateway value set, use default gateway\n            gateway = defaultGateway;\n        }\n\n        if (gateway == DISABLED || !gateway.isContract()) {\n            // not a valid gateway\n            return ZERO_ADDR;\n        }\n\n        return gateway;\n    }\n\n    function calculateL2TokenAddress(address l1ERC20)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        address gateway = getGateway(l1ERC20);\n        if (gateway == ZERO_ADDR) {\n            return ZERO_ADDR;\n        }\n        return TokenGateway(gateway).calculateL2TokenAddress(l1ERC20);\n    }\n}\n"},"IArbToken.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @title Minimum expected interface for L2 token that interacts with the L2 token bridge (this is the interface necessary\n * for a custom token that interacts with the bridge, see TestArbCustomToken.sol for an example implementation).\n */\npragma solidity ^0.6.11;\n\ninterface IArbToken {\n    /**\n     * @notice should increase token supply by amount, and should (probably) only be callable by the L1 bridge.\n     */\n    function bridgeMint(address account, uint256 amount) external;\n\n    /**\n     * @notice should decrease token supply by amount, and should (probably) only be callable by the L1 bridge.\n     */\n    function bridgeBurn(address account, uint256 amount) external;\n\n    /**\n     * @return address of layer 1 token\n     */\n    function l1Address() external view returns (address);\n}\n"},"IBridge.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed destAddr,\n        uint256 amount,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n"},"ICustomGateway.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\n// import \"./ITokenGateway.sol\";\n\ninterface ICustomGateway {\n    function l1ToL2Token(address _l1Token) external view returns (address _l2Token);\n\n    event TokenSet(address indexed l1Address, address indexed l2Address);\n}\n"},"ICustomToken.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface ArbitrumEnabledToken {\n    /// @notice should return `0xa4b1` if token is enabled for arbitrum gateways\n    function isArbitrumEnabled() external view returns (uint8);\n}\n\n/**\n * @title Minimum expected interface for L1 custom token (see TestCustomTokenL1.sol for an example implementation)\n */\ninterface ICustomToken is ArbitrumEnabledToken {\n    /**\n     * @notice Should make an external call to EthERC20Bridge.registerCustomL2Token\n     */\n    function registerTokenOnL2(\n        address l2CustomTokenAddress,\n        uint256 maxSubmissionCostForCustomBridge,\n        uint256 maxSubmissionCostForRouter,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 valueForGateway,\n        uint256 valueForRouter,\n        address creditBackAddress\n    ) external payable;\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IERC20Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IInbox.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IBridge.sol\";\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n    function bridge() external view returns (IBridge);\n\n    function pauseCreateRetryables() external;\n\n    function unpauseCreateRetryables() external;\n\n    function startRewriteAddress() external;\n\n    function stopRewriteAddress() external;\n}\n"},"IMessageProvider.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IMessageProvider {\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"},"IOutbox.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IOutbox {\n    event OutboxEntryCreated(\n        uint256 indexed batchNum,\n        uint256 outboxEntryIndex,\n        bytes32 outputRoot,\n        uint256 numInBatch\n    );\n    event OutBoxTransactionExecuted(\n        address indexed destAddr,\n        address indexed l2Sender,\n        uint256 indexed outboxEntryIndex,\n        uint256 transactionIndex\n    );\n\n    function l2ToL1Sender() external view returns (address);\n\n    function l2ToL1Block() external view returns (uint256);\n\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    function l2ToL1BatchNum() external view returns (uint256);\n\n    function l2ToL1OutputId() external view returns (bytes32);\n\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\n        external;\n\n    function outboxEntryExists(uint256 batchNum) external view returns (bool);\n}\n"},"ISperaxToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.5.0;\n\ninterface ISperaxToken {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function burnFrom(address account, uint256 amount) external;\n    function mintForUSDs(address account, uint256 amount) external;\n}\n"},"ITokenGateway.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface ITokenGateway {\n    /// @notice event deprecated in favor of DepositInitiated and WithdrawalInitiated\n    // event OutboundTransferInitiated(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    /// @notice event deprecated in favor of DepositFinalized and WithdrawalFinalized\n    // event InboundTransferFinalized(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) external view returns (address);\n}\n"},"ITransferAndCall.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./IERC20Upgradeable.sol\";\n\ninterface ITransferAndCall is IERC20Upgradeable {\n    function transferAndCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n\n/**\n * @notice note that implementation of ITransferAndCallReceiver is not expected to return a success bool\n */\ninterface ITransferAndCallReceiver {\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes memory _data\n    ) external;\n}\n"},"L1ArbitrumExtendedGateway.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./ITransferAndCall.sol\";\n\nimport \"./L1ArbitrumGateway.sol\";\n\ninterface ITradeableExitReceiver {\n    function onExitTransfer(\n        address sender,\n        uint256 exitNum,\n        bytes calldata data\n    ) external returns (bool);\n}\n\nabstract contract L1ArbitrumExtendedGateway is L1ArbitrumGateway {\n    struct ExitData {\n        bool isExit;\n        address _newTo;\n        bytes _newData;\n    }\n\n    mapping(bytes32 =\u003e ExitData) public redirectedExits;\n\n    function _initialize(\n        address _l2Counterpart,\n        address _router,\n        address _inbox\n    ) internal virtual override {\n        L1ArbitrumGateway._initialize(_l2Counterpart, _router, _inbox);\n    }\n\n    event WithdrawRedirected(\n        address indexed from,\n        address indexed to,\n        uint256 indexed exitNum,\n        bytes newData,\n        bytes data,\n        bool madeExternalCall\n    );\n\n    /**\n     * @notice Allows a user to redirect their right to claim a withdrawal to another address.\n     * @dev This method also allows you to make an arbitrary call after the transfer.\n     * This does not validate if the exit was already triggered. It is assumed the `_exitNum` is\n     * validated off-chain to ensure this was not yet triggered.\n     * @param _exitNum Sequentially increasing exit counter determined by the L2 bridge\n     * @param _initialDestination address the L2 withdrawal call initially set as the destination.\n     * @param _newDestination address the L1 will now call instead of the previously set destination\n     * @param _newData data to be used in inboundEscrowAndCall\n     * @param _data optional data for external call upon transfering the exit\n     */\n    function transferExitAndCall(\n        uint256 _exitNum,\n        address _initialDestination,\n        address _newDestination,\n        bytes calldata _newData,\n        bytes calldata _data\n    ) external {\n        // the initial data doesn\u0027t make a difference when transfering you exit\n        // since the L2 bridge gives a unique exit ID to each exit\n        (address expectedSender, ) = getExternalCall(_exitNum, _initialDestination, \"\");\n\n        // if you want to transfer your exit, you must be the current destination\n        require(msg.sender == expectedSender, \"NOT_EXPECTED_SENDER\");\n        // the inboundEscrowAndCall functionality has been disabled, so no data is allowed\n        require(_newData.length == 0, \"NO_DATA_ALLOWED\");\n\n        setRedirectedExit(_exitNum, _initialDestination, _newDestination, _newData);\n\n        if (_data.length \u003e 0) {\n            require(_newDestination.isContract(), \"TO_NOT_CONTRACT\");\n            bool success = ITradeableExitReceiver(_newDestination).onExitTransfer(\n                expectedSender,\n                _exitNum,\n                _data\n            );\n            require(success, \"TRANSFER_HOOK_FAIL\");\n        }\n\n        emit WithdrawRedirected(\n            expectedSender,\n            _newDestination,\n            _exitNum,\n            _newData,\n            _data,\n            _data.length \u003e 0\n        );\n    }\n\n    /// @notice this does not verify if the external call was already done\n    function getExternalCall(\n        uint256 _exitNum,\n        address _initialDestination,\n        bytes memory _initialData\n    ) public view virtual override returns (address target, bytes memory data) {\n        // this function is virtual so that subclasses can override it with custom logic where necessary\n        bytes32 withdrawData = encodeWithdrawal(_exitNum, _initialDestination);\n        ExitData storage exit = redirectedExits[withdrawData];\n\n        // here we don\u0027t authenticate `_initialData`. we could hash it into `withdrawData` but would increase gas costs\n        // this is safe because if the exit isn\u0027t overriden, the _initialData coming from L2 is trusted\n        // but if the exit is traded, all we care about is the latest user calldata\n        if (exit.isExit) {\n            return (exit._newTo, exit._newData);\n        } else {\n            return (_initialDestination, _initialData);\n        }\n    }\n\n    function setRedirectedExit(\n        uint256 _exitNum,\n        address _initialDestination,\n        address _newDestination,\n        bytes memory _newData\n    ) internal {\n        bytes32 withdrawData = encodeWithdrawal(_exitNum, _initialDestination);\n        redirectedExits[withdrawData] = ExitData(true, _newDestination, _newData);\n    }\n\n    function encodeWithdrawal(uint256 _exitNum, address _initialDestination)\n        public\n        pure\n        returns (bytes32)\n    {\n        // here we assume the L2 bridge gives a unique exitNum to each exit\n        return keccak256(abi.encode(_exitNum, _initialDestination));\n    }\n}\n"},"L1ArbitrumGateway.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./ERC20.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./Create2.sol\";\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\n\nimport \"./IInbox.sol\";\nimport \"./ProxyUtil.sol\";\n\nimport \"./L1ArbitrumMessenger.sol\";\nimport \"./GatewayMessageHandler.sol\";\nimport \"./TokenGateway.sol\";\nimport \"./ITransferAndCall.sol\";\n\n/**\n * @title Common interface for gatways on L1 messaging to Arbitrum.\n */\nabstract contract L1ArbitrumGateway is L1ArbitrumMessenger, TokenGateway {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    address public inbox;\n\n    event DepositInitiated(\n        address l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _sequenceNumber,\n        uint256 _amount\n    );\n\n    event WithdrawalFinalized(\n        address l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _exitNum,\n        uint256 _amount\n    );\n\n    modifier onlyCounterpartGateway() override {\n        address _inbox = inbox;\n\n        // a message coming from the counterpart gateway was executed by the bridge\n        address bridge = address(super.getBridge(_inbox));\n        require(msg.sender == bridge, \"NOT_FROM_BRIDGE\");\n\n        // and the outbox reports that the L2 address of the sender is the counterpart gateway\n        address l2ToL1Sender = super.getL2ToL1Sender(_inbox);\n        require(l2ToL1Sender == counterpartGateway, \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    function postUpgradeInit() external {\n        // it is assumed the L1 Arbitrum Gateway contract is behind a Proxy controlled by a proxy admin\n        // this function can only be called by the proxy admin contract\n        address proxyAdmin = ProxyUtil.getProxyAdmin();\n        require(msg.sender == proxyAdmin, \"NOT_FROM_ADMIN\");\n        // this has no other logic since the current upgrade doesn\u0027t require this logic\n    }\n\n    function _initialize(\n        address _l2Counterpart,\n        address _router,\n        address _inbox\n    ) internal virtual {\n        TokenGateway._initialize(_l2Counterpart, _router);\n        // L1 gateway must have a router\n        require(_router != address(0), \"BAD_ROUTER\");\n        require(_inbox != address(0), \"BAD_INBOX\");\n        inbox = _inbox;\n    }\n\n    /**\n     * @notice Finalizes a withdrawal via Outbox message; callable only by L2Gateway.outboundTransfer\n     * @param _token L1 address of token being withdrawn from\n     * @param _from initiator of withdrawal\n     * @param _to address the L2 withdrawal call set as the destination.\n     * @param _amount Token amount being withdrawn\n     * @param _data encoded exitNum (Sequentially increasing exit counter determined by the L2Gateway) and additinal hook data\n     */\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCounterpartGateway {\n        (uint256 exitNum, bytes memory callHookData) = GatewayMessageHandler.parseToL1GatewayMsg(\n            _data\n        );\n\n        if (callHookData.length != 0) {\n            // callHookData should always be 0 since inboundEscrowAndCall is disabled\n            callHookData = bytes(\"\");\n        }\n\n        // we ignore the returned data since the callHook feature is now disabled\n        (_to, ) = getExternalCall(exitNum, _to, callHookData);\n        inboundEscrowTransfer(_token, _to, _amount);\n\n        emit WithdrawalFinalized(_token, _from, _to, exitNum, _amount);\n    }\n\n    function getExternalCall(\n        uint256, /* _exitNum */\n        address _initialDestination,\n        bytes memory _initialData\n    ) public view virtual returns (address target, bytes memory data) {\n        // this method is virtual so the destination of a call can be changed\n        // using tradeable exits in a subclass (L1ArbitrumExtendedGateway)\n        target = _initialDestination;\n        data = _initialData;\n    }\n\n    function inboundEscrowTransfer(\n        address _l1Token,\n        address _dest,\n        uint256 _amount\n    ) internal virtual {\n        // this method is virtual since different subclasses can handle escrow differently\n        IERC20(_l1Token).safeTransfer(_dest, _amount);\n    }\n\n    function createOutboundTx(\n        address _from,\n        uint256, /* _tokenAmount */\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        bytes memory _outboundCalldata\n    ) internal virtual returns (uint256) {\n        // We make this function virtual since outboundTransfer logic is the same for many gateways\n        // but sometimes (ie weth) you construct the outgoing message differently.\n\n        // msg.value is sent, but 0 is set to the L2 call value\n        // the eth sent is used to pay for the tx\u0027s gas\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                _from,\n                msg.value, // we forward the L1 call value to the inbox\n                0, // l2 call value 0 by default\n                L2GasParams({\n                    _maxSubmissionCost: _maxSubmissionCost,\n                    _maxGas: _maxGas,\n                    _gasPriceBid: _gasPriceBid\n                }),\n                _outboundCalldata\n            );\n    }\n\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum. If L2 side hasn\u0027t been deployed yet, includes name/symbol/decimals data for initial L2 deploy. Initiate by GatewayRouter.\n     * @param _l1Token L1 address of ERC20\n     * @param _to account to be credited with the tokens in the L2 (can be the user\u0027s L2 account or a contract)\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user\u0027s L2 balance to cover L2 execution\n     * @param _gasPriceBid Gas price for L2 execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    //  * @param maxSubmissionCost Max gas deducted from user\u0027s L2 balance to cover base submission fee\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable virtual override returns (bytes memory res) {\n        require(isRouter(msg.sender), \"NOT_FROM_ROUTER\");\n        // This function is set as public and virtual so that subclasses can override\n        // it and add custom validation for callers (ie only whitelisted users)\n        address _from;\n        uint256 seqNum;\n        bytes memory extraData;\n        {\n            uint256 _maxSubmissionCost;\n            if (super.isRouter(msg.sender)) {\n                // router encoded\n                (_from, extraData) = GatewayMessageHandler.parseFromRouterToGateway(_data);\n            } else {\n                _from = msg.sender;\n                extraData = _data;\n            }\n            // user encoded\n            (_maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));\n            // the inboundEscrowAndCall functionality has been disabled, so no data is allowed\n            require(extraData.length == 0, \"EXTRA_DATA_DISABLED\");\n\n            require(_l1Token.isContract(), \"L1_NOT_CONTRACT\");\n            address l2Token = calculateL2TokenAddress(_l1Token);\n            require(l2Token != address(0), \"NO_L2_TOKEN_SET\");\n\n            _amount = outboundEscrowTransfer(_l1Token, _from, _amount);\n\n            // we override the res field to save on the stack\n            res = getOutboundCalldata(_l1Token, _from, _to, _amount, extraData);\n\n            seqNum = createOutboundTx(\n                _from,\n                _amount,\n                _maxGas,\n                _gasPriceBid,\n                _maxSubmissionCost,\n                res\n            );\n        }\n        emit DepositInitiated(_l1Token, _from, _to, seqNum, _amount);\n        return abi.encode(seqNum);\n    }\n\n    function outboundEscrowTransfer(\n        address _l1Token,\n        address _from,\n        uint256 _amount\n    ) internal virtual returns (uint256 amountReceived) {\n        // this method is virtual since different subclasses can handle escrow differently\n        // user funds are escrowed on the gateway using this function\n        uint256 prevBalance = IERC20(_l1Token).balanceOf(address(this));\n        IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);\n        uint256 postBalance = IERC20(_l1Token).balanceOf(address(this));\n        return SafeMath.sub(postBalance, prevBalance);\n    }\n\n    function getOutboundCalldata(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view virtual override returns (bytes memory outboundCalldata) {\n        // this function is public so users can query how much calldata will be sent to the L2\n        // before execution\n        // it is virtual since different gateway subclasses can build this calldata differently\n        // ( ie the standard ERC20 gateway queries for a tokens name/symbol/decimals )\n        bytes memory emptyBytes = \"\";\n\n        outboundCalldata = abi.encodeWithSelector(\n            TokenGateway.finalizeInboundTransfer.selector,\n            _l1Token,\n            _from,\n            _to,\n            _amount,\n            GatewayMessageHandler.encodeToL2GatewayMsg(emptyBytes, _data)\n        );\n\n        return outboundCalldata;\n    }\n}\n"},"L1ArbitrumMessenger.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IInbox.sol\";\nimport \"./IOutbox.sol\";\n\n/// @notice L1 utility contract to assist with L1 \u003c=\u003e L2 interactions\n/// @dev this is an abstract contract instead of library so the functions can be easily overriden when testing\nabstract contract L1ArbitrumMessenger {\n    event TxToL2(address indexed _from, address indexed _to, uint256 indexed _seqNum, bytes _data);\n\n    struct L2GasParams {\n        uint256 _maxSubmissionCost;\n        uint256 _maxGas;\n        uint256 _gasPriceBid;\n    }\n\n    function sendTxToL2(\n        address _inbox,\n        address _to,\n        address _user,\n        uint256 _l1CallValue,\n        uint256 _l2CallValue,\n        L2GasParams memory _l2GasParams,\n        bytes memory _data\n    ) internal virtual returns (uint256) {\n        // alternative function entry point when struggling with the stack size\n        return\n            sendTxToL2(\n                _inbox,\n                _to,\n                _user,\n                _l1CallValue,\n                _l2CallValue,\n                _l2GasParams._maxSubmissionCost,\n                _l2GasParams._maxGas,\n                _l2GasParams._gasPriceBid,\n                _data\n            );\n    }\n\n    function sendTxToL2(\n        address _inbox,\n        address _to,\n        address _user,\n        uint256 _l1CallValue,\n        uint256 _l2CallValue,\n        uint256 _maxSubmissionCost,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes memory _data\n    ) internal virtual returns (uint256) {\n        uint256 seqNum = IInbox(_inbox).createRetryableTicket{ value: _l1CallValue }(\n            _to,\n            _l2CallValue,\n            _maxSubmissionCost,\n            _user,\n            _user,\n            _maxGas,\n            _gasPriceBid,\n            _data\n        );\n        emit TxToL2(_user, _to, seqNum, _data);\n        return seqNum;\n    }\n\n    function getBridge(address _inbox) internal view virtual returns (IBridge) {\n        return IInbox(_inbox).bridge();\n    }\n\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n    function getL2ToL1Sender(address _inbox) internal view virtual returns (address) {\n        IOutbox outbox = IOutbox(getBridge(_inbox).activeOutbox());\n        address l2ToL1Sender = outbox.l2ToL1Sender();\n\n        require(l2ToL1Sender != address(0), \"NO_SENDER\");\n        return l2ToL1Sender;\n    }\n}\n"},"L1CustomGateway.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport { ArbitrumEnabledToken } from \"./ICustomToken.sol\";\nimport \"./L1ArbitrumExtendedGateway.sol\";\nimport \"./L2CustomGateway.sol\";\nimport \"./ICustomGateway.sol\";\nimport \"./Address.sol\";\n\nimport \"./Whitelist.sol\";\n\n/**\n * @title Gatway for \"custom\" bridging functionality\n * @notice Handles some (but not all!) custom Gateway needs.\n */\ncontract L1CustomGateway is L1ArbitrumExtendedGateway, ICustomGateway {\n    using Address for address;\n    // stores addresses of L2 tokens to be used\n    mapping(address =\u003e address) public override l1ToL2Token;\n    // owner is able to force add custom mappings\n    address public owner;\n\n    // whitelist not used anymore\n    address public whitelist;\n\n    function initialize(\n        address _l1Counterpart,\n        address _l1Router,\n        address _inbox,\n        address _owner\n    ) public {\n        L1ArbitrumExtendedGateway._initialize(_l1Counterpart, _l1Router, _inbox);\n        owner = _owner;\n        // disable whitelist by default\n        whitelist = address(0);\n    }\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) public view override returns (address) {\n        return l1ToL2Token[l1ERC20];\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its custom L2 counterpart. (other registerTokenToL2 method allows excess eth recovery from _maxSubmissionCost and is recommended)\n     * @param _l2Address counterpart address of L1 token\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @return Retryable ticket ID\n     */\n    function registerTokenToL2(\n        address _l2Address,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable returns (uint256) {\n        return registerTokenToL2(_l2Address, _maxGas, _gasPriceBid, _maxSubmissionCost, msg.sender);\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its custom L2 counterpart.\n     * param _l2Address counterpart address of L1 token\n     * param _maxGas max gas for L2 retryable exrecution\n     * param _gasPriceBid gas price for L2 retryable ticket\n     * param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\n     * return Retryable ticket ID\n     */\n    function registerTokenToL2(\n        address _l2Address,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) public payable returns (uint256) {\n        require(\n            ArbitrumEnabledToken(msg.sender).isArbitrumEnabled() == uint8(0xa4b1),\n            \"NOT_ARB_ENABLED\"\n        );\n\n        address currL2Addr = l1ToL2Token[msg.sender];\n        if (currL2Addr != address(0)) {\n            // if token is already set, don\u0027t allow it to set a different L2 address\n            require(currL2Addr == _l2Address, \"NO_UPDATE_TO_DIFFERENT_ADDR\");\n        }\n\n        l1ToL2Token[msg.sender] = _l2Address;\n\n        address[] memory l1Addresses = new address[](1);\n        address[] memory l2Addresses = new address[](1);\n        l1Addresses[0] = msg.sender;\n        l2Addresses[0] = _l2Address;\n\n        emit TokenSet(l1Addresses[0], l2Addresses[0]);\n\n        bytes memory _data = abi.encodeWithSelector(\n            L2CustomGateway.registerTokenFromL1.selector,\n            l1Addresses,\n            l2Addresses\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                _creditBackAddress,\n                msg.value,\n                0,\n                _maxSubmissionCost,\n                _maxGas,\n                _gasPriceBid,\n                _data\n            );\n    }\n\n    /**\n     * @notice Allows owner to force register a custom L1/L2 token pair.\n     * @dev _l1Addresses[i] counterpart is assumed to be _l2Addresses[i]\n     * @param _l1Addresses array of L1 addresses\n     * @param _l2Addresses array of L2 addresses\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @return Retryable ticket ID\n     */\n    function forceRegisterTokenToL2(\n        address[] calldata _l1Addresses,\n        address[] calldata _l2Addresses,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable returns (uint256) {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        require(_l1Addresses.length == _l2Addresses.length, \"INVALID_LENGTHS\");\n\n        for (uint256 i = 0; i \u003c _l1Addresses.length; i++) {\n            // here we assume the owner checked both addresses offchain before force registering\n            // require(address(_l1Addresses[i]).isContract(), \"MUST_BE_CONTRACT\");\n            l1ToL2Token[_l1Addresses[i]] = _l2Addresses[i];\n            emit TokenSet(_l1Addresses[i], _l2Addresses[i]);\n        }\n\n        bytes memory _data = abi.encodeWithSelector(\n            L2CustomGateway.registerTokenFromL1.selector,\n            _l1Addresses,\n            _l2Addresses\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                msg.sender,\n                msg.value,\n                0,\n                _maxSubmissionCost,\n                _maxGas,\n                _gasPriceBid,\n                _data\n            );\n    }\n}\n"},"L1GatewayRouter.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Whitelist.sol\";\n\nimport { ArbitrumEnabledToken } from \"../ICustomToken.sol\";\nimport \"./L1ArbitrumMessenger.sol\";\nimport \"./GatewayRouter.sol\";\nimport \"./L2GatewayRouter.sol\";\n\n/**\n * @title Handles deposits from Erhereum into Arbitrum. Tokens are routered to their appropriate L1 gateway (Router itself also conforms to the Gateway itnerface).\n * @notice Router also serves as an L1-L2 token address oracle.\n */\ncontract L1GatewayRouter is WhitelistConsumer, L1ArbitrumMessenger, GatewayRouter {\n    address public owner;\n    address public inbox;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    function initialize(\n        address _owner,\n        address _defaultGateway,\n        address _whitelist,\n        address _counterpartGateway,\n        address _inbox\n    ) public {\n        GatewayRouter._initialize(_counterpartGateway, address(0), _defaultGateway);\n        owner = _owner;\n        WhitelistConsumer.whitelist = _whitelist;\n        inbox = _inbox;\n    }\n\n    function setDefaultGateway(\n        address newL1DefaultGateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable onlyOwner returns (uint256) {\n        defaultGateway = newL1DefaultGateway;\n\n        emit DefaultGatewayUpdated(newL1DefaultGateway);\n\n        address l2NewDefaultGateway;\n\n        if (newL1DefaultGateway != address(0)) {\n            l2NewDefaultGateway = TokenGateway(newL1DefaultGateway).counterpartGateway();\n        }\n\n        bytes memory data = abi.encodeWithSelector(\n            L2GatewayRouter.setDefaultGateway.selector,\n            l2NewDefaultGateway\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                msg.sender,\n                msg.value,\n                0,\n                L2GasParams({\n                    _maxSubmissionCost: _maxSubmissionCost,\n                    _maxGas: _maxGas,\n                    _gasPriceBid: _gasPriceBid\n                }),\n                data\n            );\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"INVALID_OWNER\");\n        // set newOwner to address(1) to disable owner and keep `initialize` safe\n        owner = newOwner;\n    }\n\n    function _setGateways(\n        address[] memory _token,\n        address[] memory _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) internal returns (uint256) {\n        require(_token.length == _gateway.length, \"WRONG_LENGTH\");\n\n        for (uint256 i = 0; i \u003c _token.length; i++) {\n            l1TokenToGateway[_token[i]] = _gateway[i];\n            emit GatewaySet(_token[i], _gateway[i]);\n            // overwrite memory so the L2 router receives the L2 address of each gateway\n            if (_gateway[i] != address(0)) {\n                // if we are assigning a gateway to the token, the address oracle of the gateway\n                // must return something other than the 0 address\n                // this check helps avoid misconfiguring gateways\n                require(\n                    TokenGateway(_gateway[i]).calculateL2TokenAddress(_token[i]) != address(0),\n                    \"TOKEN_NOT_HANDLED_BY_GATEWAY\"\n                );\n                _gateway[i] = TokenGateway(_gateway[i]).counterpartGateway();\n            }\n        }\n\n        bytes memory data = abi.encodeWithSelector(\n            L2GatewayRouter.setGateway.selector,\n            _token,\n            _gateway\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                _creditBackAddress,\n                msg.value,\n                0,\n                L2GasParams({\n                    _maxSubmissionCost: _maxSubmissionCost,\n                    _maxGas: _maxGas,\n                    _gasPriceBid: _gasPriceBid\n                }),\n                data\n            );\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its gateway. (other setGateway method allows excess eth recovery from _maxSubmissionCost and is recommended)\n\n     * @param _gateway l1 gateway address\n     * @param _maxGas max gas for L2 retryable exrecution \n     * @param _gasPriceBid gas price for L2 retryable ticket \n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et \n     * @return Retryable ticket ID\n     */\n    function setGateway(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable returns (uint256) {\n        return setGateway(_gateway, _maxGas, _gasPriceBid, _maxSubmissionCost, msg.sender);\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its gateway.\n     * param _gateway l1 gateway address\n     * param _maxGas max gas for L2 retryable exrecution\n     * param _gasPriceBid gas price for L2 retryable ticket\n     * param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\n     * return Retryable ticket ID\n     */\n    function setGateway(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) public payable returns (uint256) {\n        require(\n            ArbitrumEnabledToken(msg.sender).isArbitrumEnabled() == uint8(0xa4b1),\n            \"NOT_ARB_ENABLED\"\n        );\n        require(_gateway.isContract(), \"NOT_TO_CONTRACT\");\n\n        address currGateway = l1TokenToGateway[msg.sender];\n        if (currGateway != address(0)) {\n            // if gateway is already set, don\u0027t allow it to set a different gateway\n            require(currGateway == _gateway, \"NO_UPDATE_TO_DIFFERENT_ADDR\");\n        }\n\n        address[] memory _tokenArr = new address[](1);\n        _tokenArr[0] = address(msg.sender);\n\n        address[] memory _gatewayArr = new address[](1);\n        _gatewayArr[0] = _gateway;\n\n        return\n            _setGateways(\n                _tokenArr,\n                _gatewayArr,\n                _maxGas,\n                _gasPriceBid,\n                _maxSubmissionCost,\n                _creditBackAddress\n            );\n    }\n\n    function setGateways(\n        address[] memory _token,\n        address[] memory _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable onlyOwner returns (uint256) {\n        // it is assumed that token and gateway are both contracts\n        // require(_token[i].isContract() \u0026\u0026 _gateway[i].isContract(), \"NOT_CONTRACT\");\n        return\n            _setGateways(_token, _gateway, _maxGas, _gasPriceBid, _maxSubmissionCost, msg.sender);\n    }\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable override onlyWhitelisted returns (bytes memory) {\n        // when sending a L1 to L2 transaction, we expect the user to send\n        // eth in flight in order to pay for L2 gas costs\n        // this check prevents users from misconfiguring the msg.value\n        (uint256 _maxSubmissionCost, ) = abi.decode(_data, (uint256, bytes));\n\n        // here we don\u0027t use SafeMath since this validation is to prevent users\n        // from shooting themselves on the foot.\n        uint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);\n        require(_maxSubmissionCost \u003e 0, \"NO_SUBMISSION_COST\");\n        require(msg.value == expectedEth, \"WRONG_ETH_VALUE\");\n\n        // will revert if msg.sender is not whitelisted\n        return super.outboundTransfer(_token, _to, _amount, _maxGas, _gasPriceBid, _data);\n    }\n\n    modifier onlyCounterpartGateway() override {\n        // don\u0027t expect messages from L2 router\n        revert(\"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n}\n"},"L2ArbitrumGateway.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Address.sol\";\nimport \"./BytesLib.sol\";\nimport \"./ProxyUtil.sol\";\nimport \"./AddressAliasHelper.sol\";\n\nimport \"./IArbToken.sol\";\n\nimport \"./L2ArbitrumMessenger.sol\";\nimport \"./GatewayMessageHandler.sol\";\nimport \"./TokenGateway.sol\";\n\n/**\n * @title Common interface for gatways on Arbitrum messaging to L1.\n */\nabstract contract L2ArbitrumGateway is L2ArbitrumMessenger, TokenGateway {\n    using Address for address;\n\n    uint256 public exitNum;\n\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    event WithdrawalInitiated(\n        address l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _l2ToL1Id,\n        uint256 _exitNum,\n        uint256 _amount\n    );\n\n    modifier onlyCounterpartGateway() override {\n        require(\n            msg.sender == counterpartGateway ||\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender) == counterpartGateway,\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n    function postUpgradeInit() external {\n        // it is assumed the L2 Arbitrum Gateway contract is behind a Proxy controlled by a proxy admin\n        // this function can only be called by the proxy admin contract\n        address proxyAdmin = ProxyUtil.getProxyAdmin();\n        require(msg.sender == proxyAdmin, \"NOT_FROM_ADMIN\");\n        // this has no other logic since the current upgrade doesn\u0027t require this logic\n    }\n\n    function _initialize(address _l1Counterpart, address _router) internal virtual override {\n        TokenGateway._initialize(_l1Counterpart, _router);\n        // L1 gateway must have a router\n        require(_router != address(0), \"BAD_ROUTER\");\n    }\n\n    function createOutboundTx(\n        address _from,\n        uint256, /* _tokenAmount */\n        bytes memory _outboundCalldata\n    ) internal virtual returns (uint256) {\n        // We make this function virtual since outboundTransfer logic is the same for many gateways\n        // but sometimes (ie weth) you construct the outgoing message differently.\n\n        // exitNum incremented after being included in _outboundCalldata\n        exitNum++;\n        return\n            sendTxToL1(\n                // default to sending no callvalue to the L1\n                0,\n                _from,\n                counterpartGateway,\n                _outboundCalldata\n            );\n    }\n\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view override returns (bytes memory outboundCalldata) {\n        outboundCalldata = abi.encodeWithSelector(\n            TokenGateway.finalizeInboundTransfer.selector,\n            _token,\n            _from,\n            _to,\n            _amount,\n            GatewayMessageHandler.encodeFromL2GatewayMsg(exitNum, _data)\n        );\n\n        return outboundCalldata;\n    }\n\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable virtual returns (bytes memory) {\n        return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n    }\n\n    /**\n     * @notice Initiates a token withdrawal from Arbitrum to Ethereum\n     * @param _l1Token l1 address of token\n     * @param _to destination address\n     * @param _amount amount of tokens withdrawn\n     * @return res encoded unique identifier for withdrawal\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256, /* _maxGas */\n        uint256, /* _gasPriceBid */\n        bytes calldata _data\n    ) public payable virtual override returns (bytes memory res) {\n        // This function is set as public and virtual so that subclasses can override\n        // it and add custom validation for callers (ie only whitelisted users)\n\n        // the function is marked as payable to conform to the inheritance setup\n        // this particular code path shouldn\u0027t have a msg.value \u003e 0\n        // TODO: remove this invariant for execution markets\n        require(msg.value == 0, \"NO_VALUE\");\n\n        address _from;\n        bytes memory _extraData;\n        {\n            if (isRouter(msg.sender)) {\n                (_from, _extraData) = GatewayMessageHandler.parseFromRouterToGateway(_data);\n            } else {\n                _from = msg.sender;\n                _extraData = _data;\n            }\n        }\n        // the inboundEscrowAndCall functionality has been disabled, so no data is allowed\n        require(_extraData.length == 0, \"EXTRA_DATA_DISABLED\");\n\n        uint256 id;\n        {\n            address l2Token = calculateL2TokenAddress(_l1Token);\n            require(l2Token.isContract(), \"TOKEN_NOT_DEPLOYED\");\n            require(IArbToken(l2Token).l1Address() == _l1Token, \"NOT_EXPECTED_L1_TOKEN\");\n\n            _amount = outboundEscrowTransfer(l2Token, _from, _amount);\n            id = triggerWithdrawal(_l1Token, _from, _to, _amount, _extraData);\n        }\n        return abi.encode(id);\n    }\n\n    function triggerWithdrawal(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) internal returns (uint256) {\n        // exit number used for tradeable exits\n        uint256 currExitNum = exitNum;\n        // unique id used to identify the L2 to L1 tx\n        uint256 id = createOutboundTx(\n            _from,\n            _amount,\n            getOutboundCalldata(_l1Token, _from, _to, _amount, _data)\n        );\n        emit WithdrawalInitiated(_l1Token, _from, _to, id, currExitNum, _amount);\n        return id;\n    }\n\n    function outboundEscrowTransfer(\n        address _l2Token,\n        address _from,\n        uint256 _amount\n    ) internal virtual returns (uint256 amountBurnt) {\n        // this method is virtual since different subclasses can handle escrow differently\n        // user funds are escrowed on the gateway using this function\n        // burns L2 tokens in order to release escrowed L1 tokens\n        IArbToken(_l2Token).bridgeBurn(_from, _amount);\n        // by default we assume that the amount we send to bridgeBurn is the amount burnt\n        // this might not be the case for every token\n        return _amount;\n    }\n\n    function inboundEscrowTransfer(\n        address _l2Address,\n        address _dest,\n        uint256 _amount\n    ) internal virtual {\n        // this method is virtual since different subclasses can handle escrow differently\n        IArbToken(_l2Address).bridgeMint(_dest, _amount);\n    }\n\n    /**\n     * @notice Mint on L2 upon L1 deposit.\n     * If token not yet deployed and symbol/name/decimal data is included, deploys StandardArbERC20\n     * @dev Callable only by the L1ERC20Gateway.outboundTransfer method. For initial deployments of a token the L1 L1ERC20Gateway\n     * is expected to include the deployData. If not a L1 withdrawal is automatically triggered for the user\n     * @param _token L1 address of ERC20\n     * @param _from account that initiated the deposit in the L1\n     * @param _to account to be credited with the tokens in the L2 (can be the user\u0027s L2 account or a contract)\n     * @param _amount token amount to be minted to the user\n     * @param _data encoded symbol/name/decimal data for deploy, in addition to any additional callhook data\n     */\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCounterpartGateway {\n        (bytes memory gatewayData, bytes memory callHookData) = GatewayMessageHandler\n            .parseFromL1GatewayMsg(_data);\n\n        if (callHookData.length != 0) {\n            // callHookData should always be 0 since inboundEscrowAndCall is disabled\n            callHookData = bytes(\"\");\n        }\n\n        address expectedAddress = calculateL2TokenAddress(_token);\n\n        if (!expectedAddress.isContract()) {\n            bool shouldHalt = handleNoContract(\n                _token,\n                expectedAddress,\n                _from,\n                _to,\n                _amount,\n                gatewayData\n            );\n            if (shouldHalt) return;\n        }\n        // ignores gatewayData if token already deployed\n\n        {\n            // validate if L1 address supplied matches that of the expected L2 address\n            (bool success, bytes memory _l1AddressData) = expectedAddress.staticcall(\n                abi.encodeWithSelector(IArbToken.l1Address.selector)\n            );\n\n            bool shouldWithdraw;\n            if (!success || _l1AddressData.length \u003c 32) {\n                shouldWithdraw = true;\n            } else {\n                // we do this in the else branch since we want to avoid reverts\n                // and `toAddress` reverts if _l1AddressData has a short length\n                // `_l1AddressData` should be 12 bytes of padding then 20 bytes for the address\n                address expectedL1Address = BytesLib.toAddress(_l1AddressData, 12);\n                if (expectedL1Address != _token) {\n                    shouldWithdraw = true;\n                }\n            }\n\n            if (shouldWithdraw) {\n                // we don\u0027t need the return value from triggerWithdrawal since this is forcing\n                // a withdrawal back to the L1 instead of composing with a L2 dapp\n                triggerWithdrawal(_token, address(this), _from, _amount, \"\");\n                return;\n            }\n        }\n\n        inboundEscrowTransfer(expectedAddress, _to, _amount);\n        emit DepositFinalized(_token, _from, _to, _amount);\n\n        return;\n    }\n\n    // returns if function should halt after\n    function handleNoContract(\n        address _l1Token,\n        address expectedL2Address,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory gatewayData\n    ) internal virtual returns (bool shouldHalt);\n}\n"},"L2ArbitrumMessenger.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./ArbSys.sol\";\n\n/// @notice L2 utility contract to assist with L1 \u003c=\u003e L2 interactions\n/// @dev this is an abstract contract instead of library so the functions can be easily overriden when testing\nabstract contract L2ArbitrumMessenger {\n    address internal constant ARB_SYS_ADDRESS = address(100);\n\n    event TxToL1(address indexed _from, address indexed _to, uint256 indexed _id, bytes _data);\n\n    function sendTxToL1(\n        uint256 _l1CallValue,\n        address _from,\n        address _to,\n        bytes memory _data\n    ) internal virtual returns (uint256) {\n        uint256 _id = ArbSys(ARB_SYS_ADDRESS).sendTxToL1{ value: _l1CallValue }(_to, _data);\n        emit TxToL1(_from, _to, _id, _data);\n        return _id;\n    }\n}\n"},"L2CustomGateway.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./L2ArbitrumGateway.sol\";\nimport \"./ICustomGateway.sol\";\n\nimport \"./SafeMath.sol\";\nimport \"./ERC20.sol\";\n\ncontract L2CustomGateway is L2ArbitrumGateway, ICustomGateway {\n    // stores addresses of L2 tokens to be used\n    mapping(address =\u003e address) public override l1ToL2Token;\n\n    function initialize(address _l1Counterpart, address _router) public {\n        L2ArbitrumGateway._initialize(_l1Counterpart, _router);\n    }\n\n    /**\n     * @notice internal utility function used to handle when no contract is deployed at expected address\n     */\n    function handleNoContract(\n        address _l1Token,\n        address, /* expectedL2Address */\n        address _from,\n        address, /* _to */\n        uint256 _amount,\n        bytes memory /* gatewayData */\n    ) internal override returns (bool shouldHalt) {\n        // it is assumed that the custom token is deployed in the L2 before deposits are made\n        // trigger withdrawal\n        // we don\u0027t need the return value from triggerWithdrawal since this is forcing a withdrawal back to the L1\n        // instead of composing with a L2 dapp\n        triggerWithdrawal(_l1Token, address(this), _from, _amount, \"\");\n        return true;\n    }\n\n    function outboundEscrowTransfer(\n        address _l2Token,\n        address _from,\n        uint256 _amount\n    ) internal override returns (uint256 amountBurnt) {\n        uint256 prevBalance = IERC20(_l2Token).balanceOf(_from);\n\n        // in the custom gateway, we do the same behaviour as the superclass, but actually check\n        // for the balances of tokens to ensure that inflationary / deflationary changes in the amount\n        // are taken into account\n        // we ignore the return value since we actually query the token before and after to calculate\n        // the amount of tokens that were burnt\n        super.outboundEscrowTransfer(_l2Token, _from, _amount);\n\n        uint256 postBalance = IERC20(_l2Token).balanceOf(_from);\n        return SafeMath.sub(prevBalance, postBalance);\n    }\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) public view override returns (address) {\n        return l1ToL2Token[l1ERC20];\n    }\n\n    function registerTokenFromL1(address[] calldata l1Address, address[] calldata l2Address)\n        external\n        onlyCounterpartGateway\n    {\n        // we assume both arrays are the same length, safe since its encoded by the L1\n        for (uint256 i = 0; i \u003c l1Address.length; i++) {\n            // here we don\u0027t check if l2Address is a contract and instead deal with that behaviour\n            // in `handleNoContract` this way we keep the l1 and l2 address oracles in sync\n            l1ToL2Token[l1Address[i]] = l2Address[i];\n            emit TokenSet(l1Address[i], l2Address[i]);\n        }\n    }\n}\n"},"L2GatewayRouter.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./GatewayRouter.sol\";\nimport \"./L1GatewayRouter.sol\";\nimport \"./L2ArbitrumMessenger.sol\";\nimport \"./AddressAliasHelper.sol\";\n\n/**\n * @title Handles withdrawals from Ethereum into Arbitrum. Tokens are routered to their appropriate L2 gateway (Router itself also conforms to the Gateway interface).\n * @notice Router also serves as an L2-L1 token address oracle.\n */\ncontract L2GatewayRouter is GatewayRouter, L2ArbitrumMessenger {\n    modifier onlyCounterpartGateway() override {\n        require(\n            msg.sender == counterpartGateway ||\n                AddressAliasHelper.undoL1ToL2Alias(msg.sender) == counterpartGateway,\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n    function initialize(address _counterpartGateway, address _defaultGateway) public {\n        GatewayRouter._initialize(_counterpartGateway, address(0), _defaultGateway);\n    }\n\n    function setGateway(address[] memory _l1Token, address[] memory _gateway)\n        external\n        onlyCounterpartGateway\n    {\n        // counterpart gateway (L1 router) should never allow wrong lengths\n        assert(_l1Token.length == _gateway.length);\n\n        for (uint256 i = 0; i \u003c _l1Token.length; i++) {\n            l1TokenToGateway[_l1Token[i]] = _gateway[i];\n            emit GatewaySet(_l1Token[i], _gateway[i]);\n        }\n    }\n\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable returns (bytes memory) {\n        return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n    }\n\n    function setDefaultGateway(address newL2DefaultGateway) external onlyCounterpartGateway {\n        defaultGateway = newL2DefaultGateway;\n        emit DefaultGatewayUpdated(newL2DefaultGateway);\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"ProxyUtil.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary ProxyUtil {\n    function getProxyAdmin() internal view returns (address admin) {\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/proxy/TransparentUpgradeableProxy.sol#L48\n        // Storage slot with the admin of the proxy contract.\n        // This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n        assembly {\n            admin := sload(slot)\n        }\n    }\n}\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c \u003c a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b \u003e a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        return a % b;\n    }\n}\n"},"SperaxTokenL1.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./ERC20.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./L1CustomGateway.sol\";\nimport \"./L1GatewayRouter.sol\";\nimport \"./ICustomToken.sol\";\nimport \"./ISperaxToken.sol\";\n\ncontract SperaxTokenL1 is ERC20, Ownable, ICustomToken {\n    using SafeERC20 for IERC20;\n    address public spaAddress;\n    address public bridge;\n    address public router;\n    bool private shouldRegisterGateway;\n    event ArbitrumGatewayRouterChanged(address newBridge, address newRouter);\n    event SPAaddressUpdated(address oldSPA, address newSPA);\n\n    modifier onlyGateway() {\n        require(_msgSender() == bridge, \"ONLY_GATEWAY\");\n        _;\n    }\n\n    constructor(string memory name_, string memory symbol_, address _spaAddress, address _bridge, address _router) ERC20(name_, symbol_) public {\n        spaAddress = _spaAddress;\n        bridge = _bridge;\n        router = _router;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override(ERC20, ICustomToken) returns (bool) {\n        return ERC20.transferFrom(sender, recipient, amount);\n    }\n\n    function balanceOf(address account) public view override(ERC20, ICustomToken) returns (uint256) {\n        return ERC20.balanceOf(account);\n    }\n\n    /**\n     * @dev mint SperaxTokenL1\n     */\n    function mint(uint256 amount) external {\n        ISperaxToken(spaAddress).burnFrom(_msgSender(), amount);\n        _mint(_msgSender(), amount);\n    }\n\n    /**\n     * @dev burn SperaxTokenL1\n     */\n    function burn(uint256 amount) external {\n        ISperaxToken(spaAddress).mintForUSDs(_msgSender(), amount);\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev mint SPA when user withdraw from Arbitrum L2\n     */\n    function bridgeMint(address account, uint256 amount) onlyGateway external {\n        ISperaxToken(spaAddress).mintForUSDs(account, amount);\n    }\n\n    // Arbitrum\n    /// @dev we only set shouldRegisterGateway to true when in `registerTokenOnL2`\n    function isArbitrumEnabled() external view override returns (uint8) {\n        require(shouldRegisterGateway, \"NOT_EXPECTED_CALL\");\n        return uint8(0xa4b1);\n    }\n\n    /**\n     * @notice change the arbitrum bridge and router address\n     * @dev normally this function should not be called\n     * @param newBridge the new bridge address\n     * @param newRouter the new router address\n     */\n    function changeArbToken(address newBridge, address newRouter) external onlyOwner {\n        bridge = newBridge;\n        router = newRouter;\n        emit ArbitrumGatewayRouterChanged(bridge, router);\n    }\n\n    function changeSpaAddress(address newSPA) external onlyOwner {\n        emit SPAaddressUpdated(spaAddress, newSPA);\n        spaAddress = newSPA;\n    }\n\n    function registerTokenOnL2(\n        address l2CustomTokenAddress,\n        uint256 maxSubmissionCostForCustomBridge,\n        uint256 maxSubmissionCostForRouter,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 valueForGateway,\n        uint256 valueForRouter,\n        address creditBackAddress\n    ) external payable onlyOwner override {\n        // we temporarily set `shouldRegisterGateway` to true for the callback in registerTokenToL2 to succeed\n        bool prev = shouldRegisterGateway;\n        shouldRegisterGateway = true;\n\n        L1CustomGateway(bridge).registerTokenToL2{value:valueForGateway}(\n            l2CustomTokenAddress,\n            maxGas,\n            gasPriceBid,\n            maxSubmissionCostForCustomBridge,\n            creditBackAddress\n        );\n\n        L1GatewayRouter(router).setGateway{value:valueForRouter}(\n            bridge,\n            maxGas,\n            gasPriceBid,\n            maxSubmissionCostForRouter,\n            creditBackAddress\n        );\n\n        shouldRegisterGateway = prev;\n    }\n}\n"},"TokenGateway.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./ITokenGateway.sol\";\nimport \"./Address.sol\";\n\nabstract contract TokenGateway is ITokenGateway {\n    using Address for address;\n\n    address public counterpartGateway;\n    address public router;\n\n    modifier onlyCounterpartGateway() virtual {\n        // this method is overriden in gateways that require special logic for validation\n        // ie L2 to L1 messages need to be validated against the outbox\n        require(msg.sender == counterpartGateway, \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    function _initialize(address _counterpartGateway, address _router) internal virtual {\n        // This initializes internal variables of the abstract contract it can be chained together with other functions.\n        // It is virtual so subclasses can override or wrap around this logic.\n        // An example where this is useful is different subclasses that validate the router address differently\n        require(_counterpartGateway != address(0), \"INVALID_COUNTERPART\");\n        require(counterpartGateway == address(0), \"ALREADY_INIT\");\n        counterpartGateway = _counterpartGateway;\n        router = _router;\n    }\n\n    function isRouter(address _target) internal view returns (bool isTargetRouter) {\n        return _target == router;\n    }\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20)\n        public\n        view\n        virtual\n        override\n        returns (address);\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable virtual override returns (bytes memory);\n\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view virtual returns (bytes memory);\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable virtual override;\n}\n"},"Whitelist.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nabstract contract WhitelistConsumer {\n    address public whitelist;\n\n    event WhitelistSourceUpdated(address newSource);\n\n    modifier onlyWhitelisted() {\n        if (whitelist != address(0)) {\n            require(Whitelist(whitelist).isAllowed(msg.sender), \"NOT_WHITELISTED\");\n        }\n        _;\n    }\n\n    function updateWhitelistSource(address newSource) external {\n        require(msg.sender == whitelist, \"NOT_FROM_LIST\");\n        whitelist = newSource;\n        emit WhitelistSourceUpdated(newSource);\n    }\n}\n\ncontract Whitelist {\n    address public owner;\n    mapping(address =\u003e bool) public isAllowed;\n\n    event OwnerUpdated(address newOwner);\n    event WhitelistUpgraded(address newWhitelist, address[] targets);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    function setWhitelist(address[] memory user, bool[] memory val) external onlyOwner {\n        require(user.length == val.length, \"INVALID_INPUT\");\n\n        for (uint256 i = 0; i \u003c user.length; i++) {\n            isAllowed[user[i]] = val[i];\n        }\n    }\n\n    // set new whitelist to address(0) to disable whitelist\n    function triggerConsumers(address newWhitelist, address[] memory targets) external onlyOwner {\n        for (uint256 i = 0; i \u003c targets.length; i++) {\n            WhitelistConsumer(targets[i]).updateWhitelistSource(newWhitelist);\n        }\n        emit WhitelistUpgraded(newWhitelist, targets);\n    }\n}\n"}}