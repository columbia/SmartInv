{{
  "language": "Solidity",
  "sources": {
    "contracts/auction/AuctionHouse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./Staged.sol\";\nimport \"./AuctionHouseMath.sol\";\n\nimport \"./interfaces/IAuctionHouse.sol\";\n\nimport \"../funds/interfaces/basket/IBasketReader.sol\";\nimport \"../oracle/interfaces/ITwap.sol\";\nimport \"../policy/interfaces/IMonetaryPolicy.sol\";\nimport \"../tokens/interfaces/ISupplyControlledERC20.sol\";\n\nimport \"../lib/BasisMath.sol\";\nimport \"../lib/BlockNumber.sol\";\nimport \"../lib/Recoverable.sol\";\nimport \"../external-lib/SafeDecimalMath.sol\";\nimport \"../tokens/SafeSupplyControlledERC20.sol\";\n\n/**\n * @title Float Protocol Auction House\n * @notice The contract used to sell or buy FLOAT\n * @dev This contract does not store any assets, except for protocol fees, hence\n * it implements an asset recovery functionality (Recoverable).\n */\ncontract AuctionHouse is\n  IAuctionHouse,\n  BlockNumber,\n  AuctionHouseMath,\n  AccessControl,\n  Staged,\n  Recoverable\n{\n  using SafeMath for uint256;\n  using SafeDecimalMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ISupplyControlledERC20;\n  using SafeSupplyControlledERC20 for ISupplyControlledERC20;\n  using BasisMath for uint256;\n\n  /* ========== CONSTANTS ========== */\n  bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n\n  IERC20 internal immutable weth;\n  ISupplyControlledERC20 internal immutable bank;\n  ISupplyControlledERC20 internal immutable float;\n  IBasketReader internal immutable basket;\n\n  /* ========== STATE VARIABLES ========== */\n  // Monetary Policy Contract that decides the target price\n  IMonetaryPolicy internal monetaryPolicy;\n  // Provides the BANK-ETH Time Weighted Average Price (TWAP) [e27]\n  ITwap internal bankEthOracle;\n  // Provides the FLOAT-ETH Time Weighted Average Price (TWAP) [e27]\n  ITwap internal floatEthOracle;\n\n  /// @inheritdoc IAuctionHouseState\n  uint16 public override buffer = 10_00; // 10% default\n\n  /// @inheritdoc IAuctionHouseState\n  uint16 public override protocolFee = 5_00; // 5% / 500 bps\n\n  /// @inheritdoc IAuctionHouseState\n  uint32 public override allowanceCap = 10_00; // 10% / 1000 bps\n\n  /// @inheritdoc IAuctionHouseVariables\n  uint64 public override round;\n\n  /**\n   * @notice Allows for monetary policy updates to be enabled and disabled.\n   */\n  bool public shouldUpdatePolicy = true;\n\n  /**\n   * Note that we choose to freeze all price values at the start of an auction.\n   * These values are stale _by design_. The burden of price checking\n   * is moved to the arbitrager, already vital for them to make a profit.\n   * We don't mind these values being out of date, as we start the auctions from a position generously in favour of the protocol (assuming our target price is correct). If these market values are stale, then profit opportunity will start earlier / later, and hence close out a mispriced auction early.\n   * We also start the auctions at `buffer`% of the price.\n   */\n\n  /// @inheritdoc IAuctionHouseVariables\n  mapping(uint64 => Auction) public override auctions;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    // Dependencies\n    address _weth,\n    address _bank,\n    address _float,\n    address _basket,\n    address _monetaryPolicy,\n    address _gov,\n    address _bankEthOracle,\n    address _floatEthOracle,\n    // Parameters\n    uint16 _auctionDuration,\n    uint32 _auctionCooldown,\n    uint256 _firstAuctionBlock\n  ) Staged(_auctionDuration, _auctionCooldown, _firstAuctionBlock) {\n    // Tokens\n    weth = IERC20(_weth);\n    bank = ISupplyControlledERC20(_bank);\n    float = ISupplyControlledERC20(_float);\n\n    // Basket\n    basket = IBasketReader(_basket);\n\n    // Monetary Policy\n    monetaryPolicy = IMonetaryPolicy(_monetaryPolicy);\n    floatEthOracle = ITwap(_floatEthOracle);\n    bankEthOracle = ITwap(_bankEthOracle);\n\n    emit ModifyParameters(\"monetaryPolicy\", _monetaryPolicy);\n    emit ModifyParameters(\"floatEthOracle\", _floatEthOracle);\n    emit ModifyParameters(\"bankEthOracle\", _bankEthOracle);\n\n    emit ModifyParameters(\"auctionDuration\", _auctionDuration);\n    emit ModifyParameters(\"auctionCooldown\", _auctionCooldown);\n    emit ModifyParameters(\"lastAuctionBlock\", lastAuctionBlock);\n    emit ModifyParameters(\"buffer\", buffer);\n    emit ModifyParameters(\"protocolFee\", protocolFee);\n    emit ModifyParameters(\"allowanceCap\", allowanceCap);\n\n    // Roles\n    _setupRole(DEFAULT_ADMIN_ROLE, _gov);\n    _setupRole(GOVERNANCE_ROLE, _gov);\n    _setupRole(RECOVER_ROLE, _gov);\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier onlyGovernance {\n    require(\n      hasRole(GOVERNANCE_ROLE, _msgSender()),\n      \"AuctionHouse/GovernanceRole\"\n    );\n    _;\n  }\n\n  modifier inExpansion {\n    require(\n      latestAuction().stabilisationCase == Cases.Up ||\n        latestAuction().stabilisationCase == Cases.Restock,\n      \"AuctionHouse/NotInExpansion\"\n    );\n    _;\n  }\n\n  modifier inContraction {\n    require(\n      latestAuction().stabilisationCase == Cases.Confidence ||\n        latestAuction().stabilisationCase == Cases.Down,\n      \"AuctionHouse/NotInContraction\"\n    );\n    _;\n  }\n\n  /* ========== VIEWS ========== */\n\n  /// @inheritdoc IAuctionHouseDerivedState\n  function price()\n    public\n    view\n    override(IAuctionHouseDerivedState)\n    returns (uint256 wethPrice, uint256 bankPrice)\n  {\n    Auction memory _latestAuction = latestAuction();\n    uint256 _step = step();\n\n    wethPrice = lerp(\n      _latestAuction.startWethPrice,\n      _latestAuction.endWethPrice,\n      _step,\n      auctionDuration\n    );\n    bankPrice = lerp(\n      _latestAuction.startBankPrice,\n      _latestAuction.endBankPrice,\n      _step,\n      auctionDuration\n    );\n    return (wethPrice, bankPrice);\n  }\n\n  /// @inheritdoc IAuctionHouseDerivedState\n  function step()\n    public\n    view\n    override(IAuctionHouseDerivedState)\n    atStage(Stages.AuctionActive)\n    returns (uint256)\n  {\n    // .sub is unnecessary here - block number >= lastAuctionBlock.\n    return _blockNumber() - lastAuctionBlock;\n  }\n\n  function _startPrice(\n    bool expansion,\n    Cases stabilisationCase,\n    uint256 targetFloatInEth,\n    uint256 marketFloatInEth,\n    uint256 bankInEth,\n    uint256 basketFactor\n  ) internal view returns (uint256 wethStart, uint256 bankStart) {\n    uint256 bufferedMarketPrice =\n      _bufferedMarketPrice(expansion, marketFloatInEth);\n\n    if (stabilisationCase == Cases.Up) {\n      uint256 bankProportion =\n        bufferedMarketPrice.sub(targetFloatInEth).divideDecimalRoundPrecise(\n          bankInEth\n        );\n\n      return (targetFloatInEth, bankProportion);\n    }\n\n    if (\n      stabilisationCase == Cases.Restock ||\n      stabilisationCase == Cases.Confidence\n    ) {\n      return (bufferedMarketPrice, 0);\n    }\n\n    assert(stabilisationCase == Cases.Down);\n    assert(basketFactor < SafeDecimalMath.PRECISE_UNIT);\n    uint256 invertedBasketFactor =\n      SafeDecimalMath.PRECISE_UNIT.sub(basketFactor);\n\n    uint256 basketFactorAdjustedEth =\n      bufferedMarketPrice.multiplyDecimalRoundPrecise(basketFactor);\n\n    // Note that the PRECISE_UNIT factors itself out\n    uint256 basketFactorAdjustedBank =\n      bufferedMarketPrice.mul(invertedBasketFactor).div(bankInEth);\n    return (basketFactorAdjustedEth, basketFactorAdjustedBank);\n  }\n\n  function _endPrice(\n    Cases stabilisationCase,\n    uint256 targetFloatInEth,\n    uint256 bankInEth,\n    uint256 basketFactor\n  ) internal pure returns (uint256 wethEnd, uint256 bankEnd) {\n    if (stabilisationCase == Cases.Down) {\n      assert(basketFactor < SafeDecimalMath.PRECISE_UNIT);\n      uint256 invertedBasketFactor =\n        SafeDecimalMath.PRECISE_UNIT.sub(basketFactor);\n\n      uint256 basketFactorAdjustedEth =\n        targetFloatInEth.multiplyDecimalRoundPrecise(basketFactor);\n\n      // Note that the PRECISE_UNIT factors itself out.\n      uint256 basketFactorAdjustedBank =\n        targetFloatInEth.mul(invertedBasketFactor).div(bankInEth);\n      return (basketFactorAdjustedEth, basketFactorAdjustedBank);\n    }\n\n    return (targetFloatInEth, 0);\n  }\n\n  /// @inheritdoc IAuctionHouseDerivedState\n  function latestAuction()\n    public\n    view\n    override(IAuctionHouseDerivedState)\n    returns (Auction memory)\n  {\n    return auctions[round];\n  }\n\n  /// @dev Returns a buffered [e27] market price, note that buffer is still [e18], so can use divideDecimal.\n  function _bufferedMarketPrice(bool expansion, uint256 marketPrice)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 factor =\n      expansion\n        ? BasisMath.FULL_PERCENT.add(buffer)\n        : BasisMath.FULL_PERCENT.sub(buffer);\n    return marketPrice.percentageOf(factor);\n  }\n\n  /// @dev Calculates the current case based on if we're expanding and basket factor.\n  function _currentCase(bool expansion, uint256 basketFactor)\n    internal\n    pure\n    returns (Cases)\n  {\n    bool underlyingDemand = basketFactor >= SafeDecimalMath.PRECISE_UNIT;\n\n    if (expansion) {\n      return underlyingDemand ? Cases.Up : Cases.Restock;\n    }\n\n    return underlyingDemand ? Cases.Confidence : Cases.Down;\n  }\n\n  /* |||||||||| AuctionPending |||||||||| */\n\n  // solhint-disable function-max-lines\n  /// @inheritdoc IAuctionHouseActions\n  function start()\n    external\n    override(IAuctionHouseActions)\n    timedTransition\n    atStage(Stages.AuctionPending)\n    returns (uint64 newRound)\n  {\n    // Check we have up to date oracles, this also ensures we don't have\n    // auctions too close together (reverts based upon timeElapsed < periodSize).\n    bankEthOracle.update(address(bank), address(weth));\n    floatEthOracle.update(address(float), address(weth));\n\n    // [e27]\n    uint256 frozenBankInEth =\n      bankEthOracle.consult(\n        address(bank),\n        SafeDecimalMath.PRECISE_UNIT,\n        address(weth)\n      );\n    // [e27]\n    uint256 frozenFloatInEth =\n      floatEthOracle.consult(\n        address(float),\n        SafeDecimalMath.PRECISE_UNIT,\n        address(weth)\n      );\n\n    // Update Monetary Policy with previous auction results\n    if (round != 0 && shouldUpdatePolicy) {\n      uint256 oldTargetPriceInEth = monetaryPolicy.consult();\n      uint256 oldBasketFactor = basket.getBasketFactor(oldTargetPriceInEth);\n\n      monetaryPolicy.updateGivenAuctionResults(\n        round,\n        lastAuctionBlock,\n        frozenFloatInEth,\n        oldBasketFactor\n      );\n    }\n\n    // Round only increments by one on start, given auction period of restriction of 150 blocks\n    // this means we'd need 2**64 / 150 blocks or ~3.7 lifetimes of the universe to overflow.\n    // Likely, we'd have upgraded the contract by this point.\n    round++;\n\n    // Calculate target price [e27]\n    uint256 frozenTargetPriceInEth = monetaryPolicy.consult();\n\n    // STC: Pull out to ValidateOracles\n    require(frozenTargetPriceInEth != 0, \"AuctionHouse/TargetSenseCheck\");\n    require(frozenBankInEth != 0, \"AuctionHouse/BankSenseCheck\");\n    require(frozenFloatInEth != 0, \"AuctionHouse/FloatSenseCheck\");\n    uint256 basketFactor = basket.getBasketFactor(frozenTargetPriceInEth);\n\n    bool expansion = frozenFloatInEth >= frozenTargetPriceInEth;\n    Cases stabilisationCase = _currentCase(expansion, basketFactor);\n\n    // Calculate Auction Price points\n    (uint256 wethStart, uint256 bankStart) =\n      _startPrice(\n        expansion,\n        stabilisationCase,\n        frozenTargetPriceInEth,\n        frozenFloatInEth,\n        frozenBankInEth,\n        basketFactor\n      );\n\n    (uint256 wethEnd, uint256 bankEnd) =\n      _endPrice(\n        stabilisationCase,\n        frozenTargetPriceInEth,\n        frozenBankInEth,\n        basketFactor\n      );\n\n    // Calculate Allowance\n    uint256 allowance =\n      AuctionHouseMath.allowance(\n        expansion,\n        allowanceCap,\n        float.totalSupply(),\n        frozenFloatInEth,\n        frozenTargetPriceInEth\n      );\n\n    require(allowance != 0, \"AuctionHouse/NoAllowance\");\n\n    auctions[round].stabilisationCase = stabilisationCase;\n    auctions[round].targetFloatInEth = frozenTargetPriceInEth;\n    auctions[round].marketFloatInEth = frozenFloatInEth;\n    auctions[round].bankInEth = frozenBankInEth;\n\n    auctions[round].basketFactor = basketFactor;\n    auctions[round].allowance = allowance;\n\n    auctions[round].startWethPrice = wethStart;\n    auctions[round].startBankPrice = bankStart;\n    auctions[round].endWethPrice = wethEnd;\n    auctions[round].endBankPrice = bankEnd;\n\n    lastAuctionBlock = _blockNumber();\n    _setStage(Stages.AuctionActive);\n\n    emit NewAuction(round, allowance, frozenTargetPriceInEth, lastAuctionBlock);\n\n    return round;\n  }\n\n  // solhint-enable function-max-lines\n\n  /* |||||||||| AuctionActive |||||||||| */\n\n  function _updateDelta(uint256 floatDelta) internal {\n    Auction memory _currentAuction = latestAuction();\n\n    require(\n      floatDelta <= _currentAuction.allowance.sub(_currentAuction.delta),\n      \"AuctionHouse/WithinAllowedDelta\"\n    );\n\n    auctions[round].delta = _currentAuction.delta.add(floatDelta);\n  }\n\n  /* |||||||||| AuctionActive:inExpansion |||||||||| */\n\n  /// @inheritdoc IAuctionHouseActions\n  function buy(\n    uint256 wethInMax,\n    uint256 bankInMax,\n    uint256 floatOutMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    override(IAuctionHouseActions)\n    timedTransition\n    atStage(Stages.AuctionActive)\n    inExpansion\n    returns (\n      uint256 usedWethIn,\n      uint256 usedBankIn,\n      uint256 usedFloatOut\n    )\n  {\n    // solhint-disable-next-line not-rely-on-time\n    require(block.timestamp <= deadline, \"AuctionHouse/TransactionTooOld\");\n\n    (uint256 wethPrice, uint256 bankPrice) = price();\n\n    usedFloatOut = Math.min(\n      wethInMax.divideDecimalRoundPrecise(wethPrice),\n      bankPrice == 0\n        ? type(uint256).max\n        : bankInMax.divideDecimalRoundPrecise(bankPrice)\n    );\n\n    require(usedFloatOut != 0, \"AuctionHouse/ZeroFloatBought\");\n    require(usedFloatOut >= floatOutMin, \"AuctionHouse/RequestedTooMuch\");\n\n    usedWethIn = wethPrice.multiplyDecimalRoundPrecise(usedFloatOut);\n    usedBankIn = bankPrice.multiplyDecimalRoundPrecise(usedFloatOut);\n\n    require(wethInMax >= usedWethIn, \"AuctionHouse/MinimumWeth\");\n    require(bankInMax >= usedBankIn, \"AuctionHouse/MinimumBank\");\n\n    _updateDelta(usedFloatOut);\n\n    emit Buy(round, _msgSender(), usedWethIn, usedBankIn, usedFloatOut);\n\n    _interactBuy(usedWethIn, usedBankIn, usedFloatOut, to);\n\n    return (usedWethIn, usedBankIn, usedFloatOut);\n  }\n\n  function _interactBuy(\n    uint256 usedWethIn,\n    uint256 usedBankIn,\n    uint256 usedFloatOut,\n    address to\n  ) internal {\n    weth.safeTransferFrom(_msgSender(), address(basket), usedWethIn);\n\n    if (usedBankIn != 0) {\n      (uint256 bankToSave, uint256 bankToBurn) =\n        usedBankIn.splitBy(protocolFee);\n\n      bank.safeTransferFrom(_msgSender(), address(this), bankToSave);\n      bank.safeBurnFrom(_msgSender(), bankToBurn);\n    }\n\n    float.safeMint(to, usedFloatOut);\n  }\n\n  /* |||||||||| AuctionActive:inContraction |||||||||| */\n\n  /// @inheritdoc IAuctionHouseActions\n  function sell(\n    uint256 floatIn,\n    uint256 wethOutMin,\n    uint256 bankOutMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    override(IAuctionHouseActions)\n    timedTransition\n    atStage(Stages.AuctionActive)\n    inContraction\n    returns (\n      uint256 usedfloatIn,\n      uint256 usedWethOut,\n      uint256 usedBankOut\n    )\n  {\n    // solhint-disable-next-line not-rely-on-time\n    require(block.timestamp <= deadline, \"AuctionHouse/TransactionTooOld\");\n    require(floatIn != 0, \"AuctionHouse/ZeroFloatSold\");\n\n    (uint256 wethPrice, uint256 bankPrice) = price();\n\n    usedWethOut = wethPrice.multiplyDecimalRoundPrecise(floatIn);\n    usedBankOut = bankPrice.multiplyDecimalRoundPrecise(floatIn);\n\n    require(wethOutMin <= usedWethOut, \"AuctionHouse/ExpectedTooMuchWeth\");\n    require(bankOutMin <= usedBankOut, \"AuctionHouse/ExpectedTooMuchBank\");\n\n    _updateDelta(floatIn);\n\n    emit Sell(round, _msgSender(), floatIn, usedWethOut, usedBankOut);\n\n    _interactSell(floatIn, usedWethOut, usedBankOut, to);\n\n    return (floatIn, usedWethOut, usedBankOut);\n  }\n\n  function _interactSell(\n    uint256 floatIn,\n    uint256 usedWethOut,\n    uint256 usedBankOut,\n    address to\n  ) internal {\n    float.safeBurnFrom(_msgSender(), floatIn);\n\n    if (usedWethOut != 0) {\n      weth.safeTransferFrom(address(basket), to, usedWethOut);\n    }\n\n    if (usedBankOut != 0) {\n      // STC: Maximum mint checks relative to allowance\n      bank.safeMint(to, usedBankOut);\n    }\n  }\n\n  /* |||||||||| AuctionCooldown, AuctionPending, AuctionActive |||||||||| */\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /* ----- onlyGovernance ----- */\n\n  /// @inheritdoc IAuctionHouseGovernedActions\n  function modifyParameters(bytes32 parameter, uint256 data)\n    external\n    override(IAuctionHouseGovernedActions)\n    onlyGovernance\n  {\n    if (parameter == \"auctionDuration\") {\n      require(data <= type(uint16).max, \"AuctionHouse/ModADMax\");\n      require(data != 0, \"AuctionHouse/ModADZero\");\n      auctionDuration = uint16(data);\n    } else if (parameter == \"auctionCooldown\") {\n      require(data <= type(uint32).max, \"AuctionHouse/ModCMax\");\n      auctionCooldown = uint32(data);\n    } else if (parameter == \"buffer\") {\n      // 0% <= buffer <= 1000%\n      require(data <= 10 * BasisMath.FULL_PERCENT, \"AuctionHouse/ModBMax\");\n      buffer = uint16(data);\n    } else if (parameter == \"protocolFee\") {\n      // 0% <= protocolFee <= 100%\n      require(data <= BasisMath.FULL_PERCENT, \"AuctionHouse/ModPFMax\");\n      protocolFee = uint16(data);\n    } else if (parameter == \"allowanceCap\") {\n      // 0% < allowanceCap <= N ~ 1_000%\n      require(data <= type(uint32).max, \"AuctionHouse/ModACMax\");\n      require(data != 0, \"AuctionHouse/ModACMin\");\n      allowanceCap = uint32(data);\n    } else if (parameter == \"shouldUpdatePolicy\") {\n      require(data == 1 || data == 0, \"AuctionHouse/ModUP\");\n      shouldUpdatePolicy = data == 1;\n    } else if (parameter == \"lastAuctionBlock\") {\n      // We wouldn't want to disable auctions for more than ~4.3 weeks\n      // A longer period should result in a \"burnt\" auction house and redeploy.\n      require(data <= block.number + 2e5, \"AuctionHouse/ModLABMax\");\n      require(data != 0, \"AuctionHouse/ModLABMin\");\n      // Can be used to pause auctions if set in the future.\n      lastAuctionBlock = data;\n    } else revert(\"AuctionHouse/InvalidParameter\");\n\n    emit ModifyParameters(parameter, data);\n  }\n\n  /// @inheritdoc IAuctionHouseGovernedActions\n  function modifyParameters(bytes32 parameter, address data)\n    external\n    override(IAuctionHouseGovernedActions)\n    onlyGovernance\n  {\n    if (parameter == \"monetaryPolicy\") {\n      // STC: Sense check\n      monetaryPolicy = IMonetaryPolicy(data);\n    } else if (parameter == \"bankEthOracle\") {\n      // STC: Sense check\n      bankEthOracle = ITwap(data);\n    } else if (parameter == \"floatEthOracle\") {\n      // STC: Sense check\n      floatEthOracle = ITwap(data);\n    } else revert(\"AuctionHouse/InvalidParameter\");\n\n    emit ModifyParameters(parameter, data);\n  }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/auction/Staged.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../lib/BlockNumber.sol\";\n\ncontract Staged is BlockNumber {\n  /**\n   * @dev The current auction stage.\n   * - AuctionCooling - We cannot start an auction due to Cooling Period.\n   * - AuctionPending - We can start an auction at any time.\n   * - AuctionActive - Auction is ongoing.\n   */\n  enum Stages {AuctionCooling, AuctionPending, AuctionActive}\n\n  /* ========== STATE VARIABLES ========== */\n\n  /**\n   * @dev The cooling period between each auction in blocks.\n   */\n  uint32 internal auctionCooldown;\n\n  /**\n   * @dev The length of the auction in blocks.\n   */\n  uint16 internal auctionDuration;\n\n  /**\n   * @notice The current stage\n   */\n  Stages public stage;\n\n  /**\n   * @notice Block number when the last auction started.\n   */\n  uint256 public lastAuctionBlock;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    uint16 _auctionDuration,\n    uint32 _auctionCooldown,\n    uint256 _firstAuctionBlock\n  ) {\n    require(\n      _firstAuctionBlock >= _auctionDuration + _auctionCooldown,\n      \"Staged/InvalidAuctionStart\"\n    );\n\n    auctionDuration = _auctionDuration;\n    auctionCooldown = _auctionCooldown;\n    lastAuctionBlock = _firstAuctionBlock - _auctionDuration - _auctionCooldown;\n    stage = Stages.AuctionCooling;\n  }\n\n  /* ============ Events ============ */\n\n  event StageChanged(uint8 _prevStage, uint8 _newStage);\n\n  /* ========== MODIFIERS ========== */\n\n  modifier atStage(Stages _stage) {\n    require(stage == _stage, \"Staged/InvalidStage\");\n    _;\n  }\n\n  /**\n   * @dev Modify the stages as necessary on call.\n   */\n  modifier timedTransition() {\n    uint256 _blockNumber = _blockNumber();\n\n    if (\n      stage == Stages.AuctionActive &&\n      _blockNumber > lastAuctionBlock + auctionDuration\n    ) {\n      stage = Stages.AuctionCooling;\n      emit StageChanged(uint8(Stages.AuctionActive), uint8(stage));\n    }\n    // Note that this can cascade so AuctionActive -> AuctionPending in one update, when auctionCooldown = 0.\n    if (\n      stage == Stages.AuctionCooling &&\n      _blockNumber > lastAuctionBlock + auctionDuration + auctionCooldown\n    ) {\n      stage = Stages.AuctionPending;\n      emit StageChanged(uint8(Stages.AuctionCooling), uint8(stage));\n    }\n\n    _;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @notice Updates the stage, even if a function with timedTransition modifier has not yet been called\n   * @return Returns current auction stage\n   */\n  function updateStage() external timedTransition returns (Stages) {\n    return stage;\n  }\n\n  /**\n   * @dev Set the stage manually.\n   */\n  function _setStage(Stages _stage) internal {\n    Stages priorStage = stage;\n    stage = _stage;\n    emit StageChanged(uint8(priorStage), uint8(_stage));\n  }\n}\n"
    },
    "contracts/auction/AuctionHouseMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"../lib/BasisMath.sol\";\nimport \"../external-lib/SafeDecimalMath.sol\";\n\ncontract AuctionHouseMath {\n  using SafeMath for uint256;\n  using SafeDecimalMath for uint256;\n  using BasisMath for uint256;\n\n  /**\n   * @notice Calculate the maximum allowance for this action to do a price correction\n   * This is normally an over-estimate as it assumes all Float is circulating\n   * and the market cap is constant through supply changes.\n   */\n  function allowance(\n    bool expansion,\n    uint256 capBasisPoint,\n    uint256 floatSupply,\n    uint256 marketFloatPrice,\n    uint256 targetFloatPrice\n  ) internal pure returns (uint256) {\n    uint256 targetSupply =\n      marketFloatPrice.mul(floatSupply).div(targetFloatPrice);\n    uint256 allowanceForAdjustment =\n      expansion ? targetSupply.sub(floatSupply) : floatSupply.sub(targetSupply);\n\n    // Cap Allowance per auction; e.g. with 10% of total supply => ~20% price move.\n    uint256 allowanceByCap = floatSupply.percentageOf(capBasisPoint);\n\n    return Math.min(allowanceForAdjustment, allowanceByCap);\n  }\n\n  /**\n   * @notice Linear interpolation: start + (end - start) * (step/duration)\n   * @dev For 150 steps, duration = 149, start / end can be in any format\n   * as long as <= 10 ** 49.\n   * @param start The starting value\n   * @param end The ending value\n   * @param step Number of blocks into interpolation\n   * @param duration Total range\n   */\n  function lerp(\n    uint256 start,\n    uint256 end,\n    uint256 step,\n    uint256 duration\n  ) internal pure returns (uint256 result) {\n    require(duration != 0, \"AuctionHouseMath/ZeroDuration\");\n    require(step <= duration, \"AuctionHouseMath/InvalidStep\");\n\n    // Max value <= 2^256 / 10^27 of which 10^49 is.\n    require(start <= 10**49, \"AuctionHouseMath/StartTooLarge\");\n    require(end <= 10**49, \"AuctionHouseMath/EndTooLarge\");\n\n    // 0 <= t <= PRECISE_UNIT\n    uint256 t = step.divideDecimalRoundPrecise(duration);\n\n    // result = start + (end - start) * t\n    //        = end * t + start - start * t\n    return\n      result = end.multiplyDecimalRoundPrecise(t).add(start).sub(\n        start.multiplyDecimalRoundPrecise(t)\n      );\n  }\n}\n"
    },
    "contracts/auction/interfaces/IAuctionHouse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./ah/IAuctionHouseState.sol\";\nimport \"./ah/IAuctionHouseVariables.sol\";\nimport \"./ah/IAuctionHouseDerivedState.sol\";\nimport \"./ah/IAuctionHouseActions.sol\";\nimport \"./ah/IAuctionHouseGovernedActions.sol\";\nimport \"./ah/IAuctionHouseEvents.sol\";\n\n/**\n * @title The interface for a Float Protocol Auction House\n * @notice The Auction House enables the sale and buy of FLOAT tokens from the\n * market in order to stabilise price.\n * @dev The Auction House interface is broken up into many smaller pieces\n */\ninterface IAuctionHouse is\n  IAuctionHouseState,\n  IAuctionHouseVariables,\n  IAuctionHouseDerivedState,\n  IAuctionHouseActions,\n  IAuctionHouseGovernedActions,\n  IAuctionHouseEvents\n{\n\n}\n"
    },
    "contracts/funds/interfaces/basket/IBasketReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\ninterface IBasketReader {\n  /**\n   * @notice Underlying token that is kept in this Basket\n   */\n  function underlying() external view returns (address);\n\n  /**\n   * @notice Given a target price, what is the basket factor\n   * @param targetPriceInUnderlying the current target price to calculate the\n   * basket factor for in the units of the underlying token.\n   */\n  function getBasketFactor(uint256 targetPriceInUnderlying)\n    external\n    view\n    returns (uint256 basketFactor);\n}\n"
    },
    "contracts/oracle/interfaces/ITwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\ninterface ITwap {\n  /**\n   * @notice Returns the amount out corresponding to the amount in for a given token using the moving average over time range [`block.timestamp` - [`windowSize`, `windowSize - periodSize * 2`], `block.timestamp`].\n   * E.g. with a windowSize = 24hrs, periodSize = 6hrs.\n   * [24hrs ago to 12hrs ago, now]\n   * @dev Update must have been called for the bucket corresponding to the timestamp `now - windowSize`\n   * @param tokenIn the address of the token we are offering\n   * @param amountIn the quantity of tokens we are pricing\n   * @param tokenOut the address of the token we want\n   * @return amountOut the `tokenOut` amount corresponding to the `amountIn` for `tokenIn` over the time range\n   */\n  function consult(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut\n  ) external view returns (uint256 amountOut);\n\n  /**\n   * @notice Checks if a particular pair can be updated\n   * @param tokenA Token A of pair (any order)\n   * @param tokenB Token B of pair (any order)\n   * @return If an update call will succeed\n   */\n  function updateable(address tokenA, address tokenB)\n    external\n    view\n    returns (bool);\n\n  /**\n   * @notice Update the cumulative price for the observation at the current timestamp. Each observation is updated at most once per epoch period.\n   * @param tokenA the first token to create pair from\n   * @param tokenB the second token to create pair from\n   * @return if the observation was updated or not.\n   */\n  function update(address tokenA, address tokenB) external returns (bool);\n}\n"
    },
    "contracts/policy/interfaces/IMonetaryPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\ninterface IMonetaryPolicy {\n  /**\n   * @notice Consult the monetary policy for the target price in eth\n   */\n  function consult() external view returns (uint256 targetPriceInEth);\n\n  /**\n   * @notice Update the Target price given the auction results.\n   * @dev 0 values are used to indicate missing data.\n   */\n  function updateGivenAuctionResults(\n    uint256 round,\n    uint256 lastAuctionBlock,\n    uint256 floatMarketPrice,\n    uint256 basketFactor\n  ) external returns (uint256 targetPriceInEth);\n}\n"
    },
    "contracts/tokens/interfaces/ISupplyControlledERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISupplyControlledERC20 is IERC20 {\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   * Requirements:\n   * - the caller must have the `MINTER_ROLE`.\n   */\n  function mint(address to, uint256 amount) external;\n\n  /**\n   * @dev Destroys `amount` tokens from the caller.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burn(uint256 amount) external;\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "contracts/lib/BasisMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n/**\n * @title Basis Mathematics\n * @notice Provides helpers to perform percentage calculations\n * @dev Percentages are [e2] i.e. with 2 decimals precision / basis point.\n */\nlibrary BasisMath {\n  uint256 internal constant FULL_PERCENT = 1e4; // 100.00% / 1000 bp\n  uint256 internal constant HALF_ONCE_SCALED = FULL_PERCENT / 2;\n\n  /**\n   * @dev Percentage pct, round 0.5+ up.\n   * @param self The value to take a percentage pct\n   * @param percentage The percentage to be calculated [e2]\n   * @return pct self * percentage\n   */\n  function percentageOf(uint256 self, uint256 percentage)\n    internal\n    pure\n    returns (uint256 pct)\n  {\n    if (self == 0 || percentage == 0) {\n      pct = 0;\n    } else {\n      require(\n        self <= (type(uint256).max - HALF_ONCE_SCALED) / percentage,\n        \"BasisMath/Overflow\"\n      );\n\n      pct = (self * percentage + HALF_ONCE_SCALED) / FULL_PERCENT;\n    }\n  }\n\n  /**\n   * @dev Split value into percentage, round 0.5+ up.\n   * @param self The value to split\n   * @param percentage The percentage to be calculated [e2]\n   * @return pct The percentage of the value\n   * @return rem Anything leftover from the value\n   */\n  function splitBy(uint256 self, uint256 percentage)\n    internal\n    pure\n    returns (uint256 pct, uint256 rem)\n  {\n    require(percentage <= FULL_PERCENT, \"BasisMath/ExcessPercentage\");\n    pct = percentageOf(self, percentage);\n    rem = self - pct;\n  }\n}\n"
    },
    "contracts/lib/BlockNumber.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n/// @title Function for getting block number\n/// @dev Base contract that is overridden for tests\nabstract contract BlockNumber {\n  /// @dev Method that exists purely to be overridden for tests\n  /// @return The current block number\n  function _blockNumber() internal view virtual returns (uint256) {\n    return block.number;\n  }\n}\n"
    },
    "contracts/lib/Recoverable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Recoverable feature\n * @dev should _only_ be used with contracts that should not store assets,\n * but instead interacted with value so there is potential to lose assets.\n */\nabstract contract Recoverable is AccessControl {\n  using SafeERC20 for IERC20;\n  using Address for address payable;\n\n  /* ========== CONSTANTS ========== */\n  bytes32 public constant RECOVER_ROLE = keccak256(\"RECOVER_ROLE\");\n\n  /* ============ Events ============ */\n\n  event Recovered(address onBehalfOf, address tokenAddress, uint256 amount);\n\n  /* ========== MODIFIERS ========== */\n\n  modifier isRecoverer {\n    require(hasRole(RECOVER_ROLE, _msgSender()), \"Recoverable/RecoverRole\");\n    _;\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n  /* ----- RECOVER_ROLE ----- */\n\n  /**\n   * @notice Provide accidental token retrieval.\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\n   */\n  function recoverERC20(\n    address to,\n    address tokenAddress,\n    uint256 tokenAmount\n  ) external isRecoverer {\n    emit Recovered(to, tokenAddress, tokenAmount);\n\n    IERC20(tokenAddress).safeTransfer(to, tokenAmount);\n  }\n\n  /**\n   * @notice Provide accidental ETH retrieval.\n   */\n  function recoverETH(address to) external isRecoverer {\n    uint256 contractBalance = address(this).balance;\n\n    emit Recovered(to, address(0), contractBalance);\n\n    payable(to).sendValue(contractBalance);\n  }\n}\n"
    },
    "contracts/external-lib/SafeDecimalMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n  using SafeMath for uint256;\n\n  /* Number of decimal places in the representations. */\n  uint8 public constant decimals = 18;\n  uint8 public constant highPrecisionDecimals = 27;\n\n  /* The number representing 1.0. */\n  uint256 public constant UNIT = 10**uint256(decimals);\n\n  /* The number representing 1.0 for higher fidelity numbers. */\n  uint256 public constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);\n  uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR =\n    10**uint256(highPrecisionDecimals - decimals);\n\n  /**\n   * @return Provides an interface to UNIT.\n   */\n  function unit() external pure returns (uint256) {\n    return UNIT;\n  }\n\n  /**\n   * @return Provides an interface to PRECISE_UNIT.\n   */\n  function preciseUnit() external pure returns (uint256) {\n    return PRECISE_UNIT;\n  }\n\n  /**\n   * @return The result of multiplying x and y, interpreting the operands as fixed-point\n   * decimals.\n   *\n   * @dev A unit factor is divided out after the product of x and y is evaluated,\n   * so that product must be less than 2**256. As this is an integer division,\n   * the internal division always rounds down. This helps save on gas. Rounding\n   * is more expensive on gas.\n   */\n  function multiplyDecimal(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    return x.mul(y) / UNIT;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of the specified precision unit.\n   *\n   * @dev The operands should be in the form of a the specified unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function _multiplyDecimalRound(\n    uint256 x,\n    uint256 y,\n    uint256 precisionUnit\n  ) private pure returns (uint256) {\n    /* Divide by UNIT to remove the extra factor introduced by the product. */\n    uint256 quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a precise unit.\n   *\n   * @dev The operands should be in the precise unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRoundPrecise(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @return The result of safely multiplying x and y, interpreting the operands\n   * as fixed-point decimals of a standard unit.\n   *\n   * @dev The operands should be in the standard unit factor which will be\n   * divided out after the product of x and y is evaluated, so that product must be\n   * less than 2**256.\n   *\n   * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n   * Rounding is useful when you need to retain fidelity for small decimal numbers\n   * (eg. small fractions or percentages).\n   */\n  function multiplyDecimalRound(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _multiplyDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is a high\n   * precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and UNIT must be less than 2**256. As\n   * this is an integer division, the result is always rounded down.\n   * This helps save on gas. Rounding is more expensive on gas.\n   */\n  function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\n    /* Reintroduce the UNIT factor that will be divided out by y. */\n    return x.mul(UNIT).div(y);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * decimal in the precision unit specified in the parameter.\n   *\n   * @dev y is divided after the product of x and the specified precision unit\n   * is evaluated, so the product of x and the specified precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function _divideDecimalRound(\n    uint256 x,\n    uint256 y,\n    uint256 precisionUnit\n  ) private pure returns (uint256) {\n    uint256 resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n    if (resultTimesTen % 10 >= 5) {\n      resultTimesTen += 10;\n    }\n\n    return resultTimesTen / 10;\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * standard precision decimal.\n   *\n   * @dev y is divided after the product of x and the standard precision unit\n   * is evaluated, so the product of x and the standard precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRound(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _divideDecimalRound(x, y, UNIT);\n  }\n\n  /**\n   * @return The result of safely dividing x and y. The return value is as a rounded\n   * high precision decimal.\n   *\n   * @dev y is divided after the product of x and the high precision unit\n   * is evaluated, so the product of x and the high precision unit must\n   * be less than 2**256. The result is rounded to the nearest increment.\n   */\n  function divideDecimalRoundPrecise(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256)\n  {\n    return _divideDecimalRound(x, y, PRECISE_UNIT);\n  }\n\n  /**\n   * @dev Convert a standard decimal representation to a high precision one.\n   */\n  function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {\n    return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n  }\n\n  /**\n   * @dev Convert a high precision decimal to a standard decimal representation.\n   */\n  function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {\n    uint256 quotientTimesTen =\n      i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n    if (quotientTimesTen % 10 >= 5) {\n      quotientTimesTen += 10;\n    }\n\n    return quotientTimesTen / 10;\n  }\n}\n"
    },
    "contracts/tokens/SafeSupplyControlledERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\nimport \"../tokens/interfaces/ISupplyControlledERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title SafeSupplyControlledERC20\n * @dev Wrappers around Supply Controlled ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n */\nlibrary SafeSupplyControlledERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeBurnFrom(\n    ISupplyControlledERC20 token,\n    address from,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.burnFrom.selector, from, value)\n    );\n  }\n\n  function safeMint(\n    ISupplyControlledERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.mint.selector, to, value)\n    );\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata =\n      address(token).functionCall(\n        data,\n        \"SafeSupplyControlled/LowlevelCallFailed\"\n      );\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeSupplyControlled/ERC20Failed\"\n      );\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/// @title Auction House state that can change by governance.\n/// @notice These methods provide vision on specific state that could be used in wrapper contracts.\ninterface IAuctionHouseState {\n  /**\n   * @notice The buffer around the starting price to handle mispriced / stale oracles.\n   * @dev Basis point\n   * Starts at 10% / 1e3 so market price is buffered by 110% or 90%\n   */\n  function buffer() external view returns (uint16);\n\n  /**\n   * @notice The fee taken by the protocol.\n   * @dev Basis point\n   */\n  function protocolFee() external view returns (uint16);\n\n  /**\n   * @notice The cap based on total FLOAT supply to change in a single auction. E.g. 10% cap => absolute max of 10% of total supply can be minted / burned\n   * @dev Basis point\n   */\n  function allowanceCap() external view returns (uint32);\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseVariables.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./ICases.sol\";\n\n/// @title Auction House state that can change\n/// @notice These methods compose the auctions state, and will change per action.\ninterface IAuctionHouseVariables is ICases {\n  /**\n   * @notice The number of auctions since inception.\n   */\n  function round() external view returns (uint64);\n\n  /**\n   * @notice Returns data about a specific auction.\n   * @param roundNumber The round number for the auction array to fetch\n   * @return stabilisationCase The Auction struct including case\n   */\n  function auctions(uint64 roundNumber)\n    external\n    view\n    returns (\n      Cases stabilisationCase,\n      uint256 targetFloatInEth,\n      uint256 marketFloatInEth,\n      uint256 bankInEth,\n      uint256 startWethPrice,\n      uint256 startBankPrice,\n      uint256 endWethPrice,\n      uint256 endBankPrice,\n      uint256 basketFactor,\n      uint256 delta,\n      uint256 allowance\n    );\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseDerivedState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./IAuction.sol\";\n\n/// @title Auction House state that can change\n/// @notice These methods are derived from the IAuctionHouseState.\ninterface IAuctionHouseDerivedState is IAuction {\n  /**\n   * @notice The price (that the Protocol with expect on expansion, and give on Contraction) for 1 FLOAT\n   * @dev Under cases, this value is used differently:\n   * - Contraction, Protocol buys FLOAT for pair.\n   * - Expansion, Protocol sells FLOAT for pair.\n   * @return wethPrice [e27] Expected price in wETH.\n   * @return bankPrice [e27] Expected price in BANK.\n   */\n  function price() external view returns (uint256 wethPrice, uint256 bankPrice);\n\n  /**\n   * @notice The current step through the auction.\n   * @dev block numbers since auction start (0 indexed)\n   */\n  function step() external view returns (uint256);\n\n  /**\n   * @notice Latest Auction alias\n   */\n  function latestAuction() external view returns (Auction memory);\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\n/// @title Open Auction House actions\n/// @notice Contains all actions that can be called by anyone\ninterface IAuctionHouseActions {\n  /**\n   * @notice Starts an auction\n   * @dev This will:\n   * - update the oracles\n   * - calculate the target price\n   * - check stabilisation case\n   * - create allowance.\n   * - Set start / end prices of the auction\n   */\n  function start() external returns (uint64 newRound);\n\n  /**\n   * @notice Buy for an amount of <WETH, BANK> for as much FLOAT tokens as possible.\n   * @dev Expansion, Protocol sells FLOAT for pair.\n    As the price descends there should be no opportunity for slippage causing failure\n    `msg.sender` should already have given the auction allowance for at least `wethIn` and `bankIn`.\n   * `wethInMax` / `bankInMax` < 2**256 / 10**18, assumption is that totalSupply\n   * doesn't exceed type(uint128).max\n   * @param wethInMax The max amount of WETH to send (takes maximum from given ratio).\n   * @param bankInMax The max amount of BANK to send (takes maximum from given ratio).\n   * @param floatOutMin The minimum amount of FLOAT that must be received for this transaction not to revert.\n   * @param to Recipient of the FLOAT.\n   * @param deadline Unix timestamp after which the transaction will revert.\n   */\n  function buy(\n    uint256 wethInMax,\n    uint256 bankInMax,\n    uint256 floatOutMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 usedWethIn,\n      uint256 usedBankIn,\n      uint256 usedFloatOut\n    );\n\n  /**\n   * @notice Sell an amount of FLOAT for the given reward tokens.\n   * @dev Contraction, Protocol buys FLOAT for pair. `msg.sender` should already have given the auction allowance for at least `floatIn`.\n   * @param floatIn The amount of FLOAT to sell.\n   * @param wethOutMin The minimum amount of WETH that can be received before the transaction reverts.\n   * @param bankOutMin The minimum amount of BANK that can be received before the tranasction reverts.\n   * @param to Recipient of <WETH, BANK>.\n   * @param deadline Unix timestamp after which the transaction will revert.\n   */\n  function sell(\n    uint256 floatIn,\n    uint256 wethOutMin,\n    uint256 bankOutMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 usedfloatIn,\n      uint256 usedWethOut,\n      uint256 usedBankOut\n    );\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseGovernedActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\n/// @title Auction House actions that require certain level of privilege\n/// @notice Contains Auction House methods that may only be called by controller\ninterface IAuctionHouseGovernedActions {\n  /**\n   * @notice Modify a uint256 parameter\n   * @param parameter The parameter name to modify\n   * @param data New value for the parameter\n   */\n  function modifyParameters(bytes32 parameter, uint256 data) external;\n\n  /**\n   * @notice Modify an address parameter\n   * @param parameter The parameter name to modify\n   * @param data New address for the parameter\n   */\n  function modifyParameters(bytes32 parameter, address data) external;\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuctionHouseEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\n/// @title Events emitted by the auction house\n/// @notice Contains all events emitted by the auction house\ninterface IAuctionHouseEvents {\n  event NewAuction(\n    uint256 indexed round,\n    uint256 allowance,\n    uint256 targetFloatInEth,\n    uint256 startBlock\n  );\n  event Buy(\n    uint256 indexed round,\n    address indexed buyer,\n    uint256 wethIn,\n    uint256 bankIn,\n    uint256 floatOut\n  );\n  event Sell(\n    uint256 indexed round,\n    address indexed seller,\n    uint256 floatIn,\n    uint256 wethOut,\n    uint256 bankOut\n  );\n  event ModifyParameters(bytes32 parameter, uint256 data);\n  event ModifyParameters(bytes32 parameter, address data);\n}\n"
    },
    "contracts/auction/interfaces/ah/ICases.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\ninterface ICases {\n  /**\n   * @dev The Stabilisation Cases\n   * Up (Expansion) - Estimated market price >= target price & Basket Factor >= 1.\n   * Restock (Expansion) - Estimated market price >= target price & Basket Factor < 1.\n   * Confidence (Contraction) - Estimated market price < target price & Basket Factor >= 1.\n   * Down (Contraction) - Estimated market price < target price & Basket Factor < 1.\n   */\n  enum Cases {Up, Restock, Confidence, Down}\n}\n"
    },
    "contracts/auction/interfaces/ah/IAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./ICases.sol\";\n\ninterface IAuction is ICases {\n  /**\n   * The current Stabilisation Case\n   * Auction's target price.\n   * Auction's floatInEth price.\n   * Auction's bankInEth price.\n   * Auction's basket factor.\n   * Auction's used float delta.\n   * Auction's allowed float delta (how much FLOAT can be created or burned).\n   */\n  struct Auction {\n    Cases stabilisationCase;\n    uint256 targetFloatInEth;\n    uint256 marketFloatInEth;\n    uint256 bankInEth;\n    uint256 startWethPrice;\n    uint256 startBankPrice;\n    uint256 endWethPrice;\n    uint256 endBankPrice;\n    uint256 basketFactor;\n    uint256 delta;\n    uint256 allowance;\n  }\n}\n"
    },
    "contracts/auction/mock/AuctionHouseHarness.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../AuctionHouse.sol\";\n\ncontract AuctionHouseHarness is AuctionHouse {\n  uint256 public blockNumber;\n\n  constructor(\n    // Dependencies\n    address _weth,\n    address _bank,\n    address _float,\n    address _basket,\n    address _monetaryPolicy,\n    address _gov,\n    address _bankEthOracle,\n    address _floatEthOracle,\n    // Parameters\n    uint16 _auctionDuration,\n    uint32 _auctionCooldown,\n    uint256 _firstAuctionBlock\n  )\n    AuctionHouse(\n      _weth,\n      _bank,\n      _float,\n      _basket,\n      _monetaryPolicy,\n      _gov,\n      _bankEthOracle,\n      _floatEthOracle,\n      _auctionDuration,\n      _auctionCooldown,\n      _firstAuctionBlock\n    )\n  {}\n\n  function _blockNumber() internal view override returns (uint256) {\n    return blockNumber;\n  }\n\n  // Private Var checkers\n\n  function __weth() external view returns (address) {\n    return address(weth);\n  }\n\n  function __bank() external view returns (address) {\n    return address(bank);\n  }\n\n  function __float() external view returns (address) {\n    return address(float);\n  }\n\n  function __basket() external view returns (address) {\n    return address(basket);\n  }\n\n  function __monetaryPolicy() external view returns (address) {\n    return address(monetaryPolicy);\n  }\n\n  function __bankEthOracle() external view returns (address) {\n    return address(bankEthOracle);\n  }\n\n  function __floatEthOracle() external view returns (address) {\n    return address(floatEthOracle);\n  }\n\n  function __auctionDuration() external view returns (uint16) {\n    return auctionDuration;\n  }\n\n  function __auctionCooldown() external view returns (uint32) {\n    return auctionCooldown;\n  }\n\n  function __mine(uint256 _blocks) external {\n    blockNumber = blockNumber + _blocks;\n  }\n\n  function __setBlock(uint256 _number) external {\n    blockNumber = _number;\n  }\n\n  function __setCap(uint256 _cap) external {\n    allowanceCap = uint32(_cap);\n  }\n}\n"
    },
    "contracts/funds/MintingCeremony.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./interfaces/basket/IBasketReader.sol\";\nimport \"./interfaces/IMintingCeremony.sol\";\n\nimport \"../external-lib/SafeDecimalMath.sol\";\nimport \"../lib/Recoverable.sol\";\nimport \"../lib/Windowed.sol\";\nimport \"../tokens/SafeSupplyControlledERC20.sol\";\nimport \"../tokens/interfaces/ISupplyControlledERC20.sol\";\nimport \"../policy/interfaces/IMonetaryPolicy.sol\";\n\n/**\n * @title Minting Ceremony\n * @dev Note that this is recoverable as it should never store any tokens.\n */\ncontract MintingCeremony is\n  IMintingCeremony,\n  Windowed,\n  Recoverable,\n  ReentrancyGuard\n{\n  using SafeMath for uint256;\n  using SafeDecimalMath for uint256;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ISupplyControlledERC20;\n  using SafeSupplyControlledERC20 for ISupplyControlledERC20;\n\n  /* ========== CONSTANTS ========== */\n  uint8 public constant ALLOWANCE_FACTOR = 100;\n  uint32 private constant CEREMONY_DURATION = 6 days;\n\n  /* ========== STATE VARIABLES ========== */\n  // Monetary Policy Contract that decides the target price\n  IMonetaryPolicy internal immutable monetaryPolicy;\n  ISupplyControlledERC20 internal immutable float;\n  IBasketReader internal immutable basket;\n\n  // Tokens that set allowance\n  IERC20[] internal allowanceTokens;\n\n  uint256 private _totalSupply;\n  mapping(address => uint256) private _balances;\n\n  /**\n   * @notice Constructs a new Minting Ceremony\n   */\n  constructor(\n    address governance_,\n    address monetaryPolicy_,\n    address basket_,\n    address float_,\n    address[] memory allowanceTokens_,\n    uint256 ceremonyStart\n  ) Windowed(ceremonyStart, ceremonyStart + CEREMONY_DURATION) {\n    require(governance_ != address(0), \"MC/ZeroAddress\");\n    require(monetaryPolicy_ != address(0), \"MC/ZeroAddress\");\n    require(basket_ != address(0), \"MC/ZeroAddress\");\n    require(float_ != address(0), \"MC/ZeroAddress\");\n\n    monetaryPolicy = IMonetaryPolicy(monetaryPolicy_);\n    basket = IBasketReader(basket_);\n    float = ISupplyControlledERC20(float_);\n\n    for (uint256 i = 0; i < allowanceTokens_.length; i++) {\n      IERC20 allowanceToken = IERC20(allowanceTokens_[i]);\n      allowanceToken.balanceOf(address(0)); // Check that this is a valid token\n\n      allowanceTokens.push(allowanceToken);\n    }\n\n    _setupRole(RECOVER_ROLE, governance_);\n  }\n\n  /* ========== EVENTS ========== */\n\n  event Committed(address indexed user, uint256 amount);\n  event Minted(address indexed user, uint256 amount);\n\n  /* ========== VIEWS ========== */\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  function underlying()\n    public\n    view\n    override(IMintingCeremony)\n    returns (address)\n  {\n    return basket.underlying();\n  }\n\n  /**\n   * @notice The allowance remaining for an account.\n   * @dev Based on the current staked balance in `allowanceTokens` and the existing allowance.\n   */\n  function allowance(address account)\n    public\n    view\n    override(IMintingCeremony)\n    returns (uint256 remainingAllowance)\n  {\n    uint256 stakedBalance = 0;\n    for (uint256 i = 0; i < allowanceTokens.length; i++) {\n      stakedBalance = stakedBalance.add(allowanceTokens[i].balanceOf(account));\n    }\n    remainingAllowance = stakedBalance.mul(ALLOWANCE_FACTOR).sub(\n      _balances[account]\n    );\n  }\n\n  /**\n   * @notice Simple conversion using monetary policy.\n   */\n  function quote(uint256 wethIn) public view returns (uint256) {\n    uint256 targetPriceInEth = monetaryPolicy.consult();\n\n    require(targetPriceInEth != 0, \"MC/MPFailure\");\n\n    return wethIn.divideDecimalRoundPrecise(targetPriceInEth);\n  }\n\n  /**\n   * @notice The amount out accounting for quote & allowance.\n   */\n  function amountOut(address recipient, uint256 underlyingIn)\n    public\n    view\n    returns (uint256 floatOut)\n  {\n    // External calls occur here, but trusted\n    uint256 floatOutFromPrice = quote(underlyingIn);\n    uint256 floatOutFromAllowance = allowance(recipient);\n\n    floatOut = Math.min(floatOutFromPrice, floatOutFromAllowance);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @notice Commit a quanity of wETH at the current price\n   * @dev This is marked non-reentrancy to protect against a malicious\n   * allowance token or monetary policy (these are trusted however).\n   *\n   * - Expects `msg.sender` to give approval to this contract from `basket.underlying()` for at least `underlyingIn`\n   *\n   * @param recipient The eventual receiver of the float\n   * @param underlyingIn The underlying token amount to commit to mint\n   * @param floatOutMin The minimum amount of FLOAT that must be received for this transaction not to revert.\n   */\n  function commit(\n    address recipient,\n    uint256 underlyingIn,\n    uint256 floatOutMin\n  )\n    external\n    override(IMintingCeremony)\n    nonReentrant\n    inWindow\n    returns (uint256 floatOut)\n  {\n    floatOut = amountOut(recipient, underlyingIn);\n    require(floatOut >= floatOutMin, \"MC/SlippageOrLowAllowance\");\n    require(floatOut != 0, \"MC/NoAllowance\");\n\n    _totalSupply = _totalSupply.add(floatOut);\n    _balances[recipient] = _balances[recipient].add(floatOut);\n\n    emit Committed(recipient, floatOut);\n\n    IERC20(underlying()).safeTransferFrom(\n      msg.sender,\n      address(basket),\n      underlyingIn\n    );\n  }\n\n  /**\n   * @notice Release the float to market which has been committed.\n   */\n  function mint() external override(IMintingCeremony) afterWindow {\n    uint256 balance = balanceOf(msg.sender);\n    require(balance != 0, \"MC/NotDueFloat\");\n\n    _totalSupply = _totalSupply.sub(balance);\n    _balances[msg.sender] = _balances[msg.sender].sub(balance);\n\n    emit Minted(msg.sender, balance);\n\n    float.safeMint(msg.sender, balance);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/funds/interfaces/IMintingCeremony.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n/**\n * @title Minting Ceremony\n */\ninterface IMintingCeremony {\n  function allowance(address account)\n    external\n    view\n    returns (uint256 remainingAllowance);\n\n  function underlying() external view returns (address);\n\n  function commit(\n    address recipient,\n    uint256 underlyingIn,\n    uint256 floatOutMin\n  ) external returns (uint256 floatOut);\n\n  function mint() external;\n}\n"
    },
    "contracts/lib/Windowed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n// The Window is time-based so will rely on time, however period > 30 minutes\n// minimise the risk of oracle manipulation.\n// solhint-disable not-rely-on-time\n\n/**\n * @title A windowed contract\n * @notice Provides a window for actions to occur\n */\ncontract Windowed {\n  /* ========== STATE VARIABLES ========== */\n\n  /**\n   * @notice The timestamp of the window start\n   */\n  uint256 public startWindow;\n\n  /**\n   * @notice The timestamp of the window end\n   */\n  uint256 public endWindow;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(uint256 _startWindow, uint256 _endWindow) {\n    require(_startWindow > block.timestamp, \"Windowed/StartInThePast\");\n    require(_endWindow > _startWindow + 1 days, \"Windowed/MustHaveDuration\");\n\n    startWindow = _startWindow;\n    endWindow = _endWindow;\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier inWindow() {\n    require(block.timestamp >= startWindow, \"Windowed/HasNotStarted\");\n    require(block.timestamp <= endWindow, \"Windowed/HasEnded\");\n    _;\n  }\n\n  modifier afterWindow() {\n    require(block.timestamp > endWindow, \"Windowed/NotEnded\");\n    _;\n  }\n}\n"
    },
    "contracts/funds/mock/MintingCeremonyHarness.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../MintingCeremony.sol\";\n\ncontract MintingCeremonyHarness is MintingCeremony {\n  constructor(\n    address governance_,\n    address monetaryPolicy_,\n    address basket_,\n    address float_,\n    address[] memory allowanceTokens_,\n    uint256 ceremonyStart\n  )\n    MintingCeremony(\n      governance_,\n      monetaryPolicy_,\n      basket_,\n      float_,\n      allowanceTokens_,\n      ceremonyStart\n    )\n  {}\n\n  function __monetaryPolicy() external view returns (address) {\n    return address(monetaryPolicy);\n  }\n\n  function __basket() external view returns (address) {\n    return address(basket);\n  }\n\n  function __float() external view returns (address) {\n    return address(float);\n  }\n\n  function __allowanceTokens(uint256 idx) external view returns (address) {\n    return address(allowanceTokens[idx]);\n  }\n}\n"
    },
    "contracts/policy/MonetaryPolicyV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport \"./interfaces/IMonetaryPolicy.sol\";\n\nimport \"../lib/BlockNumber.sol\";\nimport \"../lib/MathHelper.sol\";\nimport \"../external-lib/SafeDecimalMath.sol\";\nimport \"../oracle/interfaces/IEthUsdOracle.sol\";\n\ncontract MonetaryPolicyV1 is IMonetaryPolicy, BlockNumber, AccessControl {\n  using SafeMath for uint256;\n  using SafeDecimalMath for uint256;\n\n  /* ========== CONSTANTS ========== */\n  bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n  bytes32 public constant AUCTION_HOUSE_ROLE = keccak256(\"AUCTION_HOUSE_ROLE\");\n  // 0.001$ <= Target Price <= 1000$ as a basic sense check\n  uint256 private constant MAX_TARGET_PRICE = 1000e27;\n  uint256 private constant MIN_TARGET_PRICE = 0.001e27;\n\n  uint256 private constant MAX_PRICE_DELTA_BOUND = 1e27;\n  uint256 private constant DEFAULT_MAX_PRICE_DELTA = 4e27;\n\n  uint256 private constant DEFAULT_MAX_ADJ_PERIOD = 1e6;\n  uint256 private constant DEFAULT_MIN_ADJ_PERIOD = 2e5;\n  // 150 blocks (auction duration) < T_min < T_max < 10 000 000 (~4yrs)\n  uint256 private constant CAP_MAX_ADJ_PERIOD = 1e7;\n  uint256 private constant CAP_MIN_ADJ_PERIOD = 150;\n  /**\n   * @notice The default FLOAT starting price, golden ratio\n   * @dev [e27]\n   */\n  uint256 public constant STARTING_PRICE = 1.618033988749894848204586834e27;\n\n  /* ========== STATE VARIABLES ========== */\n  /**\n   * @notice The FLOAT target price in USD.\n   * @dev [e27]\n   */\n  uint256 public targetPrice = STARTING_PRICE;\n\n  /**\n   * @notice If dynamic pricing is enabled.\n   */\n  bool public dynamicPricing = true;\n\n  /**\n   * @notice Maximum price Delta of 400%\n   */\n  uint256 public maxPriceDelta = DEFAULT_MAX_PRICE_DELTA;\n\n  /**\n   * @notice Maximum adjustment period T_max (Blocks)\n   * @dev \"How long it takes us to normalise\"\n   * - T_max => T_min, quicker initial response with higher price changes.\n   */\n  uint256 public maxAdjustmentPeriod = DEFAULT_MAX_ADJ_PERIOD;\n\n  /**\n   * @notice Minimum adjustment period T_min (Blocks)\n   * @dev \"How quickly we respond to market price changes\"\n   * - Low T_min, increased tracking.\n   */\n  uint256 public minAdjustmentPeriod = DEFAULT_MIN_ADJ_PERIOD;\n\n  /**\n   * @notice Provides the ETH-USD exchange rate e.g. 1.5e27 would mean 1 ETH = $1.5\n   * @dev [e27] decimal fixed point number\n   */\n  IEthUsdOracle public ethUsdOracle;\n\n  /* ========== CONSTRUCTOR ========== */\n  /**\n   * @notice Construct a new Monetary Policy\n   * @param _governance Governance address (can add new roles & parameter control)\n   * @param _ethUsdOracle The [e27] ETH USD price feed.\n   */\n  constructor(address _governance, address _ethUsdOracle) {\n    ethUsdOracle = IEthUsdOracle(_ethUsdOracle);\n\n    // Roles\n    _setupRole(DEFAULT_ADMIN_ROLE, _governance);\n    _setupRole(GOVERNANCE_ROLE, _governance);\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier onlyGovernance {\n    require(hasRole(GOVERNANCE_ROLE, msg.sender), \"MonetaryPolicy/OnlyGovRole\");\n    _;\n  }\n\n  modifier onlyAuctionHouse {\n    require(\n      hasRole(AUCTION_HOUSE_ROLE, msg.sender),\n      \"MonetaryPolicy/OnlyAuctionHouse\"\n    );\n    _;\n  }\n\n  /* ========== VIEWS ========== */\n\n  /**\n   * @notice Consult monetary policy to get the current target price of FLOAT in ETH\n   * @dev [e27]\n   */\n  function consult() public view override(IMonetaryPolicy) returns (uint256) {\n    if (!dynamicPricing) return _toEth(STARTING_PRICE);\n\n    return _toEth(targetPrice);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /* ----- onlyGovernance ----- */\n\n  /**\n   * @notice Updates the EthUsdOracle\n   * @param _ethUsdOracle The address of the ETH-USD price oracle.\n   */\n  function setEthUsdOracle(address _ethUsdOracle) external onlyGovernance {\n    require(_ethUsdOracle != address(0), \"MonetaryPolicyV1/ValidAddress\");\n    ethUsdOracle = IEthUsdOracle(_ethUsdOracle);\n  }\n\n  /**\n   * @notice Set the target price of FLOAT\n   * @param _targetPrice [e27]\n   */\n  function setTargetPrice(uint256 _targetPrice) external onlyGovernance {\n    require(_targetPrice <= MAX_TARGET_PRICE, \"MonetaryPolicyV1/MaxTarget\");\n    require(_targetPrice >= MIN_TARGET_PRICE, \"MonetaryPolicyV1/MinTarget\");\n    targetPrice = _targetPrice;\n  }\n\n  /**\n   * @notice Allows dynamic pricing to be turned on / off.\n   */\n  function setDynamicPricing(bool _dynamicPricing) external onlyGovernance {\n    dynamicPricing = _dynamicPricing;\n  }\n\n  /**\n   * @notice Allows monetary policy parameters to be adjusted.\n   */\n  function setPolicyParameters(\n    uint256 _minAdjustmentPeriod,\n    uint256 _maxAdjustmentPeriod,\n    uint256 _maxPriceDelta\n  ) external onlyGovernance {\n    require(\n      _minAdjustmentPeriod < _maxAdjustmentPeriod,\n      \"MonetaryPolicyV1/MinAdjLTMaxAdj\"\n    );\n    require(\n      _maxAdjustmentPeriod <= CAP_MAX_ADJ_PERIOD,\n      \"MonetaryPolicyV1/MaxAdj\"\n    );\n    require(\n      _minAdjustmentPeriod >= CAP_MIN_ADJ_PERIOD,\n      \"MonetaryPolicyV1/MinAdj\"\n    );\n    require(\n      _maxPriceDelta >= MAX_PRICE_DELTA_BOUND,\n      \"MonetaryPolicyV1/MaxDeltaBound\"\n    );\n    minAdjustmentPeriod = _minAdjustmentPeriod;\n    maxAdjustmentPeriod = _maxAdjustmentPeriod;\n    maxPriceDelta = _maxPriceDelta;\n  }\n\n  /* ----- onlyAuctionHouse ----- */\n\n  /**\n   * @notice Updates with previous auctions result\n   * @dev future:param round Round number\n   * @param lastAuctionBlock The last time an auction started.\n   * @param floatMarketPriceInEth [e27] The current float market price (ETH)\n   * @param basketFactor [e27] The basket factor given the prior target price\n   * @return targetPriceInEth [e27]\n   */\n  function updateGivenAuctionResults(\n    uint256,\n    uint256 lastAuctionBlock,\n    uint256 floatMarketPriceInEth,\n    uint256 basketFactor\n  ) external override(IMonetaryPolicy) onlyAuctionHouse returns (uint256) {\n    // Exit early if this is the first auction\n    if (lastAuctionBlock == 0) {\n      return consult();\n    }\n\n    return\n      _updateTargetPrice(lastAuctionBlock, floatMarketPriceInEth, basketFactor);\n  }\n\n  /**\n   * @dev Converts [e27] USD price, to an [e27] ETH Price\n   */\n  function _toEth(uint256 price) internal view returns (uint256) {\n    uint256 ethInUsd = ethUsdOracle.consult();\n    return price.divideDecimalRoundPrecise(ethInUsd);\n  }\n\n  /**\n   * @dev Updates the $ valued target price, returns the eth valued target price.\n   */\n  function _updateTargetPrice(\n    uint256 _lastAuctionBlock,\n    uint256 _floatMarketPriceInEth,\n    uint256 _basketFactor\n  ) internal returns (uint256) {\n    // _toEth pulled out as we do a _fromEth later.\n    uint256 ethInUsd = ethUsdOracle.consult();\n    uint256 priorTargetPriceInEth =\n      targetPrice.divideDecimalRoundPrecise(ethInUsd);\n\n    // Check if basket and FLOAT are moving the same direction\n    bool basketFactorDown = _basketFactor < SafeDecimalMath.PRECISE_UNIT;\n    bool floatDown = _floatMarketPriceInEth < priorTargetPriceInEth;\n    if (basketFactorDown != floatDown) {\n      return priorTargetPriceInEth;\n    }\n\n    // N.B: block number will always be >= _lastAuctionBlock\n    uint256 auctionTimePeriod = _blockNumber().sub(_lastAuctionBlock);\n\n    uint256 normDelta =\n      _normalisedDelta(_floatMarketPriceInEth, priorTargetPriceInEth);\n    uint256 adjustmentPeriod = _adjustmentPeriod(normDelta);\n\n    // [e27]\n    uint256 basketFactorDiff =\n      MathHelper.diff(_basketFactor, SafeDecimalMath.PRECISE_UNIT);\n\n    uint256 targetChange =\n      priorTargetPriceInEth.multiplyDecimalRoundPrecise(\n        basketFactorDiff.mul(auctionTimePeriod).div(adjustmentPeriod)\n      );\n\n    // If we have got this far, then we know that market and basket are\n    // in the same direction, so basketFactor can be used to choose direction.\n    uint256 targetPriceInEth =\n      basketFactorDown\n        ? priorTargetPriceInEth.sub(targetChange)\n        : priorTargetPriceInEth.add(targetChange);\n\n    targetPrice = targetPriceInEth.multiplyDecimalRoundPrecise(ethInUsd);\n\n    return targetPriceInEth;\n  }\n\n  function _adjustmentPeriod(uint256 _normDelta)\n    internal\n    view\n    returns (uint256)\n  {\n    // calculate T, 'the adjustment period', similar to \"lookback\" as it controls the length of the tail\n    // T = T_max - d (T_max - T_min).\n    //   = d * T_min + T_max - d * T_max\n    // TBC: This doesn't need safety checks\n    // T_min <= T <= T_max\n    return\n      minAdjustmentPeriod\n        .multiplyDecimalRoundPrecise(_normDelta)\n        .add(maxAdjustmentPeriod)\n        .sub(maxAdjustmentPeriod.multiplyDecimalRoundPrecise(_normDelta));\n  }\n\n  /**\n   * @notice Obtain normalised delta between market and target price\n   */\n  function _normalisedDelta(\n    uint256 _floatMarketPriceInEth,\n    uint256 _priorTargetPriceInEth\n  ) internal view returns (uint256) {\n    uint256 delta =\n      MathHelper.diff(_floatMarketPriceInEth, _priorTargetPriceInEth);\n    uint256 scaledDelta =\n      delta.divideDecimalRoundPrecise(_priorTargetPriceInEth);\n\n    // Invert delta if contraction to flip curve from concave increasing to convex decreasing\n    // Also allows for a greater response in expansions than contractions.\n    if (_floatMarketPriceInEth < _priorTargetPriceInEth) {\n      scaledDelta = scaledDelta.divideDecimalRoundPrecise(\n        SafeDecimalMath.PRECISE_UNIT.sub(scaledDelta)\n      );\n    }\n\n    // Normalise delta based on Dmax -> 0 <= d <= X\n    uint256 normDelta = scaledDelta.divideDecimalRoundPrecise(maxPriceDelta);\n\n    // Cap normalised delta 0 <= d <= 1\n    if (normDelta > SafeDecimalMath.PRECISE_UNIT) {\n      normDelta = SafeDecimalMath.PRECISE_UNIT;\n    }\n\n    return normDelta;\n  }\n}\n"
    },
    "contracts/lib/MathHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nlibrary MathHelper {\n  function diff(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    z = x > y ? x - y : y - x;\n  }\n}\n"
    },
    "contracts/oracle/interfaces/IEthUsdOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\ninterface IEthUsdOracle {\n  /**\n   * @notice Spot price\n   * @return price The latest price as an [e27]\n   */\n  function consult() external view returns (uint256 price);\n}\n"
    },
    "contracts/oracle/ChainlinkEthUsdConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IEthUsdOracle.sol\";\n\ncontract ChainlinkEthUsdConsumer is IEthUsdOracle {\n  using SafeMath for uint256;\n\n  /// @dev Number of decimal places in the representations. */\n  uint8 private constant AGGREGATOR_DECIMALS = 8;\n  uint8 private constant PRICE_DECIMALS = 27;\n\n  uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR =\n    10**uint256(PRICE_DECIMALS - AGGREGATOR_DECIMALS);\n\n  AggregatorV3Interface internal immutable priceFeed;\n\n  /**\n   * @notice Construct a new price consumer\n   * @dev Source: https://docs.chain.link/docs/ethereum-addresses#config\n   */\n  constructor(address aggregatorAddress) {\n    priceFeed = AggregatorV3Interface(aggregatorAddress);\n  }\n\n  /// @inheritdoc IEthUsdOracle\n  function consult()\n    external\n    view\n    override(IEthUsdOracle)\n    returns (uint256 price)\n  {\n    (, int256 _price, , , ) = priceFeed.latestRoundData();\n    require(_price >= 0, \"ChainlinkConsumer/StrangeOracle\");\n    return (price = uint256(_price).mul(\n      UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR\n    ));\n  }\n\n  /**\n   * @notice Retrieves decimals of price feed\n   * @dev (`AGGREGATOR_DECIMALS` for ETH-USD by default, scaled up to `PRICE_DECIMALS` here)\n   */\n  function getDecimals() external pure returns (uint8 decimals) {\n    return (decimals = PRICE_DECIMALS);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/staking/Phase2Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"synthetix/contracts/interfaces/IStakingRewards.sol\";\n\nimport \"./RewardDistributionRecipient.sol\";\n\n/**\n * @title Phase 2 BANK Reward Pool for Float Protocol\n * @notice This contract is used to reward `rewardToken` when `stakeToken` is staked.\n */\ncontract Phase2Pool is\n  IStakingRewards,\n  Context,\n  AccessControl,\n  RewardDistributionRecipient,\n  ReentrancyGuard\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== CONSTANTS ========== */\n  uint256 public constant DURATION = 7 days;\n  bytes32 public constant RECOVER_ROLE = keccak256(\"RECOVER_ROLE\");\n\n  /* ========== STATE VARIABLES ========== */\n  IERC20 public rewardToken;\n  IERC20 public stakeToken;\n\n  uint256 public periodFinish = 0;\n  uint256 public rewardRate = 0;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStored;\n\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n\n  uint256 private _totalSupply;\n  mapping(address => uint256) private _balances;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @notice Construct a new Phase2Pool\n   * @param _admin The default role controller for\n   * @param _rewardDistribution The reward distributor (can change reward rate)\n   * @param _rewardToken The reward token to distribute\n   * @param _stakingToken The staking token used to qualify for rewards\n   */\n  constructor(\n    address _admin,\n    address _rewardDistribution,\n    address _rewardToken,\n    address _stakingToken\n  ) RewardDistributionRecipient(_admin) {\n    rewardDistribution = _rewardDistribution;\n    rewardToken = IERC20(_rewardToken);\n    stakeToken = IERC20(_stakingToken);\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n    _setupRole(RECOVER_ROLE, _admin);\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RewardAdded(uint256 reward);\n  event Staked(address indexed user, uint256 amount);\n  event Withdrawn(address indexed user, uint256 amount);\n  event RewardPaid(address indexed user, uint256 reward);\n  event Recovered(address token, uint256 amount);\n\n  /* ========== MODIFIERS ========== */\n\n  modifier updateReward(address account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      rewards[account] = earned(account);\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function totalSupply()\n    public\n    view\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function lastTimeRewardApplicable()\n    public\n    view\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  function rewardPerToken()\n    public\n    view\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    if (totalSupply() == 0) {\n      return rewardPerTokenStored;\n    }\n\n    return\n      rewardPerTokenStored.add(\n        lastTimeRewardApplicable()\n          .sub(lastUpdateTime)\n          .mul(rewardRate)\n          .mul(1e18)\n          .div(totalSupply())\n      );\n  }\n\n  function earned(address account)\n    public\n    view\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return\n      balanceOf(account)\n        .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n        .div(1e18)\n        .add(rewards[account]);\n  }\n\n  function getRewardForDuration()\n    external\n    view\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return rewardRate.mul(DURATION);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n  function stake(uint256 amount)\n    public\n    virtual\n    override(IStakingRewards)\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"Phase2Pool::stake: Cannot stake 0\");\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\n\n    stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n    emit Staked(msg.sender, amount);\n  }\n\n  function withdraw(uint256 amount)\n    public\n    override(IStakingRewards)\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"Phase2Pool::withdraw: Cannot withdraw 0\");\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    stakeToken.safeTransfer(msg.sender, amount);\n    emit Withdrawn(msg.sender, amount);\n  }\n\n  function exit() external override(IStakingRewards) {\n    withdraw(balanceOf(msg.sender));\n    getReward();\n  }\n\n  function getReward()\n    public\n    virtual\n    override(IStakingRewards)\n    updateReward(msg.sender)\n  {\n    uint256 reward = earned(msg.sender);\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n      rewardToken.safeTransfer(msg.sender, reward);\n      emit RewardPaid(msg.sender, reward);\n    }\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /* ----- Reward Distributor ----- */\n\n  /**\n   * @notice Should be called after the amount of reward tokens has\n     been sent to the contract.\n     Reward should be divisible by duration.\n   * @param reward number of tokens to be distributed over the duration.\n   */\n  function notifyRewardAmount(uint256 reward)\n    external\n    override\n    onlyRewardDistribution\n    updateReward(address(0))\n  {\n    if (block.timestamp >= periodFinish) {\n      rewardRate = reward.div(DURATION);\n    } else {\n      uint256 remaining = periodFinish.sub(block.timestamp);\n      uint256 leftover = remaining.mul(rewardRate);\n      rewardRate = reward.add(leftover).div(DURATION);\n    }\n\n    // Ensure provided reward amount is not more than the balance in the contract.\n    // Keeps reward rate within the right range to prevent overflows in earned or rewardsPerToken\n    // Reward + leftover < 1e18\n    uint256 balance = rewardToken.balanceOf(address(this));\n    require(\n      rewardRate <= balance.div(DURATION),\n      \"Phase2Pool::notifyRewardAmount: Insufficent balance for reward rate\"\n    );\n\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp.add(DURATION);\n    emit RewardAdded(reward);\n  }\n\n  /* ----- RECOVER_ROLE ----- */\n\n  /**\n   * @notice Provide accidental token retrieval.\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\n   */\n  function recoverERC20(address tokenAddress, uint256 tokenAmount) external {\n    require(\n      hasRole(RECOVER_ROLE, _msgSender()),\n      \"Phase2Pool::recoverERC20: You must possess the recover role to recover erc20\"\n    );\n    require(\n      tokenAddress != address(stakeToken),\n      \"Phase2Pool::recoverERC20: Cannot recover the staking token\"\n    );\n    require(\n      tokenAddress != address(rewardToken),\n      \"Phase2Pool::recoverERC20: Cannot recover the reward token\"\n    );\n\n    IERC20(tokenAddress).safeTransfer(_msgSender(), tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n}\n"
    },
    "synthetix/contracts/interfaces/IStakingRewards.sol": {
      "content": "pragma solidity >=0.4.24;\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/istakingrewards\ninterface IStakingRewards {\n    // Views\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function getRewardForDuration() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    // Mutative\n\n    function stake(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getReward() external;\n\n    function exit() external;\n}\n"
    },
    "contracts/staking/RewardDistributionRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nabstract contract RewardDistributionRecipient is Context, AccessControl {\n    bytes32 public constant DISTRIBUTION_ASSIGNER_ROLE = keccak256(\"DISTRIBUTION_ASSIGNER_ROLE\");\n\n    address public rewardDistribution;\n\n    constructor(address assigner) {\n        _setupRole(DISTRIBUTION_ASSIGNER_ROLE, assigner);\n    }\n\n    modifier onlyRewardDistribution() {\n        require(\n            _msgSender() == rewardDistribution,\n            \"RewardDisributionRecipient::onlyRewardDistribution: Caller is not RewardsDistribution contract\"\n        );\n        _;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ----- rewardDistribution ----- */\n\n    function notifyRewardAmount(uint256 reward) external virtual;\n\n    /* ----- DISTRIBUTION_ASSIGNER_ROLE ----- */\n\n    function setRewardDistribution(address _rewardDistribution)\n        external\n    {\n        require(\n            hasRole(DISTRIBUTION_ASSIGNER_ROLE, _msgSender()),\n            \"RewardDistributionRecipient::setRewardDistribution: must have distribution assigner role\"\n        );\n        rewardDistribution = _rewardDistribution;\n    }\n}"
    },
    "contracts/staking/Phase1Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"./RewardDistributionRecipient.sol\";\nimport \"./interfaces/IStakingRewardWhitelisted.sol\";\nimport \"./Whitelisted.sol\";\nimport \"./Phase2Pool.sol\";\n\ncontract Phase1Pool is Phase2Pool, Whitelisted, IStakingRewardWhitelisted {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== STATE VARIABLES ========== */\n  uint256 public maximumContribution;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @notice Construct a new Phase1Pool\n   * @param _admin The default role controller for\n   * @param _rewardDistribution The reward distributor (can change reward rate)\n   * @param _whitelist The address of the deployed whitelist contract\n   * @param _rewardToken The reward token to distribute\n   * @param _stakingToken The staking token used to qualify for rewards\n   * @param _maximumContribution The maximum contribution for this token (in the unit of the respective contract)\n   */\n  constructor(\n    address _admin,\n    address _rewardDistribution,\n    address _whitelist,\n    address _rewardToken,\n    address _stakingToken,\n    uint256 _maximumContribution\n  ) Phase2Pool(_admin, _rewardDistribution, _rewardToken, _stakingToken) {\n    whitelist = IWhitelist(_whitelist);\n    maximumContribution = _maximumContribution;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n  function stake(uint256) public pure override(Phase2Pool, IStakingRewards) {\n    revert(\n      \"Phase1Pool::stake: Cannot stake on Phase1Pool directly due to whitelist\"\n    );\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /* ----- onlyWhitelisted ----- */\n\n  function stakeWithProof(uint256 amount, bytes32[] calldata proof)\n    public\n    override(IStakingRewardWhitelisted)\n    onlyWhitelisted(proof)\n    updateReward(msg.sender)\n  {\n    require(\n      balanceOf(msg.sender).add(amount) <= maximumContribution,\n      \"Phase1Pool::stake: Cannot exceed maximum contribution\"\n    );\n\n    super.stake(amount);\n  }\n}\n"
    },
    "contracts/staking/interfaces/IStakingRewardWhitelisted.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"synthetix/contracts/interfaces/IStakingRewards.sol\";\n\ninterface IStakingRewardWhitelisted is IStakingRewards {\n  function stakeWithProof(uint256 amount, bytes32[] calldata proof) external;\n}\n"
    },
    "contracts/staking/Whitelisted.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport '@openzeppelin/contracts/GSN/Context.sol';\n\nimport './interfaces/IWhitelist.sol';\n\nabstract contract Whitelisted is Context {\n    IWhitelist public whitelist;\n\n    modifier onlyWhitelisted(bytes32[] calldata proof) {\n        require(\n            whitelist.whitelisted(_msgSender(), proof),\n            \"Whitelisted::onlyWhitelisted: Caller is not whitelisted / proof invalid\"\n        );\n        _;\n    }\n}"
    },
    "contracts/staking/interfaces/IWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.2;\n\ninterface IWhitelist {\n  // Views\n  function root() external view returns (bytes32);\n  function uri() external view returns (string memory);\n  function whitelisted(address account, bytes32[] memory proof) external view returns (bool);\n\n  // Mutative\n  function updateWhitelist(bytes32 _root, string memory _uri) external; \n}"
    },
    "contracts/staking/MerkleWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./interfaces/IWhitelist.sol\";\n\ncontract MerkleWhitelist is IWhitelist, Context, AccessControl {\n  /* ========== CONSTANTS ========== */\n  bytes32 public constant WHITELISTER_ROLE = keccak256(\"WHITELISTER_ROLE\");\n\n  /* ========== STATE VARIABLES ========== */\n  bytes32 public merkleRoot;\n  string public sourceUri;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @notice Construct a new MerkleWhitelist\n   * @param _admin The default role controller and whitelister for the contract.\n   * @param _root The default merkleRoot.\n   * @param _uri The link to the full whitelist.\n   */\n  constructor(\n    address _admin,\n    bytes32 _root,\n    string memory _uri\n  ) {\n    merkleRoot = _root;\n    sourceUri = _uri;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n    _setupRole(WHITELISTER_ROLE, _admin);\n  }\n\n  /* ========== EVENTS ========== */\n\n  event UpdatedWhitelist(bytes32 root, string uri);\n\n  /* ========== VIEWS ========== */\n\n  function root() external view override(IWhitelist) returns (bytes32) {\n    return merkleRoot;\n  }\n\n  function uri() external view override(IWhitelist) returns (string memory) {\n    return sourceUri;\n  }\n\n  function whitelisted(address account, bytes32[] memory proof)\n    public\n    view\n    override(IWhitelist)\n    returns (bool)\n  {\n    // Need to include bytes1(0x00) in order to prevent pre-image attack.\n    bytes32 leafHash = keccak256(abi.encodePacked(bytes1(0x00), account));\n    return checkProof(merkleRoot, proof, leafHash);\n  }\n\n  /* ========== PURE ========== */\n\n  function checkProof(\n    bytes32 _root,\n    bytes32[] memory _proof,\n    bytes32 _leaf\n  ) internal pure returns (bool) {\n    bytes32 computedHash = _leaf;\n\n    for (uint256 i = 0; i < _proof.length; i++) {\n      bytes32 proofElement = _proof[i];\n\n      if (computedHash < proofElement) {\n        computedHash = keccak256(\n          abi.encodePacked(bytes1(0x01), computedHash, proofElement)\n        );\n      } else {\n        computedHash = keccak256(\n          abi.encodePacked(bytes1(0x01), proofElement, computedHash)\n        );\n      }\n    }\n\n    return computedHash == _root;\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /* ----- WHITELISTER_ROLE ----- */\n\n  function updateWhitelist(bytes32 root_, string memory uri_)\n    public\n    override(IWhitelist)\n  {\n    require(\n      hasRole(WHITELISTER_ROLE, _msgSender()),\n      \"MerkleWhitelist::updateWhitelist: only whitelister may update the whitelist\"\n    );\n\n    merkleRoot = root_;\n    sourceUri = uri_;\n\n    emit UpdatedWhitelist(merkleRoot, sourceUri);\n  }\n}\n"
    },
    "contracts/tokens/mock/TokenMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * This has an open mint functionality\n */\ncontract TokenMock is Context, AccessControl, ERC20Burnable, ERC20Pausable {\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  /**\n   * @dev Grants `DEFAULT_ADMIN_ROLE`, and `PAUSER_ROLE` to the\n   * account that deploys the contract.\n   *\n   * See {ERC20-constructor}.\n   */\n  constructor(\n    address _admin,\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n  ) ERC20(_name, _symbol) {\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n    _setupRole(PAUSER_ROLE, _admin);\n\n    _setupDecimals(_decimals);\n  }\n\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   */\n  function mint(address to, uint256 amount) external virtual {\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev Pauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function pause() external virtual {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"TokenMock/PauserRole\");\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function unpause() external virtual {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"TokenMock/PauserRole\");\n    _unpause();\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override(ERC20, ERC20Pausable) {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/lib/mock/RecoverableHarness.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../Recoverable.sol\";\n\ncontract RecoverableHarness is Recoverable {\n  constructor(address governance) {\n    _setupRole(RECOVER_ROLE, governance);\n  }\n\n  receive() external payable {\n    // Blindly accept ETH.\n  }\n}\n"
    },
    "contracts/staking/ETHPhase2Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./RewardDistributionRecipient.sol\";\nimport \"./interfaces/IETHStakingRewards.sol\";\n\n/**\n * @title Phase 2 BANK Reward Pool for Float Protocol, specifically for ETH.\n * @notice This contract is used to reward `rewardToken` when ETH is staked.\n */\ncontract ETHPhase2Pool is\n  IETHStakingRewards,\n  Context,\n  AccessControl,\n  RewardDistributionRecipient,\n  ReentrancyGuard\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== CONSTANTS ========== */\n  uint256 public constant DURATION = 7 days;\n  bytes32 public constant RECOVER_ROLE = keccak256(\"RECOVER_ROLE\");\n\n  /* ========== STATE VARIABLES ========== */\n  IERC20 public rewardToken;\n\n  uint256 public periodFinish = 0;\n  uint256 public rewardRate = 0;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStored;\n\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n\n  uint256 private _totalSupply;\n  mapping(address => uint256) private _balances;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @notice Construct a new Phase2Pool for ETH\n   * @param _admin The default role controller for\n   * @param _rewardDistribution The reward distributor (can change reward rate)\n   * @param _rewardToken The reward token to distribute\n   */\n  constructor(\n    address _admin,\n    address _rewardDistribution,\n    address _rewardToken\n  ) RewardDistributionRecipient(_admin) {\n    rewardDistribution = _rewardDistribution;\n    rewardToken = IERC20(_rewardToken);\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n    _setupRole(RECOVER_ROLE, _admin);\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RewardAdded(uint256 reward);\n  event Staked(address indexed user, uint256 amount);\n  event Withdrawn(address indexed user, uint256 amount);\n  event RewardPaid(address indexed user, uint256 reward);\n  event Recovered(address token, uint256 amount);\n\n  /* ========== MODIFIERS ========== */\n\n  modifier updateReward(address account) {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      rewards[account] = earned(account);\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function totalSupply()\n    public\n    view\n    override(IETHStakingRewards)\n    returns (uint256)\n  {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    override(IETHStakingRewards)\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function lastTimeRewardApplicable()\n    public\n    view\n    override(IETHStakingRewards)\n    returns (uint256)\n  {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  function rewardPerToken()\n    public\n    view\n    override(IETHStakingRewards)\n    returns (uint256)\n  {\n    if (totalSupply() == 0) {\n      return rewardPerTokenStored;\n    }\n\n    return\n      rewardPerTokenStored.add(\n        lastTimeRewardApplicable()\n          .sub(lastUpdateTime)\n          .mul(rewardRate)\n          .mul(1e18)\n          .div(totalSupply())\n      );\n  }\n\n  function earned(address account)\n    public\n    view\n    override(IETHStakingRewards)\n    returns (uint256)\n  {\n    return\n      balanceOf(account)\n        .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n        .div(1e18)\n        .add(rewards[account]);\n  }\n\n  function getRewardForDuration()\n    external\n    view\n    override(IETHStakingRewards)\n    returns (uint256)\n  {\n    return rewardRate.mul(DURATION);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @dev Fallback, `msg.value` of ETH sent to this contract grants caller account a matching stake in contract.\n   * Emits {Staked} event to reflect this.\n   */\n  receive() external payable {\n    stake(msg.value);\n  }\n\n  function stake(uint256 amount)\n    public\n    payable\n    virtual\n    override(IETHStakingRewards)\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"ETHPhase2Pool/ZeroStake\");\n    require(amount == msg.value, \"ETHPhase2Pool/IncorrectEth\");\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\n\n    emit Staked(msg.sender, amount);\n  }\n\n  function withdraw(uint256 amount)\n    public\n    override(IETHStakingRewards)\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"ETHPhase2Pool/ZeroWithdraw\");\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n    emit Withdrawn(msg.sender, amount);\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success, \"ETHPhase2Pool/EthTransferFail\");\n  }\n\n  function exit() external override(IETHStakingRewards) {\n    withdraw(balanceOf(msg.sender));\n    getReward();\n  }\n\n  function getReward()\n    public\n    virtual\n    override(IETHStakingRewards)\n    updateReward(msg.sender)\n  {\n    uint256 reward = earned(msg.sender);\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n      rewardToken.safeTransfer(msg.sender, reward);\n      emit RewardPaid(msg.sender, reward);\n    }\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /* ----- Reward Distributor ----- */\n\n  /**\n   * @notice Should be called after the amount of reward tokens has\n     been sent to the contract.\n     Reward should be divisible by duration.\n   * @param reward number of tokens to be distributed over the duration.\n   */\n  function notifyRewardAmount(uint256 reward)\n    external\n    override\n    onlyRewardDistribution\n    updateReward(address(0))\n  {\n    if (block.timestamp >= periodFinish) {\n      rewardRate = reward.div(DURATION);\n    } else {\n      uint256 remaining = periodFinish.sub(block.timestamp);\n      uint256 leftover = remaining.mul(rewardRate);\n      rewardRate = reward.add(leftover).div(DURATION);\n    }\n\n    // Ensure provided reward amount is not more than the balance in the contract.\n    // Keeps reward rate within the right range to prevent overflows in earned or rewardsPerToken\n    // Reward + leftover < 1e18\n    uint256 balance = rewardToken.balanceOf(address(this));\n    require(\n      rewardRate <= balance.div(DURATION),\n      \"ETHPhase2Pool/LowRewardBalance\"\n    );\n\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp.add(DURATION);\n    emit RewardAdded(reward);\n  }\n\n  /* ----- RECOVER_ROLE ----- */\n\n  /**\n   * @notice Provide accidental token retrieval.\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\n   */\n  function recoverERC20(address tokenAddress, uint256 tokenAmount) external {\n    require(\n      hasRole(RECOVER_ROLE, _msgSender()),\n      \"ETHPhase2Pool/HasRecoverRole\"\n    );\n    require(tokenAddress != address(rewardToken), \"ETHPhase2Pool/NotReward\");\n\n    IERC20(tokenAddress).safeTransfer(_msgSender(), tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n}\n"
    },
    "contracts/staking/interfaces/IETHStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ninterface IETHStakingRewards {\n    // Views\n    function lastTimeRewardApplicable() external view returns (uint256);\n    function rewardPerToken() external view returns (uint256);\n    function earned(address account) external view returns (uint256);\n    function getRewardForDuration() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n\n    // Mutative\n    function stake(uint256 amount) external payable;\n    function withdraw(uint256 amount) external;\n    function getReward() external;\n    function exit() external;\n}\n"
    },
    "contracts/staking/BasePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"synthetix/contracts/interfaces/IStakingRewards.sol\";\n\nimport \"./RewardDistributionRecipient.sol\";\n\n/**\n * @title Base Reward Pool for Float Protocol\n * @notice This contract is used to reward `rewardToken` when `stakeToken` is staked.\n * @dev The Pools are based on the original Synthetix rewards contract (https://etherscan.io/address/0xDCB6A51eA3CA5d3Fd898Fd6564757c7aAeC3ca92#code) developed by @k06a which is battled tested and widely used.\n * Alterations:\n * - duration set on constructor (immutable)\n * - Internal properties rather than private\n * - Add virtual marker to functions\n * - Change stake / withdraw to external and provide internal equivalents\n * - Change require messages to match convention\n * - Add hooks for _beforeWithdraw and _beforeStake\n * - Emit events before external calls in line with best practices.\n */\nabstract contract BasePool is\n  IStakingRewards,\n  AccessControl,\n  RewardDistributionRecipient\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== CONSTANTS ========== */\n  bytes32 public constant RECOVER_ROLE = keccak256(\"RECOVER_ROLE\");\n  uint256 public immutable duration;\n\n  /* ========== STATE VARIABLES ========== */\n  IERC20 public rewardToken;\n  IERC20 public stakeToken;\n\n  uint256 public periodFinish;\n  uint256 public rewardRate;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStored;\n\n  mapping(address => uint256) public userRewardPerTokenPaid;\n  mapping(address => uint256) public rewards;\n\n  uint256 internal _totalSupply;\n  mapping(address => uint256) internal _balances;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @notice Construct a new BasePool\n   * @param _admin The default role controller\n   * @param _rewardDistribution The reward distributor (can change reward rate)\n   * @param _rewardToken The reward token to distribute\n   * @param _stakingToken The staking token used to qualify for rewards\n   */\n  constructor(\n    address _admin,\n    address _rewardDistribution,\n    address _rewardToken,\n    address _stakingToken,\n    uint256 _duration\n  ) RewardDistributionRecipient(_admin) {\n    rewardDistribution = _rewardDistribution;\n    rewardToken = IERC20(_rewardToken);\n    stakeToken = IERC20(_stakingToken);\n\n    duration = _duration;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n    _setupRole(RECOVER_ROLE, _admin);\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RewardAdded(uint256 reward);\n  event Staked(address indexed user, uint256 amount);\n  event Withdrawn(address indexed user, uint256 amount);\n  event RewardPaid(address indexed user, uint256 reward);\n  event Recovered(address token, uint256 amount);\n\n  /* ========== MODIFIERS ========== */\n\n  modifier updateReward(address account) virtual {\n    rewardPerTokenStored = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      rewards[account] = earned(account);\n      userRewardPerTokenPaid[account] = rewardPerTokenStored;\n    }\n    _;\n  }\n\n  /* ========== VIEWS ========== */\n\n  /**\n   * @notice The total reward producing staked supply (total quantity to distribute)\n   */\n  function totalSupply()\n    public\n    view\n    virtual\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return _totalSupply;\n  }\n\n  /**\n   * @notice The total reward producing balance of the account.\n   */\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function lastTimeRewardApplicable()\n    public\n    view\n    virtual\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return Math.min(block.timestamp, periodFinish);\n  }\n\n  function rewardPerToken()\n    public\n    view\n    virtual\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    if (totalSupply() == 0) {\n      return rewardPerTokenStored;\n    }\n\n    return\n      rewardPerTokenStored.add(\n        lastTimeRewardApplicable()\n          .sub(lastUpdateTime)\n          .mul(rewardRate)\n          .mul(1e18)\n          .div(totalSupply())\n      );\n  }\n\n  function earned(address account)\n    public\n    view\n    virtual\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return\n      balanceOf(account)\n        .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n        .div(1e18)\n        .add(rewards[account]);\n  }\n\n  function getRewardForDuration()\n    external\n    view\n    override(IStakingRewards)\n    returns (uint256)\n  {\n    return rewardRate.mul(duration);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function stake(uint256 amount)\n    external\n    virtual\n    override(IStakingRewards)\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"BasePool/NonZeroStake\");\n\n    _stake(msg.sender, msg.sender, amount);\n  }\n\n  function withdraw(uint256 amount)\n    external\n    virtual\n    override(IStakingRewards)\n    updateReward(msg.sender)\n  {\n    require(amount > 0, \"BasePool/NonZeroWithdraw\");\n\n    _withdraw(msg.sender, amount);\n  }\n\n  /**\n   * @notice Exit the pool, taking any rewards due and staked\n   */\n  function exit()\n    external\n    virtual\n    override(IStakingRewards)\n    updateReward(msg.sender)\n  {\n    _withdraw(msg.sender, _balances[msg.sender]);\n    getReward();\n  }\n\n  /**\n   * @notice Retrieve any rewards due\n   */\n  function getReward()\n    public\n    virtual\n    override(IStakingRewards)\n    updateReward(msg.sender)\n  {\n    uint256 reward = earned(msg.sender);\n    if (reward > 0) {\n      rewards[msg.sender] = 0;\n\n      emit RewardPaid(msg.sender, reward);\n\n      rewardToken.safeTransfer(msg.sender, reward);\n    }\n  }\n\n  /**\n   * @dev Stakes `amount` tokens from `staker` to `recipient`, increasing the total supply.\n   *\n   * Emits a {Staked} event.\n   *\n   * Requirements:\n   * - `recipient` cannot be zero address.\n   * - `staker` must have at least `amount` tokens\n   * - `staker` must approve this contract for at least `amount`\n   */\n  function _stake(\n    address staker,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(recipient != address(0), \"BasePool/ZeroAddressS\");\n\n    _beforeStake(staker, recipient, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[recipient] = _balances[recipient].add(amount);\n\n    emit Staked(recipient, amount);\n    stakeToken.safeTransferFrom(staker, address(this), amount);\n  }\n\n  /**\n   * @dev Withdraws `amount` tokens from `account`, reducing the total supply.\n   *\n   * Emits a {Withdrawn} event.\n   *\n   * Requirements:\n   * - `account` cannot be zero address.\n   * - `account` must have at least `amount` staked.\n   */\n  function _withdraw(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"BasePool/ZeroAddressW\");\n\n    _beforeWithdraw(account, amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"BasePool/WithdrawExceedsBalance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n\n    emit Withdrawn(account, amount);\n    stakeToken.safeTransfer(account, amount);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /* ----- Reward Distributor ----- */\n\n  /**\n   * @notice Should be called after the amount of reward tokens has\n     been sent to the contract.\n     Reward should be divisible by duration.\n   * @param reward number of tokens to be distributed over the duration.\n   */\n  function notifyRewardAmount(uint256 reward)\n    public\n    virtual\n    override\n    onlyRewardDistribution\n    updateReward(address(0))\n  {\n    if (block.timestamp >= periodFinish) {\n      rewardRate = reward.div(duration);\n    } else {\n      uint256 remaining = periodFinish.sub(block.timestamp);\n      uint256 leftover = remaining.mul(rewardRate);\n      rewardRate = reward.add(leftover).div(duration);\n    }\n\n    // Ensure provided reward amount is not more than the balance in the contract.\n    // Keeps reward rate within the right range to prevent overflows in earned or rewardsPerToken\n    // Reward + leftover < 1e18\n    uint256 balance = rewardToken.balanceOf(address(this));\n    require(rewardRate <= balance.div(duration), \"BasePool/InsufficentBalance\");\n\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp.add(duration);\n    emit RewardAdded(reward);\n  }\n\n  /* ----- RECOVER_ROLE ----- */\n\n  /**\n   * @notice Provide accidental token retrieval.\n   * @dev Sourced from synthetix/contracts/StakingRewards.sol\n   */\n  function recoverERC20(address tokenAddress, uint256 tokenAmount) external {\n    require(hasRole(RECOVER_ROLE, _msgSender()), \"BasePool/RecoverRole\");\n    require(tokenAddress != address(stakeToken), \"BasePool/NoRecoveryOfStake\");\n    require(\n      tokenAddress != address(rewardToken),\n      \"BasePool/NoRecoveryOfReward\"\n    );\n\n    emit Recovered(tokenAddress, tokenAmount);\n\n    IERC20(tokenAddress).safeTransfer(_msgSender(), tokenAmount);\n  }\n\n  /* ========== HOOKS ========== */\n\n  /**\n   * @dev Hook that is called before any staking of tokens.\n   *\n   * Calling conditions:\n   *\n   * - `amount` of ``staker``'s tokens will be staked into the pool\n   * - `recipient` can withdraw.\n   */\n  function _beforeStake(\n    address staker,\n    address recipient,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called before any staking of tokens.\n   *\n   * Calling conditions:\n   *\n   * - `amount` of ``from``'s tokens will be withdrawn into the pool\n   */\n  function _beforeWithdraw(address from, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/staking/Phase4aPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"./BasePool.sol\";\nimport \"./extensions/DeadlinePool.sol\";\n\nimport \"./extensions/LockInPool.sol\";\n\n/**\n * Phase 4a Pool - is a special ceremony pool that can only be joined within the window period and has a Lock in period for the tokens\n */\ncontract Phase4aPool is DeadlinePool, LockInPool {\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @notice Construct a new BasePool\n   * @param _admin The default role controller\n   * @param _rewardDistribution The reward distributor (can change reward rate)\n   * @param _rewardToken The reward token to distribute\n   * @param _stakingToken The staking token used to qualify for rewards\n   * @param _startWindow When ceremony starts\n   * @param _endWindow When ceremony ends\n   */\n  constructor(\n    address _admin,\n    address _rewardDistribution,\n    address _rewardToken,\n    address _stakingToken,\n    uint256 _duration,\n    uint256 _startWindow,\n    uint256 _endWindow\n  )\n    DeadlinePool(\n      _admin,\n      _rewardDistribution,\n      _rewardToken,\n      _stakingToken,\n      _duration,\n      _startWindow,\n      _endWindow\n    )\n  {}\n\n  // COMPILER HINTS for overrides\n\n  function _beforeStake(\n    address staker,\n    address recipient,\n    uint256 amount\n  ) internal virtual override(LockInPool, DeadlinePool) {\n    super._beforeStake(staker, recipient, amount);\n  }\n\n  function _beforeWithdraw(address from, uint256 amount)\n    internal\n    virtual\n    override(BasePool, LockInPool)\n  {\n    super._beforeWithdraw(from, amount);\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override(BasePool, LockInPool)\n    returns (uint256)\n  {\n    return super.balanceOf(account);\n  }\n\n  function totalSupply()\n    public\n    view\n    virtual\n    override(BasePool, LockInPool)\n    returns (uint256)\n  {\n    return super.totalSupply();\n  }\n}\n"
    },
    "contracts/staking/extensions/DeadlinePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"../BasePool.sol\";\nimport \"../../lib/Windowed.sol\";\n\n/**\n * @notice Only allow staking before the deadline.\n */\nabstract contract DeadlinePool is BasePool, Windowed {\n  constructor(\n    address _admin,\n    address _rewardDistribution,\n    address _rewardToken,\n    address _stakingToken,\n    uint256 _duration,\n    uint256 _startWindow,\n    uint256 _endWindow\n  )\n    BasePool(\n      _admin,\n      _rewardDistribution,\n      _rewardToken,\n      _stakingToken,\n      _duration\n    )\n    Windowed(_startWindow, _endWindow)\n  {}\n\n  function _beforeStake(\n    address staker,\n    address recipient,\n    uint256 amount\n  ) internal virtual override(BasePool) inWindow {\n    super._beforeStake(staker, recipient, amount);\n  }\n}\n"
    },
    "contracts/staking/extensions/LockInPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../BasePool.sol\";\n\n/**\n * Integrates a timelock of `LOCK_DURATION` on the Pool.\n * Can only withdraw from the pool if:\n * - not started\n * - or requested an unlock and waited the `LOCK_DURATION`\n * - or the rewards have finished for `REFILL_ALLOWANCE`.\n */\nabstract contract LockInPool is BasePool {\n  using SafeMath for uint256;\n\n  uint256 private constant REFILL_ALLOWANCE = 2 hours;\n  uint256 private constant LOCK_DURATION = 8 days;\n\n  mapping(address => uint256) public unlocks;\n  uint256 private _unlockingSupply;\n\n  event Unlock(address indexed account);\n\n  /* ========== VIEWS ========== */\n\n  /**\n   * @notice The balance that is currently being unlocked\n   * @param account The account we're interested in.\n   */\n  function inLimbo(address account) public view returns (uint256) {\n    if (unlocks[account] == 0) {\n      return 0;\n    }\n    return super.balanceOf(account);\n  }\n\n  /// @inheritdoc BasePool\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override(BasePool)\n    returns (uint256)\n  {\n    if (unlocks[account] != 0) {\n      return 0;\n    }\n    return super.balanceOf(account);\n  }\n\n  /// @inheritdoc BasePool\n  function totalSupply()\n    public\n    view\n    virtual\n    override(BasePool)\n    returns (uint256)\n  {\n    return super.totalSupply().sub(_unlockingSupply);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @notice Request unlock of the token, removing this senders reward accural by:\n   * - Setting balanceOf to return 0 (used for reward calculation) and adjusting total supply by amount unlocking.\n   */\n  function unlock() external updateReward(msg.sender) {\n    require(unlocks[msg.sender] == 0, \"LockIn/UnlockOnce\");\n\n    _unlockingSupply = _unlockingSupply.add(balanceOf(msg.sender));\n    unlocks[msg.sender] = block.timestamp;\n\n    emit Unlock(msg.sender);\n  }\n\n  /* ========== HOOKS ========== */\n\n  /**\n   * @notice Handle unlocks when staking, resets lock if was unlocking\n   */\n  function _beforeStake(\n    address staker,\n    address recipient,\n    uint256 amount\n  ) internal virtual override(BasePool) {\n    super._beforeStake(staker, recipient, amount);\n\n    if (unlocks[recipient] != 0) {\n      // If we are resetting an unlock, reset the unlockingSupply\n      _unlockingSupply = _unlockingSupply.sub(inLimbo(recipient));\n      unlocks[recipient] = 0;\n    }\n  }\n\n  /**\n   * @dev Prevent withdrawal if:\n   * - has started (i.e. rewards have entered the pool)\n   * - before finished (+ allowance)\n   * - not unlocked `LOCK_DURATION` ago\n   *\n   * - reset the unlock, so you can re-enter.\n   */\n  function _beforeWithdraw(address recipient, uint256 amount)\n    internal\n    virtual\n    override(BasePool)\n  {\n    super._beforeWithdraw(recipient, amount);\n\n    // Before rewards have been added / after + `REFILL`\n    bool releaseWithoutLock =\n      block.timestamp >= periodFinish.add(REFILL_ALLOWANCE);\n\n    // A lock has been requested and the `LOCK_DURATION` has passed.\n    bool releaseWithLock =\n      (unlocks[recipient] != 0) &&\n        (unlocks[recipient] <= block.timestamp.sub(LOCK_DURATION));\n\n    require(releaseWithoutLock || releaseWithLock, \"LockIn/NotReleased\");\n\n    if (unlocks[recipient] != 0) {\n      // Reduce unlocking supply (so we don't keep discounting total supply when\n      // it is reduced). Amount will be validated in withdraw proper.\n      _unlockingSupply = _unlockingSupply.sub(amount);\n    }\n  }\n}\n"
    },
    "contracts/staking/Phase4Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"./extensions/LockInPool.sol\";\n\n/**\n * Phase4Pool that acts as a SNX Reward Contract, with an 8 day token lock.\n */\ncontract Phase4Pool is LockInPool {\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @notice Construct a new Phase4Pool\n   * @param _admin The default role controller\n   * @param _rewardDistribution The reward distributor (can change reward rate)\n   * @param _rewardToken The reward token to distribute\n   * @param _stakingToken The staking token used to qualify for rewards\n   * @param _duration Duration for token\n   */\n  constructor(\n    address _admin,\n    address _rewardDistribution,\n    address _rewardToken,\n    address _stakingToken,\n    uint256 _duration\n  )\n    BasePool(\n      _admin,\n      _rewardDistribution,\n      _rewardToken,\n      _stakingToken,\n      _duration\n    )\n  {}\n}\n"
    },
    "contracts/staking/extensions/MasterChefV2Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../interfaces/IMasterChefRewarder.sol\";\n\nimport \"../BasePool.sol\";\n\n// !!!! WIP !!!!!\n// This code doesn't work. You can deposit via sushi, withdraw through normal functions.\n// Must separate the balances and only keep them the same for the rewards.\n\n/**\n * Provides adapters to allow this reward contract to be used as a MASTERCHEF V2 Rewards contract\n */\nabstract contract MasterChefV2Pool is BasePool, IMasterChefRewarder {\n  using SafeMath for uint256;\n\n  address private immutable masterchefV2;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @notice Construct a new MasterChefV2Pool\n   * @param _admin The default role controller\n   * @param _rewardDistribution The reward distributor (can change reward rate)\n   * @param _rewardToken The reward token to distribute\n   * @param _stakingToken The staking token used to qualify for rewards\n   * @param _duration The duration for each reward distribution\n   * @param _masterchefv2 The trusted masterchef contract\n   */\n  constructor(\n    address _admin,\n    address _rewardDistribution,\n    address _rewardToken,\n    address _stakingToken,\n    uint256 _duration,\n    address _masterchefv2\n  )\n    BasePool(\n      _admin,\n      _rewardDistribution,\n      _rewardToken,\n      _stakingToken,\n      _duration\n    )\n  {\n    masterchefV2 = _masterchefv2;\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier onlyMCV2 {\n    require(msg.sender == masterchefV2, \"MasterChefV2Pool/OnlyMCV2\");\n    _;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function pendingTokens(\n    uint256,\n    address user,\n    uint256\n  )\n    external\n    view\n    override(IMasterChefRewarder)\n    returns (IERC20[] memory rewardTokens, uint256[] memory rewardAmounts)\n  {\n    IERC20[] memory _rewardTokens = new IERC20[](1);\n    _rewardTokens[0] = (rewardToken);\n    uint256[] memory _rewardAmounts = new uint256[](1);\n    _rewardAmounts[0] = earned(user);\n    return (_rewardTokens, _rewardAmounts);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * Adds to the internal balance record,\n   */\n  function onSushiReward(\n    uint256,\n    address _user,\n    address,\n    uint256,\n    uint256 newLpAmount\n  ) external override(IMasterChefRewarder) onlyMCV2 updateReward(_user) {\n    uint256 internalBalance = _balances[_user];\n    if (internalBalance > newLpAmount) {\n      // _withdrawWithoutPush(_user, internalBalance.sub(newLpAmount));\n    } else if (internalBalance < newLpAmount) {\n      // _stakeWithoutPull(_user, _user, newLpAmount.sub(internalBalance));\n    }\n  }\n}\n"
    },
    "contracts/staking/interfaces/IMasterChefRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMasterChefRewarder {\n  function onSushiReward(\n    uint256 pid,\n    address user,\n    address recipient,\n    uint256 sushiAmount,\n    uint256 newLpAmount\n  ) external;\n\n  function pendingTokens(\n    uint256 pid,\n    address user,\n    uint256 sushiAmount\n  ) external view returns (IERC20[] memory, uint256[] memory);\n}\n"
    },
    "contracts/tokens/mock/SupplyControlledTokenMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\n\nimport \"../interfaces/ISupplyControlledERC20.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * This has an open mint functionality\n */\n// ISupplyControlledERC20,\ncontract SupplyControlledTokenMock is AccessControl, ERC20Burnable {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @dev Grants `DEFAULT_ADMIN_ROLE` to the\n   * account that deploys the contract.\n   *\n   * See {ERC20-constructor}.\n   */\n  constructor(\n    address _admin,\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n  ) ERC20(_name, _symbol) {\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n    _setupRole(MINTER_ROLE, _admin);\n\n    _setupDecimals(_decimals);\n  }\n\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   */\n  function mint(address to, uint256 amount) external {\n    require(hasRole(MINTER_ROLE, _msgSender()), \"SCTokenMock/MinterRole\");\n    _mint(to, amount);\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override(ERC20) {\n    // console.log(symbol(), from, \"->\", to);\n    // console.log(symbol(), \">\", amount);\n    super._beforeTokenTransfer(from, to, amount);\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/governance/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n// Copyright 2020 Compound Labs, Inc.\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract TimeLock {\n  using SafeMath for uint256;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  uint256 public constant GRACE_PERIOD = 14 days;\n  uint256 public constant MINIMUM_DELAY = 2 days;\n  uint256 public constant MAXIMUM_DELAY = 30 days;\n\n  address public admin;\n  address public pendingAdmin;\n  uint256 public delay;\n\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  constructor(address admin_, uint256 delay_) public {\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"TimeLock::constructor: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"TimeLock::constructor: Delay must not exceed maximum delay.\"\n    );\n\n    admin = admin_;\n    delay = delay_;\n  }\n\n  fallback() external {}\n\n  function setDelay(uint256 delay_) public {\n    require(\n      msg.sender == address(this),\n      \"TimeLock::setDelay: Call must come from TimeLock.\"\n    );\n    require(\n      delay_ >= MINIMUM_DELAY,\n      \"TimeLock::setDelay: Delay must exceed minimum delay.\"\n    );\n    require(\n      delay_ <= MAXIMUM_DELAY,\n      \"TimeLock::setDelay: Delay must not exceed maximum delay.\"\n    );\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public {\n    require(\n      msg.sender == pendingAdmin,\n      \"TimeLock::acceptAdmin: Call must come from pendingAdmin.\"\n    );\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public {\n    require(\n      msg.sender == address(this),\n      \"TimeLock::setPendingAdmin: Call must come from TimeLock.\"\n    );\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public returns (bytes32) {\n    require(\n      msg.sender == admin,\n      \"TimeLock::queueTransaction: Call must come from admin.\"\n    );\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"TimeLock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public {\n    require(\n      msg.sender == admin,\n      \"TimeLock::cancelTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable returns (bytes memory) {\n    require(\n      msg.sender == admin,\n      \"TimeLock::executeTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(\n      queuedTransactions[txHash],\n      \"TimeLock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockTimestamp() >= eta,\n      \"TimeLock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n      \"TimeLock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) =\n      target.call{value: value}(callData);\n    require(\n      success,\n      \"TimeLock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint256) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n"
    },
    "contracts/governance/mock/TimeLockMock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n// Copyright 2020 Compound Labs, Inc.\n\npragma solidity ^0.7.6;\n\nimport \"../TimeLock.sol\";\n\ncontract TimeLockMock is TimeLock {\n  constructor(address admin_, uint256 delay_)\n    TimeLock(admin_, TimeLock.MINIMUM_DELAY)\n  {\n    admin = admin_;\n    delay = delay_;\n  }\n}\n"
    },
    "contracts/auxiliary/EarnedAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"synthetix/contracts/interfaces/IStakingRewards.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract EarnedAggregator {\n  /// @notice The address of the Float Protocol Timelock\n  address public timelock;\n\n  /// @notice addresses of pools (Staking Rewards Contracts)\n  address[] public pools;\n\n  constructor(address timelock_, address[] memory pools_) {\n    timelock = timelock_;\n    pools = pools_;\n  }\n\n  function getPools() public view returns (address[] memory) {\n    address[] memory pls = pools;\n    return pls;\n  }\n\n  function addPool(address pool) public {\n    // Sanity check for function and no error\n    IStakingRewards(pool).earned(timelock);\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      require(pools[i] != pool, \"already added\");\n    }\n\n    require(msg.sender == address(timelock), \"EarnedAggregator: !timelock\");\n    pools.push(pool);\n  }\n\n  function removePool(uint256 index) public {\n    require(msg.sender == address(timelock), \"EarnedAggregator: !timelock\");\n    if (index >= pools.length) return;\n\n    if (index != pools.length - 1) {\n      pools[index] = pools[pools.length - 1];\n    }\n\n    pools.pop();\n  }\n\n  function getCurrentEarned(address account) public view returns (uint256) {\n    uint256 votes = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      // get tokens earned for staking\n      votes = SafeMath.add(votes, IStakingRewards(pools[i]).earned(account));\n    }\n    return votes;\n  }\n}\n"
    },
    "contracts/auction/mock/AuctionHouseMathTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AuctionHouseMath.sol\";\n\ncontract AuctionHouseMathTest is AuctionHouseMath {\n  function _lerp(\n    uint256 start,\n    uint256 end,\n    uint16 step,\n    uint16 maxStep\n  ) public pure returns (uint256 result) {\n    return lerp(start, end, step, maxStep);\n  }\n}\n"
    },
    "contracts/funds/BasketV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../external-lib/SafeDecimalMath.sol\";\n\nimport \"./interfaces/IBasket.sol\";\nimport \"./BasketMath.sol\";\n\n/**\n * @title Float Protocol Basket\n * @notice The logic contract for storing underlying ETH (as wETH)\n */\ncontract BasketV1 is IBasket, Initializable, AccessControlUpgradeable {\n  using SafeMath for uint256;\n  using SafeDecimalMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== CONSTANTS ========== */\n  bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n  bytes32 public constant AUCTION_HOUSE_ROLE = keccak256(\"AUCTION_HOUSE_ROLE\");\n\n  /* ========== STATE VARIABLES ========== */\n  IERC20 public float;\n  IERC20 private weth;\n\n  /**\n   * @notice The target ratio for \"collateralisation\"\n   * @dev [e27] Start at 100%\n   */\n  uint256 public targetRatio;\n\n  function initialize(\n    address _admin,\n    address _weth,\n    address _float\n  ) external initializer {\n    weth = IERC20(_weth);\n    float = IERC20(_float);\n    targetRatio = SafeDecimalMath.PRECISE_UNIT;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n    _setupRole(GOVERNANCE_ROLE, _admin);\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier onlyGovernance {\n    require(\n      hasRole(GOVERNANCE_ROLE, _msgSender()),\n      \"AuctionHouse/GovernanceRole\"\n    );\n    _;\n  }\n\n  /* ========== VIEWS ========== */\n\n  /// @inheritdoc IBasketReader\n  function underlying() public view override(IBasketReader) returns (address) {\n    return address(weth);\n  }\n\n  /// @inheritdoc IBasketReader\n  function getBasketFactor(uint256 targetPriceInEth)\n    external\n    view\n    override(IBasketReader)\n    returns (uint256 basketFactor)\n  {\n    uint256 wethInBasket = weth.balanceOf(address(this));\n    uint256 floatTotalSupply = float.totalSupply();\n\n    return\n      basketFactor = BasketMath.calcBasketFactor(\n        targetPriceInEth,\n        wethInBasket,\n        floatTotalSupply,\n        targetRatio\n      );\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /* ----- onlyGovernance ----- */\n\n  /// @inheritdoc IBasketGovernedActions\n  function buildAuctionHouse(address _auctionHouse, uint256 _allowance)\n    external\n    override(IBasketGovernedActions)\n    onlyGovernance\n  {\n    grantRole(AUCTION_HOUSE_ROLE, _auctionHouse);\n    weth.safeApprove(_auctionHouse, 0);\n    weth.safeApprove(_auctionHouse, _allowance);\n  }\n\n  /// @inheritdoc IBasketGovernedActions\n  function burnAuctionHouse(address _auctionHouse)\n    external\n    override(IBasketGovernedActions)\n    onlyGovernance\n  {\n    revokeRole(AUCTION_HOUSE_ROLE, _auctionHouse);\n    weth.safeApprove(_auctionHouse, 0);\n  }\n\n  /// @inheritdoc IBasketGovernedActions\n  function setTargetRatio(uint256 _targetRatio)\n    external\n    override(IBasketGovernedActions)\n    onlyGovernance\n  {\n    require(\n      _targetRatio <= BasketMath.MAX_TARGET_RATIO,\n      \"BasketV1/RatioTooHigh\"\n    );\n    require(\n      _targetRatio >= BasketMath.MIN_TARGET_RATIO,\n      \"BasketV1/RatioTooLow\"\n    );\n    targetRatio = _targetRatio;\n\n    emit NewTargetRatio(_targetRatio);\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSetUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using AddressUpgradeable for address;\n\n    struct RoleData {\n        EnumerableSetUpgradeable.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/funds/interfaces/IBasket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./basket/IBasketReader.sol\";\nimport \"./basket/IBasketGovernedActions.sol\";\n\n/**\n * @title The interface for a Float Protocol Asset Basket\n * @notice A Basket stores value used to stabilise price and assess the\n * the movement of the underlying assets we're trying to track.\n * @dev The Basket interface is broken up into many smaller pieces to allow only\n * relevant parts to be imported\n */\ninterface IBasket is IBasketReader, IBasketGovernedActions {\n\n}\n"
    },
    "contracts/funds/BasketMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../external-lib/SafeDecimalMath.sol\";\n\nlibrary BasketMath {\n  using SafeMath for uint256;\n  using SafeDecimalMath for uint256;\n\n  // SafeDecimalMath.PRECISE_UNIT = 1e27\n  uint256 internal constant MIN_TARGET_RATIO = 0.1e27;\n  uint256 internal constant MAX_TARGET_RATIO = 2e27;\n\n  /**\n   * @dev bF = ( eS / (fS * tP) ) / Q\n   * @param targetPriceInEth [e27] target price (tP).\n   * @param ethStored [e18] denoting total eth stored in basket (eS).\n   * @param floatSupply [e18] denoting total floatSupply (fS).\n   * @param targetRatio [e27] target ratio (Q)\n   * @return basketFactor an [e27] decimal (bF)\n   */\n  function calcBasketFactor(\n    uint256 targetPriceInEth,\n    uint256 ethStored,\n    uint256 floatSupply,\n    uint256 targetRatio\n  ) internal pure returns (uint256 basketFactor) {\n    // Note that targetRatio should already be checked on set\n    assert(targetRatio >= MIN_TARGET_RATIO);\n    assert(targetRatio <= MAX_TARGET_RATIO);\n    uint256 floatValue =\n      floatSupply.multiplyDecimalRoundPrecise(targetPriceInEth);\n    uint256 basketRatio = ethStored.divideDecimalRoundPrecise(floatValue);\n    return basketFactor = basketRatio.divideDecimalRoundPrecise(targetRatio);\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/funds/interfaces/basket/IBasketGovernedActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\n/**\n * @title Basket Actions with suitable access control\n * @notice Contains actions which can only be called by governance.\n */\ninterface IBasketGovernedActions {\n  event NewTargetRatio(uint256 targetRatio);\n\n  /**\n   * @notice Sets the basket target factor, initially \"1\"\n   * @dev Expects an [e27] fixed point decimal value.\n   * Target Ratio is what the basket factor is \"aiming for\",\n   * i.e. target ratio = 0.8 then an 80% support from the basket\n   * results in a 100% Basket Factor.\n   * @param _targetRatio [e27] The new Target ratio\n   */\n  function setTargetRatio(uint256 _targetRatio) external;\n\n  /**\n   * @notice Connect and approve a new auction house to spend from the basket.\n   * @dev Note that any allowance can be set, and even type(uint256).max will\n   * slowly be eroded.\n   * @param _auctionHouse The Auction House address to approve\n   * @param _allowance The amount of the underlying token it can spend\n   */\n  function buildAuctionHouse(address _auctionHouse, uint256 _allowance)\n    external;\n\n  /**\n   * @notice Remove an auction house, allows easy upgrades.\n   * @param _auctionHouse The Auction House address to revoke.\n   */\n  function burnAuctionHouse(address _auctionHouse) external;\n}\n"
    },
    "contracts/funds/mock/BasketMathHarness.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../BasketMath.sol\";\n\ncontract BasketMathHarness {\n  function _calcBasketFactor(\n    uint256 targetPriceInEth,\n    uint256 ethStored,\n    uint256 floatSupply,\n    uint256 targetRatio\n  ) external pure returns (uint256 basketFactor) {\n    return\n      BasketMath.calcBasketFactor(\n        targetPriceInEth,\n        ethStored,\n        floatSupply,\n        targetRatio\n      );\n  }\n}\n"
    },
    "contracts/tokens/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @title {ERC20} Pausable token through the PAUSER_ROLE\n *\n * @dev This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions using the different roles.\n */\nabstract contract ERC20PausableUpgradeable is\n  Initializable,\n  PausableUpgradeable,\n  AccessControlUpgradeable,\n  ERC20Upgradeable\n{\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __ERC20Pausable_init_unchained(address pauser) internal initializer {\n    _setupRole(PAUSER_ROLE, pauser);\n  }\n\n  /**\n   * @dev Pauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function pause() external {\n    require(\n      hasRole(PAUSER_ROLE, _msgSender()),\n      \"ERC20Pausable/PauserRoleRequired\"\n    );\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function unpause() external {\n    require(\n      hasRole(PAUSER_ROLE, _msgSender()),\n      \"ERC20Pausable/PauserRoleRequired\"\n    );\n    _unpause();\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override(ERC20Upgradeable) {\n    super._beforeTokenTransfer(from, to, amount);\n\n    require(!paused(), \"ERC20Pausable/Paused\");\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/tokens/FloatTokenV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\nimport \"./ERC20PermitUpgradeable.sol\";\nimport \"./ERC20PausableUpgradeable.sol\";\nimport \"./ERC20SupplyControlledUpgradeable.sol\";\n\n/**\n * @dev {ERC20} FLOAT token, including:\n *\n * - a minter role that allows for token minting (necessary for stabilisation)\n * - the ability to burn tokens (necessary for stabilisation)\n * - the use of permits to reduce gas costs\n * - a pauser role that allows to stop all token transfers\n *\n * This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions\n * using the different roles.\n * This contract is upgradable.\n */\ncontract FloatTokenV1 is\n  ERC20PausableUpgradeable,\n  ERC20PermitUpgradeable,\n  ERC20SupplyControlledUpgradeable\n{\n  /**\n   * @notice Construct a FloatTokenV1 instance\n   * @param governance The default role controller, minter and pauser for the contract.\n   * @param minter An additional minter (useful for quick launches, check this is revoked)\n   * @dev We expect minters to be defined on deploy, e.g. AuctionHouse should get minter role\n   */\n  function initialize(address governance, address minter) external initializer {\n    __Context_init_unchained();\n    __ERC20_init_unchained(\"Float Protocol: FLOAT\", \"FLOAT\");\n    __ERC20Permit_init_unchained(\"Float Protocol: FLOAT\", \"1\");\n    __ERC20Pausable_init_unchained(governance);\n    __ERC20SupplyControlled_init_unchained(governance);\n\n    _setupRole(DEFAULT_ADMIN_ROLE, governance);\n\n    // Quick launches\n    _setupRole(MINTER_ROLE, minter);\n  }\n\n  /// @dev Hint to compiler, that this override has already occured.\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n}\n"
    },
    "contracts/tokens/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"../external-lib/Counters.sol\";\nimport \"../external-lib/EIP712.sol\";\nimport \"./interfaces/IERC20Permit.sol\";\n\n/**\n * @dev Wrapper implementation for ERC20 Permit extension allowing approvals\n * via signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612.\n */\ncontract ERC20PermitUpgradeable is\n  IERC20Permit,\n  Initializable,\n  ERC20Upgradeable\n{\n  using Counters for Counters.Counter;\n\n  bytes32 private constant PERMIT_TYPEHASH =\n    keccak256(\n      \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n  bytes32 internal _domainSeparator;\n\n  mapping(address => Counters.Counter) private _nonces;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __ERC20Permit_init_unchained(\n    string memory domainName,\n    string memory version\n  ) internal initializer {\n    _domainSeparator = EIP712.domainSeparatorV4(domainName, version);\n  }\n\n  /// @inheritdoc IERC20Permit\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR()\n    external\n    view\n    override(IERC20Permit)\n    returns (bytes32)\n  {\n    return _domainSeparator;\n  }\n\n  /**\n   * @dev See {IERC20Permit-permit}.\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override(IERC20Permit) {\n    // solhint-disable-next-line not-rely-on-time\n    require(block.timestamp <= deadline, \"ERC20Permit/ExpiredDeadline\");\n\n    bytes32 structHash =\n      keccak256(\n        abi.encode(\n          PERMIT_TYPEHASH,\n          owner,\n          spender,\n          value,\n          _useNonce(owner),\n          deadline\n        )\n      );\n\n    bytes32 hash = EIP712.hashTypedDataV4(_domainSeparator, structHash);\n\n    address signer = ECDSA.recover(hash, v, r, s);\n    require(signer == owner, \"ERC20Permit/InvalidSignature\");\n\n    _approve(owner, spender, value);\n  }\n\n  /// @inheritdoc IERC20Permit\n  function nonces(address owner)\n    external\n    view\n    virtual\n    override(IERC20Permit)\n    returns (uint256)\n  {\n    return _nonces[owner].current();\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n   */\n  function _useNonce(address owner) internal virtual returns (uint256 current) {\n    Counters.Counter storage nonce = _nonces[owner];\n    current = nonce.current();\n    nonce.increment();\n  }\n\n  uint256[48] private __gap;\n}\n"
    },
    "contracts/tokens/ERC20SupplyControlledUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title {ERC20} Supply Controlled token that allows burning (by all), and minting\n * by MINTER_ROLE\n *\n * @dev This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions using the different roles.\n */\nabstract contract ERC20SupplyControlledUpgradeable is\n  Initializable,\n  AccessControlUpgradeable,\n  ERC20Upgradeable\n{\n  using SafeMath for uint256;\n\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __ERC20SupplyControlled_init_unchained(address minter)\n    internal\n    initializer\n  {\n    _setupRole(MINTER_ROLE, minter);\n  }\n\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `MINTER_ROLE`.\n   */\n  function mint(address to, uint256 amount) external virtual {\n    require(\n      hasRole(MINTER_ROLE, _msgSender()),\n      \"ERC20SupplyControlled/MinterRole\"\n    );\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from the caller.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burn(uint256 amount) external virtual {\n    _burn(_msgSender(), amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have allowance for `accounts`'s tokens of at least\n   * `amount`.\n   */\n  function burnFrom(address account, uint256 amount) external virtual {\n    uint256 decreasedAllowance =\n      allowance(account, _msgSender()).sub(\n        amount,\n        \"ERC20SupplyControlled/Overburn\"\n      );\n\n    _approve(account, _msgSender(), decreasedAllowance);\n    _burn(account, amount);\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/external-lib/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs) https://github.com/OpenZeppelin/openzeppelin-contracts\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    counter._value += 1;\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    counter._value = value - 1;\n  }\n}\n"
    },
    "contracts/external-lib/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"./ECDSA.sol\";\n\n// Based on OpenZeppelin's draft EIP712, with updates to remove storage variables.\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n */\nlibrary EIP712 {\n  bytes32 private constant _TYPE_HASH =\n    keccak256(\n      \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n   */\n  function domainSeparatorV4(string memory name, string memory version)\n    internal\n    view\n    returns (bytes32)\n  {\n    return\n      _buildDomainSeparator(\n        _TYPE_HASH,\n        keccak256(bytes(name)),\n        keccak256(bytes(version))\n      );\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 name,\n    bytes32 version\n  ) private view returns (bytes32) {\n    uint256 chainId;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      chainId := chainid()\n    }\n    return\n      keccak256(abi.encode(typeHash, name, version, chainId, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n   * function returns the hash of the fully encoded EIP712 message for the given domain.\n   *\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n   *\n   * ```solidity\n   * bytes32 digest = EIP712.hashTypedDataV4(\n   *   EIP712.domainSeparatorV4(\"DApp Name\", \"1\"),\n   *   keccak256(abi.encode(\n   *     keccak256(\"Mail(address to,string contents)\"),\n   *     mailTo,\n   *     keccak256(bytes(mailContents))\n   * )));\n   * address signer = ECDSA.recover(digest, signature);\n   * ```\n   */\n  function hashTypedDataV4(bytes32 domainSeparator, bytes32 structHash)\n    internal\n    pure\n    returns (bytes32)\n  {\n    return ECDSA.toTypedDataHash(domainSeparator, structHash);\n  }\n}\n"
    },
    "contracts/tokens/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n   * given ``owner``'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612.\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/external-lib/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature`. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   */\n  function recover(bytes32 hash, bytes memory signature)\n    internal\n    pure\n    returns (address)\n  {\n    // Divide the signature in r, s and v variables\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n\n    // Check the signature length\n    // - case 65: r,s,v signature (standard)\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n    if (signature.length == 65) {\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n    } else if (signature.length == 64) {\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        let vs := mload(add(signature, 0x40))\n        r := mload(add(signature, 0x20))\n        s := and(\n          vs,\n          0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        )\n        v := add(shr(255, vs), 27)\n      }\n    } else {\n      revert(\"ECDSA: invalid signature length\");\n    }\n\n    return recover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    require(\n      uint256(s) <=\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n      \"ECDSA: invalid signature 's' value\"\n    );\n    require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    require(signer != address(0), \"ECDSA: invalid signature\");\n\n    return signer;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes32 hash)\n    internal\n    pure\n    returns (bytes32)\n  {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return\n      keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\n   * to the one signed with the\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n   * JSON-RPC method as part of EIP-712.\n   *\n   * See {recover}.\n   */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n    internal\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "contracts/tokens/BankToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev {ERC20} BANK token, including:\n * \n * - a minter role that allows for token minting (creation)\n * - a pauser role that allows to stop all token transfers\n *\n * This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions\n * using the different roles.\n * This contract is upgradable.\n */\ncontract BankToken is Initializable, PausableUpgradeable, AccessControlUpgradeable, ERC20Upgradeable {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  /**\n    @notice Construct a BankToken instance\n    @param admin The default role controller, minter and pauser for the contract.\n    @param minter An additional minter (for quick launch of epoch 1).\n   */\n  function initialize(address admin, address minter) public initializer {\n    __ERC20_init(\"Float Bank\", \"BANK\");\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n\n    _setupRole(MINTER_ROLE, admin);\n    _setupRole(MINTER_ROLE, minter);\n    _setupRole(PAUSER_ROLE, admin);\n  }\n\n  /**\n    * @dev Creates `amount` new tokens for `to`.\n    *\n    * See {ERC20-_mint}.\n    *\n    * Requirements:\n    *\n    * - the caller must have the `MINTER_ROLE`.\n    */\n  function mint(address to, uint256 amount) public virtual {\n    require(hasRole(MINTER_ROLE, _msgSender()), \"Bank::mint: must have minter role to mint\");\n    _mint(to, amount);\n  }\n\n  /**\n    * @dev Pauses all token transfers.\n    *\n    * See {ERC20Pausable} and {Pausable-_pause}.\n    *\n    * Requirements:\n    *\n    * - the caller must have the `PAUSER_ROLE`.\n    */\n  function pause() public virtual {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"Bank::pause: must have pauser role to pause\");\n    _pause();\n  }\n\n  /**\n    * @dev Unpauses all token transfers.\n    *\n    * See {ERC20Pausable} and {Pausable-_unpause}.\n    *\n    * Requirements:\n    *\n    * - the caller must have the `PAUSER_ROLE`.\n    */\n  function unpause() public virtual {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"Bank::unpause: must have pauser role to unpause\");\n    _unpause();\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual\n    override(ERC20Upgradeable) {\n      super._beforeTokenTransfer(from, to, amount);\n\n      require(!paused(), \"ERC20Pausable: token transfer while paused\");\n  }\n}"
    },
    "contracts/tokens/BankTokenV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\nimport \"../lib/Upgradeable.sol\";\nimport \"./ERC20PermitUpgradeable.sol\";\nimport \"./ERC20PausableUpgradeable.sol\";\nimport \"./ERC20SupplyControlledUpgradeable.sol\";\n\n/**\n * @dev {ERC20} BANK token, including:\n *\n * - a minter role that allows for token minting (necessary for stabilisation)\n * - the ability to burn tokens (necessary for stabilisation)\n * - the use of permits to reduce gas costs\n * - a pauser role that allows to stop all token transfers\n *\n * This contract uses OpenZeppelin {AccessControlUpgradeable} to lock permissioned functions\n * using the different roles.\n * This contract is upgradable.\n */\ncontract BankTokenV2 is\n  ERC20PausableUpgradeable,\n  ERC20PermitUpgradeable,\n  ERC20SupplyControlledUpgradeable,\n  Upgradeable\n{\n  /**\n   * @notice Construct a brand new BankTokenV2 instance\n   * @param governance The default role controller, minter and pauser for the contract.\n   * @dev We expect minters to be defined after deploy, e.g. AuctionHouse should get minter role\n   */\n  function initialize(address governance) external initializer {\n    _version = 2;\n\n    __Context_init_unchained();\n    __ERC20_init_unchained(\"Float Bank\", \"BANK\");\n    __ERC20Permit_init_unchained(\"Float Protocol: BANK\", \"2\");\n    __ERC20Pausable_init_unchained(governance);\n    __ERC20SupplyControlled_init_unchained(governance);\n    _setupRole(DEFAULT_ADMIN_ROLE, governance);\n  }\n\n  /**\n   * @notice Upgrade from V1, and initialise the relevant \"new\" state\n   * @dev Uses upgradeAndCall in the ProxyAdmin, to call upgradeToAndCall, which will delegatecall this function.\n   * _version keeps this single use\n   * onlyProxyAdmin ensures this only occurs on upgrade\n   */\n  function upgrade() external onlyProxyAdmin {\n    require(_version < 2, \"BankTokenV2/AlreadyUpgraded\");\n    _version = 2;\n    _domainSeparator = EIP712.domainSeparatorV4(\"Float Protocol: BANK\", \"2\");\n  }\n\n  /// @dev Hint to compiler that this override has already occured.\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n}\n"
    },
    "contracts/lib/Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\n/**\n * @title Upgradeable\n * @dev This contract provides special helper functions when using the upgradeability proxy.\n */\nabstract contract Upgradeable {\n  uint256 internal _version;\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n   */\n  bytes32 internal constant ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier onlyProxyAdmin() {\n    address proxyAdmin;\n    bytes32 slot = ADMIN_SLOT;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      proxyAdmin := sload(slot)\n    }\n    require(msg.sender == proxyAdmin, \"Upgradeable/MustBeProxyAdmin\");\n    _;\n  }\n}\n"
    },
    "contracts/lib/mock/BasisMathMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../BasisMath.sol\";\n\ncontract BasisMathMock {\n  using BasisMath for uint256;\n\n  function _splitBy(uint256 value, uint256 percentage)\n    public\n    pure\n    returns (uint256, uint256)\n  {\n    return value.splitBy(percentage);\n  }\n}\n"
    },
    "contracts/external-lib/zapper/ZapBaseV1.sol": {
      "content": "// \n// \n// \n// \n// \n// \n// Copyright (C) 2021 zapper\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 2 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n\n///@author Zapper\n// SPDX-License-Identifier: GPLv2\n\n// Changes:\n// - Conversion to 0.7.6\n//   - library imports throughout\n//   - remove revert fallback as now default\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\npragma solidity ^0.7.6;\n\ncontract ZapBaseV1 is Ownable {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  bool public stopped = false;\n\n  // if true, goodwill is not deducted\n  mapping(address => bool) public feeWhitelist;\n\n  uint256 public goodwill;\n  // % share of goodwill (0-100 %)\n  uint256 affiliateSplit;\n  // restrict affiliates\n  mapping(address => bool) public affiliates;\n  // affiliate => token => amount\n  mapping(address => mapping(address => uint256)) public affiliateBalance;\n  // token => amount\n  mapping(address => uint256) public totalAffiliateBalance;\n\n  address internal constant ETHAddress =\n    0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  constructor(uint256 _goodwill, uint256 _affiliateSplit) {\n    goodwill = _goodwill;\n    affiliateSplit = _affiliateSplit;\n  }\n\n  // circuit breaker modifiers\n  modifier stopInEmergency {\n    if (stopped) {\n      revert(\"Temporarily Paused\");\n    } else {\n      _;\n    }\n  }\n\n  function _getBalance(address token) internal view returns (uint256 balance) {\n    if (token == address(0)) {\n      balance = address(this).balance;\n    } else {\n      balance = IERC20(token).balanceOf(address(this));\n    }\n  }\n\n  function _approveToken(address token, address spender) internal {\n    IERC20 _token = IERC20(token);\n    if (_token.allowance(address(this), spender) > 0) return;\n    else {\n      _token.safeApprove(spender, uint256(-1));\n    }\n  }\n\n  function _approveToken(\n    address token,\n    address spender,\n    uint256 amount\n  ) internal {\n    IERC20 _token = IERC20(token);\n    _token.safeApprove(spender, 0);\n    _token.safeApprove(spender, amount);\n  }\n\n  // - to Pause the contract\n  function toggleContractActive() public onlyOwner {\n    stopped = !stopped;\n  }\n\n  function set_feeWhitelist(address zapAddress, bool status)\n    external\n    onlyOwner\n  {\n    feeWhitelist[zapAddress] = status;\n  }\n\n  function set_new_goodwill(uint256 _new_goodwill) public onlyOwner {\n    require(\n      _new_goodwill >= 0 && _new_goodwill <= 100,\n      \"GoodWill Value not allowed\"\n    );\n    goodwill = _new_goodwill;\n  }\n\n  function set_new_affiliateSplit(uint256 _new_affiliateSplit)\n    external\n    onlyOwner\n  {\n    require(_new_affiliateSplit <= 100, \"Affiliate Split Value not allowed\");\n    affiliateSplit = _new_affiliateSplit;\n  }\n\n  function set_affiliate(address _affiliate, bool _status) external onlyOwner {\n    affiliates[_affiliate] = _status;\n  }\n\n  ///@notice Withdraw goodwill share, retaining affilliate share\n  function withdrawTokens(address[] calldata tokens) external onlyOwner {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      uint256 qty;\n\n      if (tokens[i] == ETHAddress) {\n        qty = address(this).balance.sub(totalAffiliateBalance[tokens[i]]);\n        Address.sendValue(payable(owner()), qty);\n      } else {\n        qty = IERC20(tokens[i]).balanceOf(address(this)).sub(\n          totalAffiliateBalance[tokens[i]]\n        );\n        IERC20(tokens[i]).safeTransfer(owner(), qty);\n      }\n    }\n  }\n\n  ///@notice Withdraw affilliate share, retaining goodwill share\n  function affilliateWithdraw(address[] calldata tokens) external {\n    uint256 tokenBal;\n    for (uint256 i = 0; i < tokens.length; i++) {\n      tokenBal = affiliateBalance[msg.sender][tokens[i]];\n      affiliateBalance[msg.sender][tokens[i]] = 0;\n      totalAffiliateBalance[tokens[i]] = totalAffiliateBalance[tokens[i]].sub(\n        tokenBal\n      );\n\n      if (tokens[i] == ETHAddress) {\n        Address.sendValue(msg.sender, tokenBal);\n      } else {\n        IERC20(tokens[i]).safeTransfer(msg.sender, tokenBal);\n      }\n    }\n  }\n}\n"
    },
    "contracts/external-lib/zapper/ZapInBaseV2.sol": {
      "content": "// \n// \n// \n// \n// \n// \n// Copyright (C) 2021 zapper\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 2 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n\n///@author Zapper\n// SPDX-License-Identifier: GPLv2\n\n// Changes:\n// - Conversion to 0.7.6\n//   - abstract type\n//   - library imports throughout\n\npragma solidity ^0.7.6;\n\nimport \"./ZapBaseV1.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nabstract contract ZapInBaseV2 is ZapBaseV1 {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  function _pullTokens(\n    address token,\n    uint256 amount,\n    address affiliate,\n    bool enableGoodwill,\n    bool shouldSellEntireBalance\n  ) internal returns (uint256 value) {\n    uint256 totalGoodwillPortion;\n\n    if (token == address(0)) {\n      require(msg.value > 0, \"No eth sent\");\n\n      // subtract goodwill\n      totalGoodwillPortion = _subtractGoodwill(\n        ETHAddress,\n        msg.value,\n        affiliate,\n        enableGoodwill\n      );\n\n      return msg.value.sub(totalGoodwillPortion);\n    }\n    require(amount > 0, \"Invalid token amount\");\n    require(msg.value == 0, \"Eth sent with token\");\n\n    //transfer token\n    if (shouldSellEntireBalance) {\n      require(\n        Address.isContract(msg.sender),\n        \"ERR: shouldSellEntireBalance is true for EOA\"\n      );\n      amount = IERC20(token).allowance(msg.sender, address(this));\n    }\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n    // subtract goodwill\n    totalGoodwillPortion = _subtractGoodwill(\n      token,\n      amount,\n      affiliate,\n      enableGoodwill\n    );\n\n    return amount.sub(totalGoodwillPortion);\n  }\n\n  function _subtractGoodwill(\n    address token,\n    uint256 amount,\n    address affiliate,\n    bool enableGoodwill\n  ) internal returns (uint256 totalGoodwillPortion) {\n    bool whitelisted = feeWhitelist[msg.sender];\n    if (enableGoodwill && !whitelisted && goodwill > 0) {\n      totalGoodwillPortion = SafeMath.div(\n        SafeMath.mul(amount, goodwill),\n        10000\n      );\n\n      if (affiliates[affiliate]) {\n        if (token == address(0)) {\n          token = ETHAddress;\n        }\n\n        uint256 affiliatePortion =\n          totalGoodwillPortion.mul(affiliateSplit).div(100);\n        affiliateBalance[affiliate][token] = affiliateBalance[affiliate][token]\n          .add(affiliatePortion);\n        totalAffiliateBalance[token] = totalAffiliateBalance[token].add(\n          affiliatePortion\n        );\n      }\n    }\n  }\n}\n"
    },
    "contracts/auxiliary/FloatMintingCeremony_ZapIn.sol": {
      "content": "// \n// \n// \n// \n// \n// \n// Copyright (C) 2021 zapper\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 2 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n\n///@author Zapper\n// SPDX-License-Identifier: GPLv2\n\n// Changes:\n// - Uses msg.sender / removes the transfer from the zap contract.\n// - Uses IMintingCeremony over IVault\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../funds/interfaces/IMintingCeremony.sol\";\nimport \"../external-lib/zapper/ZapInBaseV2.sol\";\n\ncontract FloatMintingCeremonyZapInV1 is ZapInBaseV2 {\n  using SafeMath for uint256;\n\n  // calldata only accepted for approved zap contracts\n  mapping(address => bool) public approvedTargets;\n\n  event zapIn(address sender, address pool, uint256 tokensRec);\n\n  constructor(uint256 _goodwill, uint256 _affiliateSplit)\n    ZapBaseV1(_goodwill, _affiliateSplit)\n  {}\n\n  /**\n    @notice This function commits to the Float Minting Ceremony with ETH or ERC20 tokens\n    @param fromToken The token used for entry (address(0) if ether)\n    @param amountIn The amount of fromToken to invest\n    @param ceremony Float Protocol: Minting Ceremony address\n    @param minFloatTokens The minimum acceptable quantity Float tokens to receive. Reverts otherwise\n    @param intermediateToken Token to swap fromToken to before entering ceremony\n    @param swapTarget Excecution target for the swap or zap\n    @param swapData DEX or Zap data\n    @param affiliate Affiliate address\n    @return tokensReceived - Quantity of FLOAT that will be received\n     */\n  function ZapIn(\n    address fromToken,\n    uint256 amountIn,\n    address ceremony,\n    uint256 minFloatTokens,\n    address intermediateToken,\n    address swapTarget,\n    bytes calldata swapData,\n    address affiliate,\n    bool shouldSellEntireBalance\n  ) external payable stopInEmergency returns (uint256 tokensReceived) {\n    require(\n      approvedTargets[swapTarget] || swapTarget == address(0),\n      \"Target not Authorized\"\n    );\n\n    // get incoming tokens\n    uint256 toInvest =\n      _pullTokens(\n        fromToken,\n        amountIn,\n        affiliate,\n        true,\n        shouldSellEntireBalance\n      );\n\n    // get intermediate token\n    uint256 intermediateAmt =\n      _fillQuote(fromToken, intermediateToken, toInvest, swapTarget, swapData);\n\n    // Deposit to Minting Ceremony\n    tokensReceived = _ceremonyCommit(intermediateAmt, ceremony, minFloatTokens);\n  }\n\n  function _ceremonyCommit(\n    uint256 amount,\n    address toCeremony,\n    uint256 minTokensRec\n  ) internal returns (uint256 tokensReceived) {\n    address underlyingVaultToken = IMintingCeremony(toCeremony).underlying();\n\n    _approveToken(underlyingVaultToken, toCeremony);\n\n    uint256 initialBal = IERC20(toCeremony).balanceOf(msg.sender);\n    IMintingCeremony(toCeremony).commit(msg.sender, amount, minTokensRec);\n    tokensReceived = IERC20(toCeremony).balanceOf(msg.sender).sub(initialBal);\n    require(tokensReceived >= minTokensRec, \"Err: High Slippage\");\n\n    // Note that tokens are gifted directly, so we don't transfer from vault.\n    // IERC20(toCeremony).safeTransfer(msg.sender, tokensReceived);\n    emit zapIn(msg.sender, toCeremony, tokensReceived);\n  }\n\n  function _fillQuote(\n    address _fromTokenAddress,\n    address toToken,\n    uint256 _amount,\n    address _swapTarget,\n    bytes memory swapCallData\n  ) internal returns (uint256 amtBought) {\n    uint256 valueToSend;\n\n    if (_fromTokenAddress == toToken) {\n      return _amount;\n    }\n\n    if (_fromTokenAddress == address(0)) {\n      valueToSend = _amount;\n    } else {\n      _approveToken(_fromTokenAddress, _swapTarget);\n    }\n\n    uint256 iniBal = _getBalance(toToken);\n    (bool success, ) = _swapTarget.call{value: valueToSend}(swapCallData);\n    require(success, \"Error Swapping Tokens 1\");\n    uint256 finalBal = _getBalance(toToken);\n\n    amtBought = finalBal.sub(iniBal);\n  }\n\n  function setApprovedTargets(\n    address[] calldata targets,\n    bool[] calldata isApproved\n  ) external onlyOwner {\n    require(targets.length == isApproved.length, \"Invalid Input length\");\n\n    for (uint256 i = 0; i < targets.length; i++) {\n      approvedTargets[targets[i]] = isApproved[i];\n    }\n  }\n}\n"
    },
    "contracts/oracle/Twap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.7.6;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../external-lib/UniswapV2Library.sol\";\nimport \"../external-lib/UniswapV2OracleLibrary.sol\";\nimport \"../lib/SushiswapLibrary.sol\";\n\nimport \"./interfaces/ITwap.sol\";\n\n// As these are \"Time\"-Weighted Average Price contracts, they necessarily rely on time.\n// solhint-disable not-rely-on-time\n\n/**\n * @title A sliding window for AMMs (specifically Sushiswap)\n * @notice Uses observations collected over a window to provide moving price averages in the past\n * @dev This is a singleton TWAP that only needs to be deployed once per desired parameters. `windowSize` has a precision of `windowSize / granularity`\n * Errors:\n * MissingPastObsr   - We do not have suffient past observations.\n * UnexpectedElapsed - We have an unexpected time elapsed.\n * EarlyUpdate       - Tried to update the TWAP before the period has elapsed.\n * InvalidToken      - Cannot consult an invalid token pair.\n */\ncontract Twap is ITwap {\n  using FixedPoint for *;\n  using SafeMath for uint256;\n\n  struct Observation {\n    uint256 timestamp;\n    uint256 price0Cumulative;\n    uint256 price1Cumulative;\n  }\n\n  /* ========== IMMUTABLE VARIABLES ========== */\n\n  /// @notice the Uniswap Factory contract for tracking exchanges\n  address public immutable factory;\n\n  /// @notice The desired amount of time over which the moving average should be computed, e.g. 24 hours\n  uint256 public immutable windowSize;\n\n  /// @notice The number of observations stored for each pair, i.e. how many price observations are stored for the window\n  /// @dev As granularity increases from, more frequent updates are needed; but precision increases [`windowSize - (windowSize / granularity) * 2`, `windowSize`]\n  uint8 public immutable granularity;\n\n  /// @dev Redundant with `granularity` and `windowSize`, but has gas savings & easy read\n  uint256 public immutable periodSize;\n\n  /* ========== STATE VARIABLES ========== */\n\n  /// @notice Mapping from pair address to a list of price observations of that pair\n  mapping(address => Observation[]) public pairObservations;\n\n  /* ========== EVENTS ========== */\n\n  event NewObservation(\n    uint256 timestamp,\n    uint256 price0Cumulative,\n    uint256 price1Cumulative\n  );\n\n  /* ========== CONSTRUCTOR ========== */\n\n  /**\n   * @notice Construct a new Sliding Window TWAP\n   * @param factory_ The AMM factory\n   * @param windowSize_ The window size for this TWAP\n   * @param granularity_ The granularity required for the TWAP\n   */\n  constructor(\n    address factory_,\n    uint256 windowSize_,\n    uint8 granularity_\n  ) {\n    require(factory_ != address(0), \"Twap/InvalidFactory\");\n    require(granularity_ > 1, \"Twap/Granularity\");\n    require(\n      (periodSize = windowSize_ / granularity_) * granularity_ == windowSize_,\n      \"Twap/WindowSize\"\n    );\n    factory = factory_;\n    windowSize = windowSize_;\n    granularity = granularity_;\n  }\n\n  /* ========== PURE ========== */\n\n  /**\n   * @notice Given the cumulative prices of the start and end of a period, and the length of the period, compute the average price in terms of the amount in\n   * @param priceCumulativeStart the cumulative price for the start of the period\n   * @param priceCumulativeEnd the cumulative price for the end of the period\n   * @param timeElapsed the time from now to the first observation\n   * @param amountIn the amount of tokens in\n   * @return amountOut amount out received for the amount in\n   */\n  function _computeAmountOut(\n    uint256 priceCumulativeStart,\n    uint256 priceCumulativeEnd,\n    uint256 timeElapsed,\n    uint256 amountIn\n  ) private pure returns (uint256 amountOut) {\n    // overflow is desired.\n    FixedPoint.uq112x112 memory priceAverage =\n      FixedPoint.uq112x112(\n        uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n      );\n    amountOut = priceAverage.mul(amountIn).decode144();\n  }\n\n  /* ========== VIEWS ========== */\n\n  /**\n   * @notice Calculates the index of the observation for the given `timestamp`\n   * @param timestamp the observation for the timestamp\n   * @return index The index of the observation\n   */\n  function observationIndexOf(uint256 timestamp)\n    public\n    view\n    returns (uint8 index)\n  {\n    uint256 epochPeriod = timestamp / periodSize;\n    return uint8(epochPeriod % granularity);\n  }\n\n  /// @inheritdoc ITwap\n  function updateable(address tokenA, address tokenB)\n    external\n    view\n    override(ITwap)\n    returns (bool)\n  {\n    address pair = SushiswapLibrary.pairFor(factory, tokenA, tokenB);\n\n    uint8 observationIndex = observationIndexOf(block.timestamp);\n    Observation storage observation = pairObservations[pair][observationIndex];\n\n    // We only want to commit updates once per period (i.e. windowSize / granularity).\n    uint256 timeElapsed = block.timestamp - observation.timestamp;\n\n    return timeElapsed > periodSize;\n  }\n\n  /// @inheritdoc ITwap\n  function consult(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut\n  ) external view override(ITwap) returns (uint256 amountOut) {\n    address pair = SushiswapLibrary.pairFor(factory, tokenIn, tokenOut);\n    Observation storage firstObservation = _getFirstObservationInWindow(pair);\n\n    uint256 timeElapsed = block.timestamp - firstObservation.timestamp;\n    require(timeElapsed <= windowSize, \"Twap/MissingPastObsr\");\n    require(\n      timeElapsed >= windowSize - periodSize * 2,\n      \"Twap/UnexpectedElapsed\"\n    );\n\n    (uint256 price0Cumulative, uint256 price1Cumulative, ) =\n      UniswapV2OracleLibrary.currentCumulativePrices(pair);\n    (address token0, address token1) =\n      UniswapV2Library.sortTokens(tokenIn, tokenOut);\n\n    if (token0 == tokenIn) {\n      return\n        _computeAmountOut(\n          firstObservation.price0Cumulative,\n          price0Cumulative,\n          timeElapsed,\n          amountIn\n        );\n    }\n\n    require(token1 == tokenIn, \"Twap/InvalidToken\");\n\n    return\n      _computeAmountOut(\n        firstObservation.price1Cumulative,\n        price1Cumulative,\n        timeElapsed,\n        amountIn\n      );\n  }\n\n  /**\n   * @notice Observation from the oldest epoch (at the beginning of the window) relative to the current time\n   * @param pair the Uniswap pair address\n   * @return firstObservation The observation from the oldest epoch relative to current time.\n   */\n  function _getFirstObservationInWindow(address pair)\n    private\n    view\n    returns (Observation storage firstObservation)\n  {\n    uint8 observationIndex = observationIndexOf(block.timestamp);\n    // No overflow issues; if observationIndex + 1 overflows, result is still zero.\n    uint8 firstObservationIndex = (observationIndex + 1) % granularity;\n    firstObservation = pairObservations[pair][firstObservationIndex];\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /// @inheritdoc ITwap\n  function update(address tokenA, address tokenB)\n    external\n    override(ITwap)\n    returns (bool)\n  {\n    address pair = SushiswapLibrary.pairFor(factory, tokenA, tokenB);\n\n    // Populate the array with empty observations for the first call.\n    for (uint256 i = pairObservations[pair].length; i < granularity; i++) {\n      pairObservations[pair].push();\n    }\n\n    // Get the observation for the current period.\n    uint8 observationIndex = observationIndexOf(block.timestamp);\n    Observation storage observation = pairObservations[pair][observationIndex];\n\n    // We only want to commit updates once per period (i.e. windowSize / granularity).\n    uint256 timeElapsed = block.timestamp - observation.timestamp;\n\n    if (timeElapsed <= periodSize) {\n      // Skip update as we're in the same observation slot.\n      return false;\n    }\n\n    (uint256 price0Cumulative, uint256 price1Cumulative, ) =\n      UniswapV2OracleLibrary.currentCumulativePrices(pair);\n    observation.timestamp = block.timestamp;\n    observation.price0Cumulative = price0Cumulative;\n    observation.price1Cumulative = price1Cumulative;\n\n    emit NewObservation(\n      observation.timestamp,\n      observation.price0Cumulative,\n      observation.price1Cumulative\n    );\n\n    return true;\n  }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "pragma solidity >=0.4.0;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n}\n"
    },
    "contracts/external-lib/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary UniswapV2Library {\n  using SafeMath for uint256;\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1, ) =\n      IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n    (reserveA, reserveB) = tokenA == token0\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n  }\n\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) internal pure returns (uint256 amountB) {\n    require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n    require(\n      reserveA > 0 && reserveB > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    amountB = amountA.mul(reserveB) / reserveA;\n  }\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 amountInWithFee = amountIn.mul(997);\n    uint256 numerator = amountInWithFee.mul(reserveOut);\n    uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n    uint256 denominator = reserveOut.sub(amountOut).mul(997);\n    amountIn = (numerator / denominator).add(1);\n  }\n\n  // performs chained getAmountOut calculations on any number of pairs\n  function getAmountsOut(\n    address factory,\n    uint256 amountIn,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[0] = amountIn;\n    for (uint256 i; i < path.length - 1; i++) {\n      (uint256 reserveIn, uint256 reserveOut) =\n        getReserves(factory, path[i], path[i + 1]);\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    address factory,\n    uint256 amountOut,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) =\n        getReserves(factory, path[i - 1], path[i]);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n"
    },
    "contracts/external-lib/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n  using FixedPoint for *;\n\n  // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n  function currentBlockTimestamp() internal view returns (uint32) {\n    return uint32(block.timestamp % 2**32);\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  function currentCumulativePrices(address pair)\n    internal\n    view\n    returns (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    )\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) =\n      IUniswapV2Pair(pair).getReserves();\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative +=\n        uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed;\n      // counterfactual\n      price1Cumulative +=\n        uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed;\n    }\n  }\n}\n"
    },
    "contracts/lib/SushiswapLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../external-lib/UniswapV2Library.sol\";\n\nlibrary SushiswapLibrary {\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) =\n      UniswapV2Library.sortTokens(tokenA, tokenB);\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\" // init code hash\n          )\n        )\n      )\n    );\n  }\n}\n"
    },
    "contracts/policy/mock/MonetaryPolicyV1Harness.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../MonetaryPolicyV1.sol\";\n\ncontract MonetaryPolicyV1Harness is MonetaryPolicyV1 {\n  uint256 public blockNumber;\n\n  constructor(address _governance, address _ethUsdOracle)\n    MonetaryPolicyV1(_governance, _ethUsdOracle)\n  {}\n\n  function _blockNumber() internal view override returns (uint256) {\n    return blockNumber;\n  }\n\n  function __setBlock(uint256 _number) external {\n    blockNumber = _number;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}