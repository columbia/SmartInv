{"SafeMath.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c \u003e= a, \u0027SafeMath:INVALID_ADD\u0027);\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b \u003c= a, \u0027SafeMath:OVERFLOW_SUB\u0027);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b, uint decimal) internal pure returns (uint) {\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"SafeMath: multiple overflow\");\r\n        uint c1 = c0 + (dc / 2);\r\n        require(c1 \u003e= c0, \"SafeMath: multiple overflow\");\r\n        uint c2 = c1 / dc;\r\n        return c2;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, uint decimal) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * dc;\r\n        require(a == 0 || c0 / a == dc, \"SafeMath: division internal\");\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 \u003e= c0, \"SafeMath: division internal\");\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n}\r\n"},"TransferHelper.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes(\u0027approve(address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\r\n            \u0027TransferHelper::safeApprove: approve failed\u0027\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\r\n            \u0027TransferHelper::safeTransfer: transfer failed\u0027\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes(\u0027transferFrom(address,address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\r\n            \u0027TransferHelper::transferFrom: transferFrom failed\u0027\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \u0027TransferHelper::safeTransferETH: ETH transfer failed\u0027);\r\n    }\r\n}\r\n"},"TubeChiefV2.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\nimport \u0027./TransferHelper.sol\u0027;\r\nimport \u0027./SafeMath.sol\u0027;\r\n\r\ncontract TubeChiefV2 {\r\n    using SafeMath for uint;\r\n\r\n    struct PoolInfo {\r\n        address lpTokenAddress;  // the LP token pair address\r\n        uint rewardPerBlock;     // number of TUBE will mint per block\r\n        uint lastDevBlockNo;     // record token mint to development last block number\r\n        uint lastLotBlockNo;     // record token mint to lottery last block number\r\n        uint lastStakeBlockNo;   // record token mint to staking last block number\r\n        uint lastJackpotBlockNo; // record token mint to jackpot last block number\r\n        uint accLpStaked;        // accumulate number of LP token user staked\r\n        uint accLastBlockNo;     // record last pass in block number\r\n        uint multiplier;         // reward multiplier\r\n        uint accTokenPerShare;   // accumulated token per share\r\n        bool locked;             // pool is locked\r\n        bool finished;           // pool is finished. Disable stake into pool\r\n    }\r\n\r\n    struct UserPoolInfo {\r\n        uint lpStaked;       // user staked LP\r\n        uint rewardDebt;     // user debt\r\n        uint lastClaimBlock; // last block number user retrieve reward\r\n    }\r\n\r\n    mapping(uint =\u003e PoolInfo) public pools; // dynamic pool container (pool ID =\u003e pool related data)\r\n    mapping(address =\u003e uint[]) poolIdByLp;  // pool ids recorder (LP token =\u003e pool ids)\r\n\r\n    // user pool allocate (user addr =\u003e (\u003cpool ID\u003e =\u003e user pool data))\r\n    mapping(address =\u003e mapping(uint =\u003e UserPoolInfo)) public users;\r\n    \r\n    // allow to manage defarm operation\r\n    mapping(address =\u003e bool) public defarm_permission;\r\n\r\n    // allow to manage functional operation\r\n    mapping(address =\u003e bool) public access_permission;\r\n\r\n    address public owner;         // owner of tube chief\r\n    address public tube;          // the TUBE token\r\n    address public devaddr;       // development address\r\n    address public lotaddr;       // lottery address\r\n    address public dfstakeaddr;   // sub staking address\r\n    address public dfjackpotaddr; // sub jackpot address\r\n    address public treasury;      // minting purpose. treasury or TUBE token\r\n    \r\n    uint public poolLength; // next pool id. current length is (poolLength - 1)\r\n\r\n    uint public FARMER    = 500000000000000000;\r\n    uint public DEV       = 100000000000000000;\r\n    uint public LOTTERY   = 150000000000000000;\r\n    uint public DFSTAKE   = 25000000000000000;\r\n    uint public DFJACKPOT = 225000000000000000;\r\n    \r\n    uint constant DECIMAL = 18;\r\n\r\n    event CreatePool(address lpTokenAddress, uint rewardPerBlock, uint poolId);\r\n    event UpdatePool(uint poolId, uint rewardPerBlock, uint multiplier, bool locked);\r\n    event UpdateDevAddr(address devaddr);\r\n    event UpdateLotAddr(address lotaddr);\r\n    event UpdateDefarmAddress(address dfstakeaddr, address dfjackpotaddr);\r\n    event UpdateAllocation(uint farmer, uint dev, uint lot, uint staking, uint jackpot);\r\n    event UpdateDefarmPermission(address _address, bool status);\r\n    event UpdateAccessPermission(address _address, bool status);\r\n    event UpdateTreasury(address _address);\r\n    event UpdatePoolFinish(uint poolId, bool finished);\r\n    event Stake(uint poolId, uint amount);\r\n    event Claim(uint poolId, uint amount, uint claimable);\r\n    event TransferCompany(address old_owner, address new_owner);\r\n    event TransferDev(uint poolId, address receiver, uint amount);\r\n    event TransferLottery(uint poolId, address receiver, uint amount);\r\n    event TransferStaking(uint poolId, address receiver, uint amount);\r\n    event TransferJackpotReward(address receiver, uint amount);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \u0027NOT OWNER\u0027);\r\n        _;\r\n    }\r\n    \r\n    modifier hasDefarmPermission() {\r\n        require(defarm_permission[msg.sender], \u0027NO DEFARM PERMISSION\u0027);\r\n        _;\r\n    }\r\n\r\n    modifier hasAccessPermission() {\r\n        require(access_permission[msg.sender], \u0027NO ACCESS PERMISSION\u0027);\r\n        _;\r\n    }\r\n\r\n    constructor (address _tube, address _devaddr, address _lotaddr) public {\r\n        owner   = msg.sender;\r\n        tube    = _tube;\r\n        devaddr = _devaddr;\r\n        lotaddr = _lotaddr;\r\n        defarm_permission[msg.sender] = true;\r\n        access_permission[msg.sender] = true;\r\n    }\r\n\r\n    // create new pool. only owner executable\r\n    // XX do not create twice on same LP token. reward will mess up if you do\r\n    function createPool(address _lpTokenAddress, uint _rewardPerBlock, uint _multiplier) public hasAccessPermission {\r\n        require(_lpTokenAddress != address(0), \u0027CREATE_POOL_EMPTY_ADDRESS\u0027);\r\n\r\n        emit CreatePool(_lpTokenAddress, _rewardPerBlock, poolLength);\r\n        pools[poolLength].lpTokenAddress     = _lpTokenAddress;\r\n        pools[poolLength].rewardPerBlock     = _rewardPerBlock;\r\n        pools[poolLength].multiplier         = _multiplier;\r\n        pools[poolLength].accLastBlockNo     = block.number;\r\n        pools[poolLength].lastDevBlockNo     = block.number;\r\n        pools[poolLength].lastLotBlockNo     = block.number;\r\n        pools[poolLength].lastStakeBlockNo   = block.number;\r\n        pools[poolLength].lastJackpotBlockNo = block.number;\r\n        poolIdByLp[_lpTokenAddress].push(poolLength);\r\n        poolLength = poolLength.add(1);\r\n    }\r\n\r\n    // update pool setting, edit wisely. only owner executable\r\n    function updatePool(uint poolId, uint _rewardPerBlock, uint _multiplier, bool _locked) public hasAccessPermission {\r\n        _updateAccTokenPerShare(poolId);\r\n        pools[poolId].rewardPerBlock = _rewardPerBlock;\r\n        pools[poolId].multiplier     = _multiplier;\r\n        pools[poolId].locked         = _locked;\r\n        emit UpdatePool(poolId, _rewardPerBlock, _multiplier, _locked);\r\n    }\r\n    \r\n    // update pool is finish. user not allow to stake into pool. only owner executable\r\n    function updatePoolFinish(uint poolId, bool _finished) public hasAccessPermission {\r\n        pools[poolId].finished = _finished;\r\n        emit UpdatePoolFinish(poolId, _finished);\r\n    }\r\n\r\n    // update development address. only owner executable\r\n    function updateDevAddr(address _address) public hasAccessPermission {\r\n        devaddr = _address;\r\n        emit UpdateDevAddr(devaddr);\r\n    }\r\n\r\n    // update lottery address. only owner executable\r\n    function updateLotAddr(address _address) public hasAccessPermission {\r\n        lotaddr = _address;\r\n        emit UpdateLotAddr(lotaddr);\r\n    }\r\n    \r\n    // update defarm addresses. only owner executable\r\n    function updateDefarmAddress(address _dfstakeaddr, address _dfjackpotaddr) public hasAccessPermission {\r\n        dfstakeaddr   = _dfstakeaddr;\r\n        dfjackpotaddr = _dfjackpotaddr;\r\n        emit UpdateDefarmAddress(dfstakeaddr, dfjackpotaddr);\r\n    }\r\n\r\n    // update treasury allow chief mint TUBE token. only owner executable\r\n    function updateTreasury(address _address) public hasAccessPermission {\r\n        treasury = _address;\r\n        emit UpdateTreasury(_address);\r\n    }\r\n\r\n    // update allocation for each sector. only owner executable\r\n    function updateAllocation(uint _farmer, uint _dev, uint _lot, uint _dfstake, uint _dfjackpot) public hasAccessPermission {\r\n        require(_farmer.add(_dev).add(_lot).add(_dfstake).add(_dfjackpot) == 1000000000000000000, \"invalid allocation\");\r\n        FARMER    = _farmer;\r\n        DEV       = _dev;\r\n        LOTTERY   = _lot;\r\n        DFSTAKE   = _dfstake;\r\n        DFJACKPOT = _dfjackpot;\r\n        emit UpdateAllocation(_farmer, _dev, _lot, _dfstake, _dfjackpot);\r\n    }\r\n\r\n    // update defarm permission. only owner executable\r\n    function updateDefarmPermission(address _address, bool status) public onlyOwner {\r\n        defarm_permission[_address] = status;\r\n        emit UpdateDefarmPermission(_address, status);\r\n    }\r\n\r\n    // update access permission. only owner executable\r\n    function updateAccessPermission(address _address, bool status) public onlyOwner {\r\n        access_permission[_address] = status;\r\n        emit UpdateAccessPermission(_address, status);\r\n    }\r\n\r\n    // stake LP token to earn TUBE\r\n    function stake(uint poolId, uint amount) public {\r\n        require(pools[poolId].lpTokenAddress != address(0), \u0027STAKE_POOL_NOT_EXIST\u0027);\r\n        require(pools[poolId].locked == false, \u0027STAKE_POOL_LOCKED\u0027);\r\n        require(pools[poolId].finished == false, \u0027STAKE_POOL_FINISHED\u0027);\r\n\r\n        claim(poolId, 0);\r\n        TransferHelper.safeTransferFrom(pools[poolId].lpTokenAddress, msg.sender, address(this), amount);\r\n        pools[poolId].accLpStaked = pools[poolId].accLpStaked.add(amount);\r\n        users[msg.sender][poolId].lpStaked       = users[msg.sender][poolId].lpStaked.add(amount);\r\n        users[msg.sender][poolId].lastClaimBlock = block.number;\r\n        users[msg.sender][poolId].rewardDebt     = pools[poolId].accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL);\r\n\r\n        emit Stake(poolId, amount);\r\n    }\r\n\r\n    // claim TUBE token. input LP token to exit pool\r\n    function claim(uint poolId, uint amount) public {\r\n        require(pools[poolId].lpTokenAddress != address(0), \u0027CLAIM_POOL_NOT_EXIST\u0027);\r\n        require(pools[poolId].locked == false, \u0027CLAIM_POOL_LOCKED\u0027);\r\n        \r\n        _updateAccTokenPerShare(poolId);\r\n\r\n        uint claimable = _getRewardAmount(poolId);\r\n        if (claimable \u003e 0) {\r\n            IMint(treasury).farmMint(address(this), claimable);\r\n            TransferHelper.safeTransfer(tube, msg.sender, claimable);\r\n            users[msg.sender][poolId].lastClaimBlock = block.number;\r\n        }\r\n\r\n        if (amount \u003e 0) {\r\n            TransferHelper.safeTransfer(pools[poolId].lpTokenAddress, msg.sender, amount);\r\n            users[msg.sender][poolId].lpStaked = users[msg.sender][poolId].lpStaked.sub(amount);\r\n            pools[poolId].accLpStaked = pools[poolId].accLpStaked.sub(amount);\r\n        }\r\n\r\n        // emit if necessary. cost saving\r\n        if (claimable \u003e 0 || amount \u003e 0) {\r\n            emit Claim(poolId, amount, claimable);\r\n        }\r\n\r\n        // update the user reward debt at this moment\r\n        users[msg.sender][poolId].rewardDebt = pools[poolId].accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL);\r\n    }\r\n\r\n    // get token per share with current block number\r\n    function getAccTokenInfo(uint poolId) public view returns (uint) {\r\n        if (pools[poolId].accLpStaked \u003c= 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint reward_block = pools[poolId].rewardPerBlock;\r\n        uint multiplier   = pools[poolId].multiplier;\r\n        uint total_staked = pools[poolId].accLpStaked;\r\n        uint pending      = block.number.sub(pools[poolId].accLastBlockNo);\r\n        pending           = pending * 10**DECIMAL; // cast to \"wei\" unit\r\n        uint result       = reward_block.mul(multiplier, DECIMAL).mul(pending, DECIMAL).mul(FARMER, DECIMAL);\r\n\r\n        return result.div(total_staked, DECIMAL);\r\n    }\r\n\r\n    // emergency collect token from the contract. only owner executable\r\n    function emergencyCollectToken(address token, uint amount) public onlyOwner {\r\n        TransferHelper.safeTransfer(token, owner, amount);\r\n    }\r\n\r\n    // emergency collect eth from the contract. only owner executable\r\n    function emergencyCollectEth(uint amount) public onlyOwner {\r\n        address payable owner_address = payable(owner);\r\n        TransferHelper.safeTransferETH(owner_address, amount);\r\n    }\r\n\r\n    // transfer ownership. proceed wisely. only owner executable\r\n    function transferCompany(address new_owner) public onlyOwner {\r\n        emit TransferCompany(owner, new_owner);\r\n        owner = new_owner;\r\n    }\r\n\r\n    // transfer mintable token to development address\r\n    function transferDev(uint poolId) public hasAccessPermission {\r\n        uint mintable = getExMintable(poolId, keccak256(\"DEV\"));\r\n        require(mintable \u003e 0, \u0027TRANSFER_DEV_EMPTY\u0027);\r\n        require(devaddr != address(0), \u0027EMPTY DEV ADDRESS\u0027);\r\n        IMint(treasury).farmMint(address(this), mintable);\r\n        TransferHelper.safeTransfer(tube, devaddr, mintable);\r\n        pools[poolId].lastDevBlockNo = block.number;\r\n        emit TransferDev(poolId, devaddr, mintable);\r\n    }\r\n\r\n    // transfer mintable token to lottery address\r\n    function transferLottery(uint poolId) public hasAccessPermission {\r\n        uint mintable = getExMintable(poolId, keccak256(\"LOTTERY\"));\r\n        require(mintable \u003e 0, \u0027TRANSFER_LOT_EMPTY\u0027);\r\n        require(lotaddr != address(0), \u0027EMPTY LOTTERY ADDRESS\u0027);\r\n        IMint(treasury).farmMint(address(this), mintable);\r\n        TransferHelper.safeTransfer(tube, lotaddr, mintable);\r\n        pools[poolId].lastLotBlockNo = block.number;\r\n        emit TransferLottery(poolId, lotaddr, mintable);\r\n    }\r\n    \r\n    // transfer mintable token to sub staking\r\n    function transferStaking(uint poolId) public hasDefarmPermission {\r\n        uint mintable = getExMintable(poolId, keccak256(\"STAKING\"));\r\n        require(dfstakeaddr != address(0), \u0027EMPTY DFSTAKE ADDRESS\u0027);\r\n        \r\n        if (mintable \u003e 0) {\r\n            IMint(treasury).farmMint(address(this), mintable);\r\n            TransferHelper.safeTransfer(tube, dfstakeaddr, mintable);\r\n            pools[poolId].lastStakeBlockNo = block.number;\r\n            emit TransferStaking(poolId, dfstakeaddr, mintable);\r\n        }\r\n    }\r\n    \r\n    // transfer mintable token to sub jackpot\r\n    function transferJackpotReward() public hasDefarmPermission returns (uint) {\r\n        require(dfjackpotaddr != address(0), \u0027EMPTY DFJACKPOT ADDRESS\u0027);\r\n        \r\n        uint mintable = getJackpotReward();\r\n\r\n        if (mintable \u003e 0) {\r\n            IMint(treasury).farmMint(address(this), mintable);\r\n            TransferHelper.safeTransfer(tube, dfjackpotaddr, mintable);\r\n            emit TransferJackpotReward(dfjackpotaddr, mintable);\r\n        }\r\n        \r\n        for (uint i = 0; i \u003c= poolLength.sub(1); i++) {\r\n            pools[i].lastJackpotBlockNo = block.number;\r\n        }\r\n        \r\n        return mintable;\r\n    }\r\n\r\n    // retrieve the mintable amount\r\n    function getExMintable(uint poolId, bytes32 category) public view returns (uint) {\r\n        uint last_block   = 0;\r\n        uint rate         = 0;\r\n\r\n        if (category == keccak256(\"DEV\")) {\r\n            last_block = pools[poolId].lastDevBlockNo;\r\n            rate       = DEV;\r\n        } else if (category == keccak256(\"LOTTERY\")) {\r\n            last_block = pools[poolId].lastLotBlockNo;\r\n            rate       = LOTTERY;\r\n        } else if (category == keccak256(\"STAKING\")) {\r\n            last_block = pools[poolId].lastStakeBlockNo;\r\n            rate       = DFSTAKE;\r\n        } else if (category == keccak256(\"JACKPOT\")) {\r\n            last_block = pools[poolId].lastJackpotBlockNo;\r\n            rate       = DFJACKPOT;\r\n        } else {\r\n            last_block = 0;\r\n            rate       = 0;\r\n        }\r\n        \r\n        uint block_diff = block.number.sub(last_block);\r\n        block_diff      = block_diff * 10**DECIMAL;\r\n\r\n        return block_diff.mul(pools[poolId].rewardPerBlock, DECIMAL).mul(pools[poolId].multiplier, DECIMAL).mul(rate, DECIMAL);\r\n    }\r\n    \r\n    // retrieve jackpot reward allocation\r\n    function getJackpotReward() public view returns (uint) {\r\n        uint reward = 0;\r\n        for (uint i = 0; i \u003c= poolLength.sub(1); i++) {\r\n            reward = reward.add(getExMintable(i, keccak256(\"JACKPOT\")));\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    // retrieve pool ids by LP token address\r\n    function getPidByLpToken(address _lpTokenAddress) public view returns (uint[] memory) {\r\n        return poolIdByLp[_lpTokenAddress];\r\n    }\r\n\r\n    // retrieve user reward info on the pool with current block number\r\n    function getUserReward(uint poolId) public view returns (uint, uint, uint, uint, uint) {\r\n        uint accTokenPerShare = getAccTokenInfo(poolId);\r\n        accTokenPerShare      = accTokenPerShare.add(pools[poolId].accTokenPerShare);\r\n        \r\n        uint claimable = accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL).sub(users[msg.sender][poolId].rewardDebt);\r\n        return (block.number, claimable, accTokenPerShare, users[msg.sender][poolId].lpStaked, users[msg.sender][poolId].rewardDebt);\r\n    }\r\n    \r\n    function _updateAccTokenPerShare(uint poolId) internal {\r\n        uint result = getAccTokenInfo(poolId);\r\n        pools[poolId].accTokenPerShare = pools[poolId].accTokenPerShare.add(result);\r\n        pools[poolId].accLastBlockNo   = block.number;\r\n    }\r\n\r\n    function _getRewardAmount(uint poolId) view internal returns (uint) {\r\n        if (pools[poolId].accLpStaked \u003c= 0) {\r\n            return (0);\r\n        }\r\n\r\n        uint user_staked = users[msg.sender][poolId].lpStaked;\r\n        uint user_debt   = users[msg.sender][poolId].rewardDebt;\r\n        uint claimable   = pools[poolId].accTokenPerShare.mul(user_staked, DECIMAL).sub(user_debt);\r\n\r\n        return (claimable);\r\n    }\r\n\r\n    fallback() external payable {\r\n    }\r\n}\r\n\r\ninterface IMint {\r\n    function farmMint(address _address, uint amount) external;\r\n}\r\n"}}