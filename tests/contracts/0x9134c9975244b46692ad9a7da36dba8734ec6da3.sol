{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "details": {
        "constantOptimizer": true,
        "cse": true,
        "deduplicate": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "peephole": true,
        "yul": false
      },
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/persistent/dispatcher/IDispatcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IDispatcher Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IDispatcher {\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function claimOwnership() external;\n\n    function deployVaultProxy(\n        address _vaultLib,\n        address _owner,\n        address _vaultAccessor,\n        string calldata _fundName\n    ) external returns (address vaultProxy_);\n\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\n\n    function getFundDeployerForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (address fundDeployer_);\n\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (\n            address nextFundDeployer_,\n            address nextVaultAccessor_,\n            address nextVaultLib_,\n            uint256 executableTimestamp_\n        );\n\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\n\n    function getNominatedOwner() external view returns (address nominatedOwner_);\n\n    function getOwner() external view returns (address owner_);\n\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\n\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (uint256 secondsRemaining_);\n\n    function hasExecutableMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasExecutableRequest_);\n\n    function hasMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasMigrationRequest_);\n\n    function removeNominatedOwner() external;\n\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\n\n    function setMigrationTimelock(uint256 _nextTimelock) external;\n\n    function setNominatedOwner(address _nextNominatedOwner) external;\n\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\n\n    function signalMigration(\n        address _vaultProxy,\n        address _nextVaultAccessor,\n        address _nextVaultLib,\n        bool _bypassFailure\n    ) external;\n}\n"
    },
    "contracts/persistent/utils/IMigratableVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IMigratableVault Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @dev DO NOT EDIT CONTRACT\ninterface IMigratableVault {\n    function canMigrate(address _who) external view returns (bool canMigrate_);\n\n    function init(\n        address _owner,\n        address _accessor,\n        string calldata _fundName\n    ) external;\n\n    function setAccessor(address _nextAccessor) external;\n\n    function setVaultLib(address _nextVaultLib) external;\n}\n"
    },
    "contracts/persistent/utils/IMigrationHookHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IMigrationHookHandler Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IMigrationHookHandler {\n    enum MigrationOutHook {PreSignal, PostSignal, PreMigrate, PostMigrate, PostCancel}\n\n    function invokeMigrationInCancelHook(\n        address _vaultProxy,\n        address _prevFundDeployer,\n        address _nextVaultAccessor,\n        address _nextVaultLib\n    ) external;\n\n    function invokeMigrationOutHook(\n        MigrationOutHook _hook,\n        address _vaultProxy,\n        address _nextFundDeployer,\n        address _nextVaultAccessor,\n        address _nextVaultLib\n    ) external;\n}\n"
    },
    "contracts/release/core/fund-deployer/FundDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../../persistent/dispatcher/IDispatcher.sol\";\nimport \"../../../persistent/utils/IMigrationHookHandler.sol\";\nimport \"../fund/comptroller/IComptroller.sol\";\nimport \"../fund/comptroller/ComptrollerProxy.sol\";\nimport \"../fund/vault/IVault.sol\";\nimport \"./IFundDeployer.sol\";\n\n/// @title FundDeployer Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The top-level contract of the release.\n/// It primarily coordinates fund deployment and fund migration, but\n/// it is also deferred to for contract access control and for allowed calls\n/// that can be made with a fund's VaultProxy as the msg.sender.\ncontract FundDeployer is IFundDeployer, IMigrationHookHandler {\n    event ComptrollerLibSet(address comptrollerLib);\n\n    event ComptrollerProxyDeployed(\n        address indexed creator,\n        address comptrollerProxy,\n        address indexed denominationAsset,\n        uint256 sharesActionTimelock,\n        bytes feeManagerConfigData,\n        bytes policyManagerConfigData,\n        bool indexed forMigration\n    );\n\n    event NewFundCreated(\n        address indexed creator,\n        address comptrollerProxy,\n        address vaultProxy,\n        address indexed fundOwner,\n        string fundName,\n        address indexed denominationAsset,\n        uint256 sharesActionTimelock,\n        bytes feeManagerConfigData,\n        bytes policyManagerConfigData\n    );\n\n    event ReleaseStatusSet(ReleaseStatus indexed prevStatus, ReleaseStatus indexed nextStatus);\n\n    event VaultCallDeregistered(address indexed contractAddress, bytes4 selector);\n\n    event VaultCallRegistered(address indexed contractAddress, bytes4 selector);\n\n    // Constants\n    address private immutable CREATOR;\n    address private immutable DISPATCHER;\n    address private immutable VAULT_LIB;\n\n    // Pseudo-constants (can only be set once)\n    address private comptrollerLib;\n\n    // Storage\n    ReleaseStatus private releaseStatus;\n    mapping(address => mapping(bytes4 => bool)) private contractToSelectorToIsRegisteredVaultCall;\n    mapping(address => address) private pendingComptrollerProxyToCreator;\n\n    modifier onlyLiveRelease() {\n        require(releaseStatus == ReleaseStatus.Live, \"Release is not Live\");\n        _;\n    }\n\n    modifier onlyMigrator(address _vaultProxy) {\n        require(\n            IVault(_vaultProxy).canMigrate(msg.sender),\n            \"Only a permissioned migrator can call this function\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == getOwner(), \"Only the contract owner can call this function\");\n        _;\n    }\n\n    modifier onlyPendingComptrollerProxyCreator(address _comptrollerProxy) {\n        require(\n            msg.sender == pendingComptrollerProxyToCreator[_comptrollerProxy],\n            \"Only the ComptrollerProxy creator can call this function\"\n        );\n        _;\n    }\n\n    constructor(\n        address _dispatcher,\n        address _vaultLib,\n        address[] memory _vaultCallContracts,\n        bytes4[] memory _vaultCallSelectors\n    ) public {\n        if (_vaultCallContracts.length > 0) {\n            __registerVaultCalls(_vaultCallContracts, _vaultCallSelectors);\n        }\n        CREATOR = msg.sender;\n        DISPATCHER = _dispatcher;\n        VAULT_LIB = _vaultLib;\n    }\n\n    /////////////\n    // GENERAL //\n    /////////////\n\n    /// @notice Sets the comptrollerLib\n    /// @param _comptrollerLib The ComptrollerLib contract address\n    /// @dev Can only be set once\n    function setComptrollerLib(address _comptrollerLib) external onlyOwner {\n        require(\n            comptrollerLib == address(0),\n            \"setComptrollerLib: This value can only be set once\"\n        );\n\n        comptrollerLib = _comptrollerLib;\n\n        emit ComptrollerLibSet(_comptrollerLib);\n    }\n\n    /// @notice Sets the status of the protocol to a new state\n    /// @param _nextStatus The next status state to set\n    function setReleaseStatus(ReleaseStatus _nextStatus) external {\n        require(\n            msg.sender == IDispatcher(DISPATCHER).getOwner(),\n            \"setReleaseStatus: Only the Dispatcher owner can call this function\"\n        );\n        require(\n            _nextStatus != ReleaseStatus.PreLaunch,\n            \"setReleaseStatus: Cannot return to PreLaunch status\"\n        );\n        require(\n            comptrollerLib != address(0),\n            \"setReleaseStatus: Can only set the release status when comptrollerLib is set\"\n        );\n\n        ReleaseStatus prevStatus = releaseStatus;\n        require(_nextStatus != prevStatus, \"setReleaseStatus: _nextStatus is the current status\");\n\n        releaseStatus = _nextStatus;\n\n        emit ReleaseStatusSet(prevStatus, _nextStatus);\n    }\n\n    /// @notice Gets the current owner of the contract\n    /// @return owner_ The contract owner address\n    /// @dev Dynamically gets the owner based on the Protocol status. The owner is initially the\n    /// contract's deployer, for convenience in setting up configuration.\n    /// Ownership is claimed when the owner of the Dispatcher contract (the Enzyme Council)\n    /// sets the releaseStatus to `Live`.\n    function getOwner() public view override returns (address owner_) {\n        if (releaseStatus == ReleaseStatus.PreLaunch) {\n            return CREATOR;\n        }\n\n        return IDispatcher(DISPATCHER).getOwner();\n    }\n\n    ///////////////////\n    // FUND CREATION //\n    ///////////////////\n\n    /// @notice Creates a fully-configured ComptrollerProxy, to which a fund from a previous\n    /// release can migrate in a subsequent step\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\n    /// (buying or selling shares) by the same user\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\n    function createMigratedFundConfig(\n        address _denominationAsset,\n        uint256 _sharesActionTimelock,\n        bytes calldata _feeManagerConfigData,\n        bytes calldata _policyManagerConfigData\n    ) external onlyLiveRelease returns (address comptrollerProxy_) {\n        comptrollerProxy_ = __deployComptrollerProxy(\n            _denominationAsset,\n            _sharesActionTimelock,\n            _feeManagerConfigData,\n            _policyManagerConfigData,\n            true\n        );\n\n        pendingComptrollerProxyToCreator[comptrollerProxy_] = msg.sender;\n\n        return comptrollerProxy_;\n    }\n\n    /// @notice Creates a new fund\n    /// @param _fundOwner The address of the owner for the fund\n    /// @param _fundName The name of the fund\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\n    /// (buying or selling shares) by the same user\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\n    function createNewFund(\n        address _fundOwner,\n        string calldata _fundName,\n        address _denominationAsset,\n        uint256 _sharesActionTimelock,\n        bytes calldata _feeManagerConfigData,\n        bytes calldata _policyManagerConfigData\n    ) external onlyLiveRelease returns (address comptrollerProxy_, address vaultProxy_) {\n        return\n            __createNewFund(\n                _fundOwner,\n                _fundName,\n                _denominationAsset,\n                _sharesActionTimelock,\n                _feeManagerConfigData,\n                _policyManagerConfigData\n            );\n    }\n\n    /// @dev Helper to avoid the stack-too-deep error during createNewFund\n    function __createNewFund(\n        address _fundOwner,\n        string memory _fundName,\n        address _denominationAsset,\n        uint256 _sharesActionTimelock,\n        bytes memory _feeManagerConfigData,\n        bytes memory _policyManagerConfigData\n    ) private returns (address comptrollerProxy_, address vaultProxy_) {\n        require(_fundOwner != address(0), \"__createNewFund: _owner cannot be empty\");\n\n        comptrollerProxy_ = __deployComptrollerProxy(\n            _denominationAsset,\n            _sharesActionTimelock,\n            _feeManagerConfigData,\n            _policyManagerConfigData,\n            false\n        );\n\n        vaultProxy_ = IDispatcher(DISPATCHER).deployVaultProxy(\n            VAULT_LIB,\n            _fundOwner,\n            comptrollerProxy_,\n            _fundName\n        );\n\n        IComptroller(comptrollerProxy_).activate(vaultProxy_, false);\n\n        emit NewFundCreated(\n            msg.sender,\n            comptrollerProxy_,\n            vaultProxy_,\n            _fundOwner,\n            _fundName,\n            _denominationAsset,\n            _sharesActionTimelock,\n            _feeManagerConfigData,\n            _policyManagerConfigData\n        );\n\n        return (comptrollerProxy_, vaultProxy_);\n    }\n\n    /// @dev Helper function to deploy a configured ComptrollerProxy\n    function __deployComptrollerProxy(\n        address _denominationAsset,\n        uint256 _sharesActionTimelock,\n        bytes memory _feeManagerConfigData,\n        bytes memory _policyManagerConfigData,\n        bool _forMigration\n    ) private returns (address comptrollerProxy_) {\n        require(\n            _denominationAsset != address(0),\n            \"__deployComptrollerProxy: _denominationAsset cannot be empty\"\n        );\n\n        bytes memory constructData = abi.encodeWithSelector(\n            IComptroller.init.selector,\n            _denominationAsset,\n            _sharesActionTimelock\n        );\n        comptrollerProxy_ = address(new ComptrollerProxy(constructData, comptrollerLib));\n\n        if (_feeManagerConfigData.length > 0 || _policyManagerConfigData.length > 0) {\n            IComptroller(comptrollerProxy_).configureExtensions(\n                _feeManagerConfigData,\n                _policyManagerConfigData\n            );\n        }\n\n        emit ComptrollerProxyDeployed(\n            msg.sender,\n            comptrollerProxy_,\n            _denominationAsset,\n            _sharesActionTimelock,\n            _feeManagerConfigData,\n            _policyManagerConfigData,\n            _forMigration\n        );\n\n        return comptrollerProxy_;\n    }\n\n    //////////////////\n    // MIGRATION IN //\n    //////////////////\n\n    /// @notice Cancels fund migration\n    /// @param _vaultProxy The VaultProxy for which to cancel migration\n    function cancelMigration(address _vaultProxy) external {\n        __cancelMigration(_vaultProxy, false);\n    }\n\n    /// @notice Cancels fund migration, bypassing any failures.\n    /// Should be used in an emergency only.\n    /// @param _vaultProxy The VaultProxy for which to cancel migration\n    function cancelMigrationEmergency(address _vaultProxy) external {\n        __cancelMigration(_vaultProxy, true);\n    }\n\n    /// @notice Executes fund migration\n    /// @param _vaultProxy The VaultProxy for which to execute the migration\n    function executeMigration(address _vaultProxy) external {\n        __executeMigration(_vaultProxy, false);\n    }\n\n    /// @notice Executes fund migration, bypassing any failures.\n    /// Should be used in an emergency only.\n    /// @param _vaultProxy The VaultProxy for which to execute the migration\n    function executeMigrationEmergency(address _vaultProxy) external {\n        __executeMigration(_vaultProxy, true);\n    }\n\n    /// @dev Unimplemented\n    function invokeMigrationInCancelHook(\n        address,\n        address,\n        address,\n        address\n    ) external virtual override {\n        return;\n    }\n\n    /// @notice Signal a fund migration\n    /// @param _vaultProxy The VaultProxy for which to signal the migration\n    /// @param _comptrollerProxy The ComptrollerProxy for which to signal the migration\n    function signalMigration(address _vaultProxy, address _comptrollerProxy) external {\n        __signalMigration(_vaultProxy, _comptrollerProxy, false);\n    }\n\n    /// @notice Signal a fund migration, bypassing any failures.\n    /// Should be used in an emergency only.\n    /// @param _vaultProxy The VaultProxy for which to signal the migration\n    /// @param _comptrollerProxy The ComptrollerProxy for which to signal the migration\n    function signalMigrationEmergency(address _vaultProxy, address _comptrollerProxy) external {\n        __signalMigration(_vaultProxy, _comptrollerProxy, true);\n    }\n\n    /// @dev Helper to cancel a migration\n    function __cancelMigration(address _vaultProxy, bool _bypassFailure)\n        private\n        onlyLiveRelease\n        onlyMigrator(_vaultProxy)\n    {\n        IDispatcher(DISPATCHER).cancelMigration(_vaultProxy, _bypassFailure);\n    }\n\n    /// @dev Helper to execute a migration\n    function __executeMigration(address _vaultProxy, bool _bypassFailure)\n        private\n        onlyLiveRelease\n        onlyMigrator(_vaultProxy)\n    {\n        IDispatcher dispatcherContract = IDispatcher(DISPATCHER);\n\n        (, address comptrollerProxy, , ) = dispatcherContract\n            .getMigrationRequestDetailsForVaultProxy(_vaultProxy);\n\n        dispatcherContract.executeMigration(_vaultProxy, _bypassFailure);\n\n        IComptroller(comptrollerProxy).activate(_vaultProxy, true);\n\n        delete pendingComptrollerProxyToCreator[comptrollerProxy];\n    }\n\n    /// @dev Helper to signal a migration\n    function __signalMigration(\n        address _vaultProxy,\n        address _comptrollerProxy,\n        bool _bypassFailure\n    )\n        private\n        onlyLiveRelease\n        onlyPendingComptrollerProxyCreator(_comptrollerProxy)\n        onlyMigrator(_vaultProxy)\n    {\n        IDispatcher(DISPATCHER).signalMigration(\n            _vaultProxy,\n            _comptrollerProxy,\n            VAULT_LIB,\n            _bypassFailure\n        );\n    }\n\n    ///////////////////\n    // MIGRATION OUT //\n    ///////////////////\n\n    /// @notice Allows \"hooking into\" specific moments in the migration pipeline\n    /// to execute arbitrary logic during a migration out of this release\n    /// @param _vaultProxy The VaultProxy being migrated\n    function invokeMigrationOutHook(\n        MigrationOutHook _hook,\n        address _vaultProxy,\n        address,\n        address,\n        address\n    ) external override {\n        if (_hook != MigrationOutHook.PreMigrate) {\n            return;\n        }\n\n        require(\n            msg.sender == DISPATCHER,\n            \"postMigrateOriginHook: Only Dispatcher can call this function\"\n        );\n\n        // Must use PreMigrate hook to get the ComptrollerProxy from the VaultProxy\n        address comptrollerProxy = IVault(_vaultProxy).getAccessor();\n\n        // Wind down fund and destroy its config\n        IComptroller(comptrollerProxy).destruct();\n    }\n\n    //////////////\n    // REGISTRY //\n    //////////////\n\n    /// @notice De-registers allowed arbitrary contract calls that can be sent from the VaultProxy\n    /// @param _contracts The contracts of the calls to de-register\n    /// @param _selectors The selectors of the calls to de-register\n    function deregisterVaultCalls(address[] calldata _contracts, bytes4[] calldata _selectors)\n        external\n        onlyOwner\n    {\n        require(_contracts.length > 0, \"deregisterVaultCalls: Empty _contracts\");\n        require(\n            _contracts.length == _selectors.length,\n            \"deregisterVaultCalls: Uneven input arrays\"\n        );\n\n        for (uint256 i; i < _contracts.length; i++) {\n            require(\n                isRegisteredVaultCall(_contracts[i], _selectors[i]),\n                \"deregisterVaultCalls: Call not registered\"\n            );\n\n            contractToSelectorToIsRegisteredVaultCall[_contracts[i]][_selectors[i]] = false;\n\n            emit VaultCallDeregistered(_contracts[i], _selectors[i]);\n        }\n    }\n\n    /// @notice Registers allowed arbitrary contract calls that can be sent from the VaultProxy\n    /// @param _contracts The contracts of the calls to register\n    /// @param _selectors The selectors of the calls to register\n    function registerVaultCalls(address[] calldata _contracts, bytes4[] calldata _selectors)\n        external\n        onlyOwner\n    {\n        require(_contracts.length > 0, \"registerVaultCalls: Empty _contracts\");\n\n        __registerVaultCalls(_contracts, _selectors);\n    }\n\n    /// @dev Helper to register allowed vault calls\n    function __registerVaultCalls(address[] memory _contracts, bytes4[] memory _selectors)\n        private\n    {\n        require(\n            _contracts.length == _selectors.length,\n            \"__registerVaultCalls: Uneven input arrays\"\n        );\n\n        for (uint256 i; i < _contracts.length; i++) {\n            require(\n                !isRegisteredVaultCall(_contracts[i], _selectors[i]),\n                \"__registerVaultCalls: Call already registered\"\n            );\n\n            contractToSelectorToIsRegisteredVaultCall[_contracts[i]][_selectors[i]] = true;\n\n            emit VaultCallRegistered(_contracts[i], _selectors[i]);\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `comptrollerLib` variable value\n    /// @return comptrollerLib_ The `comptrollerLib` variable value\n    function getComptrollerLib() external view returns (address comptrollerLib_) {\n        return comptrollerLib;\n    }\n\n    /// @notice Gets the `CREATOR` variable value\n    /// @return creator_ The `CREATOR` variable value\n    function getCreator() external view returns (address creator_) {\n        return CREATOR;\n    }\n\n    /// @notice Gets the `DISPATCHER` variable value\n    /// @return dispatcher_ The `DISPATCHER` variable value\n    function getDispatcher() external view returns (address dispatcher_) {\n        return DISPATCHER;\n    }\n\n    /// @notice Gets the creator of a pending ComptrollerProxy\n    /// @return pendingComptrollerProxyCreator_ The pending ComptrollerProxy creator\n    function getPendingComptrollerProxyCreator(address _comptrollerProxy)\n        external\n        view\n        returns (address pendingComptrollerProxyCreator_)\n    {\n        return pendingComptrollerProxyToCreator[_comptrollerProxy];\n    }\n\n    /// @notice Gets the `releaseStatus` variable value\n    /// @return status_ The `releaseStatus` variable value\n    function getReleaseStatus() external view override returns (ReleaseStatus status_) {\n        return releaseStatus;\n    }\n\n    /// @notice Gets the `VAULT_LIB` variable value\n    /// @return vaultLib_ The `VAULT_LIB` variable value\n    function getVaultLib() external view returns (address vaultLib_) {\n        return VAULT_LIB;\n    }\n\n    /// @notice Checks if a contract call is registered\n    /// @param _contract The contract of the call to check\n    /// @param _selector The selector of the call to check\n    /// @return isRegistered_ True if the call is registered\n    function isRegisteredVaultCall(address _contract, bytes4 _selector)\n        public\n        view\n        override\n        returns (bool isRegistered_)\n    {\n        return contractToSelectorToIsRegisteredVaultCall[_contract][_selector];\n    }\n}\n"
    },
    "contracts/release/core/fund-deployer/IFundDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IFundDeployer Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IFundDeployer {\n    enum ReleaseStatus {PreLaunch, Live, Paused}\n\n    function getOwner() external view returns (address);\n\n    function getReleaseStatus() external view returns (ReleaseStatus);\n\n    function isRegisteredVaultCall(address, bytes4) external view returns (bool);\n}\n"
    },
    "contracts/release/core/fund/comptroller/ComptrollerProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../utils/Proxy.sol\";\n\n/// @title ComptrollerProxy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A proxy contract for all ComptrollerProxy instances\ncontract ComptrollerProxy is Proxy {\n    constructor(bytes memory _constructData, address _comptrollerLib)\n        public\n        Proxy(_constructData, _comptrollerLib)\n    {}\n}\n"
    },
    "contracts/release/core/fund/comptroller/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IComptroller Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IComptroller {\n    enum VaultAction {\n        None,\n        BurnShares,\n        MintShares,\n        TransferShares,\n        ApproveAssetSpender,\n        WithdrawAssetTo,\n        AddTrackedAsset,\n        RemoveTrackedAsset\n    }\n\n    function activate(address, bool) external;\n\n    function calcGav(bool) external returns (uint256, bool);\n\n    function calcGrossShareValue(bool) external returns (uint256, bool);\n\n    function callOnExtension(\n        address,\n        uint256,\n        bytes calldata\n    ) external;\n\n    function configureExtensions(bytes calldata, bytes calldata) external;\n\n    function destruct() external;\n\n    function getDenominationAsset() external view returns (address);\n\n    function getVaultProxy() external view returns (address);\n\n    function init(address, uint256) external;\n\n    function permissionedVaultAction(VaultAction, bytes calldata) external;\n}\n"
    },
    "contracts/release/core/fund/vault/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../persistent/utils/IMigratableVault.sol\";\n\n/// @title IVault Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IVault is IMigratableVault {\n    function addTrackedAsset(address) external;\n\n    function approveAssetSpender(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function burnShares(address, uint256) external;\n\n    function callOnContract(address, bytes calldata) external;\n\n    function getAccessor() external view returns (address);\n\n    function getOwner() external view returns (address);\n\n    function getTrackedAssets() external view returns (address[] memory);\n\n    function isTrackedAsset(address) external view returns (bool);\n\n    function mintShares(address, uint256) external;\n\n    function removeTrackedAsset(address) external;\n\n    function transferShares(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function withdrawAssetTo(\n        address,\n        address,\n        uint256\n    ) external;\n}\n"
    },
    "contracts/release/utils/Proxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title Proxy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A proxy contract for all Proxy instances\n/// @dev The recommended implementation of a Proxy in EIP-1822, updated for solc 0.6.12,\n/// and using the EIP-1967 storage slot for the proxiable implementation.\n/// i.e., `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`, which is\n/// \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"\n/// See: https://eips.ethereum.org/EIPS/eip-1822\ncontract Proxy {\n    constructor(bytes memory _constructData, address _contractLogic) public {\n        assembly {\n            sstore(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\n                _contractLogic\n            )\n        }\n        (bool success, bytes memory returnData) = _contractLogic.delegatecall(_constructData);\n        require(success, string(returnData));\n    }\n\n    fallback() external payable {\n        assembly {\n            let contractLogic := sload(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n            )\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(\n                sub(gas(), 10000),\n                contractLogic,\n                0x0,\n                calldatasize(),\n                0,\n                0\n            )\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n                case 0 {\n                    revert(0, retSz)\n                }\n                default {\n                    return(0, retSz)\n                }\n        }\n    }\n}\n"
    }
  }
}}