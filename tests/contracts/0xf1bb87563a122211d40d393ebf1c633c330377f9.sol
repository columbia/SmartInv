{{
  "language": "Solidity",
  "sources": {
    "contracts/staking/PremiaStakingProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {ProxyUpgradeableOwnable} from \"../ProxyUpgradeableOwnable.sol\";\r\nimport {ERC20MetadataStorage} from \"@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol\";\r\n\r\nimport {PremiaStakingStorage} from \"./PremiaStakingStorage.sol\";\r\n\r\ncontract PremiaStakingProxy is ProxyUpgradeableOwnable {\r\n    using ERC20MetadataStorage for ERC20MetadataStorage.Layout;\r\n\r\n    constructor(address implementation)\r\n        ProxyUpgradeableOwnable(implementation)\r\n    {\r\n        ERC20MetadataStorage.Layout storage l = ERC20MetadataStorage.layout();\r\n        l.setName(\"Staked Premia\");\r\n        l.setSymbol(\"xPREMIA\");\r\n        l.setDecimals(18);\r\n\r\n        PremiaStakingStorage.layout().withdrawalDelay = 10 days;\r\n    }\r\n}\r\n"
    },
    "contracts/ProxyUpgradeableOwnable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {Proxy} from \"@solidstate/contracts/proxy/Proxy.sol\";\r\nimport {SafeOwnable, OwnableStorage} from \"@solidstate/contracts/access/SafeOwnable.sol\";\r\nimport {ProxyUpgradeableOwnableStorage} from \"./ProxyUpgradeableOwnableStorage.sol\";\r\n\r\ncontract ProxyUpgradeableOwnable is Proxy, SafeOwnable {\r\n    using ProxyUpgradeableOwnableStorage for ProxyUpgradeableOwnableStorage.Layout;\r\n    using OwnableStorage for OwnableStorage.Layout;\r\n\r\n    constructor(address implementation) {\r\n        OwnableStorage.layout().setOwner(msg.sender);\r\n        ProxyUpgradeableOwnableStorage.layout().implementation = implementation;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @inheritdoc Proxy\r\n     */\r\n    function _getImplementation() internal view override returns (address) {\r\n        return ProxyUpgradeableOwnableStorage.layout().implementation;\r\n    }\r\n\r\n    /**\r\n     * @notice get address of implementation contract\r\n     * @return implementation address\r\n     */\r\n    function getImplementation() external view returns (address) {\r\n        return _getImplementation();\r\n    }\r\n\r\n    /**\r\n     * @notice set address of implementation contract\r\n     * @param implementation address of the new implementation\r\n     */\r\n    function setImplementation(address implementation) external onlyOwner {\r\n        ProxyUpgradeableOwnableStorage.layout().implementation = implementation;\r\n    }\r\n}\r\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC20MetadataStorage {\n    struct Layout {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setName(Layout storage l, string memory name) internal {\n        l.name = name;\n    }\n\n    function setSymbol(Layout storage l, string memory symbol) internal {\n        l.symbol = symbol;\n    }\n\n    function setDecimals(Layout storage l, uint8 decimals) internal {\n        l.decimals = decimals;\n    }\n}\n"
    },
    "contracts/staking/PremiaStakingStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary PremiaStakingStorage {\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.staking.PremiaStaking\");\r\n\r\n    struct Withdrawal {\r\n        uint256 amount; // Premia amount\r\n        uint256 startDate; // Will unlock at startDate + withdrawalDelay\r\n    }\r\n\r\n    struct Layout {\r\n        uint256 pendingWithdrawal;\r\n        uint256 withdrawalDelay;\r\n        mapping(address => Withdrawal) withdrawals;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"
    },
    "@solidstate/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../utils/AddressUtils.sol';\n\n/**\n * @title Base proxy contract\n */\nabstract contract Proxy {\n    using AddressUtils for address;\n\n    /**\n     * @notice delegate all calls to implementation contract\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\n     * @dev memory location in use by assembly may be unsafe in other contexts\n     */\n    fallback() external payable virtual {\n        address implementation = _getImplementation();\n\n        require(\n            implementation.isContract(),\n            'Proxy: implementation must be contract'\n        );\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice get logic implementation address\n     * @return implementation address\n     */\n    function _getImplementation() internal virtual returns (address);\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Ownable, OwnableStorage } from './Ownable.sol';\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173 with ownership transfer safety check\n */\nabstract contract SafeOwnable is Ownable, SafeOwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    function nomineeOwner() public view virtual returns (address) {\n        return SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @inheritdoc Ownable\n     * @dev ownership transfer must be accepted by beneficiary before transfer is complete\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        SafeOwnableStorage.layout().setNomineeOwner(account);\n    }\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function acceptOwnership() public virtual onlyNomineeOwner {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, msg.sender);\n        l.setOwner(msg.sender);\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\n    }\n}\n"
    },
    "contracts/ProxyUpgradeableOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary ProxyUpgradeableOwnableStorage {\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.storage.ProxyUpgradeableOwnable\");\r\n\r\n    struct Layout {\r\n        address implementation;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary AddressUtils {\n    function toString(address account) internal pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(account)));\n        bytes memory alphabet = '0123456789abcdef';\n        bytes memory chars = new bytes(42);\n\n        chars[0] = '0';\n        chars[1] = 'x';\n\n        for (uint256 i = 0; i < 20; i++) {\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n\n        return string(chars);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        require(success, 'AddressUtils: failed to send value');\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'AddressUtils: insufficient balance for call'\n        );\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        require(\n            isContract(target),\n            'AddressUtils: function call to non-contract'\n        );\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173 } from './IERC173.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173\n */\nabstract contract Ownable is IERC173, OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() public view virtual override returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address account)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        OwnableStorage.layout().setOwner(account);\n        emit OwnershipTransferred(msg.sender, account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\nabstract contract SafeOwnableInternal {\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    modifier onlyNomineeOwner() {\n        require(\n            msg.sender == SafeOwnableStorage.layout().nomineeOwner,\n            'SafeOwnable: sender must be nominee owner'\n        );\n        _;\n    }\n}\n"
    },
    "@solidstate/contracts/access/SafeOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeOwnableStorage {\n    struct Layout {\n        address nomineeOwner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.SafeOwnable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\n        l.nomineeOwner = nomineeOwner;\n    }\n}\n"
    },
    "@solidstate/contracts/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conract owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@solidstate/contracts/access/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == OwnableStorage.layout().owner,\n            'Ownable: sender must be owner'\n        );\n        _;\n    }\n}\n"
    },
    "@solidstate/contracts/access/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}