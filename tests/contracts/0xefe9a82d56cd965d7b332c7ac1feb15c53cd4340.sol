{{
  "language": "Solidity",
  "sources": {
    "/contracts/BatchDeposits.sol": {
      "content": "\n//                                                                           ,,---.\n//                                                                         .-^^,_  `.\n//                                                                    ;`, / 3 ( o\\   }\n//         __             __                     ___              __  \\  ;   \\`, /  ,'\n//        /\\ \\__         /\\ \\                  /'___\\ __         /\\ \\ ;_/^`.__.-\"  ,'\n//    ____\\ \\ ,_\\    __  \\ \\ \\/'\\      __     /\\ \\__//\\_\\    ____\\ \\ \\___     `---'\n//   /',__\\\\ \\ \\/  /'__`\\ \\ \\ , <    /'__`\\   \\ \\ ,__\\/\\ \\  /',__\\\\ \\  _ `\\\n//  /\\__, `\\\\ \\ \\_/\\ \\L\\.\\_\\ \\ \\\\`\\ /\\  __/  __\\ \\ \\_/\\ \\ \\/\\__, `\\\\ \\ \\ \\ \\\n//  \\/\\____/ \\ \\__\\ \\__/.\\_\\\\ \\_\\ \\_\\ \\____\\/\\_\\\\ \\_\\  \\ \\_\\/\\____/ \\ \\_\\ \\_\\\n//   \\/___/   \\/__/\\/__/\\/_/ \\/_/\\/_/\\/____/\\/_/ \\/_/   \\/_/\\/___/   \\/_/\\/_/\n//\n// stakefish Eth2 Batch Deposit contract\n//\n// This contract allows deposit of multiple validators in one transaction\n// SPDX-License-Identifier: Apache-2.0\n\n// Coinbase updates: remove fee collection, pausing and ownership\n\npragma solidity 0.6.11;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/introspection/IERC165.sol\";\n\n// Deposit contract interface\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(\n        bytes pubkey,\n        bytes withdrawal_credentials,\n        bytes amount,\n        bytes signature,\n        bytes index\n    );\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n\n/// @notice BatchDeposit is a contract to support creating multiple ETH2 deposits in a single transaction\ncontract BatchDeposit {\n    using SafeMath for uint256;\n\n    address immutable depositContract;\n\n    uint256 constant PUBKEY_LENGTH = 48;\n    uint256 constant SIGNATURE_LENGTH = 96;\n    uint256 constant CREDENTIALS_LENGTH = 32;\n    uint256 constant MAX_VALIDATORS = 100;\n    uint256 constant DEPOSIT_AMOUNT = 32 ether;\n\n    /**\n     * @notice Creates a BatchDeposit contract\n     * @param depositContractAddr Address of the underlying deposit contract\n    */\n    constructor(address depositContractAddr) public {\n        require(IERC165(depositContractAddr).supportsInterface(type(IDepositContract).interfaceId), \"BatchDeposit: Invalid Deposit Contract\");\n        depositContract = depositContractAddr;\n    }\n\n    /**\n     * @notice Performs a batch deposit\n     * @param pubkeys Concatenation of multiple BLS12-381 public keys.\n     * @param withdrawal_credentials Commitment to a public key for withdrawals.\n     * @param signatures Concatenation of multiple BLS12-381 signature.\n     * @param deposit_data_roots List of SHA-256 hashes of the SSZ-encoded DepositData object.\n     */\n    function batchDeposit(\n        bytes calldata pubkeys,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signatures,\n        bytes32[] calldata deposit_data_roots\n    )\n        external payable\n    {\n        // sanity checks\n        require(msg.value % 1 gwei == 0, \"BatchDeposit: Deposit value not multiple of GWEI\");\n        require(msg.value >= DEPOSIT_AMOUNT, \"BatchDeposit: Amount is too low\");\n\n        uint256 count = deposit_data_roots.length;\n        require(count > 0, \"BatchDeposit: You should deposit at least one validator\");\n        require(count <= MAX_VALIDATORS, \"BatchDeposit: You can deposit max 100 validators at a time\");\n\n        require(pubkeys.length == count * PUBKEY_LENGTH, \"BatchDeposit: Pubkey count doesn't match\");\n        require(signatures.length == count * SIGNATURE_LENGTH, \"BatchDeposit: Signatures count doesn't match\");\n        require(withdrawal_credentials.length == 1 * CREDENTIALS_LENGTH, \"BatchDeposit: Withdrawal Credentials count doesn't match\");\n\n        uint256 expectedAmount = DEPOSIT_AMOUNT.mul(count);\n        require(msg.value == expectedAmount, \"BatchDeposit: Amount is not aligned with number of pubkeys\");\n\n        for (uint256 i = 0; i < count; ++i) {\n            bytes memory pubkey = bytes(pubkeys[i*PUBKEY_LENGTH:(i+1)*PUBKEY_LENGTH]);\n            bytes memory signature = bytes(signatures[i*SIGNATURE_LENGTH:(i+1)*SIGNATURE_LENGTH]);\n\n            IDepositContract(depositContract).deposit{value: DEPOSIT_AMOUNT}(\n                pubkey,\n                withdrawal_credentials,\n                signature,\n                deposit_data_roots[i]\n            );\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "evmVersion": "byzantium",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}