{{
  "language": "Solidity",
  "sources": {
    "src/metadata/DropMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport {IMetadataRenderer} from \"../interfaces/IMetadataRenderer.sol\";\nimport {MetadataRenderAdminCheck} from \"./MetadataRenderAdminCheck.sol\";\n\n/// @notice Drops metadata system\ncontract DropMetadataRenderer is IMetadataRenderer, MetadataRenderAdminCheck {\n    error MetadataFrozen();\n\n    /// Event to mark updated metadata information\n    event MetadataUpdated(\n        address indexed target,\n        string metadataBase,\n        string metadataExtension,\n        string contractURI,\n        uint256 freezeAt\n    );\n\n    /// @notice Hash to mark updated provenance hash\n    event ProvenanceHashUpdated(address indexed target, bytes32 provenanceHash);\n\n    /// @notice Struct to store metadata info and update data\n    struct MetadataURIInfo {\n        string base;\n        string extension;\n        string contractURI;\n        uint256 freezeAt;\n    }\n\n    /// @notice NFT metadata by contract\n    mapping(address => MetadataURIInfo) public metadataBaseByContract;\n\n    /// @notice Optional provenance hashes for NFT metadata by contract\n    mapping(address => bytes32) public provenanceHashes;\n\n    /// @notice Standard init for drop metadata from root drop contract\n    /// @param data passed in for initialization\n    function initializeWithData(bytes memory data) external {\n        // data format: string baseURI, string newContractURI\n        (string memory initialBaseURI, string memory initialContractURI) = abi\n            .decode(data, (string, string));\n        _updateMetadataDetails(\n            msg.sender,\n            initialBaseURI,\n            \"\",\n            initialContractURI,\n            0\n        );\n    }\n\n    /// @notice Update the provenance hash (optional) for a given nft\n    /// @param target target address to update\n    /// @param provenanceHash provenance hash to set\n    function updateProvenanceHash(address target, bytes32 provenanceHash)\n        external\n        requireSenderAdmin(target)\n    {\n        provenanceHashes[target] = provenanceHash;\n        emit ProvenanceHashUpdated(target, provenanceHash);\n    }\n\n    /// @notice Update metadata base URI and contract URI\n    /// @param baseUri new base URI\n    /// @param newContractUri new contract URI (can be an empty string)\n    function updateMetadataBase(\n        address target,\n        string memory baseUri,\n        string memory newContractUri\n    ) external requireSenderAdmin(target) {\n        _updateMetadataDetails(target, baseUri, \"\", newContractUri, 0);\n    }\n\n    /// @notice Update metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing detailsUpdate metadata base URI, extension, contract URI and freezing details\n    /// @param target target contract to update metadata for\n    /// @param metadataBase new base URI to update metadata with\n    /// @param metadataExtension new extension to append to base metadata URI\n    /// @param freezeAt time to freeze the contract metadata at (set to 0 to disable)\n    function updateMetadataBaseWithDetails(\n        address target,\n        string memory metadataBase,\n        string memory metadataExtension,\n        string memory newContractURI,\n        uint256 freezeAt\n    ) external requireSenderAdmin(target) {\n        _updateMetadataDetails(\n            target,\n            metadataBase,\n            metadataExtension,\n            newContractURI,\n            freezeAt\n        );\n    }\n\n    /// @notice Internal metadata update function\n    /// @param metadataBase Base URI to update metadata for\n    /// @param metadataExtension Extension URI to update metadata for\n    /// @param freezeAt timestamp to freeze metadata (set to 0 to disable freezing)\n    function _updateMetadataDetails(\n        address target,\n        string memory metadataBase,\n        string memory metadataExtension,\n        string memory newContractURI,\n        uint256 freezeAt\n    ) internal {\n        if (freezeAt != 0 && freezeAt > block.timestamp) {\n            revert MetadataFrozen();\n        }\n\n        metadataBaseByContract[target] = MetadataURIInfo({\n            base: metadataBase,\n            extension: metadataExtension,\n            contractURI: newContractURI,\n            freezeAt: freezeAt\n        });\n        emit MetadataUpdated({\n            target: target,\n            metadataBase: metadataBase,\n            metadataExtension: metadataExtension,\n            contractURI: newContractURI,\n            freezeAt: freezeAt\n        });\n    }\n\n    /// @notice A contract URI for the given drop contract\n    /// @dev reverts if a contract uri is not provided\n    /// @return contract uri for the contract metadata\n    function contractURI() external view override returns (string memory) {\n        string memory uri = metadataBaseByContract[msg.sender].contractURI;\n        if (bytes(uri).length == 0) revert();\n        return uri;\n    }\n\n    /// @notice A token URI for the given drops contract\n    /// @dev reverts if a contract uri is not set\n    /// @return token URI for the given token ID and contract (set by msg.sender)\n    function tokenURI(uint256 tokenId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        MetadataURIInfo memory info = metadataBaseByContract[msg.sender];\n\n        if (bytes(info.base).length == 0) revert();\n\n        return\n            string(\n                abi.encodePacked(\n                    info.base,\n                    StringsUpgradeable.toString(tokenId),\n                    info.extension\n                )\n            );\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/interfaces/IMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IMetadataRenderer {\n    function tokenURI(uint256) external view returns (string memory);\n    function contractURI() external view returns (string memory);\n    function initializeWithData(bytes memory initData) external;\n}\n"
    },
    "src/metadata/MetadataRenderAdminCheck.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC721Drop} from \"../interfaces/IERC721Drop.sol\";\n\ncontract MetadataRenderAdminCheck {\n    error Access_OnlyAdmin();\n\n    /// @notice Modifier to require the sender to be an admin\n    /// @param target address that the user wants to modify\n    modifier requireSenderAdmin(address target) {\n        if (target != msg.sender && !IERC721Drop(target).isAdmin(msg.sender)) {\n            revert Access_OnlyAdmin();\n        }\n\n        _;\n    }\n}\n"
    },
    "src/interfaces/IERC721Drop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IMetadataRenderer} from \"../interfaces/IMetadataRenderer.sol\";\n\n/**\n\n ________   _____   ____    ______      ____\n/\\_____  \\ /\\  __`\\/\\  _`\\ /\\  _  \\    /\\  _`\\\n\\/____//'/'\\ \\ \\/\\ \\ \\ \\L\\ \\ \\ \\L\\ \\   \\ \\ \\/\\ \\  _ __   ___   _____     ____\n     //'/'  \\ \\ \\ \\ \\ \\ ,  /\\ \\  __ \\   \\ \\ \\ \\ \\/\\`'__\\/ __`\\/\\ '__`\\  /',__\\\n    //'/'___ \\ \\ \\_\\ \\ \\ \\\\ \\\\ \\ \\/\\ \\   \\ \\ \\_\\ \\ \\ \\//\\ \\L\\ \\ \\ \\L\\ \\/\\__, `\\\n    /\\_______\\\\ \\_____\\ \\_\\ \\_\\ \\_\\ \\_\\   \\ \\____/\\ \\_\\\\ \\____/\\ \\ ,__/\\/\\____/\n    \\/_______/ \\/_____/\\/_/\\/ /\\/_/\\/_/    \\/___/  \\/_/ \\/___/  \\ \\ \\/  \\/___/\n                                                                 \\ \\_\\\n                                                                  \\/_/\n\n*/\n\n/// @notice Interface for ZORA Drops contract\ninterface IERC721Drop {\n    // Access errors\n\n    /// @notice Only admin can access this function\n    error Access_OnlyAdmin();\n    /// @notice Missing the given role or admin access\n    error Access_MissingRoleOrAdmin(bytes32 role);\n    /// @notice Withdraw is not allowed by this user\n    error Access_WithdrawNotAllowed();\n    /// @notice Cannot withdraw funds due to ETH send failure.\n    error Withdraw_FundsSendFailure();\n\n    // Sale/Purchase errors\n    /// @notice Sale is inactive\n    error Sale_Inactive();\n    /// @notice Presale is inactive\n    error Presale_Inactive();\n    /// @notice Presale merkle root is invalid\n    error Presale_MerkleNotApproved();\n    /// @notice Wrong price for purchase\n    error Purchase_WrongPrice(uint256 correctPrice);\n    /// @notice NFT sold out\n    error Mint_SoldOut();\n    /// @notice Too many purchase for address\n    error Purchase_TooManyForAddress();\n    /// @notice Too many presale for address\n    error Presale_TooManyForAddress();\n\n    // Admin errors\n    /// @notice Royalty percentage too high\n    error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n    /// @notice Invalid admin upgrade address\n    error Admin_InvalidUpgradeAddress(address proposedAddress);\n    /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n    error Admin_UnableToFinalizeNotOpenEdition();\n\n    /// @notice Event emitted for each sale\n    /// @param to address sale was made to\n    /// @param quantity quantity of the minted nfts\n    /// @param pricePerToken price for each token\n    /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n    event Sale(\n        address indexed to,\n        uint256 indexed quantity,\n        uint256 indexed pricePerToken,\n        uint256 firstPurchasedTokenId\n    );\n\n    /// @notice General configuration for NFT Minting and bookkeeping\n    struct Configuration {\n        /// @dev Metadata renderer (uint160)\n        IMetadataRenderer metadataRenderer;\n        /// @dev Total size of edition that can be minted (uint160+64 = 224)\n        uint64 editionSize;\n        /// @dev Royalty amount in bps (uint224+16 = 240)\n        uint16 royaltyBPS;\n        /// @dev Funds recipient for sale (new slot, uint160)\n        address payable fundsRecipient;\n    }\n\n    /// @notice Sales states and configuration\n    /// @dev Uses 3 storage slots\n    struct SalesConfiguration {\n        /// @dev Public sale price (max ether value > 1000 ether with this value)\n        uint104 publicSalePrice;\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n        /// @dev Max purchase number per txn (90+32 = 122)\n        uint32 maxSalePurchasePerAddress;\n        /// @dev uint64 type allows for dates into 292 billion years\n        /// @notice Public sale start timestamp (136+64 = 186)\n        uint64 publicSaleStart;\n        /// @notice Public sale end timestamp (186+64 = 250)\n        uint64 publicSaleEnd;\n        /// @notice Presale start timestamp\n        /// @dev new storage slot\n        uint64 presaleStart;\n        /// @notice Presale end timestamp\n        uint64 presaleEnd;\n        /// @notice Presale merkle root\n        bytes32 presaleMerkleRoot;\n    }\n\n    /// @notice Return value for sales details to use with front-ends\n    struct SaleDetails {\n        // Synthesized status variables for sale and presale\n        bool publicSaleActive;\n        bool presaleActive;\n        // Price for public sale\n        uint256 publicSalePrice;\n        // Timed sale actions for public sale\n        uint64 publicSaleStart;\n        uint64 publicSaleEnd;\n        // Timed sale actions for presale\n        uint64 presaleStart;\n        uint64 presaleEnd;\n        // Merkle root (includes address, quantity, and price data for each entry)\n        bytes32 presaleMerkleRoot;\n        // Limit public sale to a specific number of mints per wallet\n        uint256 maxSalePurchasePerAddress;\n        // Information about the rest of the supply\n        // Total that have been minted\n        uint256 totalMinted;\n        // The total supply available\n        uint256 maxSupply;\n    }\n\n    /// @notice Return type of specific mint counts and details per address\n    struct AddressMintDetails {\n        /// Number of total mints from the given address\n        uint256 totalMints;\n        /// Number of presale mints from the given address\n        uint256 presaleMints;\n        /// Number of public mints from the given address\n        uint256 publicMints;\n    }\n\n    /// @notice External purchase function (payable in eth)\n    /// @param quantity to purchase\n    /// @return first minted token ID\n    function purchase(uint256 quantity) external payable returns (uint256);\n\n    /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\n    /// @param quantity to purchase\n    /// @param maxQuantity can purchase (verified by merkle root)\n    /// @param pricePerToken price per token allowed (verified by merkle root)\n    /// @param merkleProof input for merkle proof leaf verified by merkle root\n    /// @return first minted token ID\n    function purchasePresale(\n        uint256 quantity,\n        uint256 maxQuantity,\n        uint256 pricePerToken,\n        bytes32[] memory merkleProof\n    ) external payable returns (uint256);\n\n    /// @notice Function to return the global sales details for the given drop\n    function saleDetails() external view returns (SaleDetails memory);\n\n    /// @notice Function to return the specific sales details for a given address\n    /// @param minter address for minter to return mint information for\n    function mintedPerAddress(address minter)\n        external\n        view\n        returns (AddressMintDetails memory);\n\n    /// @notice This is the opensea/public owner setting that can be set by the contract admin\n    function owner() external view returns (address);\n\n    /// @notice This is an admin mint function to mint a quantity to a specific address\n    /// @param to address to mint to\n    /// @param quantity quantity to mint\n    /// @return the id of the first minted NFT\n    function adminMint(address to, uint256 quantity) external returns (uint256);\n\n    /// @notice This is an admin mint function to mint a single nft each to a list of addresses\n    /// @param to list of addresses to mint an NFT each to\n    /// @return the id of the first minted NFT\n    function adminMintAirdrop(address[] memory to) external returns (uint256);\n\n    /// @dev Getter for admin role associated with the contract to handle metadata\n    /// @return boolean if address is admin\n    function isAdmin(address user) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/",
      "base64/=lib/base64/",
      "ds-test/=lib/ds-test/src/",
      "erc721a-upgradeable/=lib/ERC721A-Upgradeable/contracts/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "src/=src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london"
  }
}}