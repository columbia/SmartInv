{"IDGTXToken.sol":{"content":"pragma solidity 0.5.4;\n\n\ninterface IDGTXToken {\n    function transfer(address to, uint value) external returns (bool);\n    function balanceOf(address) external view returns (uint256);\n}"},"Sale.sol":{"content":"pragma solidity 0.5.4;\n\nimport \"./IDGTXToken.sol\";\n\n\ncontract Sale {\n    address public owner;\n    address public updater;\n    address public token;\n\n    uint256 internal rate;\n    uint256 internal constant RATE_DELIMITER = 1000;\n    uint256 internal constant ONE_TOKEN = 1e18; //1 DGTX\n\n    uint256 internal oldRate;\n    uint256 internal rateUpdateDelay = 10 minutes;\n    uint256 internal rateBecomesValidAt;\n\n    event Purchase(address indexed buyer, uint256 amount);\n    event RateUpdate(uint256 newRate, uint256 rateBecomesValidAt);\n    event DelayUpdate(uint256 newDelay);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event TokensReceived(uint256 amount);\n    event ChangedUpdater(address indexed previousUpdater, address indexed newUpdater);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyUpdater() {\n        require(msg.sender == updater, \"This function is callable only by updater\");\n        _;\n    }\n\n    constructor(address _token, uint256 _rate) public {\n        require(_token != address(0));\n        require(_rate != 0);\n\n        owner = msg.sender;\n        token = _token;\n        rate = _rate;\n    }\n\n    function() external payable {\n        require(msg.data.length == 0);\n\n        buy();\n    }\n\n    function updateRate(uint256 newRate) internal {\n        require(newRate != 0);\n\n        if (now \u003e rateBecomesValidAt) {\n            oldRate = rate;\n        }\n        rate = newRate;\n        rateBecomesValidAt = now + rateUpdateDelay;\n        emit RateUpdate(newRate, rateBecomesValidAt);\n    }\n\n    function updateRateByOwner(uint256 newRate) external onlyOwner {\n        updateRate(newRate);\n    }\n\n    function updateRateByUpdater(uint256 newRate) external onlyUpdater {\n        (uint256 rate, uint256 timePriorToApply) = futureRate();\n        require(timePriorToApply == 0, \"New rate hasn\u0027t been applied yet\");\n        uint256 newRateMultiplied = newRate * 100;\n        require(newRateMultiplied / 100 == newRate, \"Integer overflow\");\n        // No need to check previous rate for overflow as newRate is checked\n        // uint256 rateMultiplied = rate * 100;\n        // require(rateMultiplied / 100 == rate, \"Integer overflow\");\n        require(newRate * 99 \u003c= rate * 100, \"New rate is too high\");\n\n        updateRate(newRate);\n    }\n\n    function changeRateUpdateDelay(uint256 newDelay) external onlyOwner {\n        rateUpdateDelay = newDelay;\n        emit DelayUpdate(newDelay);\n    }\n\n    function withdraw() external onlyOwner {\n        require(address(this).balance \u003e 0);\n\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function withdraw(address payable to) external onlyOwner {\n        require(address(this).balance \u003e 0);\n\n        to.transfer(address(this).balance);\n    }\n\n    function transferOwnership(address _owner) external onlyOwner {\n        require(_owner != address(0));\n\n        emit OwnershipTransferred(owner, _owner);\n\n        owner = _owner;\n    }\n\n    function tokenFallback(address, uint value, bytes calldata) external {\n        require(msg.sender == token);\n\n        emit TokensReceived(value);\n    }\n\n    function buy() public payable returns (uint256) {\n        uint256 availableTotal = availableTokens();\n        require(availableTotal \u003e 0);\n\n        uint256 amount = weiToTokens(msg.value);\n        require(amount \u003e= ONE_TOKEN); // 1 DGTX\n\n        // actual = min(amount, availableTotal)\n        uint256 actual = amount \u003c availableTotal ? amount : availableTotal;\n\n        require(IDGTXToken(token).transfer(msg.sender, actual));\n\n        if (amount != actual) {\n            uint256 weiRefund = msg.value - tokensToWei(actual);\n            msg.sender.transfer(weiRefund);\n        }\n\n        emit Purchase(msg.sender, actual);\n\n        return actual;\n    }\n\n    function currentRate() public view returns (uint256) {\n        return (now \u003c rateBecomesValidAt) ? oldRate : rate;\n    }\n\n    function weiToTokens(uint256 weiAmount) public view returns (uint256) {\n        uint256 exchangeRate = currentRate();\n\n        return weiAmount * exchangeRate / RATE_DELIMITER;\n    }\n\n    function tokensToWei(uint256 tokensAmount) public view returns (uint256) {\n        uint256 exchangeRate = currentRate();\n\n        return tokensAmount * RATE_DELIMITER / exchangeRate;\n    }\n\n    function futureRate() public view returns (uint256, uint256) {\n        return (now \u003c rateBecomesValidAt) ? (rate, rateBecomesValidAt - now) : (rate, 0);\n    }\n\n    function availableTokens() public view returns (uint256) {\n        return IDGTXToken(token).balanceOf(address(this));\n    }\n\n    function changeUpdater(address _updater) external onlyOwner {\n        require(_updater != address(0), \"Invalid _updater address\");\n\n        emit ChangedUpdater(updater, _updater);\n\n        updater = _updater;\n    }\n}\n"}}