{"EmalBounty.sol":{"content":"pragma solidity 0.4.24;\n\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\n\n\ncontract EmalToken {\n    // add function prototypes of only those used here\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\n    \n    function getBountyAmount() public view returns(uint256);\n}\n\n\ncontract EmalBounty is Ownable {\n\n    using SafeMath for uint256;\n\n    // The token being sold\n    EmalToken public token;\n\n    // Bounty contract state Data structures\n    enum State {\n        Active,\n        Closed\n    }\n\n    // contains current state of bounty contract\n    State public state;\n\n    // Bounty limit in EMAL tokens\n    uint256 public bountyLimit;\n\n    // Count of total number of EML tokens that have been currently allocated to bounty users\n    uint256 public totalTokensAllocated = 0;\n\n    // Count of allocated tokens (not issued only allocated) for each bounty user\n    mapping(address =\u003e uint256) public allocatedTokens;\n\n    // Count of allocated tokens issued to each bounty user.\n    mapping(address =\u003e uint256) public amountOfAllocatedTokensGivenOut;\n\n\n    /** @dev Event fired when tokens are allocated to a bounty user account\n      * @param beneficiary Address that is allocated tokens\n      * @param tokenCount The amount of tokens that were allocated\n      */\n    event TokensAllocated(address indexed beneficiary, uint256 tokenCount);\n    event TokensDeallocated(address indexed beneficiary, uint256 tokenCount);\n\n    /**\n     * @dev Event fired when EML tokens are sent to a bounty user\n     * @param beneficiary Address where the allocated tokens were sent\n     * @param tokenCount The amount of tokens that were sent\n     */\n    event IssuedAllocatedTokens(address indexed beneficiary, uint256 tokenCount);\n\n\n\n    /** @param _token Address of the token that will be rewarded for the investors\n      */\n    constructor(address _token) public {\n        require(_token != address(0));\n        owner = msg.sender;\n        token = EmalToken(_token);\n        state = State.Active;\n        bountyLimit = token.getBountyAmount();\n    }\n\n    /* Do not accept ETH */\n    function() external payable {\n        revert();\n    }\n\n    function closeBounty() public onlyOwner returns(bool){\n        require( state!=State.Closed );\n        state = State.Closed;\n        return true;\n    }\n\n    /** @dev Public function to check if bounty isActive or not\n      * @return True if Bounty event has ended\n      */\n    function isBountyActive() public view returns(bool) {\n        if (state==State.Active \u0026\u0026 totalTokensAllocated\u003cbountyLimit){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /** @dev Allocates tokens to a bounty user\n      * @param beneficiary The address of the bounty user\n      * @param tokenCount The number of tokens to be allocated to this address\n      */\n    function allocateTokens(address beneficiary, uint256 tokenCount) public onlyOwner returns(bool success) {\n        require(beneficiary != address(0));\n        require(validAllocation(tokenCount));\n\n        uint256 tokens = tokenCount;\n\n        /* Allocate only the remaining tokens if final contribution exceeds hard cap */\n        if (totalTokensAllocated.add(tokens) \u003e bountyLimit) {\n            tokens = bountyLimit.sub(totalTokensAllocated);\n        }\n\n        /* Update state and balances */\n        allocatedTokens[beneficiary] = allocatedTokens[beneficiary].add(tokens);\n        totalTokensAllocated = totalTokensAllocated.add(tokens);\n        emit TokensAllocated(beneficiary, tokens);\n\n        return true;\n    }\n\n    function validAllocation( uint256 tokenCount ) internal view returns(bool) {\n        bool isActive = state==State.Active;\n        bool positiveAllocation = tokenCount\u003e0;\n        bool bountyLimitNotReached = totalTokensAllocated\u003cbountyLimit;\n        return isActive \u0026\u0026 positiveAllocation \u0026\u0026 bountyLimitNotReached;\n    }\n\n    /** @dev Remove tokens from a bounty user\u0027s allocation.\n      * @dev Used in game based bounty allocation, automatically called from the Sails app\n      * @param beneficiary The address of the bounty user\n      * @param tokenCount The number of tokens to be deallocated to this address\n      */\n    function deductAllocatedTokens(address beneficiary, uint256 tokenCount) public onlyOwner returns(bool success) {\n        require(beneficiary != address(0));\n        require(tokenCount\u003e0 \u0026\u0026 tokenCount\u003c=allocatedTokens[beneficiary]);\n\n        allocatedTokens[beneficiary] = allocatedTokens[beneficiary].sub(tokenCount);\n        totalTokensAllocated = totalTokensAllocated.sub(tokenCount);\n        emit TokensDeallocated(beneficiary, tokenCount);\n\n        return true;\n    }\n\n    /** @dev Getter function to check the amount of allocated tokens\n      * @param beneficiary address of the investor or the bounty user\n      */\n    function getAllocatedTokens(address beneficiary) public view returns(uint256 tokenCount) {\n        require(beneficiary != address(0));\n        return allocatedTokens[beneficiary];\n    }\n\n    /** @dev Bounty users will be issued EML Tokens by the sails api,\n      * @dev after the Bounty has ended to their address\n      * @param beneficiary address of the bounty user\n      */\n    function issueTokensToAllocatedUsers(address beneficiary) public onlyOwner returns(bool success) {\n        require(beneficiary!=address(0));\n        require(allocatedTokens[beneficiary]\u003e0);\n\n        uint256 tokensToSend = allocatedTokens[beneficiary];\n        allocatedTokens[beneficiary] = 0;\n        amountOfAllocatedTokensGivenOut[beneficiary] = amountOfAllocatedTokensGivenOut[beneficiary].add(tokensToSend);\n        assert(token.transferFrom(owner, beneficiary, tokensToSend));\n\n        emit IssuedAllocatedTokens(beneficiary, tokensToSend);\n        return true;\n    }\n}\n"},"EmalCrowdsale.sol":{"content":"pragma solidity 0.4.24;\n\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"./Pausable.sol\";\n\ncontract EmalToken {\n    // add function prototypes of only those used here\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\n    function getCrowdsaleAmount() public view returns(uint256);\n    function setStartTimeForTokenTransfers(uint256 _startTime) external;\n}\n\ncontract EmalWhitelist {\n    // add function prototypes of only those used here\n    function isWhitelisted(address investorAddr) public view returns(bool whitelisted);\n}\n\n\ncontract EmalCrowdsale is Ownable, Pausable {\n\n    using SafeMath for uint256;\n\n    // Start and end timestamps\n    uint256 public startTime;\n    uint256 public endTime;\n\n    // The token being sold\n    EmalToken public token;\n\n    // Whitelist contract used to store whitelisted addresses\n    EmalWhitelist public list;\n\n    // Address where funds are collected\n    address public multisigWallet;\n\n    // Switched to true once token contract is notified of when to enable token transfers\n    bool private isStartTimeSetForTokenTransfers = false;\n\n    // Hard cap in EMAL tokens\n    uint256 public hardCap;\n\n    // Soft cap in EMAL tokens\n    uint256 constant public soft_cap = 50000000 * (10 ** 18);\n\n    // Amount of tokens that were sold to ether investors plus tokens allocated to investors for fiat and btc investments.\n    uint256 public totalTokensSoldandAllocated = 0;\n\n\n\n    // Investor contributions made in ether\n    mapping(address =\u003e uint256) public etherInvestments;\n\n    // Tokens given to investors who sent ether investments\n    mapping(address =\u003e uint256) public tokensSoldForEther;\n\n    // Total ether raised by the Crowdsale\n    uint256 public totalEtherRaisedByCrowdsale = 0;\n\n    // Total number of tokens sold to investors who made payments in ether\n    uint256 public totalTokensSoldByEtherInvestments = 0;\n\n    // Count of allocated tokens  for each investor or bounty user\n    mapping(address =\u003e uint256) public allocatedTokens;\n\n    // Count of total number of EML tokens that have been currently allocated to Crowdsale investors\n    uint256 public totalTokensAllocated = 0;\n\n\n\n   /** @dev Event for EML token purchase using ether\n     * @param investorAddr Address that paid and got the tokens\n     * @param paidAmount The amount that was paid (in wei)\n     * @param tokenCount The amount of tokens that were bought\n     */\n    event TokenPurchasedUsingEther(address indexed investorAddr, uint256 paidAmount, uint256 tokenCount);\n\n    /**\n     * @dev Event for refund logging\n     * @param receiver The address that received the refund\n     * @param amount The amount that is being refunded (in wei)\n     */\n    event Refund(address indexed receiver, uint256 amount);\n\n    /** @dev Event fired when EML tokens are allocated to an investor account\n      * @param beneficiary Address that is allocated tokens\n      * @param tokenCount The amount of tokens that were allocated\n      */\n    event TokensAllocated(address indexed beneficiary, uint256 tokenCount);\n    event TokensDeallocated(address indexed beneficiary, uint256 tokenCount);\n\n\n    /** @dev variables and functions which determine conversion rate from ETH to EML\n      * based on bonuses and current timestamp.\n      */\n    uint256 priceOfEthInUSD = 450;\n    uint256 bonusPercent1 = 25;\n    uint256 bonusPercent2 = 15;\n    uint256 bonusPercent3 = 0;\n    uint256 priceOfEMLTokenInUSDPenny = 60;\n    uint256 overridenBonusValue = 0;\n\n    function setExchangeRate(uint256 overridenValue) public onlyOwner returns(bool) {\n        require( overridenValue \u003e 0 );\n        require( overridenValue != priceOfEthInUSD);\n        priceOfEthInUSD = overridenValue;\n        return true;\n    }\n\n    function getExchangeRate() public view returns(uint256){\n        return priceOfEthInUSD;\n    }\n\n    function setOverrideBonus(uint256 overridenValue) public onlyOwner returns(bool) {\n        require( overridenValue \u003e 0 );\n        require( overridenValue != overridenBonusValue);\n        overridenBonusValue = overridenValue;\n        return true;\n    }\n\n    /**\n     * @dev public function that is used to determine the current rate for token / ETH conversion\n     * @dev there exists a case where rate cant be set to 0, which is fine.\n     * @return The current token rate\n     */\n    function getRate() public view returns(uint256) {\n        require( priceOfEMLTokenInUSDPenny !=0 );\n        require( priceOfEthInUSD !=0 );\n        uint256 rate;\n\n        if(overridenBonusValue \u003e 0){\n            rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(overridenBonusValue.add(100)).div(100);\n        } else {\n            if (now \u003c= (startTime + 1 days)) {\n                rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(bonusPercent1.add(100)).div(100);\n            } if (now \u003e (startTime + 1 days) \u0026\u0026 now \u003c= (startTime + 2 days)) {\n                rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(bonusPercent2.add(100)).div(100);\n            } else {\n                rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(bonusPercent3.add(100)).div(100);\n            }\n        }\n        return rate;\n    }\n\n\n    /** @dev Initialise the Crowdsale contract.\n      * (can be removed for testing) _startTime Unix timestamp for the start of the token sale\n      * (can be removed for testing) _endTime Unix timestamp for the end of the token sale\n      * @param _multisigWallet Ethereum address to which the invested funds are forwarded\n      * @param _token Address of the token that will be rewarded for the investors\n      * @param _list contains a list of investors who completed KYC procedures.\n      */\n    constructor(uint256 _startTime, uint256 _endTime, address _multisigWallet, address _token, address _list) public {\n        require(_startTime \u003e= now);\n        require(_endTime \u003e= _startTime);\n        require(_multisigWallet != address(0));\n        require(_token != address(0));\n        require(_list != address(0));\n\n        startTime = _startTime;\n        endTime = _endTime;\n        multisigWallet = _multisigWallet;\n        owner = msg.sender;\n        token = EmalToken(_token);\n        list = EmalWhitelist(_list);\n        hardCap = token.getCrowdsaleAmount();\n    }\n\n    /** @dev Fallback function that can be used to buy EML tokens. Or in\n      * case of the owner, return ether to allow refunds in case crowdsale\n      * ended or paused and didnt reach soft_cap.\n      */\n    function() external payable {\n        if (msg.sender == multisigWallet) {\n            require( (!isCrowdsaleActive()) \u0026\u0026 totalTokensSoldandAllocated\u003csoft_cap);\n        } else {\n            if (list.isWhitelisted(msg.sender)) {\n                buyTokensUsingEther(msg.sender);\n            } else {\n                revert();\n            }\n        }\n    }\n\n    /** @dev Function for buying EML tokens using ether\n      * @param _investorAddr The address that should receive bought tokens\n      */\n    function buyTokensUsingEther(address _investorAddr) internal whenNotPaused {\n        require(_investorAddr != address(0));\n        require(validPurchase());\n\n        uint256 weiAmount = msg.value;\n        uint256 returnToSender = 0;\n\n        // final rate after including rate value and bonus amount.\n        uint256 finalConversionRate = getRate();\n\n        // Calculate EML token amount to be transferred\n        uint256 tokens = weiAmount.mul(finalConversionRate);\n\n        // Distribute only the remaining tokens if final contribution exceeds hard cap\n        if (totalTokensSoldandAllocated.add(tokens) \u003e hardCap) {\n            tokens = hardCap.sub(totalTokensSoldandAllocated);\n            weiAmount = tokens.div(finalConversionRate);\n            returnToSender = msg.value.sub(weiAmount);\n        }\n\n        // update state and balances\n        etherInvestments[_investorAddr] = etherInvestments[_investorAddr].add(weiAmount);\n        tokensSoldForEther[_investorAddr] = tokensSoldForEther[_investorAddr].add(tokens);\n        totalTokensSoldByEtherInvestments = totalTokensSoldByEtherInvestments.add(tokens);\n        totalEtherRaisedByCrowdsale = totalEtherRaisedByCrowdsale.add(weiAmount);\n        totalTokensSoldandAllocated = totalTokensSoldandAllocated.add(tokens);\n\n\n        // assert implies it should never fail\n        assert(token.transferFrom(owner, _investorAddr, tokens));\n        emit TokenPurchasedUsingEther(_investorAddr, weiAmount, tokens);\n\n        // Forward funds\n        multisigWallet.transfer(weiAmount);\n\n        // Update token contract.\n        _postValidationUpdateTokenContract();\n\n        // Return funds that are over hard cap\n        if (returnToSender \u003e 0) {\n            msg.sender.transfer(returnToSender);\n        }\n    }\n\n    function _postValidationUpdateTokenContract() internal {\n       /** @dev If hard cap is reachde allow token transfers after two weeks\n         * @dev Allow users to transfer tokens only after hardCap is reached\n         * @dev Notiy token contract about startTime to start transfers\n         */\n        if (totalTokensSoldandAllocated == hardCap) {\n            token.setStartTimeForTokenTransfers(now + 2 weeks);\n        }\n\n       /** @dev If its the first token sold or allocated then set s, allow after 2 weeks\n         * @dev Allow users to transfer tokens only after ICO crowdsale ends.\n         * @dev Notify token contract about sale end time\n         */\n        if (!isStartTimeSetForTokenTransfers) {\n            isStartTimeSetForTokenTransfers = true;\n            token.setStartTimeForTokenTransfers(endTime + 2 weeks);\n        }\n    }\n\n    /** @dev Internal function that is used to check if the incoming purchase should be accepted.\n      * @return True if the transaction can buy tokens\n      */\n    function validPurchase() internal view returns(bool) {\n        bool withinPeriod = now \u003e= startTime \u0026\u0026 now \u003c= endTime;\n        bool minimumPurchase = msg.value \u003e= 1*(10**18);\n        bool hardCapNotReached = totalTokensSoldandAllocated \u003c hardCap;\n        return withinPeriod \u0026\u0026 hardCapNotReached \u0026\u0026 minimumPurchase;\n    }\n\n    /** @dev Public function to check if Crowdsale isActive or not\n      * @return True if Crowdsale event has ended\n      */\n    function isCrowdsaleActive() public view returns(bool) {\n        if (!paused \u0026\u0026 now\u003estartTime \u0026\u0026 now\u003cendTime \u0026\u0026 totalTokensSoldandAllocated\u003c=hardCap){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /** @dev Gets the balance of the specified address.\n      * @param _owner The address to query the the balance of.\n      * @return An uint256 representing the amount owned by the passed address.\n      */\n    function balanceOfEtherInvestor(address _owner) external view returns(uint256 balance) {\n        require(_owner != address(0));\n        return etherInvestments[_owner];\n    }\n\n    function getTokensSoldToEtherInvestor(address _owner) public view returns(uint256 balance) {\n        require(_owner != address(0));\n        return tokensSoldForEther[_owner];\n    }\n\n    /** @dev Returns ether to token holders in case soft cap is not reached.\n      */\n    function claimRefund() public whenNotPaused onlyOwner {\n        require(now\u003eendTime);\n        require(totalTokensSoldandAllocated\u003csoft_cap);\n        uint256 amount = etherInvestments[msg.sender];\n\n        if (address(this).balance \u003e= amount) {\n            etherInvestments[msg.sender] = 0;\n            if (amount \u003e 0) {\n                msg.sender.transfer(amount);\n                emit Refund(msg.sender, amount);\n            }\n        }\n      }\n\n\n\n\n    /** @dev BELOW ARE FUNCTIONS THAT HANDLE INVESTMENTS IN FIAT AND BTC.\n      * functions are automatically called by ICO Sails.js app.\n      */\n\n\n    /** @dev Allocates EML tokens to an investor address called automatically\n      * after receiving fiat or btc investments from KYC whitelisted investors.\n      * @param beneficiary The address of the investor\n      * @param tokenCount The number of tokens to be allocated to this address\n      */\n    function allocateTokens(address beneficiary, uint256 tokenCount) public onlyOwner returns(bool success) {\n        require(beneficiary != address(0));\n        require(validAllocation(tokenCount));\n\n        uint256 tokens = tokenCount;\n\n        /* Allocate only the remaining tokens if final contribution exceeds hard cap */\n        if (totalTokensSoldandAllocated.add(tokens) \u003e hardCap) {\n            tokens = hardCap.sub(totalTokensSoldandAllocated);\n        }\n\n        /* Update state and balances */\n        allocatedTokens[beneficiary] = allocatedTokens[beneficiary].add(tokens);\n        totalTokensSoldandAllocated = totalTokensSoldandAllocated.add(tokens);\n        totalTokensAllocated = totalTokensAllocated.add(tokens);\n\n        // assert implies it should never fail\n        assert(token.transferFrom(owner, beneficiary, tokens));\n        emit TokensAllocated(beneficiary, tokens);\n\n        /* Update token contract. */\n        _postValidationUpdateTokenContract();\n        return true;\n    }\n\n    function validAllocation( uint256 tokenCount ) internal view returns(bool) {\n        bool withinPeriod = now \u003e= startTime \u0026\u0026 now \u003c= endTime;\n        bool positiveAllocation = tokenCount \u003e 0;\n        bool hardCapNotReached = totalTokensSoldandAllocated \u003c hardCap;\n        return withinPeriod \u0026\u0026 positiveAllocation \u0026\u0026 hardCapNotReached;\n    }\n\n\n    /** @dev Getter function to check the amount of allocated tokens\n      * @param beneficiary address of the investor\n      */\n    function getAllocatedTokens(address beneficiary) public view returns(uint256 tokenCount) {\n        require(beneficiary != address(0));\n        return allocatedTokens[beneficiary];\n    }\n\n    function getSoldandAllocatedTokens(address _addr) public view returns (uint256) {\n        require(_addr != address(0));\n        uint256 totalTokenCount = getAllocatedTokens(_addr).add(getTokensSoldToEtherInvestor(_addr));\n        return totalTokenCount;\n    }\n\n}\n"},"EmalPresale.sol":{"content":"pragma solidity 0.4.24;\n\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"./Pausable.sol\";\n\ncontract EmalToken {\n    // add function prototypes of only those used here\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\n    function getPresaleAmount() public view returns(uint256);\n}\n\ncontract EmalWhitelist {\n    // add function prototypes of only those used here\n    function isWhitelisted(address investorAddr) public view returns(bool whitelisted);\n}\n\n\ncontract EmalPresale is Ownable, Pausable {\n\n    using SafeMath for uint256;\n\n    // Start and end timestamps\n    uint256 public startTime;\n    uint256 public endTime;\n\n    // The token being sold\n    EmalToken public token;\n\n    // Whitelist contract used to store whitelisted addresses\n    EmalWhitelist public list;\n\n    // Address where funds are collected\n    address public multisigWallet;\n\n    // Hard cap in EMAL tokens\n    uint256 public hardCap;\n\n    // Amount of tokens that were sold to ether investors plus tokens allocated to investors for fiat and btc investments.\n    uint256 public totalTokensSoldandAllocated = 0;\n\n\n\n    // Investor contributions made in ether\n    mapping(address =\u003e uint256) public etherInvestments;\n\n    // Tokens given to investors who sent ether investments\n    mapping(address =\u003e uint256) public tokensSoldForEther;\n\n    // Total ether raised by the Presale\n    uint256 public totalEtherRaisedByPresale = 0;\n\n    // Total number of tokens sold to investors who made payments in ether\n    uint256 public totalTokensSoldByEtherInvestments = 0;\n\n    // Count of allocated tokens  for each investor or bounty user\n    mapping(address =\u003e uint256) public allocatedTokens;\n\n    // Count of total number of EML tokens that have been currently allocated to Presale investors\n    uint256 public totalTokensAllocated = 0;\n\n\n\n   /** @dev Event for EML token purchase using ether\n     * @param investorAddr Address that paid and got the tokens\n     * @param paidAmount The amount that was paid (in wei)\n     * @param tokenCount The amount of tokens that were bought\n     */\n    event TokenPurchasedUsingEther(address indexed investorAddr, uint256 paidAmount, uint256 tokenCount);\n\n    /** @dev Event fired when EML tokens are allocated to an investor account\n      * @param beneficiary Address that is allocated tokens\n      * @param tokenCount The amount of tokens that were allocated\n      */\n    event TokensAllocated(address indexed beneficiary, uint256 tokenCount);\n    event TokensDeallocated(address indexed beneficiary, uint256 tokenCount);\n\n\n    /** @dev variables and functions which determine conversion rate from ETH to EML\n      * based on bonuses and current timestamp.\n      */\n    uint256 priceOfEthInUSD = 450;\n    uint256 bonusPercent1 = 35;\n    uint256 priceOfEMLTokenInUSDPenny = 60;\n    uint256 overridenBonusValue = 0;\n\n    function setExchangeRate(uint256 overridenValue) public onlyOwner returns(bool) {\n        require( overridenValue \u003e 0 );\n        require( overridenValue != priceOfEthInUSD);\n        priceOfEthInUSD = overridenValue;\n        return true;\n    }\n\n    function getExchangeRate() public view returns(uint256){\n        return priceOfEthInUSD;\n    }\n\n    function setOverrideBonus(uint256 overridenValue) public onlyOwner returns(bool) {\n        require( overridenValue \u003e 0 );\n        require( overridenValue != overridenBonusValue);\n        overridenBonusValue = overridenValue;\n        return true;\n    }\n\n    /** @dev public function that is used to determine the current rate for ETH to EML conversion\n      * @return The current token rate\n      */\n    function getRate() public view returns(uint256) {\n        require(priceOfEMLTokenInUSDPenny \u003e 0 );\n        require(priceOfEthInUSD \u003e 0 );\n        uint256 rate;\n\n        if(overridenBonusValue \u003e 0){\n            rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(overridenBonusValue.add(100)).div(100);\n        } else {\n            rate = priceOfEthInUSD.mul(100).div(priceOfEMLTokenInUSDPenny).mul(bonusPercent1.add(100)).div(100);\n        }\n        return rate;\n    }\n\n\n    /** @dev Initialise the Presale contract.\n      * (can be removed for testing) _startTime Unix timestamp for the start of the token sale\n      * (can be removed for testing) _endTime Unix timestamp for the end of the token sale\n      * @param _multisigWallet Ethereum address to which the invested funds are forwarded\n      * @param _token Address of the token that will be rewarded for the investors\n      * @param _list contains a list of investors who completed KYC procedures.\n      */\n    constructor(uint256 _startTime, uint256 _endTime, address _multisigWallet, address _token, address _list) public {\n        require(_startTime \u003e= now);\n        require(_endTime \u003e= _startTime);\n        require(_multisigWallet != address(0));\n        require(_token != address(0));\n        require(_list != address(0));\n\n        startTime = _startTime;\n        endTime = _endTime;\n        multisigWallet = _multisigWallet;\n        owner = msg.sender;\n        token = EmalToken(_token);\n        list = EmalWhitelist(_list);\n        hardCap = token.getPresaleAmount();\n    }\n\n    /** @dev Fallback function that can be used to buy tokens.\n      */\n    function() external payable {\n        if (list.isWhitelisted(msg.sender)) {\n            buyTokensUsingEther(msg.sender);\n        } else {\n            /* Do not accept ETH */\n            revert();\n        }\n    }\n\n    /** @dev Function for buying EML tokens using ether\n      * @param _investorAddr The address that should receive bought tokens\n      */\n    function buyTokensUsingEther(address _investorAddr) internal whenNotPaused {\n        require(_investorAddr != address(0));\n        require(validPurchase());\n\n        uint256 weiAmount = msg.value;\n        uint256 returnToSender = 0;\n\n        // final rate after including rate value and bonus amount.\n        uint256 finalConversionRate = getRate();\n\n        // Calculate EML token amount to be transferred\n        uint256 tokens = weiAmount.mul(finalConversionRate);\n\n        // Distribute only the remaining tokens if final contribution exceeds hard cap\n        if (totalTokensSoldandAllocated.add(tokens) \u003e hardCap) {\n            tokens = hardCap.sub(totalTokensSoldandAllocated);\n            weiAmount = tokens.div(finalConversionRate);\n            returnToSender = msg.value.sub(weiAmount);\n        }\n\n        // update state and balances\n        etherInvestments[_investorAddr] = etherInvestments[_investorAddr].add(weiAmount);\n        tokensSoldForEther[_investorAddr] = tokensSoldForEther[_investorAddr].add(tokens);\n        totalTokensSoldByEtherInvestments = totalTokensSoldByEtherInvestments.add(tokens);\n        totalEtherRaisedByPresale = totalEtherRaisedByPresale.add(weiAmount);\n        totalTokensSoldandAllocated = totalTokensSoldandAllocated.add(tokens);\n\n\n        // assert implies it should never fail\n        assert(token.transferFrom(owner, _investorAddr, tokens));\n        emit TokenPurchasedUsingEther(_investorAddr, weiAmount, tokens);\n\n        // Forward funds\n        multisigWallet.transfer(weiAmount);\n\n        // Return funds that are over hard cap\n        if (returnToSender \u003e 0) {\n            msg.sender.transfer(returnToSender);\n        }\n    }\n\n    /**\n     * @dev Internal function that is used to check if the incoming purchase should be accepted.\n     * @return True if the transaction can buy tokens\n     */\n    function validPurchase() internal view returns(bool) {\n        bool withinPeriod = now \u003e= startTime \u0026\u0026 now \u003c= endTime;\n        bool minimumPurchase = msg.value \u003e= 1*(10**18);\n        bool hardCapNotReached = totalTokensSoldandAllocated \u003c hardCap;\n        return withinPeriod \u0026\u0026 hardCapNotReached \u0026\u0026 minimumPurchase;\n    }\n\n    /** @dev Public function to check if Presale isActive or not\n      * @return True if Presale event has ended\n      */\n    function isPresaleActive() public view returns(bool) {\n        if (!paused \u0026\u0026 now\u003estartTime \u0026\u0026 now\u003cendTime \u0026\u0026 totalTokensSoldandAllocated\u003c=hardCap){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /** @dev Gets the balance of the specified address.\n      * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOfEtherInvestor(address _owner) external view returns(uint256 balance) {\n        require(_owner != address(0));\n        return etherInvestments[_owner];\n    }\n\n    function getTokensSoldToEtherInvestor(address _owner) public view returns(uint256 balance) {\n        require(_owner != address(0));\n        return tokensSoldForEther[_owner];\n    }\n\n\n\n\n    /** @dev BELOW ARE FUNCTIONS THAT HANDLE INVESTMENTS IN FIAT AND BTC.\n      * functions are automatically called by ICO Sails.js app.\n      */\n\n\n    /** @dev Allocates EML tokens to an investor address called automatically\n      * after receiving fiat or btc investments from KYC whitelisted investors.\n      * @param beneficiary The address of the investor\n      * @param tokenCount The number of tokens to be allocated to this address\n      */\n    function allocateTokens(address beneficiary, uint256 tokenCount) public onlyOwner returns(bool success) {\n        require(beneficiary != address(0));\n        require(validAllocation(tokenCount));\n\n        uint256 tokens = tokenCount;\n\n        /* Allocate only the remaining tokens if final contribution exceeds hard cap */\n        if (totalTokensSoldandAllocated.add(tokens) \u003e hardCap) {\n            tokens = hardCap.sub(totalTokensSoldandAllocated);\n        }\n\n        /* Update state and balances */\n        allocatedTokens[beneficiary] = allocatedTokens[beneficiary].add(tokens);\n        totalTokensSoldandAllocated = totalTokensSoldandAllocated.add(tokens);\n        totalTokensAllocated = totalTokensAllocated.add(tokens);\n\n        // assert implies it should never fail\n        assert(token.transferFrom(owner, beneficiary, tokens));\n        emit TokensAllocated(beneficiary, tokens);\n\n        return true;\n    }\n\n    function validAllocation( uint256 tokenCount ) internal view returns(bool) {\n        bool withinPeriod = now \u003e= startTime \u0026\u0026 now \u003c= endTime;\n        bool positiveAllocation = tokenCount \u003e 0;\n        bool hardCapNotReached = totalTokensSoldandAllocated \u003c hardCap;\n        return withinPeriod \u0026\u0026 positiveAllocation \u0026\u0026 hardCapNotReached;\n    }\n\n\n    /** @dev Getter function to check the amount of allocated tokens\n      * @param beneficiary address of the investor\n      */\n    function getAllocatedTokens(address beneficiary) public view returns(uint256 tokenCount) {\n        require(beneficiary != address(0));\n        return allocatedTokens[beneficiary];\n    }\n\n    function getSoldandAllocatedTokens(address _addr) public view returns (uint256) {\n        require(_addr != address(0));\n        uint256 totalTokenCount = getAllocatedTokens(_addr).add(getTokensSoldToEtherInvestor(_addr));\n        return totalTokenCount;\n    }\n\n}\n"},"EmalToken.sol":{"content":"pragma solidity 0.4.24;\n\nimport \"./SafeMath.sol\";\nimport \u0027./StandardToken.sol\u0027;\nimport \u0027./Ownable.sol\u0027;\n\ncontract EmalToken is StandardToken, Ownable {\n\n    using SafeMath for uint256;\n\n    string public constant symbol = \"EML\";\n    string public constant name = \"e-Mal Token\";\n    uint8 public constant decimals = 18;\n\n    // Total Number of tokens ever goint to be minted. 1 BILLION EML tokens.\n    uint256 private constant minting_capped_amount = 1000000000 * 10 ** uint256(decimals);\n\n    // 24% of initial supply\n    uint256 constant presale_amount = 120000000 * 10 ** uint256(decimals);\n    // 60% of inital supply\n    uint256 constant crowdsale_amount = 300000000 * 10 ** uint256(decimals);\n    // 8% of inital supply.\n    uint256  constant vesting_amount = 40000000 * 10 ** uint256(decimals);\n    // 8% of inital supply.\n    uint256 constant bounty_amount = 40000000 * 10 ** uint256(decimals);\n    \n    uint256 private initialSupply = minting_capped_amount;\n\n    address public presaleAddress;\n    address public crowdsaleAddress;\n    address public vestingAddress;\n    address public bountyAddress;\n\n\n\n    /** @dev Defines the start time after which transferring of EML tokens\n      * will be allowed done so as to prevent early buyers from clearing out\n      * of their EML balance during the presale and publicsale.\n      */\n    uint256 public startTimeForTransfers;\n\n    /** @dev to cap the total number of tokens that will ever be newly minted\n      * owner has to stop the minting by setting this variable to true.\n      */\n    bool public mintingFinished = false;\n\n    /** @dev Miniting Essentials functions as per OpenZeppelin standards\n      */\n    modifier canMint() {\n      require(!mintingFinished);\n      _;\n    }\n    modifier hasMintPermission() {\n      require(msg.sender == owner);\n      _;\n    }\n\n    /** @dev to prevent malicious use of EML tokens and to comply with Anti\n      * Money laundering regulations EML tokens can be frozen.\n      */\n    mapping (address =\u003e bool) public frozenAccount;\n\n    /** @dev This generates a public event on the blockchain that will notify clients\n      */\n    event FrozenFunds(address target, bool frozen);\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n    event Burn(address indexed burner, uint256 value);\n\n\n    constructor() public {\n        startTimeForTransfers = now - 210 days;\n\n        _totalSupply = initialSupply;\n        owner = msg.sender;\n        balances[owner] = _totalSupply;\n        emit Transfer(address(0), owner, balances[owner]);\n    }\n\n    /* Do not accept ETH */\n    function() public payable {\n        revert();\n    }\n\n\n    /** @dev Basic setters and getters to allocate tokens for vesting factory, presale\n      * crowdsale and bounty this is done so that no need of actually transferring EML\n      * tokens to sale contracts and hence preventing EML tokens from the risk of being\n      * locked out in future inside the subcontracts.\n      */\n    function setPresaleAddress(address _presaleAddress) external onlyOwner {\n        presaleAddress = _presaleAddress;\n        assert(approve(presaleAddress, presale_amount));\n    }\n    function setCrowdsaleAddress(address _crowdsaleAddress) external onlyOwner {\n        crowdsaleAddress = _crowdsaleAddress;\n        assert(approve(crowdsaleAddress, crowdsale_amount));\n    }\n    function setVestingAddress(address _vestingAddress) external onlyOwner {\n        vestingAddress = _vestingAddress;\n        assert(approve(vestingAddress, vesting_amount));\n    }\n    function setBountyAddress(address _bountyAddress) external onlyOwner {\n        bountyAddress = _bountyAddress;\n        assert(approve(bountyAddress, bounty_amount));\n    }\n    \n\n\n    function getPresaleAmount()  internal pure returns(uint256) {\n        return presale_amount;\n    }\n    function getCrowdsaleAmount() internal pure  returns(uint256) {\n        return crowdsale_amount;\n    }\n    function getVestingAmount() internal pure  returns(uint256) {\n        return vesting_amount;\n    }\n    function getBountyAmount() internal pure  returns(uint256) {\n        return bounty_amount;\n    }\n\n    /** @dev Sets the start time after which transferring of EML tokens\n      * will be allowed done so as to prevent early buyers from clearing out\n      * of their EML balance during the presale and publicsale.\n      */\n    function setStartTimeForTokenTransfers(uint256 _startTimeForTransfers) external {\n        require(msg.sender == crowdsaleAddress);\n        if (_startTimeForTransfers \u003c startTimeForTransfers) {\n            startTimeForTransfers = _startTimeForTransfers;\n        }\n    }\n\n\n    /** @dev Transfer possible only after ICO ends and Frozen accounts\n      * wont be able to transfer funds to other any other account and viz.\n      * @notice added safeTransfer functionality\n      */\n    function transfer(address _to, uint256 _value) public returns(bool) {\n        require(now \u003e= startTimeForTransfers);\n        require(!frozenAccount[msg.sender]);\n        require(!frozenAccount[_to]);\n\n        require(super.transfer(_to, _value));\n        return true;\n    }\n\n    /** @dev Only owner\u0027s tokens can be transferred before Crowdsale ends.\n      * beacuse the inital supply of EML is allocated to owners acc and later\n      * distributed to various subcontracts.\n      * @notice added safeTransferFrom functionality\n      */\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {\n        require(!frozenAccount[_from]);\n        require(!frozenAccount[_to]);\n        require(!frozenAccount[msg.sender]);\n\n        if (now \u003c startTimeForTransfers) {\n            require(_from == owner);\n        }\n\n        require(super.transferFrom(_from, _to, _value));\n        return true;\n    }\n\n    /** @notice added safeApprove functionality\n      */\n    function approve(address spender, uint256 tokens) public returns (bool){\n        require(super.approve(spender, tokens));\n        return true;\n    }\n\n   /** @notice `freeze? Prevent | Allow` `target` from sending \u0026 receiving tokens\n     * @param target Address to be frozen\n     * @param freeze either to freeze it or not\n     */\n    function freezeAccount(address target, bool freeze) public onlyOwner {\n        require(frozenAccount[target] != freeze);\n\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n\n    /** @dev Function to mint tokens\n      * @param _to The address that will receive the minted tokens.\n      * @param _amount The amount of tokens to mint.\n      * @return A boolean that indicates if the operation was successful.\n      */\n    function mint(address _to, uint256 _amount) public hasMintPermission canMint returns (bool) {\n      require(_totalSupply.add(_amount) \u003c= minting_capped_amount);\n\n      _totalSupply = _totalSupply.add(_amount);\n      balances[_to] = balances[_to].add(_amount);\n      emit Mint(_to, _amount);\n      emit Transfer(address(0), _to, _amount);\n      return true;\n    }\n\n   /** @dev Function to stop minting new tokens.\n     * @return True if the operation was successful.\n     */\n    function finishMinting() public onlyOwner canMint returns (bool) {\n      mintingFinished = true;\n      emit MintFinished();\n      return true;\n    }\n\n    /** @dev Burns a specific amount of tokens.\n      * @param _value The amount of token to be burned.\n      */\n     function burn(uint256 _value) public {\n       _burn(msg.sender, _value);\n     }\n\n     function _burn(address _who, uint256 _value) internal {\n       require(_value \u003c= balances[_who]);\n       // no need to require value \u003c= totalSupply, since that would imply the\n       // sender\u0027s balance is greater than the totalSupply, which *should* be an assertion failure\n\n       balances[_who] = balances[_who].sub(_value);\n       _totalSupply = _totalSupply.sub(_value);\n       emit Burn(_who, _value);\n       emit Transfer(_who, address(0), _value);\n     }\n}\n"},"EmalTokenVestingFactory.sol":{"content":"pragma solidity 0.4.24;\n\nimport \"./EmalToken.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\n\n/** @title StandardTokenVesting\n  * @dev A token holder contract that can release its token balance gradually like a\n  * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the owner.\n  */\ncontract StandardTokenVesting is Ownable {\n  using SafeMath for uint256;\n\n  event Released(uint256 amount);\n  event Revoked();\n\n  // beneficiary of tokens after they are released\n  address public beneficiary;\n\n  uint256 public cliff;\n  uint256 public start;\n  uint256 public duration;\n\n  bool public revocable;\n\n  mapping (address =\u003e uint256) public released;\n  mapping (address =\u003e bool) public revoked;\n\n\n  /** @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\n   * of the balance will have vested.\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\n   * @param _start the time (as Unix time) at which point vesting starts\n   * @param _duration duration in seconds of the period in which the tokens will vest\n   * @param _revocable whether the vesting is revocable or not\n   */\n  constructor(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\n    require(_beneficiary != address(0));\n    require(_cliff \u003c= _duration);\n\n    beneficiary = _beneficiary;\n    revocable = _revocable;\n    duration = _duration;\n    owner = msg.sender;\n    cliff = _start.add(_cliff);\n    start = _start;\n  }\n\n  /** @notice Transfers vested tokens to beneficiary.\n    * @param token ERC20 token which is being vested\n    */\n  function release(EmalToken token) public returns (bool){\n    uint256 unreleased = releasableAmount(token);\n    require(unreleased \u003e 0);\n    released[token] = released[token].add(unreleased);\n\n    token.transfer(beneficiary, unreleased);\n    emit Released(unreleased);\n    return true;\n  }\n\n  /** @notice Allows the owner to revoke the vesting. Tokens already vested\n    * remain in the contract, the rest are returned to the owner.\n    * @param token ERC20 token which is being vested\n    */\n  function revoke(EmalToken token) public onlyOwner returns(bool) {\n    require(revocable);\n    require(!revoked[token]);\n    uint256 balance = token.balanceOf(this);\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n\n    revoked[token] = true;\n    token.transfer(owner, refund);\n    emit Revoked();\n\n    return true;\n  }\n\n  /** @dev Calculates the amount that has already vested but hasn\u0027t been released yet.\n    * @param token ERC20 token which is being vested\n    */\n  function releasableAmount(EmalToken token) public view returns (uint256) {\n    return vestedAmount(token).sub(released[token]);\n  }\n\n  /** @dev Calculates the amount that has already vested.\n    * @param token Emal token which is being vested\n    */\n  function vestedAmount(EmalToken token) public view returns (uint256) {\n    uint256 currentBalance = token.balanceOf(this);\n    uint256 totalBalance = currentBalance.add(released[token]);\n\n    if (block.timestamp \u003c cliff) {\n      return 0;\n    } else if (block.timestamp \u003e= start.add(duration) || revoked[token]) {\n      return totalBalance;\n    } else {\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n    }\n  }\n}\n"},"EmalWhitelist.sol":{"content":"pragma solidity 0.4.24;\n\nimport \u0027./Ownable.sol\u0027;\n\n/** @notice This contract provides support for whitelisting addresses.\n * only whitelisted addresses are allowed to send ether and buy tokens\n * during preSale and Pulic crowdsale.\n * @dev after deploying contract, deploy Presale / Crowdsale contract using\n * EmalWhitelist address. To allow claim refund functionality and allow wallet\n * owner efatoora to send ether to Crowdsale contract for refunds add wallet\n * address to whitelist.\n */\ncontract EmalWhitelist is Ownable {\n\n    mapping(address =\u003e bool) whitelist;\n\n    event AddToWhitelist(address investorAddr);\n    event RemoveFromWhitelist(address investorAddr);\n\n\n    /** @dev Throws if operator is not whitelisted.\n     */\n    modifier onlyIfWhitelisted(address investorAddr) {\n        require(whitelist[investorAddr]);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /** @dev Returns if an address is whitelisted or not\n     */\n    function isWhitelisted(address investorAddr) public view returns(bool whitelisted) {\n        return whitelist[investorAddr];\n    }\n\n    /**\n     * @dev Adds an investor to whitelist\n     * @param investorAddr The address to user to be added to the whitelist, signifies that the user completed KYC requirements.\n     */\n    function addToWhitelist(address investorAddr) public onlyOwner returns(bool success) {\n        require(investorAddr!= address(0));\n        whitelist[investorAddr] = true;\n        return true;\n    }\n\n    /**\n     * @dev Removes an investor\u0027s address from whitelist\n     * @param investorAddr The address to user to be added to the whitelist, signifies that the user completed KYC requirements.\n     */\n    function removeFromWhitelist(address investorAddr) public onlyOwner returns(bool success) {\n        require(investorAddr!= address(0));\n        whitelist[investorAddr] = false;\n        return true;\n    }\n\n\n}\n"},"ERC20Token.sol":{"content":"pragma solidity 0.4.24;\n\ncontract ERC20Token {\n  function totalSupply() public constant returns (uint);\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\n  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n  function transfer(address to, uint256 tokens) public returns (bool success);\n  function approve(address spender, uint256 tokens) public returns (bool success);\n  function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n"},"Ownable.sol":{"content":"pragma solidity 0.4.24;\n\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n}\n"},"Pausable.sol":{"content":"pragma solidity 0.4.24;\n\nimport \"./Ownable.sol\";\n\n/* Pausable contract */\ncontract Pausable is Ownable {\n\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n    /** @dev Modifier to make a function callable only when the contract is not paused.\n      */\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /** @dev Modifier to make a function callable only when the contract is paused.\n      */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /** @dev called by the owner to pause, triggers stopped state\n      */\n    function pause() onlyOwner whenNotPaused public {\n        paused = true;\n        emit Pause();\n    }\n\n    /** @dev called by the owner to unpause, returns to normal state\n      */\n    function unpause() onlyOwner whenPaused public {\n        paused = false;\n        emit Unpause();\n    }\n\n}\n"},"SafeMath.sol":{"content":"pragma solidity 0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting \u0027a\u0027 not being zero, but the\n    // benefit is lost if \u0027b\u0027 is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c \u003e= a);\n    return c;\n  }\n}\n"},"StandardToken.sol":{"content":"pragma solidity 0.4.24;\n\nimport \u0027./ERC20Token.sol\u0027;\nimport \u0027./SafeMath.sol\u0027;\n\ncontract StandardToken is ERC20Token {\n\n  using SafeMath for uint256;\n\n  // Global variable to store total number of tokens passed from EmalToken.sol\n  uint256 _totalSupply;\n\n  mapping(address =\u003e uint256) balances;\n  mapping(address =\u003e mapping(address =\u003e uint256)) allowed;\n\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address tokenOwner) public view returns (uint256){\n        return balances[tokenOwner];\n  }\n\n\n\n  function transfer(address to, uint256 tokens) public returns (bool){\n      require(to != address(0));\n      require(tokens \u003e 0 \u0026\u0026 tokens \u003c= balances[msg.sender]);\n\n      balances[msg.sender] = balances[msg.sender].sub(tokens);\n      balances[to] = balances[to].add(tokens);\n      emit Transfer(msg.sender, to, tokens);\n      return true;\n  }\n\n  // Transfer tokens from one address to another\n  function transferFrom(address from, address to, uint256 tokens) public returns (bool success){\n      require(to != address(0));\n      require(tokens \u003e 0 \u0026\u0026 tokens \u003c= balances[from]);\n      require(tokens \u003c= allowed[from][msg.sender]);\n\n      balances[from] = balances[from].sub(tokens);\n      balances[to] = balances[to].add(tokens);\n      allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n      emit Transfer(from, to, tokens);\n\n      return true;\n  }\n\n  // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n  function approve(address spender, uint256 tokens) public returns (bool success){\n      allowed[msg.sender][spender] = tokens;\n      emit Approval(msg.sender, spender, tokens);\n      return true;\n  }\n\n  // Function to check the amount of tokens that an owner allowed to a spender.\n  function allowance(address tokenOwner, address spender) public view returns (uint256 remaining){\n      return allowed[tokenOwner][spender];\n  }\n\n  // Increase the amount of tokens that an owner allowed to a spender.\n  // approve should be called when allowed[spender] == 0.\n  // To increment allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\n  function increaseApproval(address spender, uint256 addedValue) public returns (bool) {\n    allowed[msg.sender][spender] = (allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n    return true;\n  }\n\n  // Decrease the amount of tokens that an owner allowed to a spender.\n  // approve should be called when allowed[spender] == 0.\n  // To decrement allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\n  function decreaseApproval(address spender, uint256 subtractedValue ) public returns (bool){\n    uint256 oldValue = allowed[msg.sender][spender];\n    if (subtractedValue \u003e= oldValue) {\n      allowed[msg.sender][spender] = 0;\n    } else {\n      allowed[msg.sender][spender] = oldValue.sub(subtractedValue);\n    }\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n    return true;\n  }\n\n}\n"},"StandardTokenVesting.sol":{"content":"pragma solidity 0.4.24;\n\nimport \"./EmalToken.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\n\n/** @title StandardTokenVesting\n  * @dev A token holder contract that can release its token balance gradually like a\n  * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the owner.\n  */\ncontract StandardTokenVesting is Ownable {\n  using SafeMath for uint256;\n\n  event Released(uint256 amount);\n  event Revoked();\n\n  // beneficiary of tokens after they are released\n  address public beneficiary;\n\n  uint256 public cliff;\n  uint256 public start;\n  uint256 public duration;\n\n  bool public revocable;\n\n  mapping (address =\u003e uint256) public released;\n  mapping (address =\u003e bool) public revoked;\n\n\n  /** @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\n   * of the balance will have vested.\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\n   * @param _start the time (as Unix time) at which point vesting starts\n   * @param _duration duration in seconds of the period in which the tokens will vest\n   * @param _revocable whether the vesting is revocable or not\n   */\n  constructor(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\n    require(_beneficiary != address(0));\n    require(_cliff \u003c= _duration);\n\n    beneficiary = _beneficiary;\n    revocable = _revocable;\n    duration = _duration;\n    owner = msg.sender;\n    cliff = _start.add(_cliff);\n    start = _start;\n  }\n\n  /** @notice Transfers vested tokens to beneficiary.\n    * @param token ERC20 token which is being vested\n    */\n  function release(EmalToken token) public returns (bool){\n    uint256 unreleased = releasableAmount(token);\n    require(unreleased \u003e 0);\n    released[token] = released[token].add(unreleased);\n\n    token.transfer(beneficiary, unreleased);\n    emit Released(unreleased);\n    return true;\n  }\n\n  /** @notice Allows the owner to revoke the vesting. Tokens already vested\n    * remain in the contract, the rest are returned to the owner.\n    * @param token ERC20 token which is being vested\n    */\n  function revoke(EmalToken token) public onlyOwner returns(bool) {\n    require(revocable);\n    require(!revoked[token]);\n    uint256 balance = token.balanceOf(this);\n    uint256 unreleased = releasableAmount(token);\n    uint256 refund = balance.sub(unreleased);\n\n    revoked[token] = true;\n    token.transfer(owner, refund);\n    emit Revoked();\n\n    return true;\n  }\n\n  /** @dev Calculates the amount that has already vested but hasn\u0027t been released yet.\n    * @param token ERC20 token which is being vested\n    */\n  function releasableAmount(EmalToken token) public view returns (uint256) {\n    return vestedAmount(token).sub(released[token]);\n  }\n\n  /** @dev Calculates the amount that has already vested.\n    * @param token Emal token which is being vested\n    */\n  function vestedAmount(EmalToken token) public view returns (uint256) {\n    uint256 currentBalance = token.balanceOf(this);\n    uint256 totalBalance = currentBalance.add(released[token]);\n\n    if (block.timestamp \u003c cliff) {\n      return 0;\n    } else if (block.timestamp \u003e= start.add(duration) || revoked[token]) {\n      return totalBalance;\n    } else {\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n    }\n  }\n}\n"}}