{{
  "language": "Solidity",
  "sources": {
    "contracts/Auction.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.9;\n\nimport { AuctionOwnable } from \"./utils/AuctionOwnable.sol\";\nimport { ERC165Checker } from \"./oz-simplified/ERC165Checker.sol\";\nimport { ECDSA } from \"./oz-simplified/ECDSA.sol\";\nimport { IEscrow } from \"./interfaces/IEscrow.sol\";\nimport { ISellerToken } from './interfaces/ISellerToken.sol';\nimport { ReentrancyGuard } from 'solmate/src/utils/ReentrancyGuard.sol';\n\nimport { Errors } from \"./library/errors/Errors.sol\";\n\nenum BidReturnValue {\n    Success,\n    BidTooLow,\n    AuctionClosed,\n    ExtendedBidding\n}\n\nenum AuctionStatus {\n    Closed,\n    Open,\n    InExtended,\n    Ended,\n    DoesntExist,\n    Cancelled\n}\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\ncontract Auction is AuctionOwnable, ReentrancyGuard {\n    event AuctionAdded(uint256 indexed auctionId, uint48 startTime, uint48 endTime, uint256 indexed claimId, uint256 indexed tokenId);\n    event AuctionChanged(uint256 indexed auctionId, uint48 startTime, uint48 endTime, uint256 indexed claimId);\n    event AuctionEnded(uint256 indexed auctionId, address indexed winner, uint128 indexed bid);\n    event AuctionAborted(uint256 indexed auctionId, bool indexed refunded, string reason);\n    event AuctionProceedsClaimed(uint256 indexed auctionId, address indexed seller, address recipient, uint128 indexed amount);\n    event AuctionLotClaimed(uint256 indexed auctionId, uint256 indexed claimId, address indexed winner, address recipient);\n    event AuctionClosed(uint256 indexed auctionId);\n    event AuctionInExtendedBidding(uint indexed auctionId);\n    event BidTooLow(uint256 indexed auctionId, uint128 indexed bid, uint128 indexed minHighBid);\n\n    event Bid(\n        uint256 indexed auctionId,\n        uint256 when,\n        address indexed bidder,\n        uint128 indexed amount\n    );\n\n    struct AuctionData {\n        uint256 claimId;\n\n        // token that grants seller claim rights to this auction\n        uint256 tokenId;\n\n        // when can bidding start\n        uint48 startTime;\n        // when is auction over\n        uint48 endTime;\n        // time in seconds that extended bidding lasts\n        uint32 extendedBiddingTime;\n        // how much does each bid have to increment over the last bid\n        uint64 minBidIncrement;\n        // is auction active (accepting bids)\n        bool active;\n        // has the winner claimed\n        bool claimed;\n        // was the auction cancelled\n        bool cancelled;\n        // basis points for buyer's premium\n        uint8 basis;\n\n        // high bidder\n        address highBidder;\n        // amount of high bid\n        uint64 highBid;\n        // last bid timestamp\n        // storing as a delta value so we can fit it in fewer bits, optimizing\n        // the cost of reading/writing it from storage\n        uint32 lastBidDelta;\n    }\n\n    IEscrow private _escrow;\n    ISellerToken public _sellerToken;\n\n    uint256 private _lastId;\n\n    mapping(uint256 => AuctionData) private _auctions;\n    mapping(uint256 => uint256) public _tokenAuctionMap;\n\n    bool private _requireAuctionVerification = true;\n\n    constructor() {\n        __Ownable_init();\n    }\n\n    // function initialize() public initializer {\n    // \t__Ownable_init();\n    // }\n\n    function setup(address escrow, address sellerToken_, bool requireAuctionVerification_) public onlyOwner {\n        if (!ERC165Checker.supportsInterface(escrow, type(IEscrow).interfaceId)) {\n            revert Errors.InterfaceNotSupported();\n        }\n        _escrow = IEscrow(escrow);\n        _requireAuctionVerification = requireAuctionVerification_;\n        _sellerToken = ISellerToken(sellerToken_);\n    }\n\n    function addAuction(\n        uint48 startTime,\n        uint48 endTime,\n        uint32 extendedBiddingTime,\n        uint64 startBid,\n        uint64 increment,\n        uint8 basis,\n        uint256 claimId,\n        address seller\n    ) public onlyAuctioneer nonReentrant {\n        if (endTime < block.timestamp) {\n            revert Errors.OutOfRange(endTime);\n        }\n\n        uint256 auctionId = ++_lastId;\n        uint256 tokenId = _sellerToken.mint(seller, auctionId);\n\n        _auctions[ auctionId ] = AuctionData({\n            claimId: claimId,\n            tokenId: tokenId,\n            startTime: startTime,\n            endTime: endTime,\n            extendedBiddingTime: extendedBiddingTime,\n            minBidIncrement: increment,\n            active: true,\n            basis: basis,\n            lastBidDelta: uint32(0),\n            highBidder: address(0),\n            highBid: startBid,\n            claimed: false,\n            cancelled: false\n        });\n        emit AuctionAdded(auctionId, startTime, endTime, claimId, tokenId);\n    }\n\n    function editAuction(\n        uint256 auctionId,\n        uint48 startTime,\n        uint48 endTime,\n        uint32 extendedBiddingTime,\n        uint64 increment,\n        uint8 basis,\n        uint256 claimId\n    ) public onlyAuctioneer {\n        _auctions[auctionId].startTime = startTime;\n        _auctions[auctionId].endTime = endTime;\n        _auctions[auctionId].extendedBiddingTime = extendedBiddingTime;\n        _auctions[auctionId].minBidIncrement = increment;\n        _auctions[auctionId].basis = basis;\n        _auctions[auctionId].claimId = claimId;\n\n        emit AuctionChanged(auctionId, startTime, endTime, claimId);\n    }\n\n    function abortAuction(uint256 auctionId, bool issueRefund, string memory reason) public onlyAuctioneer {\n        _auctions[auctionId].active = false;\n        _auctions[auctionId].cancelled = true;\n        _sellerToken.burn(_auctions[auctionId].tokenId);\n        if (issueRefund) {\n            address highBidder = _auctions[auctionId].highBidder;\n            if (highBidder != address(0)) {\n                uint8 basis = _auctions[auctionId].basis;\n                uint256 premium = basis == 0 ? 0 : _auctions[auctionId].highBid * basis / 100;\n                _escrow.withdraw(highBidder, _auctions[auctionId].highBid + premium);\n            }\n        }\n        emit AuctionAborted(auctionId, issueRefund, reason);\n    }\n\n    function claimLot(uint256 auctionId, address deliverTo) public nonReentrant {\n        AuctionData storage auction = _auctions[ auctionId ];\n        if (_requireAuctionVerification) {\n            if ( auction.active ) {\n                revert Errors.AuctionActive(auctionId);\n            }\n        }\n\n        if (block.timestamp < auction.endTime + 1) {\n            revert Errors.AuctionActive(auctionId);\n        }\n\n        if (_auctionInExtendedBidding(auction)) {\n            revert Errors.AuctionActive(auctionId);\n        }\n\n        if (auction.cancelled) {\n            revert Errors.AuctionAborted(auctionId);\n        }\n\n        if (auction.claimed) {\n            revert Errors.AlreadyClaimed(auctionId);\n        }\n\n        if (_msgSender() != auction.highBidder) {\n            revert Errors.BadSender(auction.highBidder, _msgSender());\n        }\n\n        if (false == _requireAuctionVerification) {\n            _escrow.authorizeClaim(auction.claimId, auction.highBidder);\n        }\n        auction.claimed = true;\n        _escrow.claimFor(_msgSender(), auction.claimId, deliverTo);\n        emit AuctionLotClaimed(auctionId, auction.claimId, _msgSender(), deliverTo);\n    }\n\n    function claimProceeds(uint256 auctionId, address deliverTo) public nonReentrant {\n        AuctionData storage auction = _auctions[ auctionId ];\n\n        if (_requireAuctionVerification) {\n            if ( true == auction.active ) {\n                revert Errors.AuctionActive(auctionId);\n            }\n        }\n\n        if (block.timestamp < auction.endTime + 1) {\n            revert Errors.AuctionActive(auctionId);\n        }\n\n        if (_auctionInExtendedBidding(auction)) {\n            revert Errors.AuctionActive(auctionId);\n        }\n\n        if (auction.cancelled) {\n            revert Errors.AuctionAborted(auctionId);\n        }\n\n        address tokenOwner = _sellerToken.ownerOf(auction.tokenId);\n\n        if ( _msgSender() != tokenOwner) {\n            revert Errors.BadSender(tokenOwner, _msgSender());\n        }\n\n        _sellerToken.burn(auction.tokenId);\n        _escrow.withdraw(deliverTo, auction.highBid);\n        emit AuctionProceedsClaimed(auctionId, _msgSender(), deliverTo, auction.highBid);\n    }\n\n    function confirmAuctions(uint256[] calldata auctionIds, address[] calldata premiumRecipients) public nonReentrant onlyAuctioneer {\n        uint256 auctionLength = auctionIds.length;\n        if (auctionLength != premiumRecipients.length) {\n            revert Errors.ArrayMismatch();\n        }\n\n        for (uint i = 0; i < auctionLength;) {\n            confirmAuction(auctionIds[ i ], premiumRecipients[ i ]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function confirmAuction(uint256 auctionId, address premiumRecipient) public nonReentrant onlyAuctioneer {\n        AuctionData storage auction = _auctions[auctionId];\n\n        if (block.timestamp < auction.endTime + 1) {\n            revert Errors.AuctionActive(auctionId);\n        }\n\n        if (_auctionInExtendedBidding(auction)) {\n            revert Errors.AuctionActive(auctionId);\n        }\n\n        if (auction.cancelled) {\n            revert Errors.AuctionAborted(auctionId);\n        }\n\n        // require auctions to be active to call this method, so we don't\n        // double-widthdraw the buyer premium\n        if (false == auction.active) {\n            revert Errors.AuctionInactive(auctionId);\n        }\n\n        auction.active = false;\n        emit AuctionEnded(auctionId, auction.highBidder, auction.highBid);\n\n        if (auction.highBidder != address(0)) {\n            if (false == auction.claimed && _requireAuctionVerification) {\n                _escrow.authorizeClaim(auction.claimId, auction.highBidder);\n            }\n\n            if (auction.basis > 0) {\n                if (address(0) == premiumRecipient) {\n                    revert Errors.AddressTarget(premiumRecipient);\n                }\n\n                _escrow.withdraw(premiumRecipient, auction.highBid * auction.basis / 100);\n            }\n        }\n    }\n\n    function getAuctionMetadata(uint256 auctionId) public view returns (AuctionData memory) {\n        return _auctions[auctionId];\n    }\n\n    function bid(\n        uint256 auctionId,\n        uint64 amount,\n        bool revertOnFail\n    ) public nonReentrant {\n        _bid(_msgSender(), auctionId, amount, revertOnFail);\n    }\n\n    function multiBid(\n        uint256[] memory auctionIds,\n        uint64[] memory amounts,\n        bool revertOnFail\n    ) public nonReentrant {\n        uint256 arrayLength = auctionIds.length;\n        if (arrayLength != amounts.length) {\n            revert Errors.ArrayMismatch();\n        }\n\n        address bidder = _msgSender();\n\n        for (uint256 i = 0; i < arrayLength;) {\n            _bid(bidder, auctionIds[i], amounts[i], revertOnFail);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function auctionStatus(uint256 auctionId) public view returns(AuctionStatus) {\n        AuctionData storage a = _auctions[ auctionId ];\n\n        if (a.startTime == 0) {\n            return AuctionStatus.DoesntExist;\n        }\n\n        if (a.cancelled) {\n            return AuctionStatus.Cancelled;\n        }\n\n        if (block.timestamp < a.startTime) {\n            return AuctionStatus.Closed;\n        }\n\n        if (block.timestamp < a.endTime + 1) {\n            return AuctionStatus.Open;\n        }\n\n        if (_auctionInExtendedBidding(a)) {\n            return AuctionStatus.InExtended;\n        }\n\n        return AuctionStatus.Ended;\n    }\n\n    /**\n     *  ================== INTERNAL METHODS ====================\n     */\n\n    function _bid(\n        address bidder,\n        uint256 auctionId,\n        uint64 amount,\n        bool revertOnError\n    ) internal returns (BidReturnValue) {\n        uint256 timestamp = block.timestamp;\n        AuctionData storage auction = _auctions[ auctionId ];\n        if (timestamp > auction.endTime) {\n            if ( false == _auctionInExtendedBidding(auction)) {\n               // auction is over\n                if (revertOnError) {\n                    revert Errors.AuctionClosed(auctionId);\n                }\n\n                emit AuctionClosed(auctionId);\n                return BidReturnValue.AuctionClosed;\n            }\n        }\n\n        if (false == auction.active) {\n            if (revertOnError) {\n                revert Errors.AuctionClosed(auctionId);\n            }\n\n            emit AuctionClosed(auctionId);\n            return BidReturnValue.AuctionClosed;\n        }\n\n        if (timestamp < auction.startTime) {\n            if (revertOnError) {\n                revert Errors.AuctionClosed(auctionId);\n            }\n\n            emit AuctionClosed(auctionId);\n            return BidReturnValue.AuctionClosed;\n        }\n\n        uint64 previousAmount = auction.highBid;\n\n        // bid is too low\n        if (amount < previousAmount + auction.minBidIncrement) {\n            if (revertOnError) {\n                revert Errors.BidTooLow(auctionId, amount, previousAmount + auction.minBidIncrement);\n            }\n\n            emit BidTooLow(auctionId, amount, previousAmount + auction.minBidIncrement);\n            return BidReturnValue.BidTooLow;\n        }\n\n        uint256 premium = auction.basis == 0 ? 0 : amount * auction.basis / 100;\n\n        _escrow.deposit(bidder, amount + premium);\n        address prevBidder = auction.highBidder;\n        if (prevBidder != address(0)) {\n            uint256 prevPremium = auction.basis == 0 ? 0 : previousAmount * auction.basis / 100;\n            _escrow.withdraw(prevBidder, previousAmount + prevPremium);\n        }\n\n        /**\n         * There needs to be 2 bidders on a Lot to send it into extended bidding\n         * when no bids, bidder == 0x0. first bidder != 0x0, so decrement required count\n         * if second bidder != first bidder, decrement required count\n         * once we get to zero, we know we'll be going into extended bidding.\n         */\n        // if (0 < auction.extendedBiddingTime) {\n        //     if (0 < auction.extBidRequiredBids) {\n        //         if (prevBidder != bidder) {\n        //             unchecked {\n        //                 // can't overflow, value checked to be above zero, above.\n        //                 --auction.extBidRequiredBids;\n        //             }\n        //         }\n        //     }\n        // }\n\n        auction.highBidder = bidder;\n        auction.highBid = amount;\n        // only write the bid-time delta if we're in extended bidding\n        // it's irrelevant, otherwise.\n        if (auction.endTime < timestamp) {\n            auction.lastBidDelta = uint32(timestamp - auction.endTime);\n        }\n\n        emit Bid(auctionId, timestamp, bidder, amount);\n        return BidReturnValue.Success;\n    }\n\n    function _auctionInExtendedBidding(AuctionData storage auction) internal view returns(bool) {\n        uint tmpEndTime = auction.endTime;\n        if (block.timestamp > auction.endTime) {\n            uint tmpExtTime = auction.extendedBiddingTime;\n            if (0 < tmpExtTime) {\n                uint extendedEndTime = tmpEndTime + tmpExtTime;\n                // uint tmpDelta = auction.lastBidDelta;\n                if (0 < auction.lastBidDelta) {\n                    extendedEndTime = tmpEndTime + auction.lastBidDelta + tmpExtTime;\n                }\n\n                /*\n                * auction is over if we're past the extended bidding time, no matter what\n                *\n                * or\n                *\n                * we require 2+ bids to enter extended bidding. so, if we're past the auction endTime (tested above)\n                * and we need more than 0 bids to enter extended bidding\n                * (required bids is decremented from 2 to 0 on the first two bids)\n                * then we never went into extended bidding, and thus, the auction is over\n                **/\n                if (block.timestamp > extendedEndTime) {\n                    // auction is over\n                    return false;\n                }\n\n                // if we get here, then current timestamp is between endTime and extendedEndTime\n                // and aucton.extBidRequireBids == 0\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either\n     * {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IEscrow.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.9;\n\ninterface IEscrow {\n    event Withdrawal(uint256 indexed amount, address indexed withdrawer);\n    event Deposit(uint256 indexed amount, address indexed depositer);\n    event ClaimAuthorized(uint256 indexed claimId, address indexed claimant);\n    event PrizeAdded(uint256 indexed claimId);\n    event PrizeRemoved(uint256 indexed claimId, address indexed recipient);\n    event PrizeReceived(uint256 indexed claimId, address indexed recipient);\n\n    function currencyBalance() external returns (uint256);\n\n    function deposit(address spender, uint256 amount) external;\n\n    function withdraw(address recipient, uint256 amount) external;\n\n    function authorizeClaim(uint256 claimId, address claimant) external;\n\n    function claimFor(address claimant, uint256 claimId, address recipient) external;\n}\n"
    },
    "contracts/interfaces/ISellerToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport './IERC721.sol';\n\ninterface ISellerToken is IERC721 {\n    function mint(address dest, uint256 tokenId) external returns (uint256);\n    function burn(uint256 tokenId) external;\n}\n"
    },
    "contracts/library/errors/Errors.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.8.4 <0.9.0;\n\nlibrary Errors {\n    error LinkError();\n    error ArrayMismatch();\n    error OutOfRange(uint256 value);\n    error OutOfRangeSigned(int256 value);\n    error UnsignedOverflow(uint256 value);\n    error SignedOverflow(int256 value);\n    error DuplicateCall();\n\n    error NotAContract();\n    error InterfaceNotSupported();\n    error NotInitialized();\n    error AlreadyInitialized();\n    error BadSender(address expected, address caller);\n    error AddressTarget(address target);\n    error UserPermissions();\n\n    error InvalidHash();\n    error InvalidSignature();\n    error InvalidSignatureLength();\n    error InvalidSignatureS();\n\n    error InsufficientBalance(uint256 available, uint256 required);\n    error InsufficientSupply(uint256 supply, uint256 available, int256 requested);  // 0x5437b336\n    error InsufficientAvailable(uint256 available, uint256 requested);\n    error InvalidToken(uint256 tokenId);                                            // 0x925d6b18\n    error TokenNotMintable(uint256 tokenId);\n    error InvalidTokenType();\n\n    error ERC1155Receiver();\n\n    error ContractPaused();\n\n    error PaymentFailed(uint256 amount);\n    error IncorrectPayment(uint256 required, uint256 provided);                     // 0x0d35e921\n\terror TooManyForTransaction(uint256 mintLimit, uint256 amount);\n\n    error AuctionInactive(uint256 auctionId);\n    error AuctionActive(uint256 auctionId);\n    error InvalidBid(uint256 auctionId, uint256 amount);\n    error BidTooLow(uint256 auctionId, uint256 bid, uint256 minBid);\n    error AuctionClosed(uint256 auctionId);\n    error AuctionInExtendedBidding(uint256 auctionId);\n    error AuctionAborted(uint256 auctionId);\n\n    error AlreadyClaimed(uint256 lotId);\n}\n"
    },
    "contracts/oz-simplified/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\nimport { Initializable } from \"./Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/oz-simplified/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport { Errors } from \"../library/errors/Errors.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert Errors.InvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert Errors.InvalidSignatureLength();\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert Errors.InvalidSignatureS();\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/oz-simplified/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "contracts/oz-simplified/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4 <0.9.0;\n\nimport { Errors } from \"../library/errors/Errors.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n        if (!_initializing && _initialized) revert Errors.AlreadyInitialized();\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/utils/AuctionOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4 <0.9.0;\n\nimport { Context } from \"../oz-simplified/Context.sol\";\nimport { Initializable } from \"../oz-simplified/Initializable.sol\";\n\nimport { Errors } from \"../library/errors/Errors.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there are two accounts (an owner and a proxy) that can be granted exclusive\n * access to specific functions. Only the owner can set the proxy.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract AuctionOwnable is Initializable, Context {\n    address private _owner;\n    address private _auctioneer;\n    address private _broker;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    // /**\n    //  * @dev Returns the address of the current auctioneer.\n    //  */\n    // function auctioneer() public view virtual returns (address) {\n    //     return _auctioneer;\n    // }\n\n    // /**\n    //  * @dev Returns the address of the current broker.\n    //  */\n    // function broker() public view virtual returns (address) {\n    //     return _broker;\n    // }\n\n    /**\n     * @dev Returns true if the account has the auctioneer role.\n     */\n\n    function isAuctioneer(address account) public view virtual returns (bool) {\n        return account == _auctioneer;\n    }\n\n    /**\n     * @dev Returns true if the account has the broker role.\n     */\n\n    function isBroker(address account) public view virtual returns (bool) {\n        return account == _broker;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        if (_owner != _msgSender()) revert Errors.UserPermissions();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the auctioneer.\n     */\n    modifier onlyAuctioneer() {\n        if (\n            _auctioneer != _msgSender()\n            && _owner != _msgSender()\n        ) revert Errors.UserPermissions();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the broker.\n     */\n    modifier onlyBroker() {\n        if (\n            _broker != _msgSender()\n            && _owner != _msgSender()\n        ) revert Errors.UserPermissions();\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) revert Errors.AddressTarget(newOwner);\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Sets the auctioneer for the contract to a new account (`newAuctioneer`).\n     * Can only be called by the current owner.\n     */\n    function setAuctioneer(address newAuctioneer) public virtual onlyOwner {\n        _auctioneer = newAuctioneer;\n    }\n\n    /**\n     * @dev Sets the auctioneer for the contract to a new account (`newAuctioneer`).\n     * Can only be called by the current owner.\n     */\n    function setBroker(address newBroker) public virtual onlyOwner {\n        _broker = newBroker;\n    }\n\n    function _setOwner(address newOwner) internal {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}