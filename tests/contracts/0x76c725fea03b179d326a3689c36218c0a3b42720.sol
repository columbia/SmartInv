{{
  "language": "Solidity",
  "sources": {
    "contracts/EtherSwap.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.7.6;\n\nimport \"./TransferHelper.sol\";\n\n// @title Hash timelock contract for Ether\ncontract EtherSwap {\n    // State variables\n\n    /// @dev Version of the contract used for compatibility checks\n    uint8 constant public version = 2;\n\n    /// @dev Mapping between value hashes of swaps and whether they have Ether locked in the contract\n    mapping (bytes32 => bool) public swaps;\n\n    // Events\n\n    event Lockup(\n        bytes32 indexed preimageHash,\n        uint amount,\n        address claimAddress,\n        address indexed refundAddress,\n        uint timelock\n    );\n\n    event Claim(bytes32 indexed preimageHash, bytes32 preimage);\n    event Refund(bytes32 indexed preimageHash);\n\n    // Functions\n\n    // External functions\n\n    /// Locks Ether for a swap in the contract\n    /// @notice The amount locked is the Ether sent in the transaction and the refund address is the sender of the transaction\n    /// @param preimageHash Preimage hash of the swap\n    /// @param claimAddress Address that can claim the locked Ether\n    /// @param timelock Block height after which the locked Ether can be refunded\n    function lock(\n        bytes32 preimageHash,\n        address claimAddress,\n        uint timelock\n    ) external payable {\n        lockEther(preimageHash, msg.value, claimAddress, timelock);\n    }\n\n    /// Locks Ether for a swap in the contract and forwards a specified amount of Ether to the claim address\n    /// @notice The amount locked is the Ether sent in the transaction minus the prepay amount and the refund address is the sender of the transaction\n    /// @dev Make sure to set a reasonable gas limit for calling this function, else a malicious contract at the claim address could drain your Ether\n    /// @param preimageHash Preimage hash of the swap\n    /// @param claimAddress Address that can claim the locked Ether\n    /// @param timelock Block height after which the locked Ether can be refunded\n    /// @param prepayAmount Amount that should be forwarded to the claim address\n    function lockPrepayMinerfee(\n        bytes32 preimageHash,\n        address payable claimAddress,\n        uint timelock,\n        uint prepayAmount\n    ) external payable {\n        // Revert on underflow in next statement\n        require(msg.value > prepayAmount, \"EtherSwap: sent amount must be greater than the prepay amount\");\n\n        // Lock the amount of Ether sent minus the prepay amount in the contract\n        lockEther(preimageHash, msg.value - prepayAmount, claimAddress, timelock);\n\n        // Forward the prepay amount to the claim address\n        TransferHelper.transferEther(claimAddress, prepayAmount);\n    }\n\n    /// Claims Ether locked in the contract\n    /// @dev To query the arguments of this function, get the \"Lockup\" event logs for the SHA256 hash of the preimage\n    /// @param preimage Preimage of the swap\n    /// @param amount Amount locked in the contract for the swap in WEI\n    /// @param refundAddress Address that locked the Ether in the contract\n    /// @param timelock Block height after which the locked Ether can be refunded\n    function claim(\n        bytes32 preimage,\n        uint amount,\n        address refundAddress,\n        uint timelock\n    ) external {\n        // If the preimage is wrong, so will be its hash which will result in a wrong value hash and no swap being found\n        bytes32 preimageHash = sha256(abi.encodePacked(preimage));\n\n        // Passing \"msg.sender\" as \"claimAddress\" to \"hashValues\" ensures that only the destined address can claim\n        // All other addresses would produce a different hash for which no swap can be found in the \"swaps\" mapping\n        bytes32 hash = hashValues(\n            preimageHash,\n            amount,\n            msg.sender,\n            refundAddress,\n            timelock\n        );\n\n        // Make sure that the swap to be claimed has Ether locked\n        checkSwapIsLocked(hash);\n        // Delete the swap from the mapping to ensure that it cannot be claimed or refunded anymore\n        // This *HAS* to be done before actually sending the Ether to avoid reentrancy\n        delete swaps[hash];\n\n        // Emit the claim event\n        emit Claim(preimageHash, preimage);\n\n        // Transfer the Ether to the claim address\n        TransferHelper.transferEther(payable(msg.sender), amount);\n    }\n\n    /// Refunds Ether locked in the contract\n    /// @dev To query the arguments of this function, get the \"Lockup\" event logs for your refund address and the preimage hash if you have it\n    /// @dev For further explanations and reasoning behind the statements in this function, check the \"claim\" function\n    /// @param preimageHash Preimage hash of the swap\n    /// @param amount Amount locked in the contract for the swap in WEI\n    /// @param claimAddress Address that that was destined to claim the funds\n    /// @param timelock Block height after which the locked Ether can be refunded\n    function refund(\n        bytes32 preimageHash,\n        uint amount,\n        address claimAddress,\n        uint timelock\n    ) external {\n        // Make sure the timelock has expired already\n        // If the timelock is wrong, so will be the value hash of the swap which results in no swap being found\n        require(timelock <= block.number, \"EtherSwap: swap has not timed out yet\");\n\n        bytes32 hash = hashValues(\n            preimageHash,\n            amount,\n            claimAddress,\n            msg.sender,\n            timelock\n        );\n\n        checkSwapIsLocked(hash);\n        delete swaps[hash];\n\n        emit Refund(preimageHash);\n\n        TransferHelper.transferEther(payable(msg.sender), amount);\n    }\n\n    // Public functions\n\n    /// Hashes all the values of a swap with Keccak256\n    /// @param preimageHash Preimage hash of the swap\n    /// @param amount Amount the swap has locked in WEI\n    /// @param claimAddress Address that can claim the locked Ether\n    /// @param refundAddress Address that locked the Ether and can refund them\n    /// @param timelock Block height after which the locked Ether can be refunded\n    /// @return Value hash of the swap\n    function hashValues(\n        bytes32 preimageHash,\n        uint amount,\n        address claimAddress,\n        address refundAddress,\n        uint timelock\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            preimageHash,\n            amount,\n            claimAddress,\n            refundAddress,\n            timelock\n        ));\n    }\n\n    // Private functions\n\n    /// Locks Ether in the contract\n    /// @notice The refund address is the sender of the transaction\n    /// @param preimageHash Preimage hash of the swap\n    /// @param amount Amount to be locked in the contract\n    /// @param claimAddress Address that can claim the locked Ether\n    /// @param timelock Block height after which the locked Ether can be refunded\n    function lockEther(bytes32 preimageHash, uint amount, address claimAddress, uint timelock) private {\n        // Locking zero WEI in the contract is pointless\n        require(amount > 0, \"EtherSwap: locked amount must not be zero\");\n\n        // Hash the values of the swap\n        bytes32 hash = hashValues(\n            preimageHash,\n            amount,\n            claimAddress,\n            msg.sender,\n            timelock\n        );\n\n        // Make sure no swap with this value hash exists yet\n        require(swaps[hash] == false, \"EtherSwap: swap exists already\");\n\n        // Save to the state that funds were locked for this swap\n        swaps[hash] = true;\n\n        // Emit the \"Lockup\" event\n        emit Lockup(preimageHash, amount, claimAddress, msg.sender, timelock);\n    }\n\n    /// Checks whether a swap has Ether locked in the contract\n    /// @dev This function reverts if the swap has no Ether locked in the contract\n    /// @param hash Value hash of the swap\n    function checkSwapIsLocked(bytes32 hash) private view {\n        require(swaps[hash] == true, \"EtherSwap: swap has no Ether locked in the contract\");\n    }\n}\n"
    },
    "contracts/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// Copyright 2020 Uniswap team\n// Based on: https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\n\npragma solidity 0.7.6;\n\nlibrary TransferHelper {\n    /// Transfers Ether to an address\n    /// @dev This function reverts if transferring the Ether fails\n    /// @dev Please note that \".call\" forwards all leftover gas which means that sending Ether to accounts and contract is possible but also that you should specify or sanity check the gas limit\n    /// @param to Address to which the Ether should be sent\n    /// @param amount Amount of Ether to send in WEI\n    function transferEther(address payable to, uint amount) internal {\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"TransferHelper: could not transfer Ether\");\n    }\n\n    /// Transfers token to an address\n    /// @dev This function reverts if transferring the tokens fails\n    /// @dev This function supports non standard ERC20 tokens that have a \"transfer\" method that does not return a boolean\n    /// @param token Address of the token\n    /// @param to Address to which the tokens should be transferred\n    /// @param value Amount of token that should be transferred in the smallest denomination of the token\n    function safeTransferToken(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: could not transfer ERC20 tokens\"\n        );\n    }\n\n    /// Transfers token from one address to another\n    /// @dev This function reverts if transferring the tokens fails\n    /// @dev This function supports non standard ERC20 tokens that have a \"transferFrom\" method that does not return a boolean\n    /// @dev Keep in mind that \"transferFrom\" requires an allowance of the \"from\" address for the caller that is equal or greater than the \"value\"\n    /// @param token Address of the token\n    /// @param from Address from which the tokens should be transferred\n    /// @param to Address to which the tokens should be transferred\n    /// @param value Amount of token that should be transferred in the smallest denomination of the token\n    function safeTransferTokenFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: could not transferFrom ERC20 tokens\"\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "cse": true,
        "deduplicate": true,
        "orderLiterals": true,
        "constantOptimizer": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}