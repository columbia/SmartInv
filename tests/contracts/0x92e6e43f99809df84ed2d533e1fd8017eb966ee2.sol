{{
  "language": "Solidity",
  "sources": {
    "/contracts/AddressRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Votium Address Registry\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\ncontract AddressRegistry is Ownable {\n  struct Registry {\n    uint256 start;      // when first registering, there is a delay until the next vlCVX voting epoch starts\n    address to;         // forward rewards to alternate address OR 0x0 address for OPT OUT of rewards\n    uint256 expiration; // when ending an active registration, expiration is set to the next vlCVX voting epoch\n                        // an active registration cannot be changed until after it is expired (one vote round delay when changing active registration)\n  }\n  mapping(address => Registry) public registry;\n\n  mapping(address => bool) public inOptOutHistory;\n  mapping(address => bool) public inForwardHistory;\n  address[] public optOutHistory;\n  address[] public forwardHistory;\n\n  // address changes do not take effect until the next vote starts\n  uint256 public constant eDuration = 86400 * 14;\n\n\n  // Set forwarding address or OPT OUT of rewards by setting to 0x0 address\n  // Registration is active until setToExpire() is called, and then remains active until the next reward period\n  function setRegistry(address _to) public {\n    uint256 current = currentEpoch();\n    require(registry[msg.sender].start == 0 || registry[msg.sender].expiration <= current,\"Registration is still active\");\n    registry[msg.sender].start = current+eDuration;\n    registry[msg.sender].to = _to;\n    registry[msg.sender].expiration = 0xfffffffff;\n    if(_to == address(0)) {\n      // prevent duplicate entry in optOutHistory array\n      if(!inOptOutHistory[msg.sender]) {\n        optOutHistory.push(msg.sender);\n        inOptOutHistory[msg.sender] = true;\n      }\n    } else if(!inForwardHistory[msg.sender]) {\n        forwardHistory.push(msg.sender);\n        inForwardHistory[msg.sender] = true;\n    }\n    emit setReg(msg.sender, _to, registry[msg.sender].start);\n  }\n\n  // Sets a registration to expire on the following epoch (cannot change registration during an epoch)\n  function setToExpire() public {\n    uint256 next = nextEpoch();\n    require(registry[msg.sender].start > 0 && registry[msg.sender].expiration > next,\"Not registered or expiration already pending\");\n    // if not started yet, nullify instead of setting expiration\n    if(next == registry[msg.sender].start) {\n      registry[msg.sender].start = 0;\n      registry[msg.sender].to = address(0);\n    } else {\n      registry[msg.sender].expiration = next;\n    }\n    emit expReg(msg.sender, next);\n  }\n\n  // supply an array of addresses, returns their destination (same address for no change, 0x0 for opt-out, different address for forwarding)\n  function batchAddressCheck(address[] memory accounts) external view returns (address[] memory) {\n    uint256 current = currentEpoch();\n    for(uint256 i=0; i<accounts.length; i++) {\n      // if registration active return \"to\", otherwise return checked address (no forwarding)\n      if(registry[accounts[i]].start <= current && registry[accounts[i]].start != 0 && registry[accounts[i]].expiration > current) {\n        accounts[i] = registry[accounts[i]].to;\n      }\n    }\n    return accounts;\n  }\n\n  // length of optOutHistory - needed for retrieving paginated results from optOutPage()\n  function optOutLength() public view returns (uint256) {\n    return optOutHistory.length;\n  }\n\n  // returns list of actively opted-out addresses using pagination\n  function optOutPage(uint256 size, uint256 page) public view returns (address[] memory) {\n    page = size*page;\n    uint256 current = currentEpoch();\n    uint256 n = 0;\n    for(uint256 i=page; i<optOutHistory.length; i++) {\n      if(registry[optOutHistory[i]].start <= current && registry[optOutHistory[i]].expiration > current && registry[optOutHistory[i]].to == address(0)) {\n        n++;\n        if(n == size) { break; }\n      }\n    }\n    address[] memory optOuts = new address[](n);\n    n = 0;\n    for(uint256 i=page; i<optOutHistory.length; i++) {\n      if(registry[optOutHistory[i]].start <= current && registry[optOutHistory[i]].expiration > current && registry[optOutHistory[i]].to == address(0)) {\n        optOuts[n] = optOutHistory[i];\n        n++;\n        if(n == size) { break; }\n      }\n    }\n    return optOuts;\n  }\n\n  // length of forwardHistory - needed for retrieving paginated results from forwardPage()\n  function forwardLength() public view returns (uint256) {\n    return forwardHistory.length;\n  }\n\n  // returns list of actively opted-out addresses using pagination\n  function forwardPage(uint256 size, uint256 page) public view returns (address[] memory) {\n    page = size*page;\n    uint256 current = currentEpoch();\n    uint256 n = 0;\n    for(uint256 i=page; i<forwardHistory.length; i++) {\n      if(registry[forwardHistory[i]].start <= current && registry[forwardHistory[i]].expiration > current && registry[forwardHistory[i]].to != address(0)) {\n        n++;\n        if(n == size) { break; }\n      }\n    }\n    address[] memory forwards = new address[](n*2);\n    n = 0;\n    for(uint256 i=page; i<forwardHistory.length; i++) {\n      if(registry[forwardHistory[i]].start <= current && registry[forwardHistory[i]].expiration > current && registry[forwardHistory[i]].to != address(0)) {\n        forwards[n] = forwardHistory[i];\n        forwards[n+1] = registry[forwardHistory[i]].to;\n        n+=2;\n        if(n == size*2) { break; }\n      }\n    }\n    return forwards;\n  }\n\n  // returns start of current Epoch\n  function currentEpoch() public view returns (uint256) {\n    return block.timestamp/eDuration*eDuration;\n  }\n\n  // returns start of next Epoch\n  function nextEpoch() public view returns (uint256) {\n    return block.timestamp/eDuration*eDuration+eDuration;\n  }\n\n  // only used for rescuing mistakenly sent funds or other unexpected needs\n  function execute(address _to, uint256 _value, bytes calldata _data) external onlyOwner returns (bool, bytes memory) {\n    (bool success, bytes memory result) = _to.call{value:_value}(_data);\n    return (success, result);\n  }\n\n  // multi-sig functions for edge cases\n  function forceRegistry(address _from, address _to) public onlyOwner {\n    uint256 current = currentEpoch();\n    require(registry[_from].start == 0 || registry[_from].expiration < current,\"Registration is still active\");\n    registry[_from].start = current+eDuration;\n    registry[_from].to = _to;\n    registry[_from].expiration = 0xfffffffff;\n    if(_to == address(0)) {\n      // prevent duplicate entry in optOutHistory array\n      if(!inOptOutHistory[_from]) {\n        optOutHistory.push(_from);\n        inOptOutHistory[_from] = true;\n      }\n    } else if(!inForwardHistory[_from]) {\n        forwardHistory.push(_from);\n        inForwardHistory[_from] = true;\n    }\n    emit setReg(_from, _to, registry[_from].start);\n  }\n\n  function forceToExpire(address _from) public onlyOwner {\n    uint256 next = nextEpoch();\n    require(registry[_from].start > 0 && registry[_from].expiration > next,\"Not registered or expiration already pending\");\n    // if not started yet, nullify instead of setting expiration\n    if(next == registry[_from].start) {\n      registry[_from].start = 0;\n      registry[_from].to = address(0);\n    } else {\n      registry[_from].expiration = next;\n    }\n    emit expReg(_from, next);\n  }\n\n  event setReg(address indexed _from, address indexed _to, uint256 indexed _start);\n  event expReg(address indexed _from, uint256 indexed _end);\n\n}\n"
    },
    "/contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n\n\t  address private _owner = 0xe39b8617D571CEe5e75e1EC6B2bb40DdC8CF6Fa3; // Votium multi-sig address\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}