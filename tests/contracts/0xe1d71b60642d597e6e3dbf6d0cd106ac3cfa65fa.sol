{{
  "language": "Solidity",
  "sources": {
    "contracts/BondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./types/NoteKeeper.sol\";\n\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/IERC20Metadata.sol\";\nimport \"./interfaces/IBondDepository.sol\";\n\n/// @title Floor Bond Depository V2\n/// @author Zeus, Indigo\n/// Review by: JeffX\n\ncontract FloorBondDepository is IBondDepository, NoteKeeper {\n/* ======== DEPENDENCIES ======== */\n\n  using SafeERC20 for IERC20;\n\n/* ======== EVENTS ======== */\n\n  event CreateMarket(\n    uint256 indexed id,\n    address indexed quoteToken,\n    uint256 initialPrice,\n    uint256 capacity,\n    bool capacityInQuote,\n    uint256 conclusion,\n    uint256 vestingPeriod\n  );\n  event CloseMarket(uint256 indexed id);\n  event Tuned(uint256 indexed id, uint64 oldControlVariable, uint64 newControlVariable);\n  event Bond(uint256 indexed id, uint256 amount, uint256 price, uint256 payout);\n\n/* ======== STATE VARIABLES ======== */\n\n  // Storage\n  Market[] public markets; // persistent market data\n  Terms[] public terms; // deposit construction data\n  Metadata[] public metadata; // extraneous market data\n  mapping(uint256 => Adjustment) public adjustments; // control variable changes\n\n  // Queries\n  mapping(address => uint256[]) public marketsForQuote; // market IDs for quote token\n\n/* ======== CONSTRUCTOR ======== */\n\n  constructor(\n    IFloorAuthority _authority,\n    IERC20 _floor,\n    IgFLOOR _gfloor,\n    IStaking _staking,\n    ITreasury _treasury\n  ) NoteKeeper(_authority, _floor, _gfloor, _staking, _treasury) {\n    // save gas for users by bulk approving stake() transactions\n    _floor.approve(address(_staking), 1e45);\n  }\n\n/* ======== DEPOSIT ======== */\n\n  /**\n   * @notice             deposit quote tokens in exchange for a bond from a specified market\n   * @param _id          the ID of the market\n   * @param _amount      the amount of quote token to spend\n   * @param _maxPrice    the maximum price at which to buy\n   * @param _user        the recipient of the payout\n   * @param _referral    the front end operator address\n   * @return payout_     the amount of gFLOOR due\n   * @return expiry_     the timestamp at which payout is redeemable\n   * @return index_      the user index of the Note (used to redeem or query information)\n   */\n  function deposit(\n    uint256 _id,\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _user,\n    address _referral\n  ) external override returns (\n    uint256 payout_, \n    uint256 expiry_,\n    uint256 index_\n  ) {\n    Market storage market = markets[_id];\n    Terms memory term = terms[_id];\n    uint48 currentTime = uint48(block.timestamp);\n\n    // Markets end at a defined timestamp\n    // |-------------------------------------| t\n    require(currentTime < term.conclusion, \"Depository: market concluded\");\n\n    // Debt and the control variable decay over time\n    _decay(_id, currentTime);\n\n    // Users input a maximum price, which protects them from price changes after\n    // entering the mempool. max price is a slippage mitigation measure\n    uint256 price = _marketPrice(_id);\n    require(price <= _maxPrice, \"Depository: more than max price\"); \n\n    /**\n     * payout for the deposit = amount / price\n     *\n     * where\n     * payout = FLOOR out\n     * amount = quote tokens in\n     * price = quote tokens : floor (i.e. 42069 DAI : FLOOR)\n     *\n     * 1e18 = FLOOR decimals (9) + price decimals (9)\n     */\n    payout_ = (_amount * 1e18 / price) / (10 ** metadata[_id].quoteDecimals);\n\n    // markets have a max payout amount, capping size because deposits\n    // do not experience slippage. max payout is recalculated upon tuning\n    require(payout_ <= market.maxPayout, \"Depository: max size exceeded\");\n    \n    /*\n     * each market is initialized with a capacity\n     *\n     * this is either the number of FLOOR that the market can sell\n     * (if capacity in quote is false), \n     *\n     * or the number of quote tokens that the market can buy\n     * (if capacity in quote is true)\n     */\n    market.capacity -= market.capacityInQuote\n      ? _amount\n      : payout_;\n\n    /**\n     * bonds mature with a cliff at a set timestamp\n     * prior to the expiry timestamp, no payout tokens are accessible to the user\n     * after the expiry timestamp, the entire payout can be redeemed\n     *\n     * there are two types of bonds: fixed-term and fixed-expiration\n     *\n     * fixed-term bonds mature in a set amount of time from deposit\n     * i.e. term = 1 week. when alice deposits on day 1, her bond\n     * expires on day 8. when bob deposits on day 2, his bond expires day 9.\n     *\n     * fixed-expiration bonds mature at a set timestamp\n     * i.e. expiration = day 10. when alice deposits on day 1, her term\n     * is 9 days. when bob deposits on day 2, his term is 8 days.\n     */\n    expiry_ = term.fixedTerm\n      ? term.vesting + currentTime\n      : term.vesting;\n\n    // markets keep track of how many quote tokens have been\n    // purchased, and how much FLOOR has been sold\n    market.purchased += _amount;\n    market.sold += uint64(payout_);\n\n    // incrementing total debt raises the price of the next bond\n    market.totalDebt += uint64(payout_);\n\n    emit Bond(_id, _amount, price, payout_);\n\n    /**\n     * user data is stored as Notes. these are isolated array entries\n     * storing the amount due, the time created, the time when payout\n     * is redeemable, the time when payout was redeemed, and the ID\n     * of the market deposited into\n     */\n    index_ = addNote(\n      _user,\n      payout_,\n      uint48(expiry_),\n      uint48(_id),\n      _referral\n    );\n\n    // transfer payment to treasury\n    market.quoteToken.safeTransferFrom(msg.sender, address(treasury), _amount);\n\n    // if max debt is breached, the market is closed \n    // this a circuit breaker\n    if (term.maxDebt < market.totalDebt) {\n        market.capacity = 0;\n        emit CloseMarket(_id);\n    } else {\n      // if market will continue, the control variable is tuned to hit targets on time\n      _tune(_id, currentTime);\n    }\n  }\n\n  /**\n   * @notice             decay debt, and adjust control variable if there is an active change\n   * @param _id          ID of market\n   * @param _time        uint48 timestamp (saves gas when passed in)\n   */\n  function _decay(uint256 _id, uint48 _time) internal {\n\n    // Debt decay\n\n    /*\n     * Debt is a time-decayed sum of tokens spent in a market\n     * Debt is added when deposits occur and removed over time\n     * |\n     * |    debt falls with\n     * |   / \\  inactivity       / \\\n     * | /     \\              /\\/    \\\n     * |         \\           /         \\\n     * |           \\      /\\/            \\\n     * |             \\  /  and rises       \\\n     * |                with deposits\n     * |\n     * |------------------------------------| t\n     */\n    markets[_id].totalDebt -= debtDecay(_id);\n    metadata[_id].lastDecay = _time;\n\n\n    // Control variable decay\n\n    // The bond control variable is continually tuned. When it is lowered (which\n    // lowers the market price), the change is carried out smoothly over time.\n    if (adjustments[_id].active) {\n      Adjustment storage adjustment = adjustments[_id];\n\n      (uint64 adjustBy, uint48 secondsSince, bool stillActive) = _controlDecay(_id);\n      terms[_id].controlVariable -= adjustBy;\n\n      if (stillActive) {\n        adjustment.change -= adjustBy;\n        adjustment.timeToAdjusted -= secondsSince;\n        adjustment.lastAdjustment = _time;\n      } else {\n        adjustment.active = false;\n      }\n    }\n  }\n\n  /**\n   * @notice             auto-adjust control variable to hit capacity/spend target\n   * @param _id          ID of market\n   * @param _time        uint48 timestamp (saves gas when passed in)\n   */\n  function _tune(uint256 _id, uint48 _time) internal {\n    Metadata memory meta = metadata[_id];\n\n    if (_time >= meta.lastTune + meta.tuneInterval) {\n      Market memory market = markets[_id];\n      \n      // compute seconds remaining until market will conclude\n      uint256 timeRemaining = terms[_id].conclusion - _time;\n      uint256 price = _marketPrice(_id);\n\n      // standardize capacity into an base token amount\n      // floor decimals (9) + price decimals (9)\n      uint256 capacity = market.capacityInQuote\n        ? (market.capacity * 1e18 / price) / (10 ** meta.quoteDecimals)\n        : market.capacity;\n\n      /**\n       * calculate the correct payout to complete on time assuming each bond\n       * will be max size in the desired deposit interval for the remaining time\n       *\n       * i.e. market has 10 days remaining. deposit interval is 1 day. capacity\n       * is 10,000 FLOOR. max payout would be 1,000 FLOOR (10,000 * 1 / 10).\n       */  \n      markets[_id].maxPayout = uint64(capacity * meta.depositInterval / timeRemaining);\n\n      // calculate the ideal total debt to satisfy capacity in the remaining time\n      uint256 targetDebt = capacity * meta.length / timeRemaining;\n\n      // derive a new control variable from the target debt and current supply\n      uint64 newControlVariable = uint64(price * treasury.baseSupply() / targetDebt);\n\n      emit Tuned(_id, terms[_id].controlVariable, newControlVariable);\n\n      if (newControlVariable >= terms[_id].controlVariable) {\n        terms[_id].controlVariable = newControlVariable;\n      } else {\n        // if decrease, control variable change will be carried out over the tune interval\n        // this is because price will be lowered\n        uint64 change = terms[_id].controlVariable - newControlVariable;\n        adjustments[_id] = Adjustment(change, _time, meta.tuneInterval, true);\n      }\n      metadata[_id].lastTune = _time;\n    }\n  }\n\n/* ======== CREATE ======== */\n\n  /**\n   * @notice             creates a new market type\n   * @dev                current price should be in 9 decimals.\n   * @param _quoteToken  token used to deposit\n   * @param _market      [capacity (in FLOOR or quote), initial price / FLOOR (9 decimals), debt buffer (3 decimals)]\n   * @param _booleans    [capacity in quote, fixed term]\n   * @param _terms       [(seconds) vesting length (if fixed term) or vested timestamp, conclusion timestamp]\n   * @param _intervals   [deposit interval (seconds), tune interval (seconds)]\n   * @return id_         ID of new bond market\n   */\n  function create(\n    IERC20 _quoteToken,\n    uint256[3] memory _market,\n    bool[2] memory _booleans,\n    uint256[2] memory _terms,\n    uint32[2] memory _intervals\n  ) external override onlyPolicy returns (uint256 id_) {\n\n    // the length of the program, in seconds\n    uint256 secondsToConclusion = _terms[1] - block.timestamp;\n\n    // the decimal count of the quote token\n    uint256 decimals = IERC20Metadata(address(_quoteToken)).decimals();\n\n    /* \n     * initial target debt is equal to capacity (this is the amount of debt\n     * that will decay over in the length of the program if price remains the same).\n     * it is converted into base token terms if passed in in quote token terms.\n     *\n     * 1e18 = floor decimals (9) + initial price decimals (9)\n     */\n    uint64 targetDebt = uint64(_booleans[0]\n      ? (_market[0] * 1e18 / _market[1]) / 10 ** decimals\n      : _market[0]\n    );\n\n    /*\n     * max payout is the amount of capacity that should be utilized in a deposit\n     * interval. for example, if capacity is 1,000 FLOOR, there are 10 days to conclusion, \n     * and the preferred deposit interval is 1 day, max payout would be 100 FLOOR.\n     */\n    uint64 maxPayout = uint64(targetDebt * _intervals[0] / secondsToConclusion);\n\n    /*\n     * max debt serves as a circuit breaker for the market. let's say the quote\n     * token is a stablecoin, and that stablecoin depegs. without max debt, the\n     * market would continue to buy until it runs out of capacity. this is\n     * configurable with a 3 decimal buffer (1000 = 1% above initial price).\n     * note that its likely advisable to keep this buffer wide.\n     * note that the buffer is above 100%. i.e. 10% buffer = initial debt * 1.1\n     */\n    uint256 maxDebt = targetDebt + (targetDebt * _market[2] / 1e5); // 1e5 = 100,000. 10,000 / 100,000 = 10%.\n\n    /*\n     * the control variable is set so that initial price equals the desired\n     * initial price. the control variable is the ultimate determinant of price,\n     * so we compute this last.\n     *\n     * price = control variable * debt ratio\n     * debt ratio = total debt / supply\n     * therefore, control variable = price / debt ratio\n     */\n    uint256 controlVariable = _market[1] * treasury.baseSupply() / targetDebt;\n\n    // depositing into, or getting info for, the created market uses this ID\n    id_ = markets.length;\n\n    markets.push(Market({\n      quoteToken: _quoteToken, \n      capacityInQuote: _booleans[0],\n      capacity: _market[0],\n      totalDebt: targetDebt, \n      maxPayout: maxPayout,\n      purchased: 0,\n      sold: 0\n    }));\n\n    terms.push(Terms({\n      fixedTerm: _booleans[1], \n      controlVariable: uint64(controlVariable),\n      vesting: uint48(_terms[0]), \n      conclusion: uint48(_terms[1]), \n      maxDebt: uint64(maxDebt) \n    }));\n\n    metadata.push(Metadata({\n      lastTune: uint48(block.timestamp),\n      lastDecay: uint48(block.timestamp),\n      length: uint48(secondsToConclusion),\n      depositInterval: _intervals[0],\n      tuneInterval: _intervals[1],\n      quoteDecimals: uint8(decimals)\n    }));\n\n    marketsForQuote[address(_quoteToken)].push(id_);\n\n    emit CreateMarket(id_, address(_quoteToken), _market[1], _market[0], _booleans[0], _terms[1], _terms[0]);\n  }\n\n  /**\n   * @notice             disable existing market\n   * @param _id          ID of market to close\n   */\n  function close(uint256 _id) external override onlyPolicy {\n    terms[_id].conclusion = uint48(block.timestamp);\n    markets[_id].capacity = 0;\n    emit CloseMarket(_id);\n  }\n\n/* ======== EXTERNAL VIEW ======== */\n\n  /**\n   * @notice             calculate current market price of quote token in base token\n   * @dev                accounts for debt and control variable decay since last deposit (vs _marketPrice())\n   * @param _id          ID of market\n   * @return             price for market in FLOOR decimals\n   *\n   * price is derived from the equation\n   *\n   * p = cv * dr\n   *\n   * where\n   * p = price\n   * cv = control variable\n   * dr = debt ratio\n   *\n   * dr = d / s\n   * \n   * where\n   * d = debt\n   * s = supply of token at market creation\n   *\n   * d -= ( d * (dt / l) )\n   * \n   * where\n   * dt = change in time\n   * l = length of program\n   */\n  function marketPrice(uint256 _id) public view override returns (uint256) {\n    return \n      currentControlVariable(_id)\n      * debtRatio(_id)\n      / (10 ** metadata[_id].quoteDecimals);\n  }\n\n  /**\n   * @notice             payout due for amount of quote tokens\n   * @dev                accounts for debt and control variable decay so it is up to date\n   * @param _amount      amount of quote tokens to spend\n   * @param _id          ID of market\n   * @return             amount of FLOOR to be paid in FLOOR decimals\n   *\n   * @dev 1e18 = floor decimals (9) + market price decimals (9)\n   */\n  function payoutFor(uint256 _amount, uint256 _id) external view override returns (uint256) {\n    Metadata memory meta = metadata[_id];\n    return \n      _amount\n      * 1e18 \n      / marketPrice(_id)\n      / 10 ** meta.quoteDecimals;\n  }\n\n  /**\n   * @notice             calculate current ratio of debt to supply\n   * @dev                uses current debt, which accounts for debt decay since last deposit (vs _debtRatio())\n   * @param _id          ID of market\n   * @return             debt ratio for market in quote decimals\n   */\n  function debtRatio(uint256 _id) public view override returns (uint256) {\n    return \n      currentDebt(_id)\n      * (10 ** metadata[_id].quoteDecimals)\n      / treasury.baseSupply(); \n  }\n\n  /**\n   * @notice             calculate debt factoring in decay\n   * @dev                accounts for debt decay since last deposit\n   * @param _id          ID of market\n   * @return             current debt for market in FLOOR decimals\n   */\n  function currentDebt(uint256 _id) public view override returns (uint256) {\n    return markets[_id].totalDebt - debtDecay(_id);\n  }\n\n  /**\n   * @notice             amount of debt to decay from total debt for market ID\n   * @param _id          ID of market\n   * @return             amount of debt to decay\n   */\n  function debtDecay(uint256 _id) public view override returns (uint64) {\n    Metadata memory meta = metadata[_id];\n\n    uint256 secondsSince = block.timestamp - meta.lastDecay;\n\n    return uint64(markets[_id].totalDebt * secondsSince / meta.length);\n  }\n\n  /**\n   * @notice             up to date control variable\n   * @dev                accounts for control variable adjustment\n   * @param _id          ID of market\n   * @return             control variable for market in FLOOR decimals\n   */\n  function currentControlVariable(uint256 _id) public view returns (uint256) {\n    (uint64 decay,,) = _controlDecay(_id);\n    return terms[_id].controlVariable - decay;\n  }\n\n  /**\n   * @notice             is a given market accepting deposits\n   * @param _id          ID of market\n   */\n  function isLive(uint256 _id) public view override returns (bool) {\n    return (markets[_id].capacity != 0 && terms[_id].conclusion > block.timestamp);\n  }\n\n  /**\n   * @notice returns an array of all active market IDs\n   */\n  function liveMarkets() external view override returns (uint256[] memory) {\n    uint256 num;\n    for (uint256 i = 0; i < markets.length; i++) {\n      if (isLive(i)) num++;\n    }\n\n    uint256[] memory ids = new uint256[](num);\n    uint256 nonce;\n    for (uint256 i = 0; i < markets.length; i++) {\n      if (isLive(i)) {\n        ids[nonce] = i;\n        nonce++;\n      }\n    }\n    return ids;\n  }\n\n  /**\n   * @notice             returns an array of all active market IDs for a given quote token\n   * @param _token       quote token to check for\n   */\n  function liveMarketsFor(address _token) external view override returns (uint256[] memory) {\n    uint256[] memory mkts = marketsForQuote[_token];\n    uint256 num;\n\n    for (uint256 i = 0; i < mkts.length; i++) {\n      if (isLive(mkts[i])) num++;\n    }\n\n    uint256[] memory ids = new uint256[](num);\n    uint256 nonce;\n\n    for (uint256 i = 0; i < mkts.length; i++) {\n      if (isLive(mkts[i])) {\n        ids[nonce] = mkts[i];\n        nonce++;\n      }\n    }\n    return ids;\n  }\n\n/* ======== INTERNAL VIEW ======== */\n\n  /**\n   * @notice                  calculate current market price of quote token in base token\n   * @dev                     see marketPrice() for explanation of price computation\n   * @dev                     uses info from storage because data has been updated before call (vs marketPrice())\n   * @param _id               market ID\n   * @return                  price for market in FLOOR decimals\n   */ \n  function _marketPrice(uint256 _id) internal view returns (uint256) {\n    return \n      terms[_id].controlVariable \n      * _debtRatio(_id) \n      / (10 ** metadata[_id].quoteDecimals);\n  }\n  \n  /**\n   * @notice                  calculate debt factoring in decay\n   * @dev                     uses info from storage because data has been updated before call (vs debtRatio())\n   * @param _id               market ID\n   * @return                  current debt for market in quote decimals\n   */ \n  function _debtRatio(uint256 _id) internal view returns (uint256) {\n    return \n      markets[_id].totalDebt\n      * (10 ** metadata[_id].quoteDecimals)\n      / treasury.baseSupply(); \n  }\n\n  /**\n   * @notice                  amount to decay control variable by\n   * @param _id               ID of market\n   * @return decay_           change in control variable\n   * @return secondsSince_    seconds since last change in control variable\n   * @return active_          whether or not change remains active\n   */ \n  function _controlDecay(uint256 _id) internal view returns (uint64 decay_, uint48 secondsSince_, bool active_) {\n    Adjustment memory info = adjustments[_id];\n    if (!info.active) return (0, 0, false);\n\n    secondsSince_ = uint48(block.timestamp) - info.lastAdjustment;\n\n    active_ = secondsSince_ < info.timeToAdjusted;\n    decay_ = active_ \n      ? info.change * secondsSince_ / info.timeToAdjusted\n      : info.change;\n  }\n}"
    },
    "contracts/types/NoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"../types/FrontEndRewarder.sol\";\n\nimport \"../interfaces/IgFLOOR.sol\";\nimport \"../interfaces/IStaking.sol\";\nimport \"../interfaces/ITreasury.sol\";\nimport \"../interfaces/INoteKeeper.sol\";\n\nabstract contract NoteKeeper is INoteKeeper, FrontEndRewarder {\n\n  event CreateNote(address user, uint48 bondId, uint256 index, uint256 payout, uint48 expiry);\n  event PushNote(address oldUser, address newUser, uint256 oldIndex, uint256 newIndex);\n  event RedeemNote(address user, uint256[] indexes);\n\n  mapping(address => Note[]) public notes; // user deposit data\n  mapping(address => mapping(uint256 => address)) private noteTransfers; // change note ownership\n\n  IgFLOOR internal immutable gFLOOR;\n  IStaking internal immutable staking;\n  ITreasury internal treasury;\n\n  constructor (\n    IFloorAuthority _authority,\n    IERC20 _floor,\n    IgFLOOR _gfloor, \n    IStaking _staking,\n    ITreasury _treasury\n  ) FrontEndRewarder(_authority, _floor) {\n    gFLOOR = _gfloor;\n    staking = _staking;\n    treasury = _treasury;\n  }\n\n  // if treasury address changes on authority, update it\n  function updateTreasury() external {\n    require(\n      msg.sender == authority.governor() ||\n      msg.sender == authority.guardian() ||\n      msg.sender == authority.policy(),\n      \"Only authorized\"\n    );\n    treasury = ITreasury(authority.vault());\n  }\n\n/* ========== ADD ========== */\n\n  /**\n   * @notice             adds a new Note for a user, stores the front end & DAO rewards, and mints & stakes payout & rewards\n   * @param _user        the user that owns the Note\n   * @param _payout      the amount of FLOOR due to the user\n   * @param _expiry      the timestamp when the Note is redeemable\n   * @param _marketID    the ID of the market deposited into\n   * @return index_      the index of the Note in the user's array\n   */\n  function addNote(\n    address _user, \n    uint256 _payout, \n    uint48 _expiry, \n    uint48 _marketID,\n    address _referral\n  ) internal returns (uint256 index_) {\n    // the index of the note is the next in the user's array\n    index_ = notes[_user].length;\n\n    // the new note is pushed to the user's array\n    notes[_user].push(\n      Note({\n        payout: gFLOOR.balanceTo(_payout),\n        created: uint48(block.timestamp),\n        matured: _expiry,\n        redeemed: 0,\n        marketID: _marketID\n      })\n    );\n\n    emit CreateNote(_user, _marketID, index_, gFLOOR.balanceTo(_payout), _expiry);\n\n    // front end operators can earn rewards by referring users\n    uint256 rewards = _giveRewards(_payout, _referral);\n\n    // mint and stake payout\n    treasury.mint(address(this), _payout + rewards);\n\n    // note that only the payout gets staked (front end rewards are in FLOOR)\n    staking.stake(address(this), _payout, false, true);\n  }\n\n/* ========== REDEEM ========== */\n\n  /**\n   * @notice             redeem notes for user\n   * @param _user        the user to redeem for\n   * @param _indexes     the note indexes to redeem\n   * @param _sendgFLOOR  send payout as gFLOOR or sFLOOR\n   * @return payout_     sum of payout sent, in gFLOOR\n   */\n  function redeem(address _user, uint256[] memory _indexes, bool _sendgFLOOR) external override returns (uint256 payout_) {\n    uint48 time = uint48(block.timestamp);\n\n    for (uint256 i = 0; i < _indexes.length; i++) {\n      (uint256 pay, bool matured) = pendingFor(_user, _indexes[i]);\n      require(matured, \"Depository: note not matured\");\n      if (matured) {\n        notes[_user][_indexes[i]].redeemed = time; // mark as redeemed\n        payout_ += pay;\n      }\n    }\n\n    if (_sendgFLOOR) {\n      gFLOOR.transfer(_user, payout_); // send payout as gFLOOR\n    } else {\n      staking.unwrap(_user, payout_); // unwrap and send payout as sFLOOR\n    }\n\n    emit RedeemNote(_user, _indexes);\n  }\n\n/* ========== TRANSFER ========== */\n\n  /**\n   * @notice             approve an address to transfer a note\n   * @param _to          address to approve note transfer for\n   * @param _index       index of note to approve transfer for\n   */ \n  function pushNote(address _to, uint256 _index) external override {\n    require(notes[msg.sender][_index].created != 0, \"Depository: note not found\");\n    noteTransfers[msg.sender][_index] = _to;\n  }\n\n  /**\n   * @notice             transfer a note that has been approved by an address\n   * @param _from        the address that approved the note transfer\n   * @param _index       the index of the note to transfer (in the sender's array)\n   */ \n  function pullNote(address _from, uint256 _index) external override returns (uint256 newIndex_) {\n    require(noteTransfers[_from][_index] == msg.sender, \"Depository: transfer not found\");\n    require(notes[_from][_index].redeemed == 0, \"Depository: note redeemed\");\n\n    newIndex_ = notes[msg.sender].length;\n    notes[msg.sender].push(notes[_from][_index]);\n\n    delete notes[_from][_index];\n\n    emit PushNote(_from, msg.sender, _index, newIndex_);\n  }\n\n/* ========== VIEW ========== */\n\n  // Note info\n\n  /**\n   * @notice             all pending notes for user\n   * @param _user        the user to query notes for\n   * @return             the pending notes for the user\n   */\n  function indexesFor(address _user) public view override returns (uint256[] memory) {\n    Note[] memory info = notes[_user];\n\n    uint256 length;\n    for (uint256 i = 0; i < info.length; i++) {\n        if (info[i].redeemed == 0 && info[i].payout != 0) length++;\n    }\n\n    uint256[] memory indexes = new uint256[](length);\n    uint256 position;\n\n    for (uint256 i = 0; i < info.length; i++) {\n        if (info[i].redeemed == 0 && info[i].payout != 0) {\n            indexes[position] = i;\n            position++;\n        }\n    }\n\n    return indexes;\n  }\n\n  /**\n   * @notice             calculate amount available for claim for a single note\n   * @param _user        the user that the note belongs to\n   * @param _index       the index of the note in the user's array\n   * @return payout_     the payout due, in gFLOOR\n   * @return matured_    if the payout can be redeemed\n   */\n  function pendingFor(address _user, uint256 _index) public view override returns (uint256 payout_, bool matured_) {\n    Note memory note = notes[_user][_index];\n\n    payout_ = note.payout;\n    matured_ = note.redeemed == 0 && note.matured <= block.timestamp && note.payout != 0;\n  }\n}"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/interfaces/IBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IBondDepository {\n\n  // Info about each type of market\n  struct Market {\n    uint256 capacity; // capacity remaining\n    IERC20 quoteToken; // token to accept as payment\n    bool capacityInQuote; // capacity limit is in payment token (true) or in FLOOR (false, default)\n    uint64 totalDebt; // total debt from market\n    uint64 maxPayout; // max tokens in/out (determined by capacityInQuote false/true, respectively)\n    uint64 sold; // base tokens out\n    uint256 purchased; // quote tokens in\n  }\n\n  // Info for creating new markets\n  struct Terms {\n    bool fixedTerm; // fixed term or fixed expiration\n    uint64 controlVariable; // scaling variable for price\n    uint48 vesting; // length of time from deposit to maturity if fixed-term\n    uint48 conclusion; // timestamp when market no longer offered (doubles as time when market matures if fixed-expiry)\n    uint64 maxDebt; // 9 decimal debt maximum in FLOOR\n  }\n\n  // Additional info about market.\n  struct Metadata {\n    uint48 lastTune; // last timestamp when control variable was tuned\n    uint48 lastDecay; // last timestamp when market was created and debt was decayed\n    uint48 length; // time from creation to conclusion. used as speed to decay debt.\n    uint48 depositInterval; // target frequency of deposits\n    uint48 tuneInterval; // frequency of tuning\n    uint8 quoteDecimals; // decimals of quote token\n  }\n\n  // Control variable adjustment data\n  struct Adjustment {\n    uint64 change;\n    uint48 lastAdjustment;\n    uint48 timeToAdjusted;\n    bool active;\n  }\n\n\n  /**\n   * @notice deposit market\n   * @param _bid uint256\n   * @param _amount uint256\n   * @param _maxPrice uint256\n   * @param _user address\n   * @param _referral address\n   * @return payout_ uint256\n   * @return expiry_ uint256\n   * @return index_ uint256\n   */\n  function deposit(\n    uint256 _bid,\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _user,\n    address _referral\n  ) external returns (\n    uint256 payout_, \n    uint256 expiry_,\n    uint256 index_\n  );\n\n  function create (\n    IERC20 _quoteToken, // token used to deposit\n    uint256[3] memory _market, // [capacity, initial price]\n    bool[2] memory _booleans, // [capacity in quote, fixed term]\n    uint256[2] memory _terms, // [vesting, conclusion]\n    uint32[2] memory _intervals // [deposit interval, tune interval]\n  ) external returns (uint256 id_);\n  function close(uint256 _id) external;\n\n  function isLive(uint256 _bid) external view returns (bool);\n  function liveMarkets() external view returns (uint256[] memory);\n  function liveMarketsFor(address _quoteToken) external view returns (uint256[] memory);\n  function payoutFor(uint256 _amount, uint256 _bid) external view returns (uint256);\n  function marketPrice(uint256 _bid) external view returns (uint256);\n  function currentDebt(uint256 _bid) external view returns (uint256);\n  function debtRatio(uint256 _bid) external view returns (uint256);\n  function debtDecay(uint256 _bid) external view returns (uint64);\n} \n"
    },
    "contracts/types/FrontEndRewarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"../types/FloorAccessControlled.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nabstract contract FrontEndRewarder is FloorAccessControlled {\n\n  /* ========= STATE VARIABLES ========== */\n\n  uint256 public daoReward; // % reward for dao (3 decimals: 100 = 1%)\n  uint256 public refReward; // % reward for referrer (3 decimals: 100 = 1%)\n  mapping(address => uint256) public rewards; // front end operator rewards\n  mapping(address => bool) public whitelisted; // whitelisted status for operators\n\n  IERC20 internal immutable floor; // reward token\n\n  constructor(\n    IFloorAuthority _authority, \n    IERC20 _floor\n  ) FloorAccessControlled(_authority) {\n    floor = _floor;\n  }\n\n  /* ========= EXTERNAL FUNCTIONS ========== */\n\n  // pay reward to front end operator\n  function getReward() external {\n    uint256 reward = rewards[msg.sender];\n\n    rewards[msg.sender] = 0;\n    floor.transfer(msg.sender, reward);\n  }\n\n  /* ========= INTERNAL ========== */\n\n  /** \n   * @notice add new market payout to user data\n   */\n  function _giveRewards(\n    uint256 _payout,\n    address _referral\n  ) internal returns (uint256) {\n    // first we calculate rewards paid to the DAO and to the front end operator (referrer)\n    uint256 toDAO = _payout * daoReward / 1e4;\n    uint256 toRef = _payout * refReward / 1e4;\n\n    // and store them in our rewards mapping\n    if (whitelisted[_referral]) {\n      rewards[_referral] += toRef;\n      rewards[authority.guardian()] += toDAO;\n    } else { // the DAO receives both rewards if referrer is not whitelisted\n      rewards[authority.guardian()] += toDAO + toRef;\n    }\n    return toDAO + toRef;\n  }\n\n  /**\n   * @notice set rewards for front end operators and DAO\n   */\n  function setRewards(uint256 _toFrontEnd, uint256 _toDAO) external onlyGovernor {\n    refReward = _toFrontEnd;\n    daoReward = _toDAO;\n  }\n\n  /**\n   * @notice add or remove addresses from the reward whitelist\n   */\n  function whitelist(address _operator) external onlyPolicy {\n    whitelisted[_operator] = !whitelisted[_operator];\n  }\n}"
    },
    "contracts/interfaces/IgFLOOR.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IgFLOOR is IERC20 {\n  function mint(address _to, uint256 _amount) external;\n\n  function burn(address _from, uint256 _amount) external;\n\n  function index() external view returns (uint256);\n\n  function balanceFrom(uint256 _amount) external view returns (uint256);\n\n  function balanceTo(uint256 _amount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface IStaking {\n    function stake(\n        address _to,\n        uint256 _amount,\n        bool _rebasing,\n        bool _claim\n    ) external returns (uint256);\n\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\n\n    function forfeit() external returns (uint256);\n\n    function toggleLock() external;\n\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external returns (uint256);\n\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\n\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\n\n    function rebase() external;\n\n    function index() external view returns (uint256);\n\n    function contractBalance() external view returns (uint256);\n\n    function totalStaked() external view returns (uint256);\n\n    function supplyInWarmup() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface ITreasury {\n    function bondCalculator(address _address) external view returns (address);\n\n    function deposit(uint256 _amount, address _token, uint256 _profit) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function depositERC721(address _token, uint256 _tokenId) external;\n\n    function withdrawERC721(address _token, uint256 _tokenId) external;\n\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function allocatorManage(address _token, uint256 _amount) external;\n\n    function claimNFTXRewards(address _liquidityStaking, uint256 _vaultId, address _rewardToken) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function excessReserves() external view returns (uint256);\n    \n    function riskOffValuation(address _token) external view returns (uint256);\n\n    function baseSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/INoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\ninterface INoteKeeper {\n  // Info for market note\n  struct Note {\n    uint256 payout; // gFLOOR remaining to be paid\n    uint48 created; // time market was created\n    uint48 matured; // timestamp when market is matured\n    uint48 redeemed; // time market was redeemed\n    uint48 marketID; // market ID of deposit. uint48 to avoid adding a slot.\n  }\n\n  function redeem(address _user, uint256[] memory _indexes, bool _sendgFLOOR) external returns (uint256);\n  function pushNote(address to, uint256 index) external;\n  function pullNote(address from, uint256 index) external returns (uint256 newIndex_);\n\n  function indexesFor(address _user) external view returns (uint256[] memory);\n  function pendingFor(address _user, uint256 _index) external view returns (uint256 payout_, bool matured_);\n}"
    },
    "contracts/types/FloorAccessControlled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IFloorAuthority.sol\";\n\nabstract contract FloorAccessControlled {\n\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(IFloorAuthority indexed authority);\n\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    /* ========== STATE VARIABLES ========== */\n\n    IFloorAuthority public authority;\n\n\n    /* ========== Constructor ========== */\n\n    constructor(IFloorAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n    \n\n    /* ========== MODIFIERS ========== */\n    \n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyPolicy() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n    \n    /* ========== GOV ONLY ========== */\n    \n    function setAuthority(IFloorAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IFloorAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface IFloorAuthority {\n    /* ========== EVENTS ========== */\n    \n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n    \n    function governor() external view returns (address);\n    function guardian() external view returns (address);\n    function policy() external view returns (address);\n    function vault() external view returns (address);\n}"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}