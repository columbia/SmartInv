{{
  "language": "Solidity",
  "sources": {
    "contracts/distributors/open-sale/MirrorOpenSaleV0.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport {IMirrorOpenSaleV0, IMirrorOpenSaleV0Events} from \"./interface/IMirrorOpenSaleV0.sol\";\nimport {Reentrancy} from \"../../lib/Reentrancy.sol\";\nimport {IERC165} from \"../../lib/ERC165/interface/IERC165.sol\";\nimport {IERC2981} from \"../../lib/ERC2981/interface/IERC2981.sol\";\nimport {ITreasuryConfig} from \"../../treasury/interface/ITreasuryConfig.sol\";\nimport {IMirrorTreasury} from \"../../treasury/interface/IMirrorTreasury.sol\";\nimport {IMirrorFeeRegistry} from \"../../fee-registry/MirrorFeeRegistry.sol\";\nimport {IERC721Events} from \"../../lib/ERC721/interface/IERC721.sol\";\n\n/**\n * @title MirrorOpenSaleV0\n *\n * @notice The Mirror Open Sale allows anyone to list an ERC721 with a tokenId range.\n *\n * Each token will be sold with tokenId incrementing starting at the lower end of the range.\n * To minimize storage we hash all sale configuration to generate a unique ID and only store\n * the necessary data that maintains the sale state.\n *\n * The token holder must first approve this contract otherwise purchasing will revert.\n *\n * The contract forwards the ether payment to the specified recipient and pays an optional fee\n * to the Mirror Treasury (0x138c3d30a724de380739aad9ec94e59e613a9008). Additionally, sale\n * royalties are distributed using the NFT Roylaties Standard (EIP-2981).\n *\n * @author MirrorXYZ\n */\ncontract MirrorOpenSaleV0 is\n    IMirrorOpenSaleV0,\n    IMirrorOpenSaleV0Events,\n    IERC721Events,\n    Reentrancy\n{\n    /// @notice Version\n    uint8 public constant VERSION = 0;\n\n    /// @notice Mirror treasury configuration\n    address public immutable override treasuryConfig;\n\n    /// @notice Mirror fee registry\n    address public immutable override feeRegistry;\n\n    /// @notice Mirror tributary registry\n    address public immutable override tributaryRegistry;\n\n    /// @notice Map of sale data hash to sale state\n    mapping(bytes32 => Sale) internal sales_;\n\n    /// @notice Store configuration and registry addresses as immutable\n    /// @param treasuryConfig_ address for Mirror treasury configuration\n    /// @param feeRegistry_ address for Mirror fee registry\n    /// @param tributaryRegistry_ address for Mirror tributary registry\n    constructor(\n        address treasuryConfig_,\n        address feeRegistry_,\n        address tributaryRegistry_\n    ) {\n        treasuryConfig = treasuryConfig_;\n        feeRegistry = feeRegistry_;\n        tributaryRegistry = tributaryRegistry_;\n    }\n\n    /// @notice Get stored state for a specific sale\n    /// @param h keccak256 of sale configuration (see `_getHash`)\n    function sale(bytes32 h) external view override returns (Sale memory) {\n        return sales_[h];\n    }\n\n    /// @notice Register a sale\n    /// @dev only the token itself or the operator can list tokens\n    /// @param saleConfig_ sale configuration\n    function register(SaleConfig calldata saleConfig_) external override {\n        require(\n            msg.sender == saleConfig_.token ||\n                msg.sender == saleConfig_.operator,\n            \"cannot register\"\n        );\n\n        _register(saleConfig_);\n    }\n\n    /// @notice Close a sale\n    /// @dev Reverts if called by an account that does not operate the sale\n    /// @param saleConfig_ sale configuration\n    function close(SaleConfig calldata saleConfig_) external override {\n        require(msg.sender == saleConfig_.operator, \"not operator\");\n\n        _setSaleStatus(saleConfig_, false);\n    }\n\n    /// @notice Open a sale\n    /// @dev Reverts if called by an account that does not operate the sale\n    /// @param saleConfig_ sale configuration\n    function open(SaleConfig calldata saleConfig_) external override {\n        require(msg.sender == saleConfig_.operator, \"not operator\");\n\n        _setSaleStatus(saleConfig_, true);\n    }\n\n    /// @notice Purchase a token\n    /// @dev Reverts if the sale configuration does not hash to an open sale,\n    ///  not enough ether is sent, he sale is sold out, or if token approval\n    ///  has not been granted. Sends funds to the recipient and treasury.\n    /// @param saleConfig_ sale configuration\n    /// @param recipient account that will receive the purchased token\n    function purchase(SaleConfig calldata saleConfig_, address recipient)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        // generate hash of sale data\n        bytes32 h = _getHash(saleConfig_);\n\n        // retrive stored sale data\n        Sale storage s = sales_[h];\n\n        // the registered field serves to assert that the hash maps to\n        // a listed sale and the open field asserts the listed sale is open\n        require(s.registered && s.open, \"closed sale\");\n\n        // assert correct amount of eth is received\n        require(msg.value == saleConfig_.price, \"incorrect value\");\n\n        // calculate next tokenId, and increment amount sold\n        uint256 tokenId = saleConfig_.startTokenId + s.sold++;\n\n        // check that the tokenId is valid\n        require(tokenId <= saleConfig_.endTokenId, \"sold out\");\n\n        // transfer token to recipient\n        IERC721(saleConfig_.token).transferFrom(\n            saleConfig_.operator,\n            recipient,\n            tokenId\n        );\n\n        emit Purchase(\n            // h\n            h,\n            // token\n            saleConfig_.token,\n            // tokenId\n            tokenId,\n            // buyer\n            msg.sender,\n            // recipient\n            recipient\n        );\n\n        // send funds to recipient and pay fees if necessary\n        _withdraw(\n            saleConfig_.operator,\n            saleConfig_.token,\n            tokenId,\n            h,\n            saleConfig_.recipient,\n            msg.value,\n            saleConfig_.feePercentage\n        );\n    }\n\n    // ============ Internal Methods ============\n\n    function _feeAmount(uint256 amount, uint256 fee)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (amount * fee) / 10_000;\n    }\n\n    function _getHash(SaleConfig calldata saleConfig_)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    saleConfig_.token,\n                    saleConfig_.startTokenId,\n                    saleConfig_.endTokenId,\n                    saleConfig_.operator,\n                    saleConfig_.recipient,\n                    saleConfig_.price,\n                    saleConfig_.open,\n                    saleConfig_.feePercentage\n                )\n            );\n    }\n\n    function _register(SaleConfig calldata saleConfig_) internal {\n        // get maximum fee from fees registry\n        uint256 maxFee = IMirrorFeeRegistry(feeRegistry).maxFee();\n\n        // allow to pay any fee below the max, including no fees\n        require(saleConfig_.feePercentage <= maxFee, \"fee too high\");\n\n        // generate hash of sale data\n        bytes32 h = _getHash(saleConfig_);\n\n        // assert the sale has not been registered previously\n        require(!sales_[h].registered, \"sale already registered\");\n\n        // store critical sale data\n        sales_[h] = Sale({\n            registered: true,\n            open: saleConfig_.open,\n            sold: 0,\n            operator: saleConfig_.operator\n        });\n\n        // all fields used to generate the hash need to be emitted to store and\n        // generate the hash off-chain for interacting with the sale\n        emit RegisteredSale(\n            // h\n            h,\n            // token\n            saleConfig_.token,\n            // startTokenId\n            saleConfig_.startTokenId,\n            // endTokenId\n            saleConfig_.endTokenId,\n            // operator\n            saleConfig_.operator,\n            // recipient\n            saleConfig_.recipient,\n            // price\n            saleConfig_.price,\n            // open\n            saleConfig_.open,\n            // feePercentage\n            saleConfig_.feePercentage\n        );\n\n        if (saleConfig_.open) {\n            emit OpenSale(h);\n        } else {\n            emit CloseSale(h);\n        }\n    }\n\n    function _setSaleStatus(SaleConfig calldata saleConfig_, bool status)\n        internal\n    {\n        bytes32 h = _getHash(saleConfig_);\n\n        // assert the sale is registered\n        require(sales_[h].registered, \"unregistered sale\");\n\n        require(sales_[h].open != status, \"status already set\");\n\n        sales_[h].open = status;\n\n        if (status) {\n            emit OpenSale(h);\n        } else {\n            emit CloseSale(h);\n        }\n    }\n\n    function _withdraw(\n        address operator,\n        address token,\n        uint256 tokenId,\n        bytes32 h,\n        address recipient,\n        uint256 totalAmount,\n        uint256 feePercentage\n    ) internal {\n        uint256 feeAmount = 0;\n\n        if (feePercentage > 0) {\n            // calculate fee amount\n            feeAmount = _feeAmount(totalAmount, feePercentage);\n\n            // contribute to treasury\n            IMirrorTreasury(ITreasuryConfig(treasuryConfig).treasury())\n                .contributeWithTributary{value: feeAmount}(operator);\n        }\n\n        uint256 saleAmount = totalAmount - feeAmount;\n\n        (address royaltyRecipient, uint256 royaltyAmount) = _royaltyInfo(\n            token,\n            tokenId,\n            saleAmount\n        );\n\n        require(royaltyAmount < saleAmount, \"invalid royalty amount\");\n\n        if (msg.sender == royaltyRecipient || royaltyRecipient == address(0)) {\n            // transfer funds to recipient\n            _send(payable(recipient), saleAmount);\n\n            // emit an event describing the withdrawal\n            emit Withdraw(h, totalAmount, feeAmount, recipient);\n        } else {\n            // transfer funds to recipient\n            _send(payable(recipient), saleAmount - royaltyAmount);\n\n            // transfer royalties\n            _send(payable(royaltyRecipient), royaltyAmount);\n\n            // emit an event describing the withdrawal\n            emit Withdraw(h, totalAmount, feeAmount, recipient);\n        }\n    }\n\n    function _royaltyInfo(\n        address token,\n        uint256 tokenId,\n        uint256 amount\n    ) internal view returns (address royaltyRecipient, uint256 royaltyAmount) {\n        // get royalty info\n        if (IERC165(token).supportsInterface(type(IERC2981).interfaceId)) {\n            (royaltyRecipient, royaltyAmount) = IERC2981(token).royaltyInfo(\n                tokenId,\n                amount\n            );\n        }\n    }\n\n    function _send(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"recipient reverted\");\n    }\n}\n\ninterface IERC721 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n"
    },
    "contracts/distributors/open-sale/interface/IMirrorOpenSaleV0.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\ninterface IMirrorOpenSaleV0Events {\n    event RegisteredSale(\n        bytes32 h,\n        address indexed token,\n        uint256 startTokenId,\n        uint256 endTokenId,\n        address indexed operator,\n        address indexed recipient,\n        uint256 price,\n        bool open,\n        uint256 feePercentage\n    );\n\n    event Purchase(\n        bytes32 h,\n        address indexed token,\n        uint256 tokenId,\n        address indexed buyer,\n        address indexed recipient\n    );\n\n    event Withdraw(\n        bytes32 h,\n        uint256 amount,\n        uint256 fee,\n        address indexed recipient\n    );\n\n    event OpenSale(bytes32 h);\n\n    event CloseSale(bytes32 h);\n}\n\ninterface IMirrorOpenSaleV0 {\n    struct Sale {\n        bool registered;\n        bool open;\n        uint256 sold;\n        address operator;\n    }\n\n    struct SaleConfig {\n        address token;\n        uint256 startTokenId;\n        uint256 endTokenId;\n        address operator;\n        address recipient;\n        uint256 price;\n        bool open;\n        uint256 feePercentage;\n    }\n\n    function treasuryConfig() external returns (address);\n\n    function feeRegistry() external returns (address);\n\n    function tributaryRegistry() external returns (address);\n\n    function sale(bytes32 h) external view returns (Sale memory);\n\n    function register(SaleConfig calldata saleConfig_) external;\n\n    function close(SaleConfig calldata saleConfig_) external;\n\n    function open(SaleConfig calldata saleConfig_) external;\n\n    function purchase(SaleConfig calldata saleConfig_, address recipient)\n        external\n        payable;\n}\n"
    },
    "contracts/lib/Reentrancy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\ncontract Reentrancy {\n    // ============ Constants ============\n\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\n    uint256 internal constant REENTRANCY_ENTERED = 2;\n\n    // ============ Mutable Storage ============\n\n    uint256 internal reentrancyStatus;\n\n    // ============ Modifiers ============\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(reentrancyStatus != REENTRANCY_ENTERED, \"Reentrant call\");\n        // Any calls to nonReentrant after this point will fail\n        reentrancyStatus = REENTRANCY_ENTERED;\n        _;\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip2200)\n        reentrancyStatus = REENTRANCY_NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/lib/ERC165/interface/IERC165.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/lib/ERC2981/interface/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\n/**\n * @title IERC2981\n * @notice Interface for the NFT Royalty Standard\n */\ninterface IERC2981 {\n    // / bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\n\n    /**\n     * @notice Called with the sale price to determine how much royalty\n     *         is owed and to whom.\n     * @param _tokenId - the NFT asset queried for royalty information\n     * @param _salePrice - the sale price of the NFT asset specified by _tokenId\n     * @return receiver - address of who should be sent the royalty payment\n     * @return royaltyAmount - the royalty payment amount for _salePrice\n     */\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "contracts/treasury/interface/ITreasuryConfig.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\ninterface ITreasuryConfig {\n    function treasury() external returns (address payable);\n\n    function distributionModel() external returns (address);\n}\n"
    },
    "contracts/treasury/interface/IMirrorTreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\ninterface IMirrorTreasury {\n    function transferFunds(address payable to, uint256 value) external;\n\n    function transferERC20(\n        address token,\n        address to,\n        uint256 value\n    ) external;\n\n    function contributeWithTributary(address tributary) external payable;\n\n    function contribute(uint256 amount) external payable;\n}\n"
    },
    "contracts/fee-registry/MirrorFeeRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport {Ownable} from \"../lib/Ownable.sol\";\n\ninterface IMirrorFeeRegistry {\n    function maxFee() external returns (uint256);\n\n    function updateMaxFee(uint256 newFee) external;\n}\n\n/**\n * @title MirrorFeeRegistry\n * @author MirrorXYZ\n */\ncontract MirrorFeeRegistry is IMirrorFeeRegistry, Ownable {\n    uint256 public override maxFee = 500;\n\n    constructor(address owner_) Ownable(owner_) {}\n\n    function updateMaxFee(uint256 newFee) external override onlyOwner {\n        maxFee = newFee;\n    }\n}\n"
    },
    "contracts/lib/ERC721/interface/IERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\ninterface IERC721 {\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC721Events {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n}\n\ninterface IERC721Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ninterface IERC721Burnable is IERC721 {\n    function burn(uint256 tokenId) external;\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC721Royalties {\n    function getFeeRecipients(uint256 id)\n        external\n        view\n        returns (address payable[] memory);\n\n    function getFeeBps(uint256 id) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\ninterface IOwnableEvents {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n\ncontract Ownable is IOwnableEvents {\n    address public owner;\n    address private nextOwner;\n\n    // modifiers\n\n    modifier onlyOwner() {\n        require(isOwner(), \"caller is not the owner.\");\n        _;\n    }\n\n    modifier onlyNextOwner() {\n        require(isNextOwner(), \"current owner must set caller as next owner.\");\n        _;\n    }\n\n    /**\n     * @dev Initialize contract by setting transaction submitter as initial owner.\n     */\n    constructor(address owner_) {\n        owner = owner_;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /**\n     * @dev Initiate ownership transfer by setting nextOwner.\n     */\n    function transferOwnership(address nextOwner_) external onlyOwner {\n        require(nextOwner_ != address(0), \"Next owner is the zero address.\");\n\n        nextOwner = nextOwner_;\n    }\n\n    /**\n     * @dev Cancel ownership transfer by deleting nextOwner.\n     */\n    function cancelOwnershipTransfer() external onlyOwner {\n        delete nextOwner;\n    }\n\n    /**\n     * @dev Accepts ownership transfer by setting owner.\n     */\n    function acceptOwnership() external onlyNextOwner {\n        delete nextOwner;\n\n        owner = msg.sender;\n\n        emit OwnershipTransferred(owner, msg.sender);\n    }\n\n    /**\n     * @dev Renounce ownership by setting owner to zero address.\n     */\n    function renounceOwnership() external onlyOwner {\n        _renounceOwnership();\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == owner;\n    }\n\n    /**\n     * @dev Returns true if the caller is the next owner.\n     */\n    function isNextOwner() public view returns (bool) {\n        return msg.sender == nextOwner;\n    }\n\n    function _setOwner(address previousOwner, address newOwner) internal {\n        owner = newOwner;\n        emit OwnershipTransferred(previousOwner, owner);\n    }\n\n    function _renounceOwnership() internal {\n        owner = address(0);\n\n        emit OwnershipTransferred(owner, address(0));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}