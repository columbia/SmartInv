{{
  "language": "Solidity",
  "sources": {
    "contracts/liquidityMining/KyberSwapElasticLM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {LMHelper} from './LMHelper.sol';\nimport {KSMath} from '../libraries/KSMath.sol';\nimport {IKyberSwapElasticLM} from '../interfaces/liquidityMining/IKyberSwapElasticLM.sol';\nimport {IKyberRewardLockerV2} from '../interfaces/liquidityMining/IKyberRewardLockerV2.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\ncontract KyberSwapElasticLM is IKyberSwapElasticLM, AccessControl, LMHelper, ReentrancyGuard {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using SafeERC20 for IERC20Metadata;\n  using KSMath for uint256;\n\n  IERC721 public immutable nft;\n  // contract for locking reward\n  IKyberRewardLockerV2 public immutable rewardLocker;\n\n  // keccak256(\"OPERATOR\") : 0x523a704056dcd17bcf83bed8b68c59416dac1119be77755efe3bde0a64e46e0c\n  bytes32 internal constant OPERATOR_ROLE =\n    0x523a704056dcd17bcf83bed8b68c59416dac1119be77755efe3bde0a64e46e0c;\n  uint256 internal constant PRECISION = 1e12;\n\n  uint256 public numPools;\n\n  // pId => Pool info\n  mapping(uint256 => LMPoolInfo) public pools;\n\n  // nftId => Position info\n  mapping(uint256 => PositionInfo) public positions;\n\n  // nftId => pId => Stake info\n  mapping(uint256 => mapping(uint256 => StakeInfo)) public stakes;\n\n  // nftId => list of joined pools\n  mapping(uint256 => EnumerableSet.UintSet) internal joinedPools;\n\n  // user address => set of nft id which user already deposit into LM contract\n  mapping(address => EnumerableSet.UintSet) private depositNFTs;\n\n  mapping(uint256 => bool) public isEmergencyWithdrawnNFT;\n\n  bool public emergencyEnabled;\n\n  modifier checkLength(uint256 a, uint256 b) {\n    require(a == b, 'invalid length');\n    _;\n  }\n\n  constructor(IERC721 _nft, IKyberRewardLockerV2 _rewardLocker) {\n    nft = _nft;\n    rewardLocker = _rewardLocker;\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(OPERATOR_ROLE, msg.sender);\n  }\n\n  /**\n   * EXTERNAL FUNCTIONS *************************\n   */\n\n  /**\n   * @dev receive native reward token\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Set emergencyEnabled flag to true\n   */\n  function emergencyEnable() public onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(!emergencyEnabled, 'Invalid value');\n    emergencyEnabled = true;\n    emit EmergencyEnabled();\n  }\n\n  /**\n   * @dev Add a new LM pool\n   * @param poolAddress Pool address\n   * @param startTime Start time of the pool\n   * @param endTime End time of the pool\n   * @param vestingDuration Duration of the vesting period\n   * @param rewardTokens List of ERC20 reward tokens\n   * @param rewardAmounts List of total reward amount for each token\n   * @param feeTarget Fee target of the pool\n   */\n  function addPool(\n    address poolAddress,\n    uint32 startTime,\n    uint32 endTime,\n    uint32 vestingDuration,\n    address[] calldata rewardTokens,\n    uint256[] calldata rewardAmounts,\n    uint256 feeTarget\n  )\n    external\n    override\n    onlyRole(OPERATOR_ROLE)\n    checkLength(rewardTokens.length, rewardAmounts.length)\n  {\n    require(startTime >= _getBlockTime() && endTime > startTime, 'addPool: invalid times');\n    uint256 pId = numPools; // save gas\n    LMPoolInfo storage pool = pools[pId];\n\n    pool.poolAddress = poolAddress;\n    pool.startTime = startTime;\n    pool.endTime = endTime;\n    pool.vestingDuration = vestingDuration;\n    pool.totalSecondsClaimed = 0;\n    pool.feeTarget = feeTarget;\n\n    for (uint256 i = 0; i < rewardTokens.length; i++) {\n      if (\n        rewardTokens[i] != address(0) &&\n        IERC20Metadata(rewardTokens[i]).allowance(address(this), address(rewardLocker)) == 0\n      ) {\n        IERC20Metadata(rewardTokens[i]).safeIncreaseAllowance(\n          address(rewardLocker),\n          type(uint256).max\n        );\n      }\n      pool.rewards.push(RewardData(rewardTokens[i], rewardAmounts[i]));\n    }\n    numPools++;\n    emit AddPool(pId, poolAddress, startTime, endTime, vestingDuration, feeTarget);\n  }\n\n  /**\n   * @dev Renew a pool to start another LM program\n   * @param pId Pool id to be renewed\n   * @param startTime Start time of the pool\n   * @param endTime End time of the pool\n   * @param vestingDuration Duration of the vesting period\n   * @param rewardAmounts List of total reward amount for each token\n   * @param feeTarget Fee target of the pool\n   */\n  function renewPool(\n    uint256 pId,\n    uint32 startTime,\n    uint32 endTime,\n    uint32 vestingDuration,\n    uint256[] calldata rewardAmounts,\n    uint256 feeTarget\n  ) external override onlyRole(OPERATOR_ROLE) {\n    LMPoolInfo storage pool = pools[pId];\n\n    // check if pool has not started or already ended\n    require(\n      pool.startTime > _getBlockTime() || pool.endTime < _getBlockTime(),\n      'renew: invalid pool state'\n    );\n    require(pool.rewards.length == rewardAmounts.length, 'renew: invalid length');\n    // check input startTime and endTime\n    require(startTime > _getBlockTime() && endTime > startTime, 'renew: invalid times');\n    // check pool has stakes\n    require(pool.numStakes == 0, 'renew: pool has stakes');\n\n    pool.startTime = startTime;\n    pool.endTime = endTime;\n    pool.vestingDuration = vestingDuration;\n    pool.totalSecondsClaimed = 0;\n    pool.feeTarget = feeTarget;\n\n    for (uint256 i = 0; i < rewardAmounts.length; ++i) {\n      pool.rewards[i].rewardUnclaimed = rewardAmounts[i];\n    }\n    emit RenewPool(pId, startTime, endTime, vestingDuration, feeTarget);\n  }\n\n  /**\n   * @dev Deposit NFTs into the pool\n   * @param nftIds List of NFT ids from BasePositionManager\n   *\n   */\n  function deposit(uint256[] calldata nftIds) external override {\n    address sender = msg.sender;\n    // save gas\n    bool _emergencyEnabled = emergencyEnabled;\n    // save gas\n\n    for (uint256 i = 0; i < nftIds.length; i++) {\n      require(!_emergencyEnabled || !isEmergencyWithdrawnNFT[nftIds[i]], 'Not allowed to deposit');\n      require(!_emergencyEnabled || !isEmergencyWithdrawnNFT[nftIds[i]], 'Not allowed to deposit');\n      positions[nftIds[i]].owner = sender;\n      require(depositNFTs[sender].add(nftIds[i]), 'Fail to add depositNFTs');\n      nft.transferFrom(sender, address(this), nftIds[i]);\n      emit Deposit(sender, nftIds[i]);\n    }\n  }\n\n  /**\n   * @dev Withdraw NFTs, must exit all pools before call\n   * @param nftIds List of NFT ids from BasePositionManager\n   */\n  function withdraw(uint256[] calldata nftIds) external override {\n    address sender = msg.sender;\n    for (uint256 i = 0; i < nftIds.length; ++i) {\n      PositionInfo storage position = positions[nftIds[i]];\n      require(position.owner == sender, 'withdraw: not owner');\n      require(joinedPools[nftIds[i]].length() == 0, 'withdraw: not exited yet');\n      delete positions[nftIds[i]];\n      require(depositNFTs[sender].remove(nftIds[i]), 'Fail to remove depositNFTs');\n      nft.transferFrom(address(this), sender, nftIds[i]);\n      emit Withdraw(sender, nftIds[i]);\n    }\n  }\n\n  /**\n   * @dev Emergency withdraw NFT position, will not receive any reward\n   * @param nftIds NFT id from BasePositionManager\n   */\n  function emergencyWithdraw(uint256[] calldata nftIds) external {\n    address sender = msg.sender;\n    // save gas\n    bool _emergencyEnabled = emergencyEnabled;\n\n    for (uint256 i = 0; i < nftIds.length; ++i) {\n      PositionInfo storage position = positions[nftIds[i]];\n      require(position.owner == sender, 'withdraw: not owner');\n\n      isEmergencyWithdrawnNFT[nftIds[i]] = true;\n      uint256[] memory values = joinedPools[nftIds[i]].values();\n      for (uint256 j = 0; j < values.length; ++j) {\n        uint256 poolId = values[j];\n        unchecked {\n          pools[poolId].numStakes--;\n        }\n        delete stakes[nftIds[i]][poolId];\n      }\n      delete positions[nftIds[i]];\n\n      if (!_emergencyEnabled) {\n        require(depositNFTs[sender].remove(nftIds[i]), 'Fail to remove depositNFTs');\n        for (uint256 j = 0; j < values.length; ++j) {\n          uint256 poolId = values[j];\n          require(joinedPools[nftIds[i]].remove(poolId), 'Fail to remove joinedPools');\n        }\n      }\n\n      nft.transferFrom(address(this), sender, nftIds[i]);\n      emit EmergencyWithdraw(sender, nftIds[i]);\n    }\n  }\n\n  /**\n   * @dev Emergency withdraw funds from contract, only admin can call this function\n   * @param rewards List of ERC20 tokens\n   * @param amounts List of amounts to be withdrawn\n   */\n  function emergencyWithdrawForOwner(address[] calldata rewards, uint256[] calldata amounts)\n    external\n    override\n    onlyRole(DEFAULT_ADMIN_ROLE)\n    checkLength(rewards.length, amounts.length)\n  {\n    for (uint256 i = 0; i < rewards.length; ++i) {\n      if (rewards[i] == address(0)) {\n        (bool success, ) = payable(msg.sender).call{value: amounts[i]}('');\n        require(success, 'transfer reward token failed');\n        emit EmergencyWithdrawForOwner(rewards[i], amounts[i]);\n      } else {\n        IERC20Metadata(rewards[i]).safeTransfer(msg.sender, amounts[i]);\n        emit EmergencyWithdrawForOwner(rewards[i], amounts[i]);\n      }\n    }\n  }\n\n  /**\n   * @dev Join pools\n   * @param pId pool id to join\n   * @param nftIds nfts to join\n   * @param liqs list liquidity value to join each nft\n   *\n   */\n  function join(\n    uint256 pId,\n    uint256[] calldata nftIds,\n    uint256[] calldata liqs\n  ) external nonReentrant checkLength(nftIds.length, liqs.length) {\n    require(numPools > pId, 'Pool not exists');\n    LMPoolInfo storage pool = pools[pId];\n    require(pool.startTime <= _getBlockTime() && _getBlockTime() < pool.endTime, 'Invalid time');\n    for (uint256 i = 0; i < nftIds.length; ++i) {\n      require(positions[nftIds[i]].owner == msg.sender, 'Not owner');\n      positions[nftIds[i]].liquidity = getLiq(address(nft), nftIds[i]);\n      StakeInfo storage stake = stakes[nftIds[i]][pId];\n      if (stake.liquidity == 0) {\n        _join(nftIds[i], pId, liqs[i], pool);\n      } else {\n        _sync(nftIds[i], pId, liqs[i], pool);\n      }\n    }\n  }\n\n  /**\n   * @dev Exit from pools\n   * @param pId pool ids to exit\n   * @param nftIds list nfts id\n   * @param liqs list liquidity value to exit from each nft\n   *\n   */\n  function exit(\n    uint256 pId,\n    uint256[] calldata nftIds,\n    uint256[] calldata liqs\n  ) external nonReentrant checkLength(nftIds.length, liqs.length) {\n    require(numPools > pId, 'Pool not exists');\n    for (uint256 i = 0; i < nftIds.length; ++i) {\n      _exit(nftIds[i], pId, liqs[i]);\n    }\n  }\n\n  /**\n   * @dev Claim rewards for a list of pools for a list of nft positions\n   * @param nftIds List of NFT ids to harvest\n   * @param datas List of pool ids to harvest for each nftId, encoded into bytes\n   */\n  function harvestMultiplePools(uint256[] calldata nftIds, bytes[] calldata datas)\n    external\n    nonReentrant\n    checkLength(nftIds.length, datas.length)\n  {\n    for (uint256 i; i < nftIds.length; ++i) {\n      require(positions[nftIds[i]].owner == msg.sender, 'harvest: not owner');\n      HarvestData memory data = abi.decode(datas[i], (HarvestData));\n      for (uint256 j; j < data.pIds.length; ++j) {\n        _harvest(nftIds[i], data.pIds[j]);\n      }\n    }\n  }\n\n  /**\n   * GETTER FUNCTION *****************************\n   */\n  function poolLength() external view returns (uint256) {\n    return numPools;\n  }\n\n  function getJoinedPools(uint256 nftId) external view returns (uint256[] memory poolIds) {\n    uint256 length = joinedPools[nftId].length();\n    poolIds = new uint256[](length);\n    for (uint256 i = 0; i < length; ++i) {\n      poolIds[i] = joinedPools[nftId].at(i);\n    }\n  }\n\n  function getJoinedPoolsInRange(\n    uint256 nftId,\n    uint256 fromIndex,\n    uint256 toIndex\n  ) external view returns (uint256[] memory poolIds) {\n    require(fromIndex <= toIndex, 'fromIndex > toIndex');\n    require(toIndex < joinedPools[nftId].length(), 'toIndex >= length');\n    poolIds = new uint256[](toIndex - fromIndex + 1);\n    for (uint256 index = fromIndex; index <= toIndex; ++index) {\n      poolIds[index - fromIndex] = joinedPools[nftId].at(index);\n    }\n  }\n\n  function getUserInfo(uint256 nftId, uint256 pId)\n    external\n    view\n    returns (\n      uint256 liquidity,\n      uint256[] memory rewardPending,\n      uint256[] memory rewardLast\n    )\n  {\n    LMPoolInfo storage pool = pools[pId];\n    StakeInfo storage stake = stakes[nftId][pId];\n\n    require(stake.liquidity > 0, 'getUserInfo: not joined yet');\n\n    rewardPending = new uint256[](pool.rewards.length);\n    rewardLast = new uint256[](pool.rewards.length);\n\n    RewardCalculationData memory data = getRewardCalculationData(nftId, pId);\n    for (uint256 i = 0; i < pool.rewards.length; ++i) {\n      uint256 rewardHarvest = _calculateRewardHarvest(\n        stake.liquidity,\n        pool.rewards[i].rewardUnclaimed,\n        data.totalSecondsUnclaimed,\n        data.secondsPerLiquidity\n      );\n      uint256 rewardCollected = _calculateRewardCollected(\n        stake.rewardHarvested[i] + rewardHarvest,\n        data.vestingVolume,\n        stake.rewardLast[i]\n      );\n      rewardPending[i] = stake.rewardPending[i] + rewardCollected;\n      rewardLast[i] = stake.rewardLast[i];\n    }\n    liquidity = stake.liquidity;\n  }\n\n  function getPoolInfo(uint256 pId)\n    external\n    view\n    returns (\n      address poolAddress,\n      uint32 startTime,\n      uint32 endTime,\n      uint32 vestingDuration,\n      uint256 totalSecondsClaimed,\n      uint256 feeTarget,\n      uint256 numStakes,\n      //index reward => reward data\n      address[] memory rewardTokens,\n      uint256[] memory rewardUnclaimeds\n    )\n  {\n    LMPoolInfo storage pool = pools[pId];\n\n    poolAddress = pool.poolAddress;\n    startTime = pool.startTime;\n    endTime = pool.endTime;\n    vestingDuration = pool.vestingDuration;\n    totalSecondsClaimed = pool.totalSecondsClaimed;\n    feeTarget = pool.feeTarget;\n    numStakes = pool.numStakes;\n\n    uint256 length = pool.rewards.length;\n    rewardTokens = new address[](length);\n    rewardUnclaimeds = new uint256[](length);\n    for (uint256 i = 0; i < length; ++i) {\n      rewardTokens[i] = pool.rewards[i].rewardToken;\n      rewardUnclaimeds[i] = pool.rewards[i].rewardUnclaimed;\n    }\n  }\n\n  function getDepositedNFTs(address user) external view returns (uint256[] memory listNFTs) {\n    listNFTs = depositNFTs[user].values();\n  }\n\n  /**\n   * INTERNAL FUNCTIONS *************************\n   */\n  /**\n   * @dev join pool first time\n   * @param nftId NFT id to join\n   * @param pId pool id to join\n   * @param liq liquidity amount to join\n   * @param pool LM pool\n   */\n  function _join(\n    uint256 nftId,\n    uint256 pId,\n    uint256 liq,\n    LMPoolInfo storage pool\n  ) internal {\n    PositionInfo storage position = positions[nftId];\n    StakeInfo storage stake = stakes[nftId][pId];\n    require(checkPool(pool.poolAddress, address(nft), nftId), 'join: invalid pool');\n    require(liq != 0 && liq <= position.liquidity, 'join: invalid liq');\n\n    stake.secondsPerLiquidityLast = getActiveTime(pool.poolAddress, address(nft), nftId);\n    stake.rewardLast = new uint256[](pool.rewards.length);\n    stake.rewardPending = new uint256[](pool.rewards.length);\n    stake.rewardHarvested = new uint256[](pool.rewards.length);\n    if (pool.feeTarget != 0) {\n      stake.feeFirst = getSignedFee(address(nft), nftId);\n    }\n    stake.liquidity = liq;\n    pool.numStakes++;\n\n    require(joinedPools[nftId].add(pId), 'Fail to add joinedPools');\n\n    emit Join(nftId, pId, liq);\n  }\n\n  /**\n   * @dev Increase liquidity in pool\n   * @param nftId NFT id to sync\n   * @param pId pool id to sync\n   * @param liq liquidity amount to increase\n   * @param pool LM pool\n   */\n  function _sync(\n    uint256 nftId,\n    uint256 pId,\n    uint256 liq,\n    LMPoolInfo storage pool\n  ) internal {\n    PositionInfo storage position = positions[nftId];\n    StakeInfo storage stake = stakes[nftId][pId];\n\n    require(liq != 0 && liq + stake.liquidity <= position.liquidity, 'sync: invalid liq');\n\n    RewardCalculationData memory data = getRewardCalculationData(nftId, pId);\n\n    for (uint256 i = 0; i < pool.rewards.length; ++i) {\n      uint256 rewardHarvest = _calculateRewardHarvest(\n        stake.liquidity,\n        pool.rewards[i].rewardUnclaimed,\n        data.totalSecondsUnclaimed,\n        data.secondsPerLiquidity\n      );\n\n      if (rewardHarvest != 0) {\n        stake.rewardHarvested[i] += rewardHarvest;\n        pool.rewards[i].rewardUnclaimed -= rewardHarvest;\n      }\n\n      uint256 rewardCollected = _calculateRewardCollected(\n        stake.rewardHarvested[i],\n        data.vestingVolume,\n        stake.rewardLast[i]\n      );\n\n      if (rewardCollected != 0) {\n        stake.rewardLast[i] += rewardCollected;\n        stake.rewardPending[i] += rewardCollected;\n      }\n    }\n\n    pool.totalSecondsClaimed += data.secondsClaim;\n    stake.secondsPerLiquidityLast = data.secondsPerLiquidityNow;\n    stake.feeFirst = _calculateFeeFirstAfterJoin(\n      stake.feeFirst,\n      data.feeNow,\n      pool.feeTarget,\n      stake.liquidity,\n      liq,\n      nftId\n    );\n    stake.liquidity += liq;\n    emit SyncLiq(nftId, pId, liq);\n  }\n\n  /**\n   * @dev Exit pool\n   * @param nftId NFT id to exit\n   * @param pId pool id to exit\n   * @param liq liquidity amount to exit\n   */\n  function _exit(\n    uint256 nftId,\n    uint256 pId,\n    uint256 liq\n  ) internal {\n    LMPoolInfo storage pool = pools[pId];\n    PositionInfo storage position = positions[nftId];\n    StakeInfo storage stake = stakes[nftId][pId];\n\n    require(\n      position.owner == msg.sender ||\n        (_getBlockTime() > pool.endTime && hasRole(OPERATOR_ROLE, msg.sender)),\n      'exit: not owner or pool not ended'\n    );\n\n    require(liq != 0 && liq <= stake.liquidity, 'exit: invalid liq');\n\n    uint256 liquidityOld = stake.liquidity;\n    uint256 liquidityNew = liquidityOld - liq;\n    RewardCalculationData memory data = getRewardCalculationData(nftId, pId);\n\n    pool.totalSecondsClaimed += data.secondsClaim;\n    stake.secondsPerLiquidityLast = data.secondsPerLiquidityNow;\n    stake.liquidity = liquidityNew;\n    for (uint256 i = 0; i < pool.rewards.length; ++i) {\n      uint256 rewardHarvest = _calculateRewardHarvest(\n        liquidityOld,\n        pool.rewards[i].rewardUnclaimed,\n        data.totalSecondsUnclaimed,\n        data.secondsPerLiquidity\n      );\n\n      if (rewardHarvest != 0) {\n        stake.rewardHarvested[i] += rewardHarvest;\n        pool.rewards[i].rewardUnclaimed -= rewardHarvest;\n      }\n\n      uint256 rewardCollected = _calculateRewardCollected(\n        stake.rewardHarvested[i],\n        data.vestingVolume,\n        stake.rewardLast[i]\n      );\n\n      uint256 rewardPending = stake.rewardPending[i] + rewardCollected;\n      if (rewardPending != 0) {\n        if (rewardCollected != 0) {\n          stake.rewardLast[i] += rewardCollected;\n        }\n        stake.rewardPending[i] = 0;\n        _lockReward(\n          IERC20Metadata(pool.rewards[i].rewardToken),\n          position.owner,\n          rewardPending,\n          pool.vestingDuration\n        );\n      }\n    }\n    if (liquidityNew == 0) {\n      delete stakes[nftId][pId];\n      pool.numStakes--;\n\n      require(joinedPools[nftId].remove(pId), 'Fail to remove joinedPools');\n    }\n    emit Exit(msg.sender, nftId, pId, liq);\n  }\n\n  /**\n   * @dev Harvest reward\n   * @param nftId NFT id to harvest\n   * @param pId pool id to harvest\n   */\n  function _harvest(uint256 nftId, uint256 pId) internal {\n    require(numPools > pId, 'Pool not exists');\n    LMPoolInfo storage pool = pools[pId];\n    PositionInfo storage position = positions[nftId];\n    StakeInfo storage stake = stakes[nftId][pId];\n\n    require(stake.liquidity > 0, 'harvest: not joined yet');\n\n    RewardCalculationData memory data = getRewardCalculationData(nftId, pId);\n\n    pool.totalSecondsClaimed += data.secondsClaim;\n    stake.secondsPerLiquidityLast = data.secondsPerLiquidityNow;\n    for (uint256 i = 0; i < pool.rewards.length; ++i) {\n      uint256 rewardHarvest = _calculateRewardHarvest(\n        stake.liquidity,\n        pool.rewards[i].rewardUnclaimed,\n        data.totalSecondsUnclaimed,\n        data.secondsPerLiquidity\n      );\n\n      if (rewardHarvest != 0) {\n        stake.rewardHarvested[i] += rewardHarvest;\n        pool.rewards[i].rewardUnclaimed -= rewardHarvest;\n      }\n\n      uint256 rewardCollected = _calculateRewardCollected(\n        stake.rewardHarvested[i],\n        data.vestingVolume,\n        stake.rewardLast[i]\n      );\n\n      uint256 rewardPending = stake.rewardPending[i] + rewardCollected;\n      if (rewardPending != 0) {\n        if (rewardCollected != 0) {\n          stake.rewardLast[i] += rewardCollected;\n        }\n        stake.rewardPending[i] = 0;\n        _lockReward(\n          IERC20Metadata(pool.rewards[i].rewardToken),\n          position.owner,\n          rewardPending,\n          pool.vestingDuration\n        );\n      }\n    }\n  }\n\n  /**\n   * @dev Send reward to rewardLocker contract\n   */\n  function _lockReward(\n    IERC20Metadata token,\n    address _account,\n    uint256 _amount,\n    uint32 _vestingDuration\n  ) internal {\n    uint256 value = token == IERC20Metadata(address(0)) ? _amount : 0;\n    rewardLocker.lock{value: value}(address(token), _account, _amount, _vestingDuration);\n    emit Harvest(_account, address(token), _amount);\n  }\n\n  /**\n   * HELPER MATH FUNCTIONS *************************\n   */\n  function getRewardCalculationData(uint256 nftId, uint256 pId)\n    public\n    view\n    returns (RewardCalculationData memory data)\n  {\n    LMPoolInfo storage pool = pools[pId];\n    StakeInfo storage stake = stakes[nftId][pId];\n\n    data.secondsPerLiquidityNow = getActiveTime(pool.poolAddress, address(nft), nftId);\n    data.feeNow = getSignedFeePool(pool.poolAddress, address(nft), nftId);\n    data.vestingVolume = _calculateVestingVolume(data.feeNow, stake.feeFirst, pool.feeTarget);\n    data.totalSecondsUnclaimed = _calculateSecondsUnclaimed(\n      pool.startTime,\n      pool.endTime,\n      pool.totalSecondsClaimed\n    );\n    unchecked {\n      data.secondsPerLiquidity = data.secondsPerLiquidityNow - stake.secondsPerLiquidityLast;\n    }\n    data.secondsClaim = stake.liquidity * data.secondsPerLiquidity;\n  }\n\n  /**\n   * @dev feeFirst = (liq * max(feeNow - feeTarget, feeFirst) + liqAdd * feeNow) / liqNew\n   */\n  function _calculateFeeFirstAfterJoin(\n    int256 feeFirst,\n    int256 feeNow,\n    uint256 feeTarget,\n    uint256 liquidity,\n    uint256 liquidityAdd,\n    uint256 nftId\n  ) internal view returns (int256) {\n    if (feeTarget == 0) {\n      return 0;\n    }\n    int256 feeFirstCurrent = feeNow - int256(feeTarget) < feeFirst\n      ? feeFirst\n      : feeNow - int256(feeTarget);\n    int256 numerator = int256(liquidity) *\n      feeFirstCurrent +\n      int256(liquidityAdd) *\n      getSignedFee(address(nft), nftId);\n    int256 denominator = int256(liquidity + liquidityAdd);\n    return numerator / denominator;\n  }\n\n  /**\n   * @dev vesting = min((feeNow - feeFirst) / feeTarget, 1)\n   */\n  function _calculateVestingVolume(\n    int256 feeNow,\n    int256 feeFirst,\n    uint256 feeTarget\n  ) internal pure returns (uint256) {\n    if (feeTarget == 0) {\n      return PRECISION;\n    }\n    uint256 feeInside = uint256(feeNow - feeFirst);\n    return KSMath.min((feeInside * PRECISION) / feeTarget, PRECISION);\n  }\n\n  /**\n   * @dev secondsUnclaimed = (max(currentTime, endTime) - startTime) - secondsClaimed\n   */\n  function _calculateSecondsUnclaimed(\n    uint256 startTime,\n    uint256 endTime,\n    uint256 totalSecondsClaimed\n  ) internal view returns (uint256) {\n    uint256 totalSeconds = KSMath.max(_getBlockTime(), endTime) - startTime;\n    uint256 totalSecondsScaled = totalSeconds * (1 << 96);\n    return totalSecondsScaled > totalSecondsClaimed ? totalSecondsScaled - totalSecondsClaimed : 0;\n  }\n\n  /**\n   * @dev rewardHarvested = L * rewardRate * secondsPerLiquidity\n   */\n  function _calculateRewardHarvest(\n    uint256 liquidity,\n    uint256 rewardUnclaimed,\n    uint256 totalSecondsUnclaimed,\n    uint256 secondsPerLiquidity\n  ) internal pure returns (uint256) {\n    return (liquidity * rewardUnclaimed * secondsPerLiquidity) / totalSecondsUnclaimed;\n  }\n\n  /**\n   * @dev rewardCollected = Max(rewardHarvested * vestingVolume - rewardLast, 0);\n   */\n  function _calculateRewardCollected(\n    uint256 rewardHarvested,\n    uint256 vestingVolume,\n    uint256 rewardLast\n  ) internal pure returns (uint256) {\n    uint256 rewardNow = (rewardHarvested * vestingVolume) / PRECISION;\n    return rewardNow > rewardLast ? rewardNow - rewardLast : 0;\n  }\n\n  function _getBlockTime() internal view virtual returns (uint32) {\n    return uint32(block.timestamp);\n  }\n}\n"
    },
    "contracts/liquidityMining/LMHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport '../interfaces/liquidityMining/IBasePositionManager.sol';\nimport '../interfaces/liquidityMining/IPoolStorage.sol';\nimport {MathConstants as C} from '../libraries/MathConstants.sol';\nimport {FullMath} from '../libraries/FullMath.sol';\nimport {ReinvestmentMath} from '../libraries/ReinvestmentMath.sol';\n\nabstract contract LMHelper {\n  function checkPool(\n    address pAddress,\n    address nftContract,\n    uint256 nftId\n  ) public view returns (bool) {\n    IBasePositionManager.Position memory pData = _getPositionFromNFT(nftContract, nftId);\n    return IBasePositionManager(nftContract).addressToPoolId(pAddress) == pData.poolId;\n  }\n\n  /**\n   * @dev Get fee\n   * use virtual to be overrided to mock data for fuzz tests\n   */\n  function getFee(address nftContract, uint256 nftId) public view virtual returns (uint256) {\n    IBasePositionManager.Position memory pData = _getPositionFromNFT(nftContract, nftId);\n    return pData.feeGrowthInsideLast;\n  }\n\n  /**\n   * @dev Get fee\n   * use virtual to be overrided to mock data for fuzz tests\n   *\n   */\n  function getFeePool(\n    address poolAddress,\n    address nftContract,\n    uint256 nftId\n  ) public view virtual returns (uint256 feeGrowthInside) {\n    IBasePositionManager.Position memory position = _getPositionFromNFT(nftContract, nftId);\n    (, , uint256 lowerValue, ) = IPoolStorage(poolAddress).ticks(position.tickLower);\n    (, , uint256 upperValue, ) = IPoolStorage(poolAddress).ticks(position.tickUpper);\n    (, int24 currentTick, , ) = IPoolStorage(poolAddress).getPoolState();\n    uint256 feeGrowthGlobal = IPoolStorage(poolAddress).getFeeGrowthGlobal();\n\n    {\n      (uint128 baseL, uint128 reinvestL, uint128 reinvestLLast) = IPoolStorage(poolAddress)\n        .getLiquidityState();\n      uint256 rTotalSupply = IERC20(poolAddress).totalSupply();\n      // logic ported from Pool._syncFeeGrowth()\n      uint256 rMintQty = ReinvestmentMath.calcrMintQty(\n        uint256(reinvestL),\n        uint256(reinvestLLast),\n        baseL,\n        rTotalSupply\n      );\n\n      if (rMintQty != 0) {\n        // fetch governmentFeeUnits\n        (, uint24 governmentFeeUnits) = IPoolStorage(poolAddress).factory().feeConfiguration();\n        unchecked {\n          if (governmentFeeUnits != 0) {\n            uint256 rGovtQty = (rMintQty * governmentFeeUnits) / C.FEE_UNITS;\n            rMintQty -= rGovtQty;\n          }\n          feeGrowthGlobal += FullMath.mulDivFloor(rMintQty, C.TWO_POW_96, baseL);\n        }\n      }\n    }\n    unchecked {\n      if (currentTick < position.tickLower) {\n        feeGrowthInside = lowerValue - upperValue;\n      } else if (currentTick >= position.tickUpper) {\n        feeGrowthInside = upperValue - lowerValue;\n      } else {\n        feeGrowthInside = feeGrowthGlobal - (lowerValue + upperValue);\n      }\n    }\n  }\n\n  /// @dev use virtual to be overrided to mock data for fuzz tests\n  function getActiveTime(\n    address pAddr,\n    address nftContract,\n    uint256 nftId\n  ) public view virtual returns (uint128) {\n    IBasePositionManager.Position memory pData = _getPositionFromNFT(nftContract, nftId);\n    return IPoolStorage(pAddr).getSecondsPerLiquidityInside(pData.tickLower, pData.tickUpper);\n  }\n\n  function getSignedFee(address nftContract, uint256 nftId) public view returns (int256) {\n    uint256 feeGrowthInsideLast = getFee(nftContract, nftId);\n    return int256(feeGrowthInsideLast);\n  }\n\n  function getSignedFeePool(\n    address poolAddress,\n    address nftContract,\n    uint256 nftId\n  ) public view returns (int256) {\n    uint256 feeGrowthInside = getFeePool(poolAddress, nftContract, nftId);\n    return int256(feeGrowthInside);\n  }\n\n  function getLiq(address nftContract, uint256 nftId) public view returns (uint128) {\n    IBasePositionManager.Position memory pData = _getPositionFromNFT(nftContract, nftId);\n    return pData.liquidity;\n  }\n\n  function _getPositionFromNFT(address nftContract, uint256 nftId)\n    internal\n    view\n    returns (IBasePositionManager.Position memory)\n  {\n    (IBasePositionManager.Position memory pData, ) = IBasePositionManager(nftContract).positions(\n      nftId\n    );\n    return pData;\n  }\n}\n"
    },
    "contracts/libraries/KSMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nlibrary KSMath {\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? b : a;\n  }\n}\n"
    },
    "contracts/interfaces/liquidityMining/IKyberSwapElasticLM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IKyberSwapElasticLMEvents} from './IKyberSwapElasticLMEvents.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\ninterface IKyberSwapElasticLM is IKyberSwapElasticLMEvents {\n  struct RewardData {\n    address rewardToken;\n    uint256 rewardUnclaimed;\n  }\n\n  struct LMPoolInfo {\n    address poolAddress;\n    uint32 startTime;\n    uint32 endTime;\n    uint32 vestingDuration;\n    uint256 totalSecondsClaimed; // scaled by (1 << 96)\n    RewardData[] rewards;\n    uint256 feeTarget;\n    uint256 numStakes;\n  }\n\n  struct PositionInfo {\n    address owner;\n    uint256 liquidity;\n  }\n\n  struct StakeInfo {\n    uint128 secondsPerLiquidityLast;\n    uint256[] rewardLast;\n    uint256[] rewardPending;\n    uint256[] rewardHarvested;\n    int256 feeFirst;\n    uint256 liquidity;\n  }\n\n  // input data in harvestMultiplePools function\n  struct HarvestData {\n    uint256[] pIds;\n  }\n\n  // avoid stack too deep error\n  struct RewardCalculationData {\n    uint128 secondsPerLiquidityNow;\n    int256 feeNow;\n    uint256 vestingVolume;\n    uint256 totalSecondsUnclaimed;\n    uint256 secondsPerLiquidity;\n    uint256 secondsClaim; // scaled by (1 << 96)\n  }\n\n  /**\n   * @dev Add new pool to LM\n   * @param poolAddr pool address\n   * @param startTime start time of liquidity mining\n   * @param endTime end time of liquidity mining\n   * @param vestingDuration time locking in reward locker\n   * @param rewardTokens reward token list for pool\n   * @param rewardAmounts reward amount of list token\n   * @param feeTarget fee target for pool\n   *\n   */\n  function addPool(\n    address poolAddr,\n    uint32 startTime,\n    uint32 endTime,\n    uint32 vestingDuration,\n    address[] calldata rewardTokens,\n    uint256[] calldata rewardAmounts,\n    uint256 feeTarget\n  ) external;\n\n  /**\n   * @dev Renew a pool to start another LM program\n   * @param pId pool id to update\n   * @param startTime start time of liquidity mining\n   * @param endTime end time of liquidity mining\n   * @param vestingDuration time locking in reward locker\n   * @param rewardAmounts reward amount of list token\n   * @param feeTarget fee target for pool\n   *\n   */\n  function renewPool(\n    uint256 pId,\n    uint32 startTime,\n    uint32 endTime,\n    uint32 vestingDuration,\n    uint256[] calldata rewardAmounts,\n    uint256 feeTarget\n  ) external;\n\n  /**\n   * @dev Deposit NFT\n   * @param nftIds list nft id\n   *\n   */\n  function deposit(uint256[] calldata nftIds) external;\n\n  /**\n   * @dev Withdraw NFT, must exit all pool before call.\n   * @param nftIds list nft id\n   *\n   */\n  function withdraw(uint256[] calldata nftIds) external;\n\n  /**\n   * @dev Join pools\n   * @param pId pool id to join\n   * @param nftIds nfts to join\n   * @param liqs list liquidity value to join each nft\n   *\n   */\n  function join(\n    uint256 pId,\n    uint256[] calldata nftIds,\n    uint256[] calldata liqs\n  ) external;\n\n  /**\n   * @dev Exit from pools\n   * @param pId pool ids to exit\n   * @param nftIds list nfts id\n   * @param liqs list liquidity value to exit from each nft\n   *\n   */\n  function exit(\n    uint256 pId,\n    uint256[] calldata nftIds,\n    uint256[] calldata liqs\n  ) external;\n\n  /**\n   * @dev Operator only. Call to withdraw all reward from list pools.\n   * @param rewards list reward address erc20 token\n   * @param amounts amount to withdraw\n   *\n   */\n  function emergencyWithdrawForOwner(address[] calldata rewards, uint256[] calldata amounts)\n    external;\n\n  /**\n   * @dev Withdraw NFT, can call any time, reward will be reset. Must enable this func by operator\n   * @param pIds list pool to withdraw\n   *\n   */\n  function emergencyWithdraw(uint256[] calldata pIds) external;\n\n  function nft() external view returns (IERC721);\n\n  function poolLength() external view returns (uint256);\n\n  function getUserInfo(uint256 nftId, uint256 pId)\n    external\n    view\n    returns (\n      uint256 liquidity,\n      uint256[] memory rewardPending,\n      uint256[] memory rewardLast\n    );\n\n  function getPoolInfo(uint256 pId)\n    external\n    view\n    returns (\n      address poolAddress,\n      uint32 startTime,\n      uint32 endTime,\n      uint32 vestingDuration,\n      uint256 totalSecondsClaimed,\n      uint256 feeTarget,\n      uint256 numStakes,\n      //index reward => reward data\n      address[] memory rewardTokens,\n      uint256[] memory rewardUnclaimeds\n    );\n\n  function getDepositedNFTs(address user) external view returns (uint256[] memory listNFTs);\n\n  function getRewardCalculationData(uint256 nftId, uint256 pId)\n    external\n    view\n    returns (RewardCalculationData memory data);\n}\n"
    },
    "contracts/interfaces/liquidityMining/IKyberRewardLockerV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.9;\n\ninterface IKyberRewardLockerV2 {\n  /**\n   * @dev queue a vesting schedule starting from now\n   */\n  function lock(\n    address token,\n    address account,\n    uint256 amount,\n    uint32 vestingDuration\n  ) external payable;\n\n  /**\n   * @dev queue a vesting schedule\n   */\n  function lockWithStartTime(\n    address token,\n    address account,\n    uint256 quantity,\n    uint256 startTime,\n    uint32 vestingDuration\n  ) external payable;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/liquidityMining/IBasePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\ninterface IBasePositionManager {\n  struct Position {\n    // the nonce for permits\n    uint96 nonce;\n    // the address that is approved for spending this token\n    address operator;\n    // the ID of the pool with which this token is connected\n    uint80 poolId;\n    // the tick range of the position\n    int24 tickLower;\n    int24 tickUpper;\n    // the liquidity of the position\n    uint128 liquidity;\n    // the current rToken that the position owed\n    uint256 rTokenOwed;\n    // fee growth per unit of liquidity as of the last update to liquidity\n    uint256 feeGrowthInsideLast;\n  }\n\n  struct PoolInfo {\n    address token0;\n    uint16 fee;\n    address token1;\n  }\n\n  function positions(uint256 tokenId)\n    external\n    view\n    returns (Position memory pos, PoolInfo memory info);\n\n  function addressToPoolId(address pool) external view returns (uint80);\n}\n"
    },
    "contracts/interfaces/liquidityMining/IPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IFactory} from './IFactory.sol';\n\ninterface IPoolStorage {\n  struct PoolData {\n    uint160 sqrtP;\n    int24 nearestCurrentTick;\n    int24 currentTick;\n    bool locked;\n    uint128 baseL;\n    uint128 reinvestL;\n    uint128 reinvestLLast;\n    uint256 feeGrowthGlobal;\n    uint128 secondsPerLiquidityGlobal;\n    uint32 secondsPerLiquidityUpdateTime;\n  }\n\n  // data stored for each initialized individual tick\n  struct TickData {\n    // gross liquidity of all positions in tick\n    uint128 liquidityGross;\n    // liquidity quantity to be added | removed when tick is crossed up | down\n    int128 liquidityNet;\n    // fee growth per unit of liquidity on the other side of this tick (relative to current tick)\n    // only has relative meaning, not absolute  the value depends on when the tick is initialized\n    uint256 feeGrowthOutside;\n    // seconds spent on the other side of this tick (relative to current tick)\n    // only has relative meaning, not absolute  the value depends on when the tick is initialized\n    uint128 secondsPerLiquidityOutside;\n  }\n\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\n  /// @return The contract address\n  function factory() external view returns (IFactory);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (IERC20);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (IERC20);\n\n  /// @notice The fee to be charged for a swap in basis points\n  /// @return The swap fee in basis points\n  function swapFeeBps() external view returns (uint16);\n\n  /// @notice The pool tick distance\n  /// @dev Ticks can only be initialized and used at multiples of this value\n  /// It remains an int24 to avoid casting even though it is >= 1.\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\n  /// @return The tick distance\n  function tickDistance() external view returns (int24);\n\n  /// @notice Maximum gross liquidity that an initialized tick can have\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxTickLiquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\n  /// secondsPerLiquidityOutside the seconds spent on the other side of the tick relative to the current tick\n  function ticks(int24 tick)\n    external\n    view\n    returns (\n      uint128 liquidityGross,\n      int128 liquidityNet,\n      uint256 feeGrowthOutside,\n      uint128 secondsPerLiquidityOutside\n    );\n\n  /// @notice Returns the previous and next initialized ticks of a specific tick\n  /// @dev If specified tick is uninitialized, the returned values are zero.\n  /// @param tick The tick to look up\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @return liquidity the liquidity quantity of the position\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\n  function getPositions(\n    address owner,\n    int24 tickLower,\n    int24 tickUpper\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\n\n  /// @notice Fetches the pool's prices, ticks and lock status\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\n  /// @return currentTick pool's current tick\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\n  /// @return locked true if pool is locked, false otherwise\n  function getPoolState()\n    external\n    view\n    returns (\n      uint160 sqrtP,\n      int24 currentTick,\n      int24 nearestCurrentTick,\n      bool locked\n    );\n\n  /// @notice Fetches the pool's liquidity values\n  /// @return baseL pool's base liquidity without reinvest liqudity\n  /// @return reinvestL the liquidity is reinvested into the pool\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\n  function getLiquidityState()\n    external\n    view\n    returns (\n      uint128 baseL,\n      uint128 reinvestL,\n      uint128 reinvestLLast\n    );\n\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\n  function getFeeGrowthGlobal() external view returns (uint256);\n\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\n  function getSecondsPerLiquidityData()\n    external\n    view\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\n\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\n  /// @param tickLower The lower tick (of a position)\n  /// @param tickUpper The upper tick (of a position)\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\n  /// between the 2 ticks, per unit of liquidity.\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\n    external\n    view\n    returns (uint128 secondsPerLiquidityInside);\n}\n"
    },
    "contracts/libraries/MathConstants.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\n/// @title Contains constants needed for math libraries\nlibrary MathConstants {\n  uint256 internal constant TWO_POW_96 = 2**96;\n  uint128 internal constant MIN_LIQUIDITY = 100_000;\n  uint24 internal constant FEE_UNITS = 100_000;\n  uint8 internal constant RES_96 = 96;\n}\n"
    },
    "contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n/// @dev Code has been modified to be compatible with sol 0.8\nlibrary FullMath {\n  /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDivFloor(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(a, b, not(0))\n      prod0 := mul(a, b)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == 0) {\n      require(denominator > 0, '0 denom');\n      assembly {\n        result := div(prod0, denominator)\n      }\n      return result;\n    }\n\n    // Make sure the result is less than 2**256.\n    // Also prevents denominator == 0\n    require(denominator > prod1, 'denom <= prod1');\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0]\n    // Compute remainder using mulmod\n    uint256 remainder;\n    assembly {\n      remainder := mulmod(a, b, denominator)\n    }\n    // Subtract 256 bit number from 512 bit number\n    assembly {\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator\n    // Compute largest power of two divisor of denominator.\n    // Always >= 1.\n    uint256 twos = denominator & (~denominator + 1);\n    // Divide denominator by power of two\n    assembly {\n      denominator := div(denominator, twos)\n    }\n\n    // Divide [prod1 prod0] by the factors of two\n    assembly {\n      prod0 := div(prod0, twos)\n    }\n    // Shift in bits from prod1 into prod0. For this we need\n    // to flip `twos` such that it is 2**256 / twos.\n    // If twos is zero, then it becomes one\n    assembly {\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n    unchecked {\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2**256\n      // Now that denominator is an odd number, it has an inverse\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n      // Compute the inverse by starting with a seed that is correct\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\n      uint256 inv = (3 * denominator) ^ 2;\n\n      // Now use Newton-Raphson iteration to improve the precision.\n      // Thanks to Hensel's lifting lemma, this also works in modular\n      // arithmetic, doubling the correct bits in each step.\n      inv *= 2 - denominator * inv; // inverse mod 2**8\n      inv *= 2 - denominator * inv; // inverse mod 2**16\n      inv *= 2 - denominator * inv; // inverse mod 2**32\n      inv *= 2 - denominator * inv; // inverse mod 2**64\n      inv *= 2 - denominator * inv; // inverse mod 2**128\n      inv *= 2 - denominator * inv; // inverse mod 2**256\n\n      // Because the division is now exact we can divide by multiplying\n      // with the modular inverse of denominator. This will give us the\n      // correct result modulo 2**256. Since the precoditions guarantee\n      // that the outcome is less than 2**256, this is the final result.\n      // We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inv;\n    }\n    return result;\n  }\n\n  /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivCeiling(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n    result = mulDivFloor(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      result++;\n    }\n  }\n}\n"
    },
    "contracts/libraries/ReinvestmentMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\nimport {FullMath} from './FullMath.sol';\n\n/// @title Contains helper function to calculate the number of reinvestment tokens to be minted\nlibrary ReinvestmentMath {\n  /// @dev calculate the mint amount with given reinvestL, reinvestLLast, baseL and rTotalSupply\n  /// contribution of lp to the increment is calculated by the proportion of baseL with reinvestL + baseL\n  /// then rMintQty is calculated by mutiplying this with the liquidity per reinvestment token\n  /// rMintQty = rTotalSupply * (reinvestL - reinvestLLast) / reinvestLLast * baseL / (baseL + reinvestL)\n  function calcrMintQty(\n    uint256 reinvestL,\n    uint256 reinvestLLast,\n    uint128 baseL,\n    uint256 rTotalSupply\n  ) internal pure returns (uint256 rMintQty) {\n    uint256 lpContribution = FullMath.mulDivFloor(\n      baseL,\n      reinvestL - reinvestLLast,\n      baseL + reinvestL\n    );\n    rMintQty = FullMath.mulDivFloor(rTotalSupply, lpContribution, reinvestLLast);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/liquidityMining/IFactory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\n/// @title KyberSwap v2 factory\n/// @notice Deploys KyberSwap v2 pools and manages control over government fees\ninterface IFactory {\n  /// @notice Emitted when a pool is created\n  /// @param token0 First pool token by address sort order\n  /// @param token1 Second pool token by address sort order\n  /// @param swapFeeBps Fee to be collected upon every swap in the pool, in basis points\n  /// @param tickDistance Minimum number of ticks between initialized ticks\n  /// @param pool The address of the created pool\n  event PoolCreated(\n    address indexed token0,\n    address indexed token1,\n    uint16 indexed swapFeeBps,\n    int24 tickDistance,\n    address pool\n  );\n\n  /// @notice Emitted when a new fee is enabled for pool creation via the factory\n  /// @param swapFeeBps Fee to be collected upon every swap in the pool, in basis points\n  /// @param tickDistance Minimum number of ticks between initialized ticks for pools created with the given fee\n  event SwapFeeEnabled(uint16 indexed swapFeeBps, int24 indexed tickDistance);\n\n  /// @notice Emitted when vesting period changes\n  /// @param vestingPeriod The maximum time duration for which LP fees\n  /// are proportionally burnt upon LP removals\n  event VestingPeriodUpdated(uint32 vestingPeriod);\n\n  /// @notice Emitted when configMaster changes\n  /// @param oldConfigMaster configMaster before the update\n  /// @param newConfigMaster configMaster after the update\n  event ConfigMasterUpdated(address oldConfigMaster, address newConfigMaster);\n\n  /// @notice Emitted when fee configuration changes\n  /// @param feeTo Recipient of government fees\n  /// @param governmentFeeBps Fee amount, in basis points,\n  /// to be collected out of the fee charged for a pool swap\n  event FeeConfigurationUpdated(address feeTo, uint16 governmentFeeBps);\n\n  /// @notice Emitted when whitelist feature is enabled\n  event WhitelistEnabled();\n\n  /// @notice Emitted when whitelist feature is disabled\n  event WhitelistDisabled();\n\n  /// @notice Returns the maximum time duration for which LP fees\n  /// are proportionally burnt upon LP removals\n  function vestingPeriod() external view returns (uint32);\n\n  /// @notice Returns the tick distance for a specified fee.\n  /// @dev Once added, cannot be updated or removed.\n  /// @param swapFeeBps Swap fee, in basis points.\n  /// @return The tick distance. Returns 0 if fee has not been added.\n  function feeAmountTickDistance(uint16 swapFeeBps) external view returns (int24);\n\n  /// @notice Returns the address which can update the fee configuration\n  function configMaster() external view returns (address);\n\n  /// @notice Returns the keccak256 hash of the Pool creation code\n  /// This is used for pre-computation of pool addresses\n  function poolInitHash() external view returns (bytes32);\n\n  /// @notice Fetches the recipient of government fees\n  /// and current government fee charged in basis points\n  function feeConfiguration() external view returns (address _feeTo, uint16 _governmentFeeBps);\n\n  /// @notice Returns the status of whitelisting feature of NFT managers\n  /// If true, anyone can mint liquidity tokens\n  /// Otherwise, only whitelisted NFT manager(s) are allowed to mint liquidity tokens\n  function whitelistDisabled() external view returns (bool);\n\n  //// @notice Returns all whitelisted NFT managers\n  /// If the whitelisting feature is turned on,\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\n  function getWhitelistedNFTManagers() external view returns (address[] memory);\n\n  /// @notice Checks if sender is a whitelisted NFT manager\n  /// If the whitelisting feature is turned on,\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\n  /// @param sender address to be checked\n  /// @return true if sender is a whistelisted NFT manager, false otherwise\n  function isWhitelistedNFTManager(address sender) external view returns (bool);\n\n  /// @notice Returns the pool address for a given pair of tokens and a swap fee\n  /// @dev Token order does not matter\n  /// @param tokenA Contract address of either token0 or token1\n  /// @param tokenB Contract address of the other token\n  /// @param swapFeeBps Fee to be collected upon every swap in the pool, in basis points\n  /// @return pool The pool address. Returns null address if it does not exist\n  function getPool(\n    address tokenA,\n    address tokenB,\n    uint16 swapFeeBps\n  ) external view returns (address pool);\n\n  /// @notice Fetch parameters to be used for pool creation\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\n  /// @return factory The factory address\n  /// @return token0 First pool token by address sort order\n  /// @return token1 Second pool token by address sort order\n  /// @return swapFeeBps Fee to be collected upon every swap in the pool, in basis points\n  /// @return tickDistance Minimum number of ticks between initialized ticks\n  function parameters()\n    external\n    view\n    returns (\n      address factory,\n      address token0,\n      address token1,\n      uint16 swapFeeBps,\n      int24 tickDistance\n    );\n\n  /// @notice Creates a pool for the given two tokens and fee\n  /// @param tokenA One of the two tokens in the desired pool\n  /// @param tokenB The other of the two tokens in the desired pool\n  /// @param swapFeeBps Desired swap fee for the pool, in basis points\n  /// @dev Token order does not matter. tickDistance is determined from the fee.\n  /// Call will revert under any of these conditions:\n  ///     1) pool already exists\n  ///     2) invalid swap fee\n  ///     3) invalid token arguments\n  /// @return pool The address of the newly created pool\n  function createPool(\n    address tokenA,\n    address tokenB,\n    uint16 swapFeeBps\n  ) external returns (address pool);\n\n  /// @notice Enables a fee amount with the given tickDistance\n  /// @dev Fee amounts may never be removed once enabled\n  /// @param swapFeeBps The fee amount to enable, in basis points\n  /// @param tickDistance The distance between ticks to be enforced for all pools created with the given fee amount\n  function enableSwapFee(uint16 swapFeeBps, int24 tickDistance) external;\n\n  /// @notice Updates the address which can update the fee configuration\n  /// @dev Must be called by the current configMaster\n  function updateConfigMaster(address) external;\n\n  /// @notice Updates the vesting period\n  /// @dev Must be called by the current configMaster\n  function updateVestingPeriod(uint32) external;\n\n  /// @notice Updates the address receiving government fees and fee quantity\n  /// @dev Only configMaster is able to perform the update\n  /// @param feeTo Address to receive government fees collected from pools\n  /// @param governmentFeeBps Fee amount, in basis points,\n  /// to be collected out of the fee charged for a pool swap\n  function updateFeeConfiguration(address feeTo, uint16 governmentFeeBps) external;\n\n  /// @notice Enables the whitelisting feature\n  /// @dev Only configMaster is able to perform the update\n  function enableWhitelist() external;\n\n  /// @notice Disables the whitelisting feature\n  /// @dev Only configMaster is able to perform the update\n  function disableWhitelist() external;\n}\n"
    },
    "contracts/interfaces/liquidityMining/IKyberSwapElasticLMEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IKyberSwapElasticLMEvents {\n  event AddPool(\n    uint256 indexed pId,\n    address poolAddress,\n    uint32 startTime,\n    uint32 endTime,\n    uint32 vestingDuration,\n    uint256 feeTarget\n  );\n\n  event RenewPool(\n    uint256 indexed pid,\n    uint32 startTime,\n    uint32 endTime,\n    uint32 vestingDuration,\n    uint256 feeTarget\n  );\n\n  event Deposit(address sender, uint256 indexed nftId);\n\n  event Withdraw(address sender, uint256 indexed nftId);\n\n  event Join(uint256 indexed nftId, uint256 indexed pId, uint256 indexed liq);\n\n  event Exit(address to, uint256 indexed nftId, uint256 indexed pId, uint256 indexed liq);\n\n  event SyncLiq(uint256 indexed nftId, uint256 indexed pId, uint256 indexed liq);\n\n  event Harvest(address to, address reward, uint256 indexed amount);\n\n  event EmergencyEnabled();\n\n  event EmergencyWithdrawForOwner(address reward, uint256 indexed amount);\n\n  event EmergencyWithdraw(address sender, uint256 indexed nftId);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}