{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Interface staking contract\npragma solidity ^0.7.0;\n\ninterface Staking {\n\n    /// @notice Returns total amount of tokens counted as stake\n    /// @param _userAddress user to retrieve staked balance from\n    /// @return finalized staked of _userAddress\n    function getStakedBalance(\n        address _userAddress) external view returns (uint256);\n\n    /// @notice Returns the timestamp when next deposit can be finalized\n    /// @return timestamp of when finalizeStakes() is callable\n    function getMaturingTimestamp(address _userAddress) external view returns (uint256);\n\n    /// @notice Returns the timestamp when next withdraw can be finalized\n    /// @return timestamp of when finalizeWithdraw() is callable\n    function getReleasingTimestamp(address _userAddress) external view returns (uint256);\n\n\n    /// @notice Returns the balance waiting/ready to be matured\n    /// @return amount that will get staked after finalization\n    function getMaturingBalance(address _userAddress) external view  returns (uint256);\n\n    /// @notice Returns the balance waiting/ready to be released\n    /// @return amount that will get withdrew after finalization\n    function getReleasingBalance(address _userAddress) external view  returns (uint256);\n\n\n    /// @notice Deposit CTSI to be staked. The money will turn into staked\n    ///         balance after timeToStake days\n    /// @param _amount The amount of tokens that are gonna be deposited.\n    function stake(uint256 _amount) external;\n\n    /// @notice Remove tokens from staked balance. The money can\n    ///         be released after timeToRelease seconds, if the\n    ///         function withdraw is called.\n    /// @param _amount The amount of tokens that are gonna be unstaked.\n    function unstake(uint256 _amount) external;\n\n    /// @notice Transfer tokens to user's wallet.\n    /// @param _amount The amount of tokens that are gonna be transferred.\n    function withdraw(uint256 _amount) external;\n\n    // events\n    /// @notice CTSI tokens were deposited, they count as stake after _maturationDate\n    /// @param user address of msg.sender\n    /// @param amount amount deposited for staking\n    /// @param maturationDate date when the stake can be finalized\n    event Stake(\n        address indexed user,\n        uint256 amount,\n        uint256 maturationDate\n    );\n\n    /// @notice Unstake tokens, moving them to releasing structure\n    /// @param user address of msg.sender\n    /// @param amount amount of tokens to be released\n    /// @param maturationDate date when the tokens can be withdrew\n    event Unstake(\n        address indexed user,\n        uint256 amount,\n        uint256 maturationDate\n    );\n\n    /// @notice Withdraw process was finalized\n    /// @param user address of msg.sender\n    /// @param amount amount of tokens withdrawn\n    event Withdraw(\n        address indexed user,\n        uint256 amount\n    );\n}\n\n"
    },
    "contracts/StakingImpl.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Cartesi Staking\n/// @author Felipe Argento\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./Staking.sol\";\n\ncontract StakingImpl is Staking {\n    using SafeMath for uint256;\n    IERC20 private ctsi;\n\n    uint256 timeToStake; // time it takes for deposited tokens to become staked.\n    uint256 timeToRelease; // time it takes from witdraw signal to tokens to be unlocked.\n\n    mapping(address => uint256) staked; // amount of money being staked.\n    mapping(address => MaturationStruct) maturing; // deposits waiting to be staked.\n    mapping(address => MaturationStruct) releasing; // money waiting for withdraw.\n\n    struct MaturationStruct {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    /// @notice constructor\n    /// @param _ctsiAddress address of compatible ERC20\n    /// @param _timeToStake time it takes for deposited tokens to become staked.\n    /// @param _timeToRelease time it takes from unstake to tokens being unlocked.\n    constructor(\n        address _ctsiAddress,\n        uint256 _timeToStake,\n        uint256 _timeToRelease\n    ) {\n        ctsi = IERC20(_ctsiAddress);\n        timeToStake = _timeToStake;\n        timeToRelease = _timeToRelease;\n    }\n\n    function stake(uint256 _amount) public override {\n        require(_amount > 0, \"amount cant be zero\");\n\n        // pointers to releasing/maturing structs\n        MaturationStruct storage r = releasing[msg.sender];\n        MaturationStruct storage m = maturing[msg.sender];\n\n        // check if there are mature coins to be staked\n        if (m.timestamp.add(timeToStake) <= block.timestamp) {\n            staked[msg.sender] = staked[msg.sender].add(m.amount);\n            m.amount = 0;\n        }\n\n        // first move tokens from releasing pool to maturing\n        // then transfer from wallet\n        if (r.amount >= _amount) {\n            r.amount = (r.amount).sub(_amount);\n        } else {\n            // transfer stake to contract\n            // from: msg.sender\n            // to: this contract\n            // value: _amount - releasing[msg.sender].amount\n            ctsi.transferFrom(msg.sender, address(this), _amount.sub(r.amount));\n            r.amount = 0;\n\n        }\n\n        m.amount = (m.amount).add(_amount);\n        m.timestamp = block.timestamp;\n\n        emit Stake(\n            msg.sender,\n            m.amount,\n            block.timestamp.add(timeToStake)\n        );\n    }\n\n    function unstake(uint256 _amount) public override {\n        require(_amount > 0, \"amount cant be zero\");\n\n        // pointers to releasing/maturing structs\n        MaturationStruct storage r = releasing[msg.sender];\n        MaturationStruct storage m = maturing[msg.sender];\n\n        if (m.amount >= _amount) {\n            m.amount = (m.amount).sub(_amount);\n        } else {\n            // safemath.sub guarantees that _amount <= m.amount + staked amount\n            staked[msg.sender] = staked[msg.sender].sub(_amount.sub(m.amount));\n            m.amount = 0;\n        }\n        // update releasing amount\n        r.amount = (r.amount).add(_amount);\n        r.timestamp = block.timestamp;\n\n        emit Unstake(\n            msg.sender,\n            r.amount,\n            block.timestamp.add(timeToRelease)\n        );\n    }\n\n    function withdraw(uint256 _amount) public override {\n        // pointer to releasing struct\n        MaturationStruct storage r = releasing[msg.sender];\n\n        require(_amount > 0, \"amount cant be zero\");\n        require(\n            r.timestamp.add(timeToRelease) <= block.timestamp,\n            \"tokens are not yet ready to be released\"\n        );\n\n        r.amount = (r.amount).sub(_amount, \"not enough tokens waiting to be released;\");\n\n        // withdraw tokens\n        // from: this contract\n        // to: msg.sender\n        // value: bet total withdraw value on toWithdraw\n        ctsi.transfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    // getters\n    function getMaturingTimestamp(\n        address _userAddress\n    )\n    public\n    view override\n    returns (uint256)\n    {\n        return maturing[_userAddress].timestamp.add(timeToStake);\n    }\n\n    function getMaturingBalance(\n        address _userAddress\n    )\n    public\n    view override\n    returns (uint256)\n    {\n        MaturationStruct storage m = maturing[_userAddress];\n\n        if (m.timestamp.add(timeToStake) <= block.timestamp) {\n            return 0;\n        }\n\n        return m.amount;\n    }\n\n    function getReleasingBalance(\n        address _userAddress\n    )\n    public\n    view override\n    returns (uint256)\n    {\n        return releasing[_userAddress].amount;\n    }\n\n    function getReleasingTimestamp(\n        address _userAddress\n    )\n    public\n    view override\n    returns (uint256)\n    {\n        return releasing[_userAddress].timestamp.add(timeToRelease);\n    }\n\n    function getStakedBalance(address _userAddress)\n    public\n    view override\n    returns (uint256)\n    {\n        MaturationStruct storage m = maturing[_userAddress];\n\n        // if there are mature deposits, treat them as staked\n        if (m.timestamp.add(timeToStake) <= block.timestamp) {\n            return staked[_userAddress].add(m.amount);\n        }\n\n        return staked[_userAddress];\n    }\n}\n"
    }
  }
}}