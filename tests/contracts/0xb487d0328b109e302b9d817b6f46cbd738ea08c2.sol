{"dao.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\ncontract DAO {\n    address public dao;\n\n    event DAOChanged(address from, address to);\n\n    constructor() {\n        dao = msg.sender;\n        emit DAOChanged(address(0), msg.sender);\n    }\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Only DAO\");\n        _;\n    }\n\n    function changeDAO(address _dao) external onlyDAO {\n        require(_dao != address(0), \"DAO to ZERO\");\n        address olddao = dao;\n        dao = _dao;\n        emit DAOChanged(olddao, dao);\n    }\n\n}\n"},"interfaces.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// Interfaces for contract interaction\ninterface INterfaces {\n    function balanceOf(address) external returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n}\n\n// For tokens that do not return true on transfers eg. USDT\ninterface INterfacesNoR {\n    function transfer(address, uint256) external;\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external;\n}\n"},"owned.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipChanged(address from, address to);\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipChanged(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    // owner can give super-rights to someone\n    function giveOwnership(address user) external onlyOwner {\n        require(user != address(0), \"User renounceOwnership\");\n        newOwner = user;\n    }\n\n    // new owner need to accept\n    function acceptOwnership() external {\n        require(msg.sender == newOwner, \"Only NewOwner\");\n        emit OwnershipChanged(owner, newOwner);\n        owner = msg.sender;\n        delete newOwner;\n    }\n}\n"},"TattooMoneyV2.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\n/**\nAbout TattooMoney DeFi \u0026 NFT project:\n\nTattooing is a timeless phenomenon. The first human to be tattooed was Ötzi the Iceman when archaeologists discovered his body dating between 3,370 and 3,100 BC, or more than 5,000 years ago.\nWe bring tattoos to the cryptographic space...\n\nhttps://app.TattooMoney.io/ - Our App\nhttps://TattooMoney.io/ - Info about Project\n*/\n\n// ------------------------------------------------------------------------------------\n// \u0027TattooMoneyV2\u0027 Token Contract\n//\n// Symbol      : TAT2\n// Name        : TattooMoney\n// Total Supply: 1,000,000,000 TAT2\n// Decimals    : 18\n//\n// © By \u0027TattooMoney Co LTD\u0027 With \u0027TAT2\u0027 Symbol since 2019.\n//\n// This is upgrade of token 0x960773318c1aeab5da6605c49266165af56435fa\n//\n// ------------------------------------------------------------------------------------\n\nimport \"./owned.sol\";\nimport \"./dao.sol\";\nimport \"./interfaces.sol\";\n\npragma solidity 0.8.7;\n\ncontract TattooMoneyV2 is IERC20, Owned, DAO {\n    constructor(address _owner) {\n        balances[_owner] = INITIAL_SUPPLY;\n        emit Transfer(ZERO, _owner, INITIAL_SUPPLY);\n        owner = _owner;\n        dao = 0x1e3d5272aa13f0c6d911866DBEF3C5979d9B7b40;\n        setfeesfree();\n    }\n\n    string public constant name = \"TattooMoney\";\n    string public constant symbol = \"TAT2\";\n    uint8 public constant decimals = 18;\n\n    uint256 private constant INITIAL_SUPPLY = 1_000_000_000 * (10**decimals);\n\n    uint256 private constant maxFee = 10;\n\n    uint256 private _totalSupply = INITIAL_SUPPLY;\n    uint256 private FeeTotalCollected;\n    uint256 private FeeTotalCollectedBurned;\n\n    address private constant ZERO = address(0);\n    mapping(address =\u003e uint256) private balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public override allowance;\n    mapping(address =\u003e bool) public isFeeFreeSender;\n    mapping(address =\u003e bool) public isFeeFreeRecipient;\n    mapping(address =\u003e bool) public frozenAccount;\n\n    uint256 public totalFee = 2; // Total procent fee deductet from transaction\n\n    uint256 public burnFees = 40; // fee taken and burned\n    uint256 public charityFees = 20; // fee taken and added to the charity\n    address public charityaddress = 0xA48E5C39c9AF0f3B1A948a63F44d63AB777CB684;\n    uint256 public rewardsFees = 20; // fee taken and added to rewards\n    address public rewardsaddress = 0x2794F6a795823EDebC41D1799c0829EcD36821d2;\n    uint256 public systemFees = 0; // fee taken and added to system\n    address public systemaddress = 0x705E0d5120511d823b813b9e24e5E34a58616C3A;\n    uint256 public stakingFees = 20; // fee taken and added to staking pool\n    address public stakingaddress = 0xEDC46D5dDb981b7Da1A743b2739e69e44c4FBCE7;\n\n    uint256 public minTotalSupply =0; // min amount of tokens total supply\n\n    /**\n    * @dev Update charity address\n    * @param _charityaddress new charity address\n    */\n    function updateCharityAddress( address _charityaddress ) external onlyDAO {\n        charityaddress = _charityaddress;\n        emit updateedCharityAddress( charityaddress );\n    }\n\n    /**\n    * @dev Update rewards address\n    * @param _rewardsaddress new charity address\n    */\n    function updateRewardsAddress( address _rewardsaddress ) external onlyDAO {\n        rewardsaddress = _rewardsaddress;\n        emit updateedRewardsAddress( rewardsaddress );\n    }\n\n    /**\n    * @dev Update rewards address\n    * @param _systemaddress new charity address\n    */\n    function updateSystemAddress( address _systemaddress ) external onlyDAO {\n        systemaddress = _systemaddress;\n        emit updateedSystemAddress( systemaddress );\n    }\n\n    /**\n    * @dev Update staking address\n    * @param _stakingaddress new charity address\n    */\n    function updateStakingAddress( address _stakingaddress ) external onlyDAO {\n        stakingaddress = _stakingaddress;\n        emit updateedStakingAddress( stakingaddress );\n    }\n\n    /**\n    * @dev Updates fees\n    * @param _totalFee total taken fee\n    * @param _burnFees burn fees\n    * @param _charityFees liquidity pool fees\n    * @param _rewardsFees rewards fees\n    */\n    function updateFees( uint256 _totalFee, uint256 _burnFees, uint256 _charityFees, uint256 _rewardsFees, uint256 _systemFees, uint256 _stakingFees ) external onlyDAO {\n       require( _totalFee \u003c= maxFee, \"VERIFY FEE: TOO BIG FEE\" );\n       require(  _verifyFees(_burnFees, _charityFees, _rewardsFees, _systemFees, _stakingFees), \"VERIFY FEE: SUM DO NOT MATCH\");\n\n        totalFee = _totalFee;\n        burnFees = _burnFees;\n        charityFees = _charityFees;\n        rewardsFees = _rewardsFees;\n        systemFees = _systemFees;\n        stakingFees = _stakingFees;\n\n        emit FeesUpdated( totalFee, burnFees, charityFees, rewardsFees, systemFees, stakingFees );\n    }\n\n    /**\n    * @dev verify fees\n    * @param _burnFees liquidity pool fees\n    * @param _charityFees charity fees\n    * @param _rewardsFees rewards fees\n    * @param _systemFees system fees\n    * @param _stakingFees staking fees\n    */\n    function _verifyFees( uint256 _burnFees, uint256 _charityFees, uint256 _rewardsFees, uint256 _systemFees, uint256 _stakingFees) private pure returns (bool){\n        uint256 _totalFees = _burnFees + _charityFees + _rewardsFees + _systemFees + _stakingFees;\n        if(_totalFees == 100){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n    * @dev Emitted when dao is updated\n    * @param dao dao address\n    */\n    event DAOUpdated(\n      address dao\n    );\n\n    // ERC20 totalSupply\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply  - balances[ZERO];\n    }\n\n    /// Total fees collected\n    function FeesCollected() external view returns (uint256) {\n        return FeeTotalCollected;\n    }\n    /// Total fees collected burned\n    function FeesCollectedBurned() external view returns (uint256) {\n        return FeeTotalCollectedBurned;\n    }\n\n\n    // ERC20 balanceOf\n    function balanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balances[account];\n    }\n\n    // ERC20 transfer\n    function transfer(address recipient, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // ERC20 approve\n    function approve(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    // ERC20 transferFrom\n    function transferFrom( address sender, address recipient, uint256 amount ) external override returns (bool) {\n        uint256 amt = allowance[sender][msg.sender];\n        require(amt \u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n        // reduce only if not permament allowance (uniswap etc)\n        allowance[sender][msg.sender] -= amount;\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // ERC20 increaseAllowance\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        _approve( msg.sender, spender, allowance[msg.sender][spender] + addedValue );\n        return true;\n    }\n\n    // ERC20 decreaseAllowance\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        require( allowance[msg.sender][spender] \u003e= subtractedValue, \"ERC20: decreased allowance below zero\" );\n        _approve( msg.sender, spender, allowance[msg.sender][spender] - subtractedValue );\n        return true;\n    }\n\n    // ERC20 burn\n    function burn(uint256 amount) external {\n        require(msg.sender != ZERO, \"ERC20: burn from the zero address\");\n        _burn(msg.sender, amount);\n    }\n\n    // ERC20 burnFrom\n    function burnFrom(address account, uint256 amount) external {\n        require(account != ZERO, \"ERC20: burn from the zero address\");\n        require(allowance[account][msg.sender] \u003e= amount, \"ERC20: burn amount exceeds allowance\");\n        allowance[account][msg.sender] -= amount;\n        _burn(account, amount);\n    }\n\n    function _calcTransferFees( uint256 amount ) private view returns ( uint256 _FeesToTake, uint256 _toburn, uint256 _tocharity, uint256 _toreward, uint256 _tosystem, uint256 _tostaking )\n      {\n        _FeesToTake = amount * totalFee / 100;\n        if((_totalSupply  - balances[ZERO]) \u003e minTotalSupply){\n            _toburn = _FeesToTake * burnFees / 100;\n        } else {\n            _toburn = 0;\n        }\n\n        _tocharity = _FeesToTake * charityFees / 100;\n        _toreward =  _FeesToTake * rewardsFees / 100;\n        _tosystem =  _FeesToTake * systemFees / 100;\n        _tostaking =  _FeesToTake * stakingFees / 100;\n        _FeesToTake = _toburn + _tocharity + _toreward + _tosystem + _tostaking;\n      }\n\n    /**\n        Internal approve function, emit Approval event\n        @param _owner approving address\n        @param spender delegated spender\n        @param amount amount of tokens\n     */\n    function _approve( address _owner, address spender, uint256 amount ) private {\n        require(_owner != ZERO, \"ERC20: approve from the zero address\");\n        require(spender != ZERO, \"ERC20: approve to the zero address\");\n\n        allowance[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    /**\n        Internal transfer function, calling feeFree if needed\n        @param sender sender address\n        @param recipient destination address\n        @param Amount transfer amount\n     */\n    function _transfer( address sender, address recipient, uint256 Amount ) private {\n        require(sender != ZERO, \"ERC20: transfer from the zero address\");\n        require(recipient != ZERO, \"ERC20: transfer to the zero address\");\n        require(!frozenAccount[sender], \"DAO: transfer from this address frozen\");\n        require(!frozenAccount[recipient], \"DAO: transfer to this address frozen\");\n\n        if (Amount \u003e 0) {\n            if (isFeeFreeSender[sender]){\n              _feeFreeTransfer(sender, recipient, Amount);\n            } else if(isFeeFreeRecipient[recipient]){\n              _feeFreeTransfer(sender, recipient, Amount);\n            } else {\n                ( uint256 _FeesToTake, uint256 _toburn, uint256 _tocharity, uint256 _toreward, uint256 _tosystem, uint256 _tostaking ) = _calcTransferFees( Amount );\n\n                uint256 _totransfer = Amount - _FeesToTake;\n                uint256 _takefromsender = Amount - _toburn;\n                FeeTotalCollected += _FeesToTake;\n                balances[sender] -= _takefromsender;\n                balances[recipient] += _totransfer;\n                if(_toburn\u003e0){\n                    _burn(sender, _toburn);\n                    FeeTotalCollectedBurned += _toburn;\n                    emit Transfer(sender, ZERO, _toburn);\n                }\n                if(_tocharity\u003e0){\n                    balances[charityaddress] += _tocharity;\n                    emit Transfer(sender, charityaddress, _tocharity);\n                }\n                if(_toreward\u003e0){\n                    balances[rewardsaddress] += _toreward;\n                    emit Transfer(sender, rewardsaddress, _toreward);\n                }\n                if(_tosystem\u003e0){\n                    balances[systemaddress] += _tosystem;\n                    emit Transfer(sender, systemaddress, _tosystem);\n                }\n                if(_tostaking\u003e0){\n                    balances[stakingaddress] += _tostaking;\n                    emit Transfer(sender, stakingaddress, _tostaking);\n                }\n                emit Transfer(sender, recipient, _totransfer);\n            }\n        } else emit Transfer(sender, recipient, 0);\n    }\n\n\n    /**\n        Function provide fee-free transfer for selected addresses\n        @param sender sender address\n        @param recipient destination address\n        @param Amount transfer amount\n     */\n    function _feeFreeTransfer( address sender, address recipient, uint256 Amount ) private {\n        balances[sender] -= Amount;\n        balances[recipient] += Amount;\n        emit Transfer(sender, recipient, Amount);\n    }\n\n\n    /// internal burn function\n    function _burn(address account, uint256 Amount) private {\n        require( balances[account] \u003e= Amount, \"ERC20: burn amount exceeds balance\" );\n        balances[account] -= Amount;\n        _totalSupply -= Amount;\n    }\n\n    /**\n    * @dev Freez Account\n    * @param _address adress to feez/unfreez\n    * @param _freeze set state\n    */\n    function freezeAccount(address _address, bool _freeze) public onlyDAO {\n      frozenAccount[_address] = _freeze;\n    }\n\n    /**\n    * @dev Update charity address\n    * @param _minTotalSupply new charity address\n    */\n\n    function updateminTotalSupply( uint256 _minTotalSupply ) external onlyDAO {\n        minTotalSupply = _minTotalSupply;\n        emit updatedminTotalSupply( minTotalSupply );\n    }\n\n    function setfeesfree() private{\n        isFeeFreeSender[owner] = true;\n        isFeeFreeSender[dao] = true;\n        isFeeFreeSender[charityaddress] = true;\n        isFeeFreeSender[rewardsaddress] = true;\n        isFeeFreeSender[systemaddress] = true;\n        isFeeFreeSender[stakingaddress] = true;\n        isFeeFreeRecipient[charityaddress] = true;\n    }\n\n    /**\n    * @dev Emitted when fees are updated\n    * @param totalFee burn fees\n    * @param burnFees liquidity pool fees\n    * @param charityFees charity fees\n    * @param rewardsFees rewards fees\n    * @param systemFees system fees\n    * @param stakingFees staking fees\n    */\n    event FeesUpdated( uint256 totalFee, uint256 burnFees, uint256 charityFees, uint256 rewardsFees, uint256 systemFees, uint256 stakingFees );\n\n    /**\n    * @dev Emitted when staking is updated\n    * @param stakingaddress burn fees\n    */\n    event updateedStakingAddress( address stakingaddress );\n\n    /**\n    * @dev Emitted when system is updated\n    * @param systemaddress burn fees\n    */\n    event updateedSystemAddress( address systemaddress );\n\n    /**\n    * @dev Emitted when rewards is updated\n    * @param rewardsaddress burn fees\n    */\n    event updateedRewardsAddress( address rewardsaddress );\n\n    /**\n    * @dev Emitted when charity is updated\n    * @param charityaddress burn fees\n    */\n    event updateedCharityAddress( address charityaddress );\n\n    /**\n    * @dev Emitted when minTotalSupply is updated\n    * @param minTotalSupply burn fees\n    */\n    event updatedminTotalSupply( uint256 minTotalSupply );\n\n    //\n    // Hard Ride\n    //\n\n    /**\n        Add address that will not pay transfer fees\n        @param user address to mark as fee-free\n     */\n    function addFeeFree(address user) external onlyDAO {\n        isFeeFreeSender[user] = true;\n    }\n\n    /**\n        Remove address form privileged list\n        @param user user to remove\n     */\n    function removeFeeFree(address user) external onlyDAO {\n        isFeeFreeSender[user] = false;\n    }\n\n    /**\n        Add address that will recive tokens without fee\n        @param user address to mark as fee-free\n     */\n    function addFeeFreeRecipient(address user) external onlyDAO {\n        isFeeFreeRecipient[user] = true;\n    }\n\n    /**\n        Remove address form privileged list\n        @param user user to remove\n     */\n    function removeFeeFreeRecipient(address user) external onlyDAO {\n        isFeeFreeRecipient[user] = false;\n    }\n\n    /**\n        Take ETH accidentally send to contract\n    */\n    function withdrawEth() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    /**\n        Take any ERC20 sent to contract\n        @param token token address\n    */\n    function withdrawErc20(address token) external onlyOwner {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        require(balance \u003e 0, \"Nothing to withdraw\");\n        // use broken IERC20\n        INterfacesNoR(token).transfer(owner, balance);\n    }\n}\n\n//by Patrick\n"}}