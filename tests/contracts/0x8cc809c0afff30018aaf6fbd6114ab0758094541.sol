{"Date.sol":{"content":"pragma solidity \u003e=0.5.12;\n\n\nlibrary Date {\n    struct _Date {\n        uint16 year;\n        uint8 month;\n        uint8 day;\n    }\n\n    uint constant DAY_IN_SECONDS = 86400;\n    uint constant YEAR_IN_SECONDS = 31536000;\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n\n    uint16 constant ORIGIN_YEAR = 1970;\n\n    function isLeapYear(uint16 year) public pure returns (bool) {\n        if (year % 4 != 0) {\n                return false;\n        }\n        if (year % 100 != 0) {\n                return true;\n        }\n        if (year % 400 != 0) {\n                return false;\n        }\n        return true;\n    }\n\n    function leapYearsBefore(uint year) public pure returns (uint) {\n        year -= 1;\n        return year / 4 - year / 100 + year / 400;\n    }\n\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n                return 31;\n        }\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\n                return 30;\n        }\n        else if (isLeapYear(year)) {\n                return 29;\n        }\n        else {\n                return 28;\n        }\n    }\n\n    function parseTimestamp(uint timestamp) internal pure returns (_Date memory dt) {\n        uint secondsAccountedFor = 0;\n        uint buf;\n        uint8 i;\n\n        // Year\n        dt.year = getYear(timestamp);\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n\n        // Month\n        uint secondsInMonth;\n        for (i = 1; i \u003c= 12; i++) {\n                secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n                if (secondsInMonth + secondsAccountedFor \u003e timestamp) {\n                        dt.month = i;\n                        break;\n                }\n                secondsAccountedFor += secondsInMonth;\n        }\n\n        // Day\n        for (i = 1; i \u003c= getDaysInMonth(dt.month, dt.year); i++) {\n                if (DAY_IN_SECONDS + secondsAccountedFor \u003e timestamp) {\n                        dt.day = i;\n                        break;\n                }\n                secondsAccountedFor += DAY_IN_SECONDS;\n        }\n    }\n\n    function getYear(uint timestamp) public pure returns (uint16) {\n        uint secondsAccountedFor = 0;\n        uint16 year;\n        uint numLeapYears;\n\n        // Year\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n\n        while (secondsAccountedFor \u003e timestamp) {\n                if (isLeapYear(uint16(year - 1))) {\n                        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n                }\n                else {\n                        secondsAccountedFor -= YEAR_IN_SECONDS;\n                }\n                year -= 1;\n        }\n        return year;\n    }\n\n    function getMonth(uint timestamp) public pure returns (uint8) {\n        return parseTimestamp(timestamp).month;\n    }\n\n    function getDay(uint timestamp) public pure returns (uint8) {\n        return parseTimestamp(timestamp).day;\n    }\n\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n        uint16 i;\n\n        // Year\n        for (i = ORIGIN_YEAR; i \u003c year; i++) {\n                if (isLeapYear(i)) {\n                        timestamp += LEAP_YEAR_IN_SECONDS;\n                }\n                else {\n                        timestamp += YEAR_IN_SECONDS;\n                }\n        }\n\n        // Month\n        uint8[12] memory monthDayCounts;\n        monthDayCounts[0] = 31;\n        if (isLeapYear(year)) {\n                monthDayCounts[1] = 29;\n        }\n        else {\n                monthDayCounts[1] = 28;\n        }\n        monthDayCounts[2] = 31;\n        monthDayCounts[3] = 30;\n        monthDayCounts[4] = 31;\n        monthDayCounts[5] = 30;\n        monthDayCounts[6] = 31;\n        monthDayCounts[7] = 31;\n        monthDayCounts[8] = 30;\n        monthDayCounts[9] = 31;\n        monthDayCounts[10] = 30;\n        monthDayCounts[11] = 31;\n\n        for (i = 1; i \u003c month; i++) {\n                timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n        }\n\n        // Day\n        timestamp += DAY_IN_SECONDS * (day - 1);\n\n        return timestamp;\n    }\n}"},"LitionPool.sol":{"content":"pragma solidity \u003e=0.5.12;\n\nimport \u0027Date.sol\u0027;\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title   Lition Pool Contract\n * @author  Patricio Mosse\n * @notice  This contract is used for staking LIT (ERC20) tokens to support a validator running in the Lition blockchain network and distribute rewards.\n **/\ncontract LitionPool {\n    using SafeMath for uint256;\n\n    /**************************************************** Events **************************************************************/\n    \n    event NewStake(address indexed staker, uint256 totalStaked, uint8 lockupPeriod, bool compound);\n    event StakerMigrated(address indexed staker);\n    event StakeFinishedByUser(address indexed staker, uint256 totalRecovered, uint256 index);\n    event StakeRestakedByUser(address indexed staker, uint256 totalStaked, uint8 lockupPeriod, bool compound);\n    event StakeEnabledToBeFinished(address indexed staker, uint256 index);\n    event StakeRemoved(address indexed staker, uint256 totalRecovered, uint256 index);\n    event RewardsAccredited(address indexed staker, uint256 index, uint256 delta, uint256 total);\n    event StakeIncreased(address indexed staker, uint256 index, uint256 delta, uint256 total);\n    event RewardsWithdrawn(address indexed staker, uint256 index, uint256 total);\n    event TransferredToVestingAccount(uint256 total);\n\n    /**************************************************** Vars and structs **************************************************************/\n    \n    address public owner;\n    IERC20 litionToken;\n    bool public paused = false;\n\n    struct Stake {\n        uint256 createdOn;\n        uint256 totalStaked;\n        uint8 lockupPeriod;\n        bool compound;\n        uint256 rewards;\n        bool finished;\n    }\n    \n    address[] public stakers;\n    mapping (address =\u003e Stake[]) public stakeListBySender;\n\n    /**************************************************** Admin **************************************************************/\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor(IERC20 _litionToken) public {\n        owner = msg.sender;\n        litionToken = _litionToken;\n    }\n\n    function _transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner can\u0027t be the zero address\");\n        owner = newOwner;\n    }\n    \n    function _switchPaused() public onlyOwner {\n        paused = !paused;\n    }\n\n    function() external payable {\n        revert();\n    }\n\n    /**************************************************** Public Interface for Stakers **************************************************************/\n\n    function createNewStake(uint256 _amount, uint8 _lockupPeriod, bool _compound) public {\n        require(!paused, \"New stakes are paused\");\n        require(_isValidLockupPeriod(_lockupPeriod), \"The lockup period is invalid\");\n        require(_amount \u003e= 5000000000000000000000, \"You must stake at least 5000 LIT\");\n        require(IERC20(litionToken).transferFrom(msg.sender, address(this), _amount), \"Couldn\u0027t take the LIT from the sender\");\n        \n        Stake memory stake = Stake({createdOn: now, \n                                    totalStaked:_amount, \n                                    lockupPeriod:_lockupPeriod, \n                                    compound:_compound, \n                                    rewards:0,\n                                    finished:false});\n                                    \n        _addStakerIfNotExist(msg.sender);\n        Stake[] storage stakes = stakeListBySender[msg.sender];\n        stakes.push(stake);\n        \n        emit NewStake(msg.sender, _amount, _lockupPeriod, _compound);\n    }\n    \n    function _migrateStakes(address _staker, \n                            uint256[] memory _created_on_array, \n                            uint256[] memory _amount_array, \n                            uint8[] memory _lockup_period_array, \n                            bool[] memory _compound_array, \n                            uint256[] memory _rewards_array, \n                            bool[] memory _finished_array) public onlyOwner {\n                                \n        _addStakerIfNotExist(_staker);\n        \n        for (uint256 index = 0; index \u003c _created_on_array.length; index++) {\n            Stake memory stake = Stake({createdOn: _created_on_array[index], \n                                        totalStaked: _amount_array[index], \n                                        lockupPeriod: _lockup_period_array[index], \n                                        compound: _compound_array[index], \n                                        rewards: _rewards_array[index],\n                                        finished: _finished_array[index]});\n    \n            Stake[] storage stakes = stakeListBySender[_staker];\n            stakes.push(stake);\n        }\n\n        emit StakerMigrated(_staker);\n    }\n    \n    function finishStake(uint256 _index) public {\n        require(stakeListBySender[msg.sender].length \u003e _index, \"The stake doesn\u0027t exist\");\n\n        Stake memory stake = stakeListBySender[msg.sender][_index];\n\n        require(stake.finished, \"The stake is not finished yet\");\n        \n        uint256 total = _closeStake(msg.sender, _index);\n        \n        emit StakeFinishedByUser(msg.sender, total, _index);\n    }\n    \n    function restake(uint256 _index) public {\n        require(stakeListBySender[msg.sender].length \u003e _index, \"The stake doesn\u0027t exist\");\n\n        Stake storage stake = stakeListBySender[msg.sender][_index];\n\n        require(stake.finished, \"The stake is not finished yet\");\n        \n        stake.totalStaked = stake.totalStaked.add(stake.rewards);\n        stake.rewards = 0;\n        stake.createdOn = now;\n        stake.finished = false;\n\n        emit StakeRestakedByUser(msg.sender, stake.totalStaked, stake.lockupPeriod, stake.compound);\n    }\n    \n    function withdrawRewards(uint256 _index) public {\n        require(stakeListBySender[msg.sender].length \u003e _index, \"The stake doesn\u0027t exist\");\n\n        Stake storage stake = stakeListBySender[msg.sender][_index];\n\n        require(stake.rewards \u003e 0, \"You don\u0027t have rewards to withdraw\");\n        \n        uint256 total = stake.rewards;\n        stake.rewards = 0;\n\n        require(litionToken.transfer(msg.sender, total));\n\n        emit RewardsWithdrawn(msg.sender, _index, total);\n    }\n\n    /**************************************************** Public Interface for Admin **************************************************************/\n\n    function _accredit(address _staker, uint256 _index, uint256 _total) public onlyOwner {\n        require(stakeListBySender[_staker].length \u003e _index, \"The stake doesn\u0027t exist\");\n\n        Stake storage stake = stakeListBySender[_staker][_index];\n        require(!stake.finished, \"The stake is already finished\");\n        \n        if (stake.compound) {\n            stake.totalStaked += _total;\n\n            emit StakeIncreased(_staker, _index, _total, stake.totalStaked);\n        }\n        else {\n            stake.rewards += _total;\n\n            emit RewardsAccredited(_staker, _index, _total, stake.rewards);\n        }\n        \n        if (_isLockupPeriodFinished(stake.createdOn, stake.lockupPeriod)) {\n            stake.finished = true;\n            \n            emit StakeEnabledToBeFinished(_staker, _index);\n        }\n    }\n    \n    function _accreditMultiple(address _staker, uint256[] memory _totals) public onlyOwner {\n        require(stakeListBySender[_staker].length == _totals.length, \"Invalid number of stakes\");\n        \n        for (uint256 index = 0; index \u003c _totals.length; index++) {\n            Stake storage stake = stakeListBySender[_staker][index];\n            require(!stake.finished, \"The stake is already finished\");\n            \n            if (stake.compound) {\n                stake.totalStaked += _totals[index];\n    \n                emit StakeIncreased(_staker, index, _totals[index], stake.totalStaked);\n            }\n            else {\n                stake.rewards += _totals[index];\n    \n                emit RewardsAccredited(_staker, index, _totals[index], stake.rewards);\n            }\n            \n            if (_isLockupPeriodFinished(stake.createdOn, stake.lockupPeriod)) {\n                stake.finished = true;\n                \n                emit StakeEnabledToBeFinished(_staker, index);\n            }\n        }\n    }\n    \n    function _forceFinishStake(address _staker, uint256 _index) public onlyOwner {\n        require(stakeListBySender[_staker].length \u003e _index, \"The stake doesn\u0027t exist\");\n        Stake storage stake = stakeListBySender[_staker][_index];\n        require(!stake.finished, \"The stake is already finished\");\n        stake.finished = true;\n        \n        emit StakeEnabledToBeFinished(_staker, _index);\n    }\n\n    function _transferLITToVestingAccount(uint256 _total) public onlyOwner {\n        require(litionToken.transfer(msg.sender, _total));\n\n        emit TransferredToVestingAccount(_total);\n    }\n    \n    function _extractLitSentByMistake(uint256 amount, address _sendTo) public onlyOwner {\n        require(litionToken.transfer(_sendTo, amount));\n    }\n\n    function _removeStaker(address _staker, uint256 _index) public onlyOwner {\n        require(stakeListBySender[_staker].length \u003e _index, \"The stake doesn\u0027t exist\");\n        \n        uint256 total = _closeStake(_staker, _index);\n\n        emit StakeRemoved(_staker, total, _index);\n    }\n\n    /**************************************************** Pool Information **************************************************************/\n\n    function getTotalInStake() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i \u003c stakers.length; i++) {\n            Stake[] memory stakes = stakeListBySender[stakers[i]];\n            for (uint256 j = 0; j \u003c stakes.length; j++) {\n                if (!stakes[j].finished) {\n                    total = total.add(stakes[j].totalStaked);\n                }\n            }\n        }\n        return total;\n    }\n    \n    function getTotalStakes() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i \u003c stakers.length; i++) {\n            Stake[] memory stakes = stakeListBySender[stakers[i]];\n            for (uint256 j = 0; j \u003c stakes.length; j++) {\n                if (!stakes[j].finished) {\n                    total += 1;\n                }\n            }\n        }\n        return total;\n    }\n    \n    function getTotalStakers() public view returns (uint256) {\n        return stakers.length;\n    }\n\n    function getTotalStakesByStaker(address _staker) external view returns (uint256) {\n        return stakeListBySender[_staker].length;\n    }\n    \n    function getStake(address _staker, uint256 _index) external view returns (uint256 createdOn, uint256 totalStaked, uint8 lockupPeriod, bool compound, uint256 rewards, bool finished, uint256 lockupFinishes) {\n        require(stakeListBySender[_staker].length \u003e _index, \"The stake doesn\u0027t exist\");\n        Stake memory stake = stakeListBySender[_staker][_index];\n        createdOn = stake.createdOn;\n        totalStaked = stake.totalStaked;\n        lockupPeriod = stake.lockupPeriod;\n        compound = stake.compound;\n        rewards = stake.rewards;\n        finished = stake.finished;\n        lockupFinishes = getLockupFinishTimestamp(_staker, _index);\n    }\n\n    function getLockupFinishTimestamp(address _staker, uint256 _index) public view returns (uint256) {\n        require(stakeListBySender[_staker].length \u003e _index, \"The stake doesn\u0027t exist\");\n        Stake memory stake = stakeListBySender[_staker][_index];\n        return calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\n    }\n\n    /**************************************************** Internal Admin - Lockups **************************************************************/\n\n    function calculateFinishTimestamp(uint256 _timestamp, uint8 _lockupPeriod) public pure returns (uint256) {\n        uint16 year = Date.getYear(_timestamp);\n        uint8 month = Date.getMonth(_timestamp);\n        month += _lockupPeriod;\n        if (month \u003e 12) {\n            year += 1;\n            month = month % 12;\n        }\n        uint8 day = Date.getDay(_timestamp);\n        uint256 finishOn = Date.toTimestamp(year, month, day);\n        return finishOn;\n    }\n\n    /**************************************************** Internal Admin - Stakes and Rewards **************************************************************/\n\n    function _closeStake(address _staker, uint256 _index) internal returns (uint256) {\n        uint256 totalStaked = stakeListBySender[_staker][_index].totalStaked;\n        uint256 total = totalStaked + stakeListBySender[_staker][_index].rewards;\n        \n        _removeStakeByIndex(_staker, _index);\n        if (stakeListBySender[_staker].length == 0) {\n            _removeStakerByValue(_staker);\n        }\n        \n        require(litionToken.transfer(_staker, total));\n\n        return total;\n    }\n    \n    /**************************************************** Internal Admin - Validations **************************************************************/\n    \n    function _isValidLockupPeriod(uint8 n) internal pure returns (bool) {\n        return n == 1 || n == 3 || n == 6 || n == 12;\n    }\n\n    function _isLockupPeriodFinished(uint256 _timestamp, uint8 _lockupPeriod) internal view returns (bool) {\n        return now \u003e calculateFinishTimestamp(_timestamp, _lockupPeriod);\n    }\n\n    /**************************************************** Internal Admin - Arrays **************************************************************/\n    \n    function _addStakerIfNotExist(address _staker) internal {\n        if (stakeListBySender[_staker].length == 0) {\n            stakers.push(_staker);\n        }\n    }\n\n    function _findStaker(address _value) internal view returns(uint) {\n        uint i = 0;\n        while (stakers[i] != _value) {\n            i++;\n        }\n        return i;\n    }\n\n    function _removeStakerByValue(address _value) internal {\n        uint i = _findStaker(_value);\n        _removeStakerByIndex(i);\n    }\n\n    function _removeStakerByIndex(uint _i) internal {\n        while (_i\u003cstakers.length-1) {\n            stakers[_i] = stakers[_i+1];\n            _i++;\n        }\n        stakers.length--;\n    }\n    \n    function _removeStakeByIndex(address _staker, uint _i) internal {\n        Stake[] storage stakes = stakeListBySender[_staker];\n        while (_i\u003cstakes.length-1) {\n            stakes[_i] = stakes[_i+1];\n            _i++;\n        }\n        stakes.length--;\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        require(c \u003e= a);\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n}"}}