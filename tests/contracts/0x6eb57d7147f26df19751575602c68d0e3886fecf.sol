{{
  "language": "Solidity",
  "sources": {
    "contracts/game/GameStats.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n ______     __                            __           __                      __\n|_   _ \\   [  |                          |  ]         [  |                    |  ]\n  | |_) |   | |    .--.     .--.     .--.| |   .--.    | |--.    .---.    .--.| |\n  |  __'.   | |  / .'`\\ \\ / .'`\\ \\ / /'`\\' |  ( (`\\]   | .-. |  / /__\\\\ / /'`\\' |\n _| |__) |  | |  | \\__. | | \\__. | | \\__/  |   `'.'.   | | | |  | \\__., | \\__/  |\n|_______/  [___]  '.__.'   '.__.'   '.__.;__] [\\__) ) [___]|__]  '.__.'  '.__.;__]\n                      ________\n                      ___  __ )_____ ______ _________________\n                      __  __  |_  _ \\_  __ `/__  ___/__  ___/\n                      _  /_/ / /  __// /_/ / _  /    _(__  )\n                      /_____/  \\___/ \\__,_/  /_/     /____/\n*/\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    function approve(address spender, uint256 value) external returns (bool success);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function decimals() external view returns (uint8 decimalPlaces);\n\n    function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n    function increaseApproval(address spender, uint256 subtractedValue) external;\n\n    function name() external view returns (string memory tokenName);\n\n    function symbol() external view returns (string memory tokenSymbol);\n\n    function totalSupply() external view returns (uint256 totalTokensIssued);\n\n    function transfer(address to, uint256 value) external returns (bool success);\n\n    function transferAndCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool success);\n}\n\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n    /**\n     * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n    function makeVRFInputSeed(\n        bytes32 _keyHash,\n        uint256 _userSeed,\n        address _requester,\n        uint256 _nonce\n    ) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n    }\n\n    /**\n     * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n    function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n    }\n}\n\npragma solidity ^0.8.0;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n    /**\n     * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\n\n    /**\n     * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n    uint256 private constant USER_SEED_PLACEHOLDER = 0;\n\n    /**\n     * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n    function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\n        LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n        // This is the seed passed to VRFCoordinator. The oracle will mix this with\n        // the hash of the block containing this request to obtain the seed/input\n        // which is finally passed to the VRF cryptographic machinery.\n        uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n        // nonces[_keyHash] must stay in sync with\n        // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n        // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n        // This provides protection against the user repeating their input seed,\n        // which would result in a predictable/duplicate output, if multiple such\n        // requests appeared in the same block.\n        nonces[_keyHash] = nonces[_keyHash] + 1;\n        return makeRequestId(_keyHash, vRFSeed);\n    }\n\n    LinkTokenInterface internal immutable LINK;\n    address private immutable vrfCoordinator;\n\n    // Nonces for each VRF key from which randomness has been requested.\n    //\n    // Must stay in sync with VRFCoordinator[_keyHash][this]\n    mapping(bytes32 => uint256) /* keyHash */ /* nonce */\n    private nonces;\n\n    /**\n     * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n    constructor(address _vrfCoordinator, address _link) {\n        vrfCoordinator = _vrfCoordinator;\n        LINK = LinkTokenInterface(_link);\n    }\n\n    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n    // the origin of the call\n    function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n        require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n        fulfillRandomness(requestId, randomness);\n    }\n}\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\ninterface IToken {\n    function add(address wallet, uint256 amount) external;\n    function spend(address wallet, uint256 amount) external;\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function mintTokens(address to, uint256 amount) external;\n    function getWalletBalance(address wallet) external returns (uint256);\n}\n\ninterface IStakingContract {\n    function ownerOf(address collection, uint256 token) external returns (address);\n}\n\npragma solidity ^0.8.0;\n\ncontract GameStats is Ownable, VRFConsumerBase, Pausable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    struct TokenSelection {\n        address collectionAddress;\n        uint256[] tokens;\n    }\n\n    struct ImpactType {\n        uint256 boost;\n        uint256 riskReduction;\n    }\n\n    struct TokenData {\n        bool isElite;\n        bool faction;\n        uint256 level;\n        uint256 levelEnrolDate;\n        uint256 stakeType;\n        address owner;\n    }\n\n    mapping(bytes32 => TokenData) tokenDataEncoded;\n    EnumerableSet.Bytes32Set redElites;\n    EnumerableSet.Bytes32Set blueElites;\n\n    uint256 houseUpgradeCost = 1000000000 ether;\n\n    uint256 public treeHouseRisk = 25;\n    uint256 public tokenGeneratorRisk = 25;\n\n    uint256 public HOUSE_CAP = 5;\n    uint256 public LEVEL_CAP = 1000;\n    uint256 public BASE_RISK = 50;\n    uint256 public HOME_STAKE = 1;\n    uint256 public TREE_HOUSE_STAKE = 2;\n\n    mapping(string => address) public contractsAddressesMap;\n\n    uint256[] public levelMilestones;\n    mapping(uint256 => ImpactType) public levelImpacts;\n\n    mapping(uint256 => ImpactType) public stakeTypeImpacts;\n\n    uint256 private vrfFee;\n    bytes32 private vrfKeyHash;\n\n    uint256 private seed;\n\n\n    mapping(address => bool) public authorisedAddresses;\n\n    modifier authorised() {\n        require(authorisedAddresses[msg.sender], \"The token contract is not authorised\");\n        _;\n    }\n\n    event SeedFulfilled();\n\n    event BLDStolen(address to, uint256 amount);\n\n    constructor(\n        address vrfCoordinatorAddr_,\n        address linkTokenAddr_,\n        bytes32 vrfKeyHash_,\n        uint256 fee_\n    ) VRFConsumerBase(vrfCoordinatorAddr_, linkTokenAddr_) {\n        vrfKeyHash = vrfKeyHash_;\n        vrfFee = fee_;\n    }\n\n    // ADMIN\n    function setCollectionsKeys(\n        string[] calldata keys_,\n        address[] calldata collections_\n    ) external onlyOwner {\n        for (uint i = 0; i < keys_.length; ++i) {\n            contractsAddressesMap[keys_[i]] = collections_[i];\n        }\n    }\n\n    function setLevelImpacts(uint256[] memory milestones_, ImpactType[] calldata impacts_) external onlyOwner {\n\n        require(milestones_.length == impacts_.length, \"INVALID LENGTH\");\n\n        levelMilestones = milestones_;\n\n        for (uint256 i = 0; i < milestones_.length; i++) {\n            ImpactType storage levelImpact = levelImpacts[milestones_[i]];\n            levelImpact.boost = impacts_[i].boost;\n            levelImpact.riskReduction = impacts_[i].riskReduction;\n        }\n    }\n\n    function setStakeTypeImpacts(uint256[] calldata stakeTypes_, ImpactType[] calldata impacts_) external onlyOwner {\n\n        require(stakeTypes_.length == impacts_.length, \"INVALID LENGTH\");\n\n        for (uint256 i = 0; i < stakeTypes_.length; i++) {\n            ImpactType storage levelImpact = stakeTypeImpacts[stakeTypes_[i]];\n            levelImpact.boost = impacts_[i].boost;\n            levelImpact.riskReduction = impacts_[i].riskReduction;\n        }\n    }\n\n    function setAuthorised(address[] calldata addresses_, bool[] calldata authorisations_) external onlyOwner {\n        for (uint256 i = 0; i < addresses_.length; ++i) {\n            authorisedAddresses[addresses_[i]] = authorisations_[i];\n        }\n    }\n\n    function setHouseUpgradeCost(uint256 houseUpgradeCost_) external onlyOwner {\n        houseUpgradeCost = houseUpgradeCost_;\n    }\n\n    function setTokensData(\n        address collection_,\n        uint256[] calldata tokenIds_,\n        uint256[] calldata levels_,\n        bool[] calldata factions_,\n        bool[] calldata elites_\n    ) external authorised {\n\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            bytes32 tokenKey = getTokenKey(collection_, tokenIds_[i]);\n            TokenData storage tokenData = tokenDataEncoded[tokenKey];\n            if (tokenData.level == 0) {\n                tokenData.faction = factions_[i];\n                tokenData.isElite = elites_[i];\n                tokenData.level = levels_[i];\n            }\n        }\n    }\n\n    function setStakedTokenData(\n        address collection_,\n        address owner_,\n        uint256 stakeType_,\n        uint256[] calldata tokenIds_\n    ) external authorised {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            bytes32 tokenKey = getTokenKey(collection_, tokenIds_[i]);\n            TokenData storage tokenData = tokenDataEncoded[tokenKey];\n\n            tokenData.owner = owner_;\n\n            if (tokenData.isElite) {\n                if (tokenData.faction) {\n                    blueElites.add(tokenKey);\n                } else {\n                    redElites.add(tokenKey);\n                }\n            }\n\n            tokenData.stakeType = stakeType_;\n            tokenData.levelEnrolDate = block.timestamp;\n        }\n    }\n\n    function unsetStakedTokenData(\n        address collection_,\n        uint256[] calldata tokenIds_\n    ) external authorised {\n\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n\n            bytes32 tokenKey = getTokenKey(collection_, tokenIds_[i]);\n            TokenData storage tokenData = tokenDataEncoded[tokenKey];\n\n            if (tokenData.isElite) {\n                if (tokenData.faction) {\n                    blueElites.remove(tokenKey);\n                } else {\n                    redElites.remove(tokenKey);\n                }\n            }\n\n            _claimLevelForToken(collection_, tokenIds_[i]);\n\n            tokenData.stakeType = 0;\n\n        }\n    }\n\n\n    function getTokenKey(address collection_, uint256 tokenId_) public pure returns (bytes32) {\n        return keccak256(abi.encode(collection_, tokenId_));\n    }\n\n    function getLevel(address collection_, uint256 tokenId_) public view returns (uint256) {\n        return tokenDataEncoded[getTokenKey(collection_, tokenId_)].level;\n    }\n\n    function getLevels(\n        address collection_,\n        uint256[] calldata tokenIds_\n    ) external view returns (uint256[] memory) {\n        uint256[] memory levels = new uint256[](tokenIds_.length);\n\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\n            levels[i] = getLevel(collection_, tokenIds_[i]);\n        }\n\n        return levels;\n    }\n\n    function getLevelBoosts(\n        address collection_,\n        uint256[] calldata tokenIds_\n    ) external view returns (uint256[] memory) {\n        uint256[] memory levelBoosts = new uint256[](tokenIds_.length);\n\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\n            bytes32 tokenKey = getTokenKey(collection_, tokenIds_[i]);\n            for (uint256 j = levelMilestones.length - 1; j >= 0; --j) {\n                if (tokenDataEncoded[tokenKey].level >= levelMilestones[j]) {\n                    levelBoosts[i] = levelImpacts[levelMilestones[j]].boost;\n                    break;\n                }\n            }\n        }\n        return levelBoosts;\n    }\n\n    function getLevelBoost(address collection, uint256 tokenId) external view returns (uint256) {\n        uint256 levelBoost;\n        bytes32 tokenKey = getTokenKey(collection, tokenId);\n        for (uint256 j = levelMilestones.length - 1; j >= 0; --j) {\n            if (tokenDataEncoded[tokenKey].level >= levelMilestones[j]) {\n                levelBoost = levelImpacts[levelMilestones[j]].boost;\n                break;\n            }\n        }\n\n        return levelBoost;\n    }\n\n    function claimLevel(TokenSelection[] calldata tokensSelection_) public {\n        for (uint256 i = 0; i < tokensSelection_.length; ++i) {\n            for (uint256 j = 0; j < tokensSelection_[i].tokens.length; ++j) {\n                bytes32 tokenKey = getTokenKey(\n                    tokensSelection_[i].collectionAddress,\n                    tokensSelection_[i].tokens[j]\n                );\n\n                require(tokenDataEncoded[tokenKey].owner == msg.sender);\n                _claimLevelForToken(tokensSelection_[i].collectionAddress, tokensSelection_[i].tokens[j]);\n            }\n        }\n    }\n\n    function _claimLevelForToken(address collection_, uint256 tokenId_) internal {\n\n        bytes32 tokenKey = getTokenKey(collection_, tokenId_);\n        if (\n            tokenDataEncoded[tokenKey].stakeType == TREE_HOUSE_STAKE ||\n            tokenDataEncoded[tokenKey].stakeType == HOME_STAKE ||\n            tokenDataEncoded[tokenKey].stakeType == 0\n        ) {\n            return;\n        }\n\n        if (\n            collection_ != contractsAddressesMap[\"gen0\"] &&\n            collection_ != contractsAddressesMap[\"gen1\"]\n        ) {\n            return;\n        }\n\n\n        if (tokenDataEncoded[tokenKey].level != LEVEL_CAP) {\n\n            uint256 levelYield = (block.timestamp - tokenDataEncoded[tokenKey].levelEnrolDate) /\n                (stakeTypeImpacts[tokenDataEncoded[tokenKey].stakeType].boost * 1 days);\n\n\n            if (tokenDataEncoded[tokenKey].level + levelYield > LEVEL_CAP) {\n                tokenDataEncoded[tokenKey].level = LEVEL_CAP;\n            } else {\n                tokenDataEncoded[tokenKey].level += levelYield;\n            }\n\n            delete levelYield;\n\n            tokenDataEncoded[tokenKey].levelEnrolDate = block.timestamp;\n        }\n\n        delete tokenKey;\n    }\n\n    function isClaimSuccessful(\n        address collection_,\n        uint256 tokenId,\n        uint256 amount_,\n        uint256 stakeType_\n    ) external returns (bool) {\n\n        uint256 risk;\n\n        bool isBearCollection =\n            collection_ == contractsAddressesMap[\"gen0\"]\n            || collection_ == contractsAddressesMap[\"gen1\"];\n\n        if (isBearCollection) {\n            risk = BASE_RISK * 100;\n\n            for (uint256 j = levelMilestones.length - 1; j >= 0; --j) {\n                if (tokenDataEncoded[getTokenKey(collection_, tokenId)].level >= levelMilestones[j]) {\n                    risk -= levelImpacts[levelMilestones[j]].riskReduction;\n                    break;\n                }\n            }\n\n            risk = risk / stakeTypeImpacts[stakeType_].riskReduction / 100;\n\n            risk = risk < 10 ? 10 : risk;\n        } else {\n            if (collection_ == contractsAddressesMap[\"tokenGenerator\"]) {\n                risk = tokenGeneratorRisk;\n            } else if (collection_ == contractsAddressesMap[\"treeHouse\"]) {\n                risk = treeHouseRisk;\n            }\n        }\n\n        bool didLose = _didLoseClaimAmount(risk, tokenId, amount_);\n        if (didLose) {\n            bool winningFaction;\n            if (isBearCollection) {\n                winningFaction = !tokenDataEncoded[getTokenKey(collection_, tokenId)].faction;\n            } else {\n                winningFaction = _getFaction(tokenId);\n            }\n\n            address winner = pickWinnerFromElites(\n                winningFaction,\n                tokenId\n            );\n\n            if (winner != address(0)) {\n                emit BLDStolen(winner, amount_);\n                IToken(contractsAddressesMap[\"token\"]).add(winner, amount_);\n            } else {\n                didLose = false;\n            }\n        }\n\n        delete isBearCollection;\n\n        return !didLose;\n    }\n\n    function _didLoseClaimAmount(uint256 risk_, uint256 tokenId_, uint256 amount_) internal view returns (bool) {\n        return uint256(\n            keccak256(\n                abi.encodePacked(\n                    seed,\n                    tokenId_,\n                    amount_,\n                    tx.origin,\n                    blockhash(block.number - 1),\n                    block.timestamp)\n            )\n        ) % 100 < risk_;\n    }\n\n    function pickWinnerFromElites(bool faction_, uint256 tokenId) public view returns (address) {\n        if (faction_) {\n            return _pickWinnerFromElitesBySide(blueElites, tokenId);\n        } else {\n            return _pickWinnerFromElitesBySide(redElites, tokenId);\n        }\n    }\n\n    function _pickWinnerFromElitesBySide(\n        EnumerableSet.Bytes32Set storage elites_,\n        uint256 tokenId\n    ) internal view returns (address) {\n\n        if(elites_.length() == 0) {\n            return address(0);\n        }\n\n        uint256 index = _getRandom(elites_.length(), tokenId);\n\n        return tokenDataEncoded[elites_.at(index)].owner;\n    }\n\n    function _getRandom(uint256 len, uint256 tokenId) internal view returns (uint256) {\n        return uint256(\n            keccak256(\n                abi.encodePacked(\n                    seed,\n                    tokenId,\n                    tx.origin,\n                    blockhash(block.number - 1),\n                    block.timestamp\n                )\n            )\n        ) % len;\n    }\n\n    function _getFaction(uint256 tokenId) internal view returns (bool) {\n        return uint256(\n            keccak256(\n                abi.encodePacked(\n                    seed,\n                    tokenId,\n                    tx.origin,\n                    blockhash(block.number - 1),\n                    block.timestamp\n                )\n            )\n        ) & 1 == 1;\n    }\n\n    function initSeedGeneration() public onlyOwner returns (bytes32 requestId) {\n        require(LINK.balanceOf(address(this)) >= vrfFee, \"Not enough LINK\");\n        return requestRandomness(vrfKeyHash, vrfFee);\n    }\n\n    function fulfillRandomness(bytes32, uint256 randomness) internal override {\n        seed = randomness;\n        emit SeedFulfilled();\n    }\n\n    function upgradeHouseSize(uint256 tokenId_, uint256 upgrade_) external {\n\n        require(tokenDataEncoded[getTokenKey(contractsAddressesMap[\"treeHouse\"], tokenId_)].level + upgrade_ <= HOUSE_CAP);\n        require(tokenDataEncoded[getTokenKey(contractsAddressesMap[\"treeHouse\"], tokenId_)].owner == msg.sender);\n        require(IToken(contractsAddressesMap[\"token\"]).getWalletBalance(msg.sender) >= houseUpgradeCost * upgrade_);\n\n        IToken(contractsAddressesMap[\"token\"]).spend(msg.sender, houseUpgradeCost * upgrade_);\n\n        tokenDataEncoded[getTokenKey(contractsAddressesMap[\"treeHouse\"], tokenId_)].level += upgrade_;\n    }\n\n    function addLevel(address collection_, uint256 tokenId_, uint256 levelIncrease_) external authorised {\n        tokenDataEncoded[getTokenKey(collection_, tokenId_)].level += levelIncrease_;\n    }\n\n    function setLevel(address collection_, uint256 tokenId_, uint256 levelIncrease_) external authorised {\n        tokenDataEncoded[getTokenKey(collection_, tokenId_)].level = levelIncrease_;\n    }\n\n    function setEliteStatus(address collection_, uint256 tokenId_) external authorised {\n\n        bytes32 tokenKey = getTokenKey(collection_, tokenId_);\n\n        require(!tokenDataEncoded[tokenKey].isElite);\n        require(tokenDataEncoded[tokenKey].stakeType == 0);\n\n        tokenDataEncoded[tokenKey].isElite = true;\n\n        delete tokenKey;\n    }\n\n    function setHousesLevels(uint256[] calldata tokenIds_, uint256[] calldata levels_) external authorised {\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\n            tokenDataEncoded[getTokenKey(contractsAddressesMap[\"treeHouse\"], tokenIds_[i])].level = levels_[i];\n        }\n    }\n\n    function calculateLevels(\n        address collection,\n        uint256[] calldata tokenIds_\n    ) external view returns (uint256[] memory) {\n        uint256[] memory expectedLevels = new uint256[](tokenIds_.length);\n\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\n            expectedLevels[i] = calculateLevel(collection, tokenIds_[i]);\n        }\n\n        return expectedLevels;\n    }\n\n    function calculateLevel(address collection_, uint256 tokenId_) public view returns (uint256) {\n\n        bytes32 tokenKey = getTokenKey(collection_, tokenId_);\n\n        if (\n            tokenDataEncoded[tokenKey].stakeType == TREE_HOUSE_STAKE ||\n            tokenDataEncoded[tokenKey].stakeType == HOME_STAKE ||\n            tokenDataEncoded[tokenKey].stakeType == 0\n        ) {\n            return tokenDataEncoded[tokenKey].level;\n        }\n\n        if (\n            collection_ != contractsAddressesMap[\"gen0\"] &&\n            collection_ != contractsAddressesMap[\"gen1\"]\n        ) {\n            return tokenDataEncoded[tokenKey].level;\n        }\n\n        if (tokenDataEncoded[tokenKey].level == LEVEL_CAP) {\n            return LEVEL_CAP;\n        }\n\n        uint256 levelYield = (block.timestamp - tokenDataEncoded[tokenKey].levelEnrolDate) /\n\n        (stakeTypeImpacts[tokenDataEncoded[tokenKey].stakeType].boost * 1 days);\n\n\n        if (tokenDataEncoded[tokenKey].level + levelYield > LEVEL_CAP) {\n            return LEVEL_CAP;\n        }\n\n        return tokenDataEncoded[tokenKey].level + levelYield;\n    }\n\n    function setTokenGeneratorRisk(uint256 risk_) external onlyOwner {\n        tokenGeneratorRisk = risk_;\n    }\n\n    function setTreeHouseRisk(uint256 risk_) external onlyOwner {\n        treeHouseRisk = risk_;\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}