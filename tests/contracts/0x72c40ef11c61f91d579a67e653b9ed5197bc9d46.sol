{{
  "language": "Solidity",
  "sources": {
    "contracts/ONXPlatform.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\nimport \"./modules/Configable.sol\";\nimport \"./modules/ConfigNames.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\n\ninterface IONXSupplyToken {\n\tfunction mint(address account, uint256 amount) external;\n\tfunction burn(address account, uint256 amount) external;\n\tfunction approve(address spender, uint256 amount) external;\n}\n\ninterface IWETH {\n\tfunction deposit() external payable;\n\tfunction withdraw(uint256) external;\n}\n\ninterface IONXPool {\n\tfunction deposit(uint _amountDeposit, address _from) external;\n\tfunction withdraw(uint _amountWithdraw, address _from) external returns(uint, uint);\n\tfunction borrow(uint _amountCollateral, uint _repayAmount, uint _expectBorrow, address _from) external;\n\tfunction repay(uint _amountCollateral, address _from) external returns(uint, uint);\n\tfunction liquidation(address _user, address _from) external returns (uint);\n\tfunction reinvest(address _from) external returns(uint);\n\n\tfunction setCollateralStrategy(address _collateralStrategy, address _supplyStrategy) external;\n\tfunction supplys(address user) external view returns(uint,uint,uint,uint,uint);\n\tfunction borrows(address user) external view returns(uint,uint,uint,uint,uint);\n\tfunction getPoolCapacity() external view returns (uint);\n\tfunction supplyToken() external view returns (address);\n\tfunction interestPerBorrow() external view returns(uint);\n\tfunction interestPerSupply() external view returns(uint);\n\tfunction lastInterestUpdate() external view returns(uint);\n\tfunction getInterests() external view returns(uint, uint);\n\tfunction totalBorrow() external view returns(uint);\n\tfunction remainSupply() external view returns(uint);\n\tfunction liquidationPerSupply() external view returns(uint);\n\tfunction totalLiquidationSupplyAmount() external view returns(uint);\n\tfunction totalLiquidation() external view returns(uint);\n}\n\ninterface IONXFactory {\n    function getPool(address _lendToken, address _collateralToken) external view returns (address);\n    function countPools() external view returns(uint);\n    function allPools(uint index) external view returns (address);\n}\n\ncontract ONXPlatform is Configable {\n\tusing SafeMath for uint256;\n\tuint256 private unlocked;\n\taddress public payoutAddress;\n\taddress public onxSupplyToken;\n\tmodifier lock() {\n\t\trequire(unlocked == 1, \"Locked\");\n\t\tunlocked = 0;\n\t\t_;\n\t\tunlocked = 1;\n\t}\n\n\treceive() external payable {}\n\n\tfunction initialize(address _payoutAddress, address _onxSupplyToken) external initializer {\n\t\tConfigable.__config_initialize();\n\t\tunlocked = 1;\n\t\tpayoutAddress = _payoutAddress;\n\t\tonxSupplyToken = _onxSupplyToken;\n\t}\n\n\tfunction deposit(address _lendToken, address _collateralToken, uint256 _amountDeposit) external lock {\n\t\trequire(IConfig(config).getValue(ConfigNames.DEPOSIT_ENABLE) == 1, \"NOT ENABLE NOW\");\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\tTransferHelper.safeTransferFrom(_lendToken, msg.sender, pool, _amountDeposit);\n\t\tif(onxSupplyToken != address(0) && _amountDeposit > 0)\n\t\t{\n\t\t\tIONXSupplyToken(onxSupplyToken).mint(address(this), _amountDeposit);\n\t\t\tTransferHelper.safeTransfer(onxSupplyToken, pool, _amountDeposit);\n\t\t}\n\t\tIONXPool(pool).deposit(_amountDeposit, msg.sender);\n\t}\n\n\tfunction depositETH(address _lendToken, address _collateralToken) external payable lock {\n\t\trequire(_lendToken == IConfig(config).WETH(), \"INVALID WETH POOL\");\n\t\trequire(IConfig(config).getValue(ConfigNames.DEPOSIT_ENABLE) == 1, \"NOT ENABLE NOW\");\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\tIWETH(IConfig(config).WETH()).deposit{value: msg.value}();\n\t\tTransferHelper.safeTransfer(_lendToken, pool, msg.value);\n\t\tif(onxSupplyToken != address(0) && msg.value > 0)\n\t\t{\n\t\t\tIONXSupplyToken(onxSupplyToken).mint(address(this), msg.value);\n\t\t\tTransferHelper.safeTransfer(onxSupplyToken, pool, msg.value);\n\t\t}\n\t\tIONXPool(pool).deposit(msg.value, msg.sender);\n\t}\n\n\tfunction withdraw(address _lendToken, address _collateralToken, uint256 _amountWithdraw) external lock {\n\t\trequire(IConfig(config).getValue(ConfigNames.WITHDRAW_ENABLE) == 1, \"NOT ENABLE NOW\");\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\t(uint256 withdrawSupplyAmount, uint256 withdrawLiquidationAmount) =\n\t\t\tIONXPool(pool).withdraw(_amountWithdraw, msg.sender);\n\t\tif (withdrawSupplyAmount > 0) {\n\t\t\t_innerTransfer(_lendToken, msg.sender, withdrawSupplyAmount);\n\t\t\tif(onxSupplyToken != address(0) && _amountWithdraw > 0) {\n\t\t\t\tIONXSupplyToken(onxSupplyToken).burn(address(this), _amountWithdraw);\n\t\t\t}\n\t\t}\n\t\tif (withdrawLiquidationAmount > 0) _innerTransfer(_collateralToken, msg.sender, withdrawLiquidationAmount);\n\t}\n\n\tfunction borrow(address _lendToken, address _collateralToken, uint256 _amountCollateral, uint256 _expectBorrow) external lock {\n\t\trequire(IConfig(config).getValue(ConfigNames.BORROW_ENABLE) == 1, \"NOT ENABLE NOW\");\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\tif (_amountCollateral > 0) {\n\t\t\tTransferHelper.safeTransferFrom(_collateralToken, msg.sender, pool, _amountCollateral);\n\t\t}\n\n\t\t(, uint256 borrowAmountCollateral, , , ) = IONXPool(pool).borrows(msg.sender);\n\t\tuint256 repayAmount = getRepayAmount(_lendToken, _collateralToken, borrowAmountCollateral, msg.sender);\n\t\tIONXPool(pool).borrow(_amountCollateral, repayAmount, _expectBorrow, msg.sender);\n\t\tif (_expectBorrow > 0) _innerTransfer(_lendToken, msg.sender, _expectBorrow);\n\t}\n\n\tfunction borrowTokenWithETH(address _lendToken, address _collateralToken, uint256 _expectBorrow) external payable lock {\n\t\trequire(_collateralToken == IConfig(config).WETH(), \"INVALID WETH POOL\");\n\t\trequire(IConfig(config).getValue(ConfigNames.BORROW_ENABLE) == 1, \"NOT ENABLE NOW\");\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n        \n\t\tif (msg.value > 0) {\n\t\t\tIWETH(IConfig(config).WETH()).deposit{value: msg.value}();\n\t\t\tTransferHelper.safeTransfer(_collateralToken, pool, msg.value);\n\t\t}\n\n\t\t(, uint256 borrowAmountCollateral, , , ) = IONXPool(pool).borrows(msg.sender);\n\t\tuint256 repayAmount = getRepayAmount(_lendToken, _collateralToken, borrowAmountCollateral, msg.sender);\n\t\tIONXPool(pool).borrow(msg.value, repayAmount, _expectBorrow, msg.sender);\n\t\tif (_expectBorrow > 0) _innerTransfer(_lendToken, msg.sender, _expectBorrow);\n\t}\n\n\tfunction repay(address _lendToken, address _collateralToken, uint256 _amountCollateral) external lock {\n\t\trequire(IConfig(config).getValue(ConfigNames.REPAY_ENABLE) == 1, \"NOT ENABLE NOW\");\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\tuint256 repayAmount = getRepayAmount(_lendToken, _collateralToken, _amountCollateral, msg.sender);\n\t\tif (repayAmount > 0) {\n\t\t\tTransferHelper.safeTransferFrom(_lendToken, msg.sender, pool, repayAmount);\n\t\t}\n\n\t\t(, uint256 payoutInterest) = IONXPool(pool).repay(_amountCollateral, msg.sender);\n\t\tif (payoutInterest > 0) {\n\t\t\t_innerTransfer(_lendToken, payoutAddress, payoutInterest);\n\t\t}\n\t\t_innerTransfer(_collateralToken, msg.sender, _amountCollateral);\n\t}\n\n\tfunction repayETH(address _lendToken, address _collateralToken, uint256 _amountCollateral) external payable lock {\n\t\trequire(IConfig(config).getValue(ConfigNames.REPAY_ENABLE) == 1, \"NOT ENABLE NOW\");\n\t\trequire(_lendToken == IConfig(config).WETH(), \"INVALID WETH POOL\");\n\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\tuint256 repayAmount = getRepayAmount(_lendToken, _collateralToken, _amountCollateral, msg.sender);\n\t\trequire(repayAmount <= msg.value, \"INVALID VALUE\");\n\t\tif (repayAmount > 0) {\n\t\t\tIWETH(IConfig(config).WETH()).deposit{value: repayAmount}();\n\t\t\tTransferHelper.safeTransfer(_lendToken, pool, repayAmount);\n\t\t}\n\n\t\t(, uint256 payoutInterest) = IONXPool(pool).repay(_amountCollateral, msg.sender);\n\t\tif (payoutInterest > 0) {\n\t\t\t_innerTransfer(_lendToken, payoutAddress, payoutInterest);\n\t\t}\n\t\t_innerTransfer(_collateralToken, msg.sender, _amountCollateral);\n\t\tif (msg.value > repayAmount) TransferHelper.safeTransferETH(msg.sender, msg.value.sub(repayAmount));\n\t}\n\n\tfunction liquidation(address _lendToken, address _collateralToken, address _user) external lock {\n\t\trequire(IConfig(config).getValue(ConfigNames.LIQUIDATION_ENABLE) == 1, \"NOT ENABLE NOW\");\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\tIONXPool(pool).liquidation(_user, msg.sender);\n\t}\n\n\tfunction reinvest(address _lendToken, address _collateralToken) external lock {\n\t\trequire(IConfig(config).getValue(ConfigNames.REINVEST_ENABLE) == 1, \"NOT ENABLE NOW\");\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\tIONXPool(pool).reinvest(msg.sender);\n\t}\n\n\tfunction _innerTransfer(\n\t\taddress _token,\n\t\taddress _to,\n\t\tuint256 _amount\n\t) internal {\n\t\tif (_token == IConfig(config).WETH()) {\n\t\t\tIWETH(_token).withdraw(_amount);\n\t\t\tTransferHelper.safeTransferETH(_to, _amount);\n\t\t} else {\n\t\t\tTransferHelper.safeTransfer(_token, _to, _amount);\n\t\t}\n\t}\n\n\tfunction getRepayAmount(address _lendToken, address _collateralToken, uint256 amountCollateral, address from) public view returns (uint256 repayAmount) {\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\n\t\t(, uint256 borrowAmountCollateral, uint256 interestSettled, uint256 amountBorrow, uint256 borrowInterests) =\n\t\t\tIONXPool(pool).borrows(from);\n\t\t(, uint256 borrowInterestPerBlock) = IONXPool(pool).getInterests();\n\t\tuint256 _interestPerBorrow =\n\t\t\tIONXPool(pool).interestPerBorrow().add(\n\t\t\t\tborrowInterestPerBlock.mul(block.number - IONXPool(pool).lastInterestUpdate())\n\t\t\t);\n\t\tuint256 repayInterest =\n\t\t\tborrowAmountCollateral == 0 \n\t\t\t? 0 \n\t\t\t: borrowInterests.add(_interestPerBorrow.mul(amountBorrow).div(1e18).sub(interestSettled)).mul(amountCollateral).div(borrowAmountCollateral);\n\t\trepayAmount = borrowAmountCollateral == 0\n\t\t\t? 0\n\t\t\t: amountBorrow.mul(amountCollateral).div(borrowAmountCollateral).add(repayInterest);\n\t}\n\n\tfunction getMaximumBorrowAmount(address _lendToken, address _collateralToken, uint256 amountCollateral) external view returns (uint256 amountBorrow) {\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\n\t\tuint256 pledgeAmount = IConfig(config).convertTokenAmount(_collateralToken, _lendToken, amountCollateral);\n\t\tuint256 pledgeRate = IConfig(config).getPoolValue(pool, ConfigNames.POOL_PLEDGE_RATE);\n\t\tamountBorrow = pledgeAmount.mul(pledgeRate).div(1e18);\n\t}\n\n\tfunction getLiquidationAmount(address _lendToken, address _collateralToken, address from) public view returns (uint256 liquidationAmount) {\n        \taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t        require(pool != address(0), \"POOL NOT EXIST\");\n\n\t\t(uint256 amountSupply, , uint256 liquidationSettled, , uint256 supplyLiquidation) =\n\t\t\tIONXPool(pool).supplys(from);\n\t\tliquidationAmount = supplyLiquidation.add(\n\t\t\tIONXPool(pool).liquidationPerSupply().mul(amountSupply).div(1e18).sub(liquidationSettled)\n\t\t);\n\t}\n\n\tfunction getInterestAmount(address _lendToken, address _collateralToken, address from) public view returns (uint256 interestAmount) {\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\n\t\tuint256 totalBorrow = IONXPool(pool).totalBorrow();\n\t\tuint256 totalSupply = totalBorrow + IONXPool(pool).remainSupply();\n\t\t(uint256 amountSupply, uint256 interestSettled, , uint256 interests, ) = IONXPool(pool).supplys(from);\n\t\t(uint256 supplyInterestPerBlock,) = IONXPool(pool).getInterests();\n\t\tuint256 _interestPerSupply =\n\t\t\tIONXPool(pool).interestPerSupply().add(\n\t\t\t\ttotalSupply == 0\n\t\t\t\t\t? 0\n\t\t\t\t\t: supplyInterestPerBlock\n\t\t\t\t\t\t.mul(block.number - IONXPool(pool).lastInterestUpdate())\n\t\t\t\t\t\t.mul(IONXPool(pool).totalBorrow())\n\t\t\t\t\t\t.div(totalSupply)\n\t\t\t);\n\t\tinterestAmount = interests.add(_interestPerSupply.mul(amountSupply).div(1e18).sub(interestSettled));\n\t}\n\n\tfunction getWithdrawAmount(address _lendToken, address _collateralToken, address from)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 withdrawAmount,\n\t\t\tuint256 interestAmount,\n\t\t\tuint256 liquidationAmount\n\t\t)\n\t{\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\n\t\tuint256 _totalInterest = getInterestAmount(_lendToken, _collateralToken, from);\n\t\tliquidationAmount = getLiquidationAmount(_lendToken, _collateralToken, from);\n\t\tinterestAmount = _totalInterest;\n\t\tuint256 totalLiquidation = IONXPool(pool).totalLiquidation();\n\t\tuint256 withdrawLiquidationSupplyAmount =\n\t\t\ttotalLiquidation == 0\n\t\t\t\t? 0\n\t\t\t\t: liquidationAmount.mul(IONXPool(pool).totalLiquidationSupplyAmount()).div(totalLiquidation);\n\t\t(uint256 amountSupply, , , , ) = IONXPool(pool).supplys(from);\n\t\tif (withdrawLiquidationSupplyAmount > amountSupply.add(interestAmount)) withdrawAmount = 0;\n\t\telse withdrawAmount = amountSupply.add(interestAmount).sub(withdrawLiquidationSupplyAmount);\n\t}\n\n\tfunction updatePoolParameter(address _lendToken, address _collateralToken, bytes32 _key, uint256 _value) external onlyOwner {\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\tIConfig(config).setPoolValue(pool, _key, _value);\n\t}\n\n\tfunction setCollateralStrategy(address _lendToken, address _collateralToken, address _collateralStrategy, address _supplyStrategy) external onlyOwner\n\t{\n\t\taddress pool = IONXFactory(IConfig(config).factory()).getPool(_lendToken, _collateralToken);\n\t\trequire(pool != address(0), \"POOL NOT EXIST\");\n\t\tIONXPool(pool).setCollateralStrategy(_collateralStrategy, _supplyStrategy);\n\t}\n\n\tfunction setPayoutAddress(address _payoutAddress) external onlyOwner {\n\t\tpayoutAddress = _payoutAddress;\n\t}\n}\n"
    },
    "contracts/modules/Configable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\ninterface IConfig {\n\t\tfunction owner() external view returns (address);\n    function platform() external view returns (address);\n    function factory() external view returns (address);\n    function mint() external view returns (address);\n    function token() external view returns (address);\n    function developPercent() external view returns (uint);\n    function share() external view returns (address);\n    function base() external view returns (address); \n    function governor() external view returns (address);\n    function getPoolValue(address pool, bytes32 key) external view returns (uint);\n    function getValue(bytes32 key) external view returns(uint);\n    function getParams(bytes32 key) external view returns(uint, uint, uint); \n    function getPoolParams(address pool, bytes32 key) external view returns(uint, uint, uint); \n    function wallets(bytes32 key) external view returns(address);\n    function setValue(bytes32 key, uint value) external;\n    function setPoolValue(address pool, bytes32 key, uint value) external;\n    function initPoolParams(address _pool) external;\n    function isMintToken(address _token) external returns (bool);\n    function prices(address _token) external returns (uint);\n    function convertTokenAmount(address _fromToken, address _toToken, uint _fromAmount) external view returns (uint);\n    function DAY() external view returns (uint);\n    function WETH() external view returns (address);\n}\n\ncontract Configable is Initializable {\n\taddress public config;\n\taddress public owner;\n\tevent OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\n\n\tfunction __config_initialize() internal initializer {\n\t\towner = msg.sender;\n\t}\n\n\tfunction setupConfig(address _config) external onlyOwner {\n\t\tconfig = _config;\n\t\towner = IConfig(config).owner();\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"OWNER FORBIDDEN\");\n\t\t_;\n\t}\n\n\tmodifier onlyPlatform() {\n\t\trequire(msg.sender == IConfig(config).platform(), \"PLATFORM FORBIDDEN\");\n\t\t_;\n\t}\n\n\tmodifier onlyFactory() {\n\t\t\trequire(msg.sender == IConfig(config).factory(), 'FACTORY FORBIDDEN');\n\t\t\t_;\n\t}\n}\n"
    },
    "contracts/modules/ConfigNames.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\nlibrary ConfigNames {\n\t//GOVERNANCE\n\tbytes32 public constant STAKE_LOCK_TIME = bytes32(\"STAKE_LOCK_TIME\");\n\tbytes32 public constant CHANGE_PRICE_DURATION = bytes32(\"CHANGE_PRICE_DURATION\");\n\tbytes32 public constant CHANGE_PRICE_PERCENT = bytes32(\"CHANGE_PRICE_PERCENT\"); // POOL\n\tbytes32 public constant POOL_BASE_INTERESTS = bytes32(\"POOL_BASE_INTERESTS\");\n\tbytes32 public constant POOL_MARKET_FRENZY = bytes32(\"POOL_MARKET_FRENZY\");\n\tbytes32 public constant POOL_PLEDGE_RATE = bytes32(\"POOL_PLEDGE_RATE\");\n\tbytes32 public constant POOL_LIQUIDATION_RATE = bytes32(\"POOL_LIQUIDATION_RATE\");\n\tbytes32 public constant POOL_MINT_BORROW_PERCENT = bytes32(\"POOL_MINT_BORROW_PERCENT\");\n\tbytes32 public constant POOL_MINT_POWER = bytes32(\"POOL_MINT_POWER\");\n\tbytes32 public constant POOL_REWARD_RATE = bytes32(\"POOL_REWARD_RATE\");\n\tbytes32 public constant POOL_ARBITRARY_RATE = bytes32(\"POOL_ARBITRARY_RATE\");\n\n\t//NOT GOVERNANCE\n\tbytes32 public constant DEPOSIT_ENABLE = bytes32(\"DEPOSIT_ENABLE\");\n\tbytes32 public constant WITHDRAW_ENABLE = bytes32(\"WITHDRAW_ENABLE\");\n\tbytes32 public constant BORROW_ENABLE = bytes32(\"BORROW_ENABLE\");\n\tbytes32 public constant REPAY_ENABLE = bytes32(\"REPAY_ENABLE\");\n\tbytes32 public constant LIQUIDATION_ENABLE = bytes32(\"LIQUIDATION_ENABLE\");\n\tbytes32 public constant REINVEST_ENABLE = bytes32(\"REINVEST_ENABLE\");\n\tbytes32 public constant POOL_PRICE = bytes32(\"POOL_PRICE\"); //wallet\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(\n\t\tuint256 a,\n\t\tuint256 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nlibrary TransferHelper {\n\tfunction safeApprove(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 value\n\t) internal {\n\t\t// bytes4(keccak256(bytes('approve(address,uint256)')));\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\n\t}\n\n\tfunction safeTransfer(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 value\n\t) internal {\n\t\t// bytes4(keccak256(bytes('transfer(address,uint256)')));\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\n\t}\n\n\tfunction safeTransferFrom(\n\t\taddress token,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) internal {\n\t\t// bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\n\t}\n\n\tfunction safeTransferETH(address to, uint256 value) internal {\n\t\t(bool success, ) = to.call{value: value}(new bytes(0));\n\t\trequire(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { cs := extcodesize(self) }\n        return cs == 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}