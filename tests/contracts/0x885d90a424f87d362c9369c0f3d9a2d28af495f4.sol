{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/BaoDistribution.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLibrary {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n\n\ninterface IVotingEscrow {\n    function create_lock_for(address _to, uint256 _value, uint256 _unlock_time) external;\n}\n\n\ncontract BaoDistribution is ReentrancyGuard {\n\n    // -------------------------------\n    // VARIABLES\n    // -------------------------------\n\n    //BaoToken public baoToken;\n    IERC20 public baoToken;\n    IVotingEscrow public votingEscrow;\n    mapping(address => DistInfo) public distributions;\n    mapping(address => bool) public lockStatus;\n    address public treasury;\n\n    // -------------------------------\n    // CONSTANTS\n    // -------------------------------\n\n    bytes32 public immutable merkleRoot;\n\n    // -------------------------------\n    // STRUCTS\n    // -------------------------------\n\n    struct DistInfo {\n        uint64 dateStarted;\n        uint64 dateEnded;\n        uint64 lastClaim;\n        uint256 amountOwedTotal;\n    }\n\n    // -------------------------------\n    // EVENTS\n    // -------------------------------\n\n    event DistributionStarted(address _account);\n    event TokensClaimed(address _account, uint256 _amount);\n    event DistributionEnded(address _account, uint256 _amount);\n    event DistributionLocked(address _account, uint256 _amount);\n\n    // -------------------------------\n    // CUSTOM ERRORS\n    // -------------------------------\n\n    error DistributionAlreadyStarted();\n    error DistributionEndedEarly();\n    error InvalidProof(address _account, uint256 _amount, bytes32[] _proof);\n    error ZeroClaimable();\n    error InvalidTimestamp();\n    error outsideLockRange();\n    error alreadyLocked();\n\n    /**\n     * Create a new BaoDistribution contract.\n     *\n     * @param _baoToken Token to distribute.\n     * @param _votingEscrow vote escrow BAO contract\n     * @param _merkleRoot Merkle root to verify accounts' inclusion and amount owed when starting their distribution.\n     */\n    constructor(address _baoToken, address _votingEscrow ,bytes32 _merkleRoot, address _treasury) {\n        baoToken = IERC20(_baoToken);\n        votingEscrow = IVotingEscrow(_votingEscrow);\n        merkleRoot = _merkleRoot;\n        treasury = _treasury;\n    }\n\n    // -------------------------------\n    // PUBLIC FUNCTIONS\n    // -------------------------------\n\n    /**\n     * Starts the distribution of BAO for msg.sender.\n     *\n     * @param _proof Merkle proof to verify msg.sender's inclusion and claimed amount.\n     * @param _amount Amount of tokens msg.sender is owed. Used to generate the merkle tree leaf.\n     */\n    function startDistribution(bytes32[] memory _proof, uint256 _amount) external {\n        if (distributions[msg.sender].dateStarted != 0) {\n            revert DistributionAlreadyStarted();\n        } else if (!verifyProof(_proof, keccak256(abi.encodePacked(msg.sender, _amount)))) {\n            revert InvalidProof(msg.sender, _amount, _proof);\n        }\n\n        uint64 _now = uint64(block.timestamp);\n        distributions[msg.sender] = DistInfo(\n            _now,\n            0,\n            _now,\n            _amount / 1000\n        );\n        emit DistributionStarted(msg.sender);\n    }\n\n    /**\n     * Claim all tokens that have been accrued since msg.sender's last claim.\n     */\n    function claim() external nonReentrant {\n        uint256 _claimable = claimable(msg.sender, 0);\n        if (_claimable == 0) {\n            revert ZeroClaimable();\n        }\n\n        // Update account's DistInfo\n        distributions[msg.sender].lastClaim = uint64(block.timestamp);\n\n        // Send account the tokens that they've accrued since their last claim.\n        baoToken.transfer(msg.sender, _claimable);\n\n        // Emit tokens claimed event for logging\n        emit TokensClaimed(msg.sender, _claimable);\n    }\n\n    /**\n     * Claim all tokens that have been accrued since msg.sender's last claim AND\n     * the rest of the total locked amount owed immediately at a pre-defined slashed rate.\n     *\n     * Slash Rate:\n     * days_since_start <= 365: (100 - .01369863013 * days_since_start)%\n     * days_since_start > 365: 95%\n     */\n    function endDistribution() external nonReentrant {\n        uint256 _claimable = claimable(msg.sender, 0);\n        if (_claimable == 0) {\n            revert ZeroClaimable();\n        }\n\n        DistInfo storage distInfo = distributions[msg.sender];\n        uint64 timestamp = uint64(block.timestamp);\n\n        uint256 daysSinceStart = FixedPointMathLibrary.mulDivDown(uint256(timestamp - distInfo.dateStarted), 1e18, 86400);\n\n        // Calculate total tokens left in distribution after the above claim\n        uint256 tokensLeft = distInfo.amountOwedTotal - distCurve(distInfo.amountOwedTotal, daysSinceStart);\n\n        // Calculate slashed amount\n        uint256 slash = FixedPointMathLibrary.mulDivDown(\n            daysSinceStart > 365e18 ? 95e16 : 1e18 - FixedPointMathLibrary.mulDivDown(daysSinceStart, 1369863013, 1e13),\n            tokensLeft,\n            1e18\n        );\n        uint256 owed = tokensLeft - slash;\n\n        // Account gets slashed for (slash / tokensLeft)% of their remaining distribution\n        baoToken.transfer(msg.sender, owed + _claimable);\n        // Protocol treasury receives slashed tokens\n        baoToken.transfer(treasury, slash);\n\n        // Update DistInfo storage for account to reflect the end of the account's distribution\n        distInfo.lastClaim = timestamp;\n        distInfo.dateEnded = timestamp;\n\n        // Emit tokens claimed event for logging\n        emit TokensClaimed(msg.sender, _claimable);\n        // Emit distribution ended event for logging\n        emit DistributionEnded(msg.sender, owed);\n    }\n\n    /**\n     * Lock all tokens that have NOT been claimed since msg.sender's last claim\n     *\n     * The Lock into veBAO will be set at _time with this function in-line with length of distribution curve (minimum of 3 years)\n     */\n    function lockDistribution(uint256 _time) external nonReentrant {\n        if (lockStatus[msg.sender] == true) {\n            revert alreadyLocked();\n        }\n        uint256 _claimable = claimable(msg.sender, 0);\n        if (_claimable == 0) {\n            revert ZeroClaimable();\n        }\n        if (_time < block.timestamp + 94608000) {\n            revert outsideLockRange();\n        }\n\n        DistInfo storage distInfo = distributions[msg.sender];\n        uint64 timestamp = uint64(block.timestamp);\n\n        uint256 daysSinceStart = FixedPointMathLibrary.mulDivDown(uint256(timestamp - distInfo.dateStarted), 1e18, 86400);\n\n        // Calculate total tokens left in distribution after the above claim\n        uint256 tokensLeft = distInfo.amountOwedTotal - distCurve(distInfo.amountOwedTotal, daysSinceStart);\n\n        baoToken.approve(address(votingEscrow), tokensLeft);\n\n        //lock tokensLeft for msg.sender for _time years (minimum of 3 years)\n        votingEscrow.create_lock_for(msg.sender, tokensLeft, _time);\n\n        lockStatus[msg.sender] = true;\n        distInfo.dateEnded = timestamp;\n\n        emit DistributionLocked(msg.sender, tokensLeft);\n    }\n\n    /**\n     * Get how many tokens an account is able to claim at a given timestamp. 0 = now.\n     * This function takes into account the date of the account's last claim, and returns the amount\n     * of tokens they've accrued since.\n     *\n     * @param _account Account address to query.\n     * @param _timestamp Timestamp to query.\n     * @return c _account's claimable tokens, scaled by 1e18.\n     */\n    function claimable(address _account, uint64 _timestamp) public view returns (uint256 c) {\n        DistInfo memory distInfo = distributions[_account];\n        uint64 dateStarted = distInfo.dateStarted;\n        if (dateStarted == 0) {\n            revert ZeroClaimable();\n        } else if (distInfo.dateEnded != 0) {\n            revert DistributionEndedEarly();\n        }\n\n        uint64 timestamp = _timestamp == 0 ? uint64(block.timestamp) : _timestamp;\n        if (timestamp < dateStarted) {\n            revert InvalidTimestamp();\n        }\n\n        uint256 daysSinceStart = FixedPointMathLibrary.mulDivDown(uint256(timestamp - dateStarted), 1e18, 86400);\n        uint256 daysSinceClaim = FixedPointMathLibrary.mulDivDown(uint256(timestamp - distInfo.lastClaim), 1e18, 86400);\n\n        // Allow the account to claim all tokens accrued since the last time they've claimed.\n        uint256 _total = distInfo.amountOwedTotal;\n        c = distCurve(_total, daysSinceStart) - distCurve(_total, daysSinceStart - daysSinceClaim);\n    }\n\n    /**\n     * Get the amount of tokens that would have been accrued along the distribution curve, assuming _daysSinceStart\n     * days have passed and the account has never claimed.\n     *\n     * f(x) = 0 <= x <= 1095 : (2x/219)^2\n     *\n     * @param _amountOwedTotal Total amount of tokens owed, scaled by 1e18.\n     * @param _daysSinceStart Time since the start of the distribution, scaled by 1e18.\n     * @return _amount Amount of tokens accrued on the distribution curve, assuming the time passed is _daysSinceStart.\n     */\n    function distCurve(uint256 _amountOwedTotal, uint256 _daysSinceStart) public pure returns (uint256 _amount) {\n        if (_daysSinceStart >= 1095e18) return _amountOwedTotal;\n\n        assembly {\n            // Solmate's mulDivDown function\n            function mulDivDown(x, y, denominator) -> z {\n                // Store x * y in z for now.\n                z := mul(x, y)\n\n                // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n                if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                    revert(0, 0)\n                }\n\n                // Divide z by the denominator.\n                z := div(z, denominator)\n            }\n\n            // This is disgusting, but its more gas efficient than storing the results in `_amount` each time.\n            _amount := mulDivDown( // Multiply `amountOwedTotal` by distribution curve result\n                div( // Correct precision after exponent op (scale down by 1e20 instead of 1e18 to convert % to a proportion)\n                    exp( // Raise result to the power of two\n                        mulDivDown( // (2/219) * `_daysSinceStart`\n                            mulDivDown(0x1BC16D674EC80000, 0xDE0B6B3A7640000, 0xBDF3C4BB0328C0000),\n                            _daysSinceStart,\n                            0xDE0B6B3A7640000\n                        ),\n                        2\n                    ),\n                    0xDE0B6B3A7640000\n                ),\n                _amountOwedTotal,\n                0x56BC75E2D63100000\n            )\n        }\n    }\n\n    // -------------------------------\n    // PRIVATE FUNCTIONS\n    // -------------------------------\n\n    /**\n     * Verifies a merkle proof against the stored root.\n     *\n     * @param _proof Merkle proof.\n     * @param _leaf Leaf to verify.\n     * @return bool True if proof is valid, false if proof is invalid.\n     */\n    function verifyProof(bytes32[] memory _proof, bytes32 _leaf) private view returns (bool) {\n        return MerkleProof.verify(_proof, merkleRoot, _leaf);\n    }\n}"
    }
  }
}}