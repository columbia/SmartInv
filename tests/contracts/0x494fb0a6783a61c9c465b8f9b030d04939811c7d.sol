{{
  "language": "Solidity",
  "sources": {
    "contracts/X2ETHMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/utils/ReentrancyGuard.sol\";\nimport \"./libraries/token/IERC20.sol\";\n\nimport \"./interfaces/IX2ETHFactory.sol\";\nimport \"./interfaces/IX2PriceFeed.sol\";\nimport \"./interfaces/IX2Token.sol\";\nimport \"./interfaces/IX2Market.sol\";\nimport \"./interfaces/IChi.sol\";\n\ncontract X2ETHMarket is ReentrancyGuard, IX2Market {\n    using SafeMath for uint256;\n\n    // use a single storage slot\n    // max uint64 has 19 digits so it can support the INITIAL_REBASE_DIVISOR\n    // increasing by 10^9 times\n    uint64 public override previousBullDivisor;\n    uint64 public override previousBearDivisor;\n    uint64 public override cachedBullDivisor;\n    uint64 public override cachedBearDivisor;\n\n    // use a single storage slot\n    // max uint176 can store prices up to 52 digits\n    uint176 public override lastPrice;\n    uint80 public lastRound;\n\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\n    // X2Token.balance uses uint128, max uint128 has 38 digits\n    // with an initial rebase divisor of 10^10\n    // and 18 decimals for ETH, collateral of up to 10 billion ETH\n    // can be supported\n    uint64 public constant INITIAL_REBASE_DIVISOR = 10**10;\n    uint256 public constant MAX_DIVISOR = uint64(-1);\n    int256 public constant MAX_PRICE = uint176(-1);\n\n    uint256 public constant MAX_FUNDING_POINTS = 100; // 0.1%\n    uint256 public constant FUNDING_POINTS_DIVISOR = 100000;\n    uint256 public constant MIN_FUNDING_INTERVAL = 30 minutes;\n\n    address public override bullToken;\n    address public override bearToken;\n    address public priceFeed;\n    uint256 public multiplierBasisPoints;\n    uint256 public maxProfitBasisPoints;\n    uint256 public feeReserve;\n\n    address public factory;\n    IChi public chi;\n\n    uint256 public fundingPoints;\n    uint256 public fundingInterval;\n    uint256 public lastFundingTime;\n\n    bool public isInitialized;\n\n    event DistributeFees(address feeReceiver, uint256 amount);\n    event DistributeInterest(address feeReceiver, uint256 amount);\n    event Rebase(uint256 price, uint64 bullDivisor, uint64 bearDivisor);\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"X2ETHMarket: forbidden\");\n        _;\n    }\n\n    modifier discountCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 *\n                           msg.data.length;\n        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n    }\n\n    function initialize(\n        address _factory,\n        address _priceFeed,\n        uint256 _multiplierBasisPoints,\n        uint256 _maxProfitBasisPoints\n    ) public {\n        require(!isInitialized, \"X2ETHMarket: already initialized\");\n        require(_maxProfitBasisPoints <= BASIS_POINTS_DIVISOR, \"X2ETHMarket: maxProfitBasisPoints limit exceeded\");\n        isInitialized = true;\n\n        factory = _factory;\n        priceFeed = _priceFeed;\n        multiplierBasisPoints = _multiplierBasisPoints;\n        maxProfitBasisPoints = _maxProfitBasisPoints;\n\n        lastPrice = uint176(latestPrice());\n        require(lastPrice != 0, \"X2ETHMarket: unsupported price feed\");\n    }\n\n    function setFunding(uint256 _fundingPoints, uint256 _fundingInterval) public override onlyFactory {\n        require(_fundingPoints <= MAX_FUNDING_POINTS, \"X2ETHMarket: fundingPoints exceeds limit\");\n        require(_fundingInterval >= MIN_FUNDING_INTERVAL, \"X2ETHMarket: fundingInterval below limit\");\n\n        fundingPoints = _fundingPoints;\n        fundingInterval = _fundingInterval;\n    }\n\n    function setBullToken(address _bullToken) public onlyFactory {\n        require(bullToken == address(0), \"X2ETHMarket: bullToken already set\");\n        bullToken = _bullToken;\n        cachedBullDivisor = INITIAL_REBASE_DIVISOR;\n        previousBullDivisor = INITIAL_REBASE_DIVISOR;\n    }\n\n    function setBearToken(address _bearToken) public onlyFactory {\n        require(bearToken == address(0), \"X2ETHMarket: bearToken already set\");\n        bearToken = _bearToken;\n        cachedBearDivisor = INITIAL_REBASE_DIVISOR;\n        previousBearDivisor = INITIAL_REBASE_DIVISOR;\n    }\n\n    function setChi(IChi _chi) public onlyFactory {\n        chi = _chi;\n    }\n\n    function buy(address _token, address _receiver) public payable nonReentrant returns (uint256) {\n        return _buy(_token, _receiver);\n    }\n\n    function buyUsingChi(address _token, address _receiver) public payable nonReentrant discountCHI returns (uint256) {\n        return _buy(_token, _receiver);\n    }\n\n    function sell(address _token, uint256 _amount, address _receiver) public nonReentrant returns (uint256) {\n        return _sell(_token, _amount, _receiver, true);\n    }\n\n    function sellUsingChi(address _token, uint256 _amount, address _receiver) public nonReentrant discountCHI returns (uint256) {\n        return _sell(_token, _amount, _receiver, true);\n    }\n\n    function sellAll(address _token, address _receiver) public nonReentrant returns (uint256) {\n        uint256 amount = IERC20(_token).balanceOf(msg.sender);\n        return _sell(_token, amount, _receiver, true);\n    }\n\n    function sellAllUsingChi(address _token, address _receiver) public nonReentrant discountCHI returns (uint256) {\n        uint256 amount = IERC20(_token).balanceOf(msg.sender);\n        return _sell(_token, amount, _receiver, true);\n    }\n\n    // since an X2Token's distributor can be set by the factory's gov,\n    // the market should allow an option to sell the token without invoking\n    // the distributor\n    // this ensures that tokens can always be sold even if the distributor\n    // is set to an address that intentionally fails when `distribute` is called\n    function sellWithoutDistribution(address _token, uint256 _amount, address _receiver) public nonReentrant returns (uint256) {\n        return _sell(_token, _amount, _receiver, false);\n    }\n\n    function rebase() public returns (bool) {\n        uint256 _lastPrice = uint256(lastPrice);\n        uint256 nextPrice = latestPrice();\n        uint80 _latestRound = latestRound();\n        uint256 _lastRound = lastRound;\n        if (_latestRound == _lastRound) { return false; }\n\n        (uint256 _cachedBullDivisor, uint256 _cachedBearDivisor) = getDivisors(_lastPrice, nextPrice);\n        _updateLastFundingTime();\n\n        // the latest round is just one after the last recorded round\n        // so update the previous divisors to the cached divisors\n        // and update the cached divisors to the latest divisors\n        if (_latestRound == _lastRound + 1) {\n            lastPrice = uint176(nextPrice);\n            lastRound = _latestRound;\n            previousBullDivisor = cachedBullDivisor;\n            previousBearDivisor = cachedBearDivisor;\n            cachedBullDivisor = uint64(_cachedBullDivisor);\n            cachedBearDivisor = uint64(_cachedBearDivisor);\n\n            emit Rebase(nextPrice, uint64(_cachedBullDivisor), uint64(_cachedBearDivisor));\n            return true;\n        }\n\n        // if the previous price cannot be retrieved then\n        // update the previous divisors to the cached divisors\n        // and update the cached divisors to the latest divisors\n        (bool ok, uint256 previousPrice) = getRoundPrice(_latestRound - 1);\n        if (!ok) {\n            lastPrice = uint176(nextPrice);\n            lastRound = _latestRound;\n            previousBullDivisor = cachedBullDivisor;\n            previousBearDivisor = cachedBearDivisor;\n            cachedBullDivisor = uint64(_cachedBullDivisor);\n            cachedBearDivisor = uint64(_cachedBearDivisor);\n            emit Rebase(nextPrice, uint64(_cachedBullDivisor), uint64(_cachedBearDivisor));\n            return false;\n        }\n\n        (uint256 _previousBullDivisor, uint256 _previousBearDivisor) = getDivisors(_lastPrice, previousPrice);\n\n        lastPrice = uint176(nextPrice);\n        lastRound = _latestRound;\n        previousBullDivisor = uint64(_previousBullDivisor);\n        previousBearDivisor = uint64(_previousBearDivisor);\n        cachedBullDivisor = uint64(_cachedBullDivisor);\n        cachedBearDivisor = uint64(_cachedBearDivisor);\n        emit Rebase(nextPrice, uint64(_cachedBullDivisor), uint64(_cachedBearDivisor));\n        return true;\n    }\n\n    function distributeFees() public nonReentrant returns (uint256) {\n        address feeReceiver = IX2ETHFactory(factory).feeReceiver();\n        require(feeReceiver != address(0), \"X2Market: empty feeReceiver\");\n\n        uint256 fees = feeReserve;\n        feeReserve = 0;\n\n        (bool success,) = feeReceiver.call{value: fees}(\"\");\n        require(success, \"X2ETHMarket: transfer failed\");\n\n        emit DistributeFees(feeReceiver, fees);\n\n        return fees;\n    }\n\n    function distributeInterest() public nonReentrant returns (uint256) {\n        address feeReceiver = IX2ETHFactory(factory).feeReceiver();\n        require(feeReceiver != address(0), \"X2Market: empty feeReceiver\");\n\n        uint256 interest = interestReserve();\n\n        (bool success,) = feeReceiver.call{value: interest}(\"\");\n        require(success, \"X2ETHMarket: transfer failed\");\n\n        emit DistributeInterest(feeReceiver, interest);\n\n        return interest;\n    }\n\n    function interestReserve() public view returns (uint256) {\n        uint256 bullRefSupply = IX2Token(bullToken)._totalSupply();\n        uint256 bearRefSupply = IX2Token(bearToken)._totalSupply();\n\n        // the actual underlying supplies\n        uint256 totalBulls = bullRefSupply.div(cachedBullDivisor);\n        uint256 totalBears = bearRefSupply.div(cachedBearDivisor);\n\n        uint256 balance = address(this).balance;\n        return balance.sub(totalBulls).sub(totalBears).sub(feeReserve);\n    }\n\n    function getDivisor(address _token) public override view returns (uint256) {\n        uint80 _lastRound = lastRound;\n        uint80 _latestRound = latestRound();\n        bool isBull = _token == bullToken;\n\n        // if the latest round is the same as the last recorded round\n        // then select the largest divisor from the previous and cached divisors\n        if (_latestRound == _lastRound) {\n            return isBull ? _max(previousBullDivisor, cachedBullDivisor) : _max(previousBearDivisor, cachedBearDivisor);\n        }\n\n        uint256 _lastPrice = uint256(lastPrice);\n        uint256 nextPrice = latestPrice();\n        (uint256 nextBullDivisor, uint256 nextBearDivisor) = getDivisors(_lastPrice, nextPrice);\n\n        // if the latest round is just after the last recorded round\n        // then select the largest divisor from the cached divisor and the\n        // divisor for the next price\n        if (_latestRound == _lastRound + 1) {\n            return isBull ? _max(cachedBullDivisor, nextBullDivisor) : _max(cachedBearDivisor, nextBearDivisor);\n        }\n\n        (bool ok, uint256 previousPrice) = getRoundPrice(_latestRound - 1);\n        // if the price just before the lastest round cannot be retrieved\n        // then fallback to selecting the largest divisor from the cached divisor\n        // and the divisor for the next price\n        if (!ok) {\n            return isBull ? _max(cachedBullDivisor, nextBullDivisor) : _max(cachedBearDivisor, nextBearDivisor);\n        }\n\n        (uint256 _previousBullDivisor, uint256 _previousBearDivisor) = getDivisors(_lastPrice, previousPrice);\n        return isBull ? _max(_previousBullDivisor, nextBullDivisor) : _max(_previousBearDivisor, nextBearDivisor);\n    }\n\n    function getRoundPrice(uint80 round) public view returns (bool, uint256) {\n        address _priceFeed = priceFeed;\n        (, int256 price, , ,) = IX2PriceFeed(_priceFeed).getRoundData(round);\n        if (price <= 0 || price > MAX_PRICE) {\n            return (false, 0);\n        }\n\n        return (true, uint256(price));\n    }\n\n    function latestPrice() public override view returns (uint256) {\n        int256 answer = IX2PriceFeed(priceFeed).latestAnswer();\n        // avoid negative, zero or overflow values being returned\n        if (answer <= 0 || answer > MAX_PRICE) {\n            return uint256(lastPrice);\n        }\n        return uint256(answer);\n    }\n\n    function latestRound() public view returns (uint80) {\n        return IX2PriceFeed(priceFeed).latestRound();\n    }\n\n    function getDivisors(uint256 _lastPrice, uint256 _nextPrice) public override view returns (uint256, uint256) {\n        uint256 bullRefSupply = IX2Token(bullToken)._totalSupply();\n        uint256 bearRefSupply = IX2Token(bearToken)._totalSupply();\n\n        // the actual underlying supplies\n        uint256 totalBulls = bullRefSupply.div(cachedBullDivisor);\n        uint256 totalBears = bearRefSupply.div(cachedBearDivisor);\n\n        // scope variables to avoid stack too deep errors\n        {\n        // refSupply is the smaller of the two supplies\n        uint256 refSupply = totalBulls < totalBears ? totalBulls : totalBears;\n        uint256 delta = _nextPrice > _lastPrice ? _nextPrice.sub(_lastPrice) : _lastPrice.sub(_nextPrice);\n        // profit is [(smaller supply) * (change in price) / (last price)] * multiplierBasisPoints\n        uint256 profit = refSupply.mul(delta).div(_lastPrice).mul(multiplierBasisPoints).div(BASIS_POINTS_DIVISOR);\n\n        // cap the profit to the (max profit percentage) of the smaller supply\n        uint256 maxProfit = refSupply.mul(maxProfitBasisPoints).div(BASIS_POINTS_DIVISOR);\n        if (profit > maxProfit) { profit = maxProfit; }\n\n        totalBulls = _nextPrice > _lastPrice ? totalBulls.add(profit) : totalBulls.sub(profit);\n        totalBears = _nextPrice > _lastPrice ? totalBears.sub(profit) : totalBears.add(profit);\n        }\n\n        if (fundingPoints > 0 && fundingInterval > 0) {\n            uint256 intervals = block.timestamp.sub(lastFundingTime).div(fundingInterval);\n            if (intervals > 0) {\n                if (totalBulls > totalBears) {\n                    totalBulls = totalBulls.sub(totalBulls.mul(intervals).mul(fundingPoints).div(FUNDING_POINTS_DIVISOR));\n                } else {\n                    totalBears = totalBears.sub(totalBears.mul(intervals).mul(fundingPoints).div(FUNDING_POINTS_DIVISOR));\n                }\n            }\n        }\n\n        return (_getNextDivisor(bullRefSupply, totalBulls, cachedBullDivisor), _getNextDivisor(bearRefSupply, totalBears, cachedBearDivisor));\n    }\n\n    function _updateLastFundingTime() private {\n        if (fundingPoints > 0 && fundingInterval > 0) {\n            lastFundingTime = block.timestamp;\n        }\n    }\n\n    function _max(uint256 a, uint256 b) private pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    function _getNextDivisor(uint256 _refSupply, uint256 _nextSupply, uint256 _fallbackDivisor) private pure returns (uint256) {\n        if (_nextSupply == 0) {\n            return INITIAL_REBASE_DIVISOR;\n        }\n\n        // round up the divisor\n        uint256 divisor = _refSupply.mul(10).div(_nextSupply).add(9).div(10);\n        // prevent the cachedDivisor from overflowing or being set to 0\n        if (divisor == 0 || divisor > MAX_DIVISOR) { return _fallbackDivisor; }\n\n        return divisor;\n    }\n\n    function _collectFees(uint256 _amount) private returns (uint256) {\n        uint256 fee = IX2ETHFactory(factory).getFee(address(this), _amount);\n        if (fee == 0) { return 0; }\n\n        feeReserve = feeReserve.add(fee);\n        return fee;\n    }\n\n    function _buy(address _token, address _receiver) private returns (uint256) {\n        bool isBull = _token == bullToken;\n        require(isBull || _token == bearToken, \"X2ETHMarket: unsupported token\");\n        uint256 amount = msg.value;\n        require(amount > 0, \"X2ETHMarket: insufficient collateral sent\");\n\n        rebase();\n\n        uint256 fee = _collectFees(amount);\n        uint256 depositAmount = amount.sub(fee);\n        IX2Token(_token).mint(_receiver, depositAmount, isBull ? cachedBullDivisor : cachedBearDivisor);\n\n        return depositAmount;\n    }\n\n    function _sell(address _token, uint256 _amount, address _receiver, bool distribute) private returns (uint256) {\n        require(_token == bullToken || _token == bearToken, \"X2ETHMarket: unsupported token\");\n        rebase();\n\n        IX2Token(_token).burn(msg.sender, _amount, distribute);\n\n        uint256 fee = _collectFees(_amount);\n        uint256 withdrawAmount = _amount.sub(fee);\n        (bool success,) = _receiver.call{value: withdrawAmount}(\"\");\n        require(success, \"X2ETHMarket: transfer failed\");\n\n        return withdrawAmount;\n    }\n}\n"
    },
    "contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IX2ETHFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IX2ETHFactory {\n    function feeReceiver() external view returns (address);\n    function getFee(address market, uint256 amount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IX2PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IX2PriceFeed {\n    function latestAnswer() external view returns (int256);\n    function latestRound() external view returns (uint80);\n    function getRoundData(uint80 roundId) external view returns (uint80, int256, uint256, uint256, uint80);\n}\n"
    },
    "contracts/interfaces/IX2Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IX2Token {\n    function distributor() external view returns (address);\n    function _totalSupply() external view returns (uint256);\n    function _balanceOf(address account) external view returns (uint256);\n    function market() external view returns (address);\n    function getDivisor() external view returns (uint256);\n    function getReward(address account) external view returns (uint256);\n    function costOf(address account) external view returns (uint256);\n    function mint(address account, uint256 amount, uint256 divisor) external;\n    function burn(address account, uint256 amount, bool distribute) external;\n    function setDistributor(address _distributor) external;\n    function setInfo(string memory name, string memory symbol) external;\n}\n"
    },
    "contracts/interfaces/IX2Market.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IX2Market {\n    function bullToken() external view returns (address);\n    function bearToken() external view returns (address);\n    function latestPrice() external view returns (uint256);\n    function lastPrice() external view returns (uint176);\n    function getDivisor(address token) external view returns (uint256);\n    function getDivisors(uint256 _lastPrice, uint256 _nextPrice) external view returns (uint256, uint256);\n    function setFunding(uint256 fundingPoints, uint256 fundingInterval) external;\n    function previousBullDivisor() external view returns (uint64);\n    function previousBearDivisor() external view returns (uint64);\n    function cachedBullDivisor() external view returns (uint64);\n    function cachedBearDivisor() external view returns (uint64);\n}\n"
    },
    "contracts/interfaces/IChi.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IChi {\n    function freeFromUpTo(address from, uint256 value) external returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}