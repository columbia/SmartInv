{{
  "language": "Solidity",
  "sources": {
    "contracts/CollectionPartyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {NonReceivableInitializedProxy} from \"./NonReceivableInitializedProxy.sol\";\nimport {CollectionParty} from \"./CollectionParty.sol\";\nimport {Structs} from \"./Structs.sol\";\n\n/**\n * @title CollectionParty Factory\n * @author Anna Carroll\n */\ncontract CollectionPartyFactory {\n    //======== Events ========\n\n    event CollectionPartyDeployed(\n        address indexed partyProxy,\n        address indexed creator,\n        address indexed nftContract,\n        uint256 maxPrice,\n        uint256 secondsToTimeout,\n        address[] deciders,\n        address splitRecipient,\n        uint256 splitBasisPoints,\n        address gatedToken,\n        uint256 gatedTokenAmount,\n        string name,\n        string symbol\n    );\n\n    //======== Immutable storage =========\n\n    address public immutable logic;\n    address public immutable partyDAOMultisig;\n    address public immutable tokenVaultFactory;\n    address public immutable weth;\n\n    //======== Mutable storage =========\n\n    // PartyBid proxy => block number deployed at\n    mapping(address => uint256) public deployedAt;\n\n    //======== Constructor =========\n\n    constructor(\n        address _partyDAOMultisig,\n        address _tokenVaultFactory,\n        address _weth,\n        address _allowList\n    ) {\n        partyDAOMultisig = _partyDAOMultisig;\n        tokenVaultFactory = _tokenVaultFactory;\n        weth = _weth;\n        // deploy logic contract\n        CollectionParty _logicContract = new CollectionParty(\n            _partyDAOMultisig,\n            _tokenVaultFactory,\n            _weth,\n            _allowList\n        );\n        // store logic contract address\n        logic = address(_logicContract);\n    }\n\n    //======== Deploy function =========\n\n    function startParty(\n        address _nftContract,\n        uint256 _maxPrice,\n        uint256 _secondsToTimeout,\n        address[] calldata _deciders,\n        Structs.AddressAndAmount calldata _split,\n        Structs.AddressAndAmount calldata _tokenGate,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address partyProxy) {\n        bytes memory _initializationCalldata = abi.encodeWithSelector(\n            CollectionParty.initialize.selector,\n            _nftContract,\n            _maxPrice,\n            _secondsToTimeout,\n            _deciders,\n            _split,\n            _tokenGate,\n            _name,\n            _symbol\n        );\n\n        partyProxy = address(\n            new NonReceivableInitializedProxy(logic, _initializationCalldata)\n        );\n\n        deployedAt[partyProxy] = block.number;\n\n        emit CollectionPartyDeployed(\n            partyProxy,\n            msg.sender,\n            _nftContract,\n            _maxPrice,\n            _secondsToTimeout,\n            _deciders,\n            _split.addr,\n            _split.amount,\n            _tokenGate.addr,\n            _tokenGate.amount,\n            _name,\n            _symbol\n        );\n    }\n}\n"
    },
    "contracts/NonReceivableInitializedProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n/**\n * @title NonReceivableInitializedProxy\n * @author Anna Carroll\n */\ncontract NonReceivableInitializedProxy {\n    // address of logic contract\n    address public immutable logic;\n\n    // ======== Constructor =========\n\n    constructor(address _logic, bytes memory _initializationCalldata) {\n        logic = _logic;\n        // Delegatecall into the logic contract, supplying initialization calldata\n        (bool _ok, bytes memory returnData) = _logic.delegatecall(\n            _initializationCalldata\n        );\n        // Revert if delegatecall to implementation reverts\n        require(_ok, string(returnData));\n    }\n\n    // ======== Fallback =========\n\n    fallback() external payable {\n        address _impl = logic;\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/CollectionParty.sol": {
      "content": "/*\n                                                                                     .-'''-.\n                                                             _______                '   _    \\\n_________   _...._                                           \\  ___ `'.           /   /` '.   \\\n\\        |.'      '-.                          .-.          .-' |--.\\  \\         .   |     \\  '\n \\        .'```'.    '.          .-,.--.      .|\\ \\        / /| |    \\  '        |   '      |  '\n  \\      |       \\     \\   __    |  .-. |   .' |_\\ \\      / / | |     |  '    __ \\    \\     / /\n   |     |        |    |.:--.'.  | |  | | .'     |\\ \\    / /  | |     |  | .:--.'.`.   ` ..' /\n   |      \\      /    ./ |   \\ | | |  | |'--.  .-' \\ \\  / /   | |     ' .'/ |   \\ |  '-...-'`\n   |     |\\`'-.-'   .' `\" __ | | | |  '-    |  |    \\ `  /    | |___.' /' `\" __ | |\n   |     | '-....-'`    .'.''| | | |        |  |     \\  /    /_______.'/   .'.''| |\n  .'     '.            / /   | |_| |        |  '.'   / /     \\_______|/   / /   | |_\n'-----------'          \\ \\._,\\ '/|_|        |   /|`-' /                   \\ \\._,\\ '/\n                        `--'  `\"            `'-'  '..'                     `--'  `\"\nAnna Carroll for PartyDAO\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n// ============ External Imports: External Contracts & Contract Interfaces ============\nimport {Party} from \"./Party.sol\";\nimport {Structs} from \"./Structs.sol\";\nimport {IAllowList} from \"./IAllowList.sol\";\n\ncontract CollectionParty is Party {\n    // partyStatus Transitions:\n    //   (1) PartyStatus.ACTIVE on deploy\n    //   (2) PartyStatus.WON after successful buy()\n    //   (3) PartyStatus.LOST after successful expire()\n\n    // ============ Internal Constants ============\n\n    // Collection Party version 1\n    uint16 public constant VERSION = 1;\n    string public constant PARTY_TYPE = \"Collection\";\n\n    // ============ Immutables ============\n\n    IAllowList public immutable allowList;\n\n    // ============ Public Not-Mutated Storage ============\n\n    // the timestamp at which the Party is no longer active\n    uint256 public expiresAt;\n    // the maximum price that the party is willing to\n    // spend on an item in the collection.\n    // NOTE: to remove the maximum price cap, set maxPrice to 0.\n    // by default, CollectionParties shouldn't need a maxPrice\n    // because the deciders should already be trusted to buy well-priced items.\n    // NOTE: the party can accept *UP TO* 102.5% of maxPrice in total,\n    // and will not accept more contributions after this.\n    uint256 public maxPrice;\n    // decider => true if this address is a decider\n    mapping(address => bool) public isDecider;\n\n    // ============ Events ============\n\n    // emitted when a token is successfully bought\n    event Bought(\n        uint256 tokenId,\n        address triggeredBy,\n        address targetAddress,\n        uint256 ethSpent,\n        uint256 ethFeePaid,\n        uint256 totalContributed\n    );\n\n    // emitted if the Party fails to buy the token before expiresAt\n    // and someone expires the Party so folks can reclaim ETH\n    event Expired(address triggeredBy);\n\n    // ======== Constructor =========\n\n    constructor(\n        address _partyDAOMultisig,\n        address _tokenVaultFactory,\n        address _weth,\n        address _allowList\n    ) Party(_partyDAOMultisig, _tokenVaultFactory, _weth) {\n        allowList = IAllowList(_allowList);\n    }\n\n    // ======== Initializer =========\n\n    function initialize(\n        address _nftContract,\n        uint256 _maxPrice,\n        uint256 _secondsToTimeout,\n        address[] calldata _deciders,\n        Structs.AddressAndAmount calldata _split,\n        Structs.AddressAndAmount calldata _tokenGate,\n        string memory _name,\n        string memory _symbol\n    ) external initializer {\n        // initialize & validate shared Party variables\n        __Party_init(_nftContract, _split, _tokenGate, _name, _symbol);\n        // set PartyBuy-specific state variables\n        expiresAt = block.timestamp + _secondsToTimeout;\n        maxPrice = _maxPrice;\n        // attempt to calculate maximum contributions to ensure this value won't overflow later\n        getMaximumContributions();\n        // set deciders list\n        require(\n            _deciders.length > 0,\n            \"PartyBuy::initialize: set at least one decider\"\n        );\n        for (uint256 i = 0; i < _deciders.length; i++) {\n            isDecider[_deciders[i]] = true;\n        }\n    }\n\n    // ======== External: Contribute =========\n\n    /**\n     * @notice Contribute to the Party's treasury\n     * while the Party is still active\n     * @dev Emits a Contributed event upon success; callable by anyone\n     */\n    function contribute() external payable nonReentrant {\n        // require that the new total contributed is not greater than\n        // the maximum amount the Party is willing to spend\n        require(\n            totalContributedToParty + msg.value <= getMaximumContributions(),\n            \"PartyBuy::contribute: cannot contribute more than max\"\n        );\n        // continue with shared _contribute flow\n        // shared _contribute flow\n        _contribute();\n    }\n\n    // ======== External: Buy =========\n\n    /**\n     * @notice Buy the token by calling targetContract with calldata supplying value\n     * @dev Emits a Bought event upon success; reverts otherwise. callable by anyone\n     */\n    function buy(\n        uint256 _tokenId,\n        uint256 _value,\n        address _targetContract,\n        bytes calldata _calldata\n    ) external nonReentrant {\n        require(\n            partyStatus == PartyStatus.ACTIVE,\n            \"PartyBuy::buy: party not active\"\n        );\n        // ensure the caller is a decider\n        require(isDecider[msg.sender], \"PartyBuy::buy: caller not a decider\");\n        // ensure the target contract is on allow list\n        require(\n            allowList.allowed(_targetContract),\n            \"PartyBuy::buy: targetContract not on AllowList\"\n        );\n        // check that value is not zero (else, token will be burned in TokenVault)\n        require(_value > 0, \"PartyBuy::buy: can't spend zero\");\n        // check that value is not more than the maximum price set at deploy time\n        require(\n            maxPrice == 0 || _value <= maxPrice,\n            \"PartyBuy::buy: can't spend over max price\"\n        );\n        // check that value is not more than\n        // the maximum amount the party can spend while paying ETH fee\n        require(\n            _value <= getMaximumSpend(),\n            \"PartyBuy::buy: insuffucient funds to buy token plus fee\"\n        );\n        // set tokenId variable before _getOwner\n        tokenId = _tokenId;\n        // require that the NFT is NOT owned by the Party\n        require(\n            _getOwner() != address(this),\n            \"PartyBuy::buy: own token before call\"\n        );\n        // execute the calldata on the target contract\n        (bool _success, bytes memory _returnData) = address(_targetContract)\n            .call{value: _value}(_calldata);\n        // require that the external call succeeded\n        require(_success, string(_returnData));\n        // require that the NFT is owned by the Party\n        require(\n            _getOwner() == address(this),\n            \"PartyBuy::buy: failed to buy token\"\n        );\n        // set partyStatus to WON\n        partyStatus = PartyStatus.WON;\n        // record totalSpent,\n        // send ETH fees to PartyDAO,\n        // fractionalize the Token\n        // send Token fees to PartyDAO & split proceeds to split recipient\n        uint256 _ethFee = _closeSuccessfulParty(_value);\n        // emit Bought event\n        emit Bought(\n            _tokenId,\n            msg.sender,\n            _targetContract,\n            _value,\n            _ethFee,\n            totalContributedToParty\n        );\n    }\n\n    // ======== External: Fail =========\n\n    /**\n     * @notice If the token couldn't be successfully bought\n     * within the specified period of time, move to FAILED state\n     * so users can reclaim their funds.\n     * @dev Emits a Expired event upon finishing; reverts otherwise.\n     * callable by anyone after expiresAt\n     */\n    function expire() external nonReentrant {\n        require(\n            partyStatus == PartyStatus.ACTIVE,\n            \"PartyBuy::expire: party not active\"\n        );\n        require(\n            expiresAt <= block.timestamp,\n            \"PartyBuy::expire: party has not timed out\"\n        );\n        // set partyStatus to LOST\n        partyStatus = PartyStatus.LOST;\n        // emit Expired event\n        emit Expired(msg.sender);\n    }\n\n    // ============ Internal ============\n\n    /**\n     * @notice Get the maximum amount that can be contributed to the Party\n     * @return _maxContributions the maximum amount that can be contributed to the party\n     */\n    function getMaximumContributions()\n        public\n        view\n        returns (uint256 _maxContributions)\n    {\n        uint256 _price = maxPrice;\n        if (_price == 0) {\n            return 2**256 - 1; // max-int\n        }\n        _maxContributions = _price + _getEthFee(_price);\n    }\n}\n"
    },
    "contracts/Structs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface Structs {\n    struct AddressAndAmount {\n        address addr;\n        uint256 amount;\n    }\n}\n"
    },
    "contracts/Party.sol": {
      "content": "/*\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\_____________________________________________________________/\\\\\\\\\\\\\\\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\______\n _\\/\\\\\\/////////\\\\\\__________________________________________________________\\/\\\\\\////////\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\\\\\______/\\\\\\///\\\\\\____\n  _\\/\\\\\\_______\\/\\\\\\__________________________________/\\\\\\_________/\\\\\\__/\\\\\\_\\/\\\\\\______\\//\\\\\\__/\\\\\\/////////\\\\\\___/\\\\\\/__\\///\\\\\\__\n   _\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/___/\\\\\\\\\\\\\\\\\\_____/\\\\/\\\\\\\\\\\\\\___/\\\\\\\\\\\\\\\\\\\\\\___\\//\\\\\\/\\\\\\__\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_______\\/\\\\\\__/\\\\\\______\\//\\\\\\_\n    _\\/\\\\\\/////////____\\////////\\\\\\___\\/\\\\\\/////\\\\\\_\\////\\\\\\////_____\\//\\\\\\\\\\___\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_\n     _\\/\\\\\\_______________/\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\___\\///_____\\/\\\\\\__________\\//\\\\\\____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\/////////\\\\\\_\\//\\\\\\______/\\\\\\__\n      _\\/\\\\\\______________/\\\\\\/////\\\\\\__\\/\\\\\\____________\\/\\\\\\_/\\\\___/\\\\_/\\\\\\_____\\/\\\\\\_______/\\\\\\__\\/\\\\\\_______\\/\\\\\\__\\///\\\\\\__/\\\\\\____\n       _\\/\\\\\\_____________\\//\\\\\\\\\\\\\\\\/\\\\_\\/\\\\\\____________\\//\\\\\\\\\\___\\//\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\/___\\/\\\\\\_______\\/\\\\\\____\\///\\\\\\\\\\/_____\n        _\\///_______________\\////////\\//__\\///______________\\/////_____\\////________\\////////////_____\\///________\\///_______\\/////_______\n\nAnna Carroll for PartyDAO\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n// ============ External Imports: Inherited Contracts ============\n// NOTE: we inherit from OpenZeppelin upgradeable contracts\n// because of the proxy structure used for cheaper deploys\n// (the proxies are NOT actually upgradeable)\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n// ============ External Imports: External Contracts & Contract Interfaces ============\nimport {IERC721VaultFactory} from \"./external/interfaces/IERC721VaultFactory.sol\";\nimport {ITokenVault} from \"./external/interfaces/ITokenVault.sol\";\nimport {IWETH} from \"./external/interfaces/IWETH.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// ============ Internal Imports ============\nimport {Structs} from \"./Structs.sol\";\n\ncontract Party is ReentrancyGuardUpgradeable, ERC721HolderUpgradeable {\n    // ============ Enums ============\n\n    // State Transitions:\n    //   (0) ACTIVE on deploy\n    //   (1) WON if the Party has won the token\n    //   (2) LOST if the Party is over & did not win the token\n    enum PartyStatus {\n        ACTIVE,\n        WON,\n        LOST\n    }\n\n    // ============ Structs ============\n\n    struct Contribution {\n        uint256 amount;\n        uint256 previousTotalContributedToParty;\n    }\n\n    // ============ Internal Constants ============\n\n    // tokens are minted at a rate of 1 ETH : 1000 tokens\n    uint16 internal constant TOKEN_SCALE = 1000;\n    // PartyDAO receives an ETH fee equal to 2.5% of the amount spent\n    uint16 internal constant ETH_FEE_BASIS_POINTS = 250;\n    // PartyDAO receives a token fee equal to 2.5% of the total token supply\n    uint16 internal constant TOKEN_FEE_BASIS_POINTS = 250;\n    // token is relisted on Fractional with an\n    // initial reserve price equal to 2x the price of the token\n    uint8 internal constant RESALE_MULTIPLIER = 2;\n\n    // ============ Immutables ============\n\n    address public immutable partyFactory;\n    address public immutable partyDAOMultisig;\n    IERC721VaultFactory public immutable tokenVaultFactory;\n    IWETH public immutable weth;\n\n    // ============ Public Not-Mutated Storage ============\n\n    // NFT contract\n    IERC721Metadata public nftContract;\n    // ID of token within NFT contract\n    uint256 public tokenId;\n    // Fractionalized NFT vault responsible for post-purchase experience\n    ITokenVault public tokenVault;\n    // the address that will receive a portion of the tokens\n    // if the Party successfully buys the token\n    address public splitRecipient;\n    // percent of the total token supply\n    // taken by the splitRecipient\n    uint256 public splitBasisPoints;\n    // address of token that users need to hold to contribute\n    // address(0) if party is not token gated\n    IERC20 public gatedToken;\n    // amount of token that users need to hold to contribute\n    // 0 if party is not token gated\n    uint256 public gatedTokenAmount;\n    // ERC-20 name and symbol for fractional tokens\n    string public name;\n    string public symbol;\n\n    // ============ Public Mutable Storage ============\n\n    // state of the contract\n    PartyStatus public partyStatus;\n    // total ETH deposited by all contributors\n    uint256 public totalContributedToParty;\n    // the total spent buying the token;\n    // 0 if the NFT is not won; price of token + 2.5% PartyDAO fee if NFT is won\n    uint256 public totalSpent;\n    // contributor => array of Contributions\n    mapping(address => Contribution[]) public contributions;\n    // contributor => total amount contributed\n    mapping(address => uint256) public totalContributed;\n    // contributor => true if contribution has been claimed\n    mapping(address => bool) public claimed;\n\n    // ============ Events ============\n\n    event Contributed(\n        address indexed contributor,\n        uint256 amount,\n        uint256 previousTotalContributedToParty,\n        uint256 totalFromContributor\n    );\n\n    event Claimed(\n        address indexed contributor,\n        uint256 totalContributed,\n        uint256 excessContribution,\n        uint256 tokenAmount\n    );\n\n    // ======== Modifiers =========\n\n    modifier onlyPartyDAO() {\n        require(\n            msg.sender == partyDAOMultisig,\n            \"Party:: only PartyDAO multisig\"\n        );\n        _;\n    }\n\n    // ======== Constructor =========\n\n    constructor(\n        address _partyDAOMultisig,\n        address _tokenVaultFactory,\n        address _weth\n    ) {\n        partyFactory = msg.sender;\n        partyDAOMultisig = _partyDAOMultisig;\n        tokenVaultFactory = IERC721VaultFactory(_tokenVaultFactory);\n        weth = IWETH(_weth);\n    }\n\n    // ======== Internal: Initialize =========\n\n    function __Party_init(\n        address _nftContract,\n        Structs.AddressAndAmount calldata _split,\n        Structs.AddressAndAmount calldata _tokenGate,\n        string memory _name,\n        string memory _symbol\n    ) internal {\n        require(\n            msg.sender == partyFactory,\n            \"Party::__Party_init: only factory can init\"\n        );\n        // if split is non-zero,\n        if (_split.addr != address(0) && _split.amount != 0) {\n            // validate that party split won't retain the total token supply\n            uint256 _remainingBasisPoints = 10000 - TOKEN_FEE_BASIS_POINTS;\n            require(\n                _split.amount < _remainingBasisPoints,\n                \"Party::__Party_init: basis points can't take 100%\"\n            );\n            splitBasisPoints = _split.amount;\n            splitRecipient = _split.addr;\n        }\n        // if token gating is non-zero\n        if (_tokenGate.addr != address(0) && _tokenGate.amount != 0) {\n            // call totalSupply to verify that address is ERC-20 token contract\n            IERC20(_tokenGate.addr).totalSupply();\n            gatedToken = IERC20(_tokenGate.addr);\n            gatedTokenAmount = _tokenGate.amount;\n        }\n        // initialize ReentrancyGuard and ERC721Holder\n        __ReentrancyGuard_init();\n        __ERC721Holder_init();\n        // set storage variables\n        nftContract = IERC721Metadata(_nftContract);\n        name = _name;\n        symbol = _symbol;\n    }\n\n    // ======== Internal: Contribute =========\n\n    /**\n     * @notice Contribute to the Party's treasury\n     * while the Party is still active\n     * @dev Emits a Contributed event upon success; callable by anyone\n     */\n    function _contribute() internal {\n        require(\n            partyStatus == PartyStatus.ACTIVE,\n            \"Party::contribute: party not active\"\n        );\n        address _contributor = msg.sender;\n        uint256 _amount = msg.value;\n        // if token gated, require that contributor has balance of gated tokens\n        if (address(gatedToken) != address(0)) {\n            require(\n                gatedToken.balanceOf(_contributor) >= gatedTokenAmount,\n                \"Party::contribute: must hold tokens to contribute\"\n            );\n        }\n        require(_amount > 0, \"Party::contribute: must contribute more than 0\");\n        // get the current contract balance\n        uint256 _previousTotalContributedToParty = totalContributedToParty;\n        // add contribution to contributor's array of contributions\n        Contribution memory _contribution = Contribution({\n            amount: _amount,\n            previousTotalContributedToParty: _previousTotalContributedToParty\n        });\n        contributions[_contributor].push(_contribution);\n        // add to contributor's total contribution\n        totalContributed[_contributor] =\n            totalContributed[_contributor] +\n            _amount;\n        // add to party's total contribution & emit event\n        totalContributedToParty = _previousTotalContributedToParty + _amount;\n        emit Contributed(\n            _contributor,\n            _amount,\n            _previousTotalContributedToParty,\n            totalContributed[_contributor]\n        );\n    }\n\n    // ======== External: Claim =========\n\n    /**\n     * @notice Claim the tokens and excess ETH owed\n     * to a single contributor after the party has ended\n     * @dev Emits a Claimed event upon success\n     * callable by anyone (doesn't have to be the contributor)\n     * @param _contributor the address of the contributor\n     */\n    function claim(address _contributor) external nonReentrant {\n        // ensure party has finalized\n        require(\n            partyStatus != PartyStatus.ACTIVE,\n            \"Party::claim: party not finalized\"\n        );\n        // ensure contributor submitted some ETH\n        require(\n            totalContributed[_contributor] != 0,\n            \"Party::claim: not a contributor\"\n        );\n        // ensure the contributor hasn't already claimed\n        require(\n            !claimed[_contributor],\n            \"Party::claim: contribution already claimed\"\n        );\n        // mark the contribution as claimed\n        claimed[_contributor] = true;\n        // calculate the amount of fractional NFT tokens owed to the user\n        // based on how much ETH they contributed towards the party,\n        // and the amount of excess ETH owed to the user\n        (uint256 _tokenAmount, uint256 _ethAmount) = getClaimAmounts(\n            _contributor\n        );\n        // transfer tokens to contributor for their portion of ETH used\n        _transferTokens(_contributor, _tokenAmount);\n        // if there is excess ETH, send it back to the contributor\n        _transferETHOrWETH(_contributor, _ethAmount);\n        emit Claimed(\n            _contributor,\n            totalContributed[_contributor],\n            _ethAmount,\n            _tokenAmount\n        );\n    }\n\n    // ======== External: Emergency Escape Hatches (PartyDAO Multisig Only) =========\n\n    /**\n     * @notice Escape hatch: in case of emergency,\n     * PartyDAO can use emergencyWithdrawEth to withdraw\n     * ETH stuck in the contract\n     */\n    function emergencyWithdrawEth(uint256 _value) external onlyPartyDAO {\n        _transferETHOrWETH(partyDAOMultisig, _value);\n    }\n\n    /**\n     * @notice Escape hatch: in case of emergency,\n     * PartyDAO can use emergencyCall to call an external contract\n     * (e.g. to withdraw a stuck NFT or stuck ERC-20s)\n     */\n    function emergencyCall(address _contract, bytes memory _calldata)\n        external\n        onlyPartyDAO\n        returns (bool _success, bytes memory _returnData)\n    {\n        (_success, _returnData) = _contract.call(_calldata);\n        require(_success, string(_returnData));\n    }\n\n    /**\n     * @notice Escape hatch: in case of emergency,\n     * PartyDAO can force the Party to finalize with status LOST\n     * (e.g. if finalize is not callable)\n     */\n    function emergencyForceLost() external onlyPartyDAO {\n        // set partyStatus to LOST\n        partyStatus = PartyStatus.LOST;\n    }\n\n    // ======== Public: Utility Calculations =========\n\n    /**\n     * @notice Convert ETH value to equivalent token amount\n     */\n    function valueToTokens(uint256 _value)\n        public\n        pure\n        returns (uint256 _tokens)\n    {\n        _tokens = _value * TOKEN_SCALE;\n    }\n\n    /**\n     * @notice The maximum amount that can be spent by the Party\n     * while paying the ETH fee to PartyDAO\n     * @return _maxSpend the maximum spend\n     */\n    function getMaximumSpend() public view returns (uint256 _maxSpend) {\n        _maxSpend =\n            (totalContributedToParty * 10000) /\n            (10000 + ETH_FEE_BASIS_POINTS);\n    }\n\n    /**\n     * @notice Calculate the amount of fractional NFT tokens owed to the contributor\n     * based on how much ETH they contributed towards buying the token,\n     * and the amount of excess ETH owed to the contributor\n     * based on how much ETH they contributed *not* used towards buying the token\n     * @param _contributor the address of the contributor\n     * @return _tokenAmount the amount of fractional NFT tokens owed to the contributor\n     * @return _ethAmount the amount of excess ETH owed to the contributor\n     */\n    function getClaimAmounts(address _contributor)\n        public\n        view\n        returns (uint256 _tokenAmount, uint256 _ethAmount)\n    {\n        require(\n            partyStatus != PartyStatus.ACTIVE,\n            \"Party::getClaimAmounts: party still active; amounts undetermined\"\n        );\n        uint256 _totalContributed = totalContributed[_contributor];\n        if (partyStatus == PartyStatus.WON) {\n            // calculate the amount of this contributor's ETH\n            // that was used to buy the token\n            uint256 _totalEthUsed = totalEthUsed(_contributor);\n            if (_totalEthUsed > 0) {\n                _tokenAmount = valueToTokens(_totalEthUsed);\n            }\n            // the rest of the contributor's ETH should be returned\n            _ethAmount = _totalContributed - _totalEthUsed;\n        } else {\n            // if the token wasn't bought, no ETH was spent;\n            // all of the contributor's ETH should be returned\n            _ethAmount = _totalContributed;\n        }\n    }\n\n    /**\n     * @notice Calculate the total amount of a contributor's funds\n     * that were used towards the buying the token\n     * @dev always returns 0 until the party has been finalized\n     * @param _contributor the address of the contributor\n     * @return _total the sum of the contributor's funds that were\n     * used towards buying the token\n     */\n    function totalEthUsed(address _contributor)\n        public\n        view\n        returns (uint256 _total)\n    {\n        require(\n            partyStatus != PartyStatus.ACTIVE,\n            \"Party::totalEthUsed: party still active; amounts undetermined\"\n        );\n        // load total amount spent once from storage\n        uint256 _totalSpent = totalSpent;\n        // get all of the contributor's contributions\n        Contribution[] memory _contributions = contributions[_contributor];\n        for (uint256 i = 0; i < _contributions.length; i++) {\n            // calculate how much was used from this individual contribution\n            uint256 _amount = _ethUsed(_totalSpent, _contributions[i]);\n            // if we reach a contribution that was not used,\n            // no subsequent contributions will have been used either,\n            // so we can stop calculating to save some gas\n            if (_amount == 0) break;\n            _total = _total + _amount;\n        }\n    }\n\n    // ============ Internal ============\n\n    function _closeSuccessfulParty(uint256 _nftCost)\n        internal\n        returns (uint256 _ethFee)\n    {\n        // calculate PartyDAO fee & record total spent\n        _ethFee = _getEthFee(_nftCost);\n        totalSpent = _nftCost + _ethFee;\n        // transfer ETH fee to PartyDAO\n        _transferETHOrWETH(partyDAOMultisig, _ethFee);\n        // deploy fractionalized NFT vault\n        // and mint fractional ERC-20 tokens\n        _fractionalizeNFT(_nftCost);\n    }\n\n    /**\n     * @notice Calculate ETH fee for PartyDAO\n     * NOTE: Remove this fee causes a critical vulnerability\n     * allowing anyone to exploit a Party via price manipulation.\n     * See Security Review in README for more info.\n     * @return _fee the portion of _amount represented by scaling to ETH_FEE_BASIS_POINTS\n     */\n    function _getEthFee(uint256 _amount) internal pure returns (uint256 _fee) {\n        _fee = (_amount * ETH_FEE_BASIS_POINTS) / 10000;\n    }\n\n    /**\n     * @notice Calculate token amount for specified token recipient\n     * @return _totalSupply the total token supply\n     * @return _partyDAOAmount the amount of tokens for partyDAO fee,\n     * which is equivalent to TOKEN_FEE_BASIS_POINTS of total supply\n     * @return _splitRecipientAmount the amount of tokens for the token recipient,\n     * which is equivalent to splitBasisPoints of total supply\n     */\n    function _getTokenInflationAmounts(uint256 _amountSpent)\n        internal\n        view\n        returns (\n            uint256 _totalSupply,\n            uint256 _partyDAOAmount,\n            uint256 _splitRecipientAmount\n        )\n    {\n        // the token supply will be inflated to provide a portion of the\n        // total supply for PartyDAO, and a portion for the splitRecipient\n        uint256 inflationBasisPoints = TOKEN_FEE_BASIS_POINTS +\n            splitBasisPoints;\n        _totalSupply = valueToTokens(\n            (_amountSpent * 10000) / (10000 - inflationBasisPoints)\n        );\n        // PartyDAO receives TOKEN_FEE_BASIS_POINTS of the total supply\n        _partyDAOAmount = (_totalSupply * TOKEN_FEE_BASIS_POINTS) / 10000;\n        // splitRecipient receives splitBasisPoints of the total supply\n        _splitRecipientAmount = (_totalSupply * splitBasisPoints) / 10000;\n    }\n\n    /**\n     * @notice Query the NFT contract to get the token owner\n     * @dev nftContract must implement the ERC-721 token standard exactly:\n     * function ownerOf(uint256 _tokenId) external view returns (address);\n     * See https://eips.ethereum.org/EIPS/eip-721\n     * @dev Returns address(0) if NFT token or NFT contract\n     * no longer exists (token burned or contract self-destructed)\n     * @return _owner the owner of the NFT\n     */\n    function _getOwner() internal view returns (address _owner) {\n        (bool _success, bytes memory _returnData) = address(nftContract)\n            .staticcall(abi.encodeWithSignature(\"ownerOf(uint256)\", tokenId));\n        if (_success && _returnData.length > 0) {\n            _owner = abi.decode(_returnData, (address));\n        }\n    }\n\n    /**\n     * @notice Upon winning the token, transfer the NFT\n     * to fractional.art vault & mint fractional ERC-20 tokens\n     */\n    function _fractionalizeNFT(uint256 _amountSpent) internal {\n        // approve fractionalized NFT Factory to withdraw NFT\n        nftContract.approve(address(tokenVaultFactory), tokenId);\n        // Party \"votes\" for a reserve price on Fractional\n        // equal to 2x the price of the token\n        uint256 _listPrice = RESALE_MULTIPLIER * _amountSpent;\n        // users receive tokens at a rate of 1:TOKEN_SCALE for each ETH they contributed that was ultimately spent\n        // partyDAO receives a percentage of the total token supply equivalent to TOKEN_FEE_BASIS_POINTS\n        // splitRecipient receives a percentage of the total token supply equivalent to splitBasisPoints\n        (\n            uint256 _tokenSupply,\n            uint256 _partyDAOAmount,\n            uint256 _splitRecipientAmount\n        ) = _getTokenInflationAmounts(totalSpent);\n        // deploy fractionalized NFT vault\n        uint256 vaultNumber = tokenVaultFactory.mint(\n            name,\n            symbol,\n            address(nftContract),\n            tokenId,\n            _tokenSupply,\n            _listPrice,\n            0\n        );\n        // store token vault address to storage\n        tokenVault = ITokenVault(tokenVaultFactory.vaults(vaultNumber));\n        // transfer curator to null address (burn the curator role)\n        tokenVault.updateCurator(address(0));\n        // transfer tokens to PartyDAO multisig\n        _transferTokens(partyDAOMultisig, _partyDAOAmount);\n        // transfer tokens to token recipient\n        if (splitRecipient != address(0)) {\n            _transferTokens(splitRecipient, _splitRecipientAmount);\n        }\n    }\n\n    // ============ Internal: Claim ============\n\n    /**\n     * @notice Calculate the amount of a single Contribution\n     * that was used towards buying the token\n     * @param _contribution the Contribution struct\n     * @return the amount of funds from this contribution\n     * that were used towards buying the token\n     */\n    function _ethUsed(uint256 _totalSpent, Contribution memory _contribution)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (\n            _contribution.previousTotalContributedToParty +\n                _contribution.amount <=\n            _totalSpent\n        ) {\n            // contribution was fully used\n            return _contribution.amount;\n        } else if (\n            _contribution.previousTotalContributedToParty < _totalSpent\n        ) {\n            // contribution was partially used\n            return _totalSpent - _contribution.previousTotalContributedToParty;\n        }\n        // contribution was not used\n        return 0;\n    }\n\n    // ============ Internal: TransferTokens ============\n\n    /**\n     * @notice Transfer tokens to a recipient\n     * @param _to recipient of tokens\n     * @param _value amount of tokens\n     */\n    function _transferTokens(address _to, uint256 _value) internal {\n        // skip if attempting to send 0 tokens\n        if (_value == 0) {\n            return;\n        }\n        // guard against rounding errors;\n        // if token amount to send is greater than contract balance,\n        // send full contract balance\n        uint256 _partyBalance = tokenVault.balanceOf(address(this));\n        if (_value > _partyBalance) {\n            _value = _partyBalance;\n        }\n        tokenVault.transfer(_to, _value);\n    }\n\n    // ============ Internal: TransferEthOrWeth ============\n\n    /**\n     * @notice Attempt to transfer ETH to a recipient;\n     * if transferring ETH fails, transfer WETH insteads\n     * @param _to recipient of ETH or WETH\n     * @param _value amount of ETH or WETH\n     */\n    function _transferETHOrWETH(address _to, uint256 _value) internal {\n        // skip if attempting to send 0 ETH\n        if (_value == 0) {\n            return;\n        }\n        // guard against rounding errors;\n        // if ETH amount to send is greater than contract balance,\n        // send full contract balance\n        if (_value > address(this).balance) {\n            _value = address(this).balance;\n        }\n        // Try to transfer ETH to the given recipient.\n        if (!_attemptETHTransfer(_to, _value)) {\n            // If the transfer fails, wrap and send as WETH\n            weth.deposit{value: _value}();\n            weth.transfer(_to, _value);\n            // At this point, the recipient can unwrap WETH.\n        }\n    }\n\n    /**\n     * @notice Attempt to transfer ETH to a recipient\n     * @dev Sending ETH is not guaranteed to succeed\n     * this method will return false if it fails.\n     * We will limit the gas used in transfers, and handle failure cases.\n     * @param _to recipient of ETH\n     * @param _value amount of ETH\n     */\n    function _attemptETHTransfer(address _to, uint256 _value)\n        internal\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = _to.call{value: _value, gas: 30000}(\"\");\n        return success;\n    }\n}\n"
    },
    "contracts/IAllowList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n/**\n * @title IAllowList\n * @author Anna Carroll\n */\ninterface IAllowList {\n    function allowed(address _addr) external view returns (bool _bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n  /**\n   * @dev Implementation of the {IERC721Receiver} interface.\n   *\n   * Accepts all token transfers.\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n   */\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\n    function __ERC721Holder_init() internal initializer {\n        __ERC721Holder_init_unchained();\n    }\n\n    function __ERC721Holder_init_unchained() internal initializer {\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/external/interfaces/IERC721VaultFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC721VaultFactory {\n    /// @notice the mapping of vault number to vault address\n    function vaults(uint256) external returns (address);\n\n    /// @notice the function to mint a new vault\n    /// @param _name the desired name of the vault\n    /// @param _symbol the desired sumbol of the vault\n    /// @param _token the ERC721 token address fo the NFT\n    /// @param _id the uint256 ID of the token\n    /// @param _listPrice the initial price of the NFT\n    /// @return the ID of the vault\n    function mint(string memory _name, string memory _symbol, address _token, uint256 _id, uint256 _supply, uint256 _listPrice, uint256 _fee) external returns(uint256);\n}\n"
    },
    "contracts/external/interfaces/ITokenVault.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface ITokenVault {\n    /// @notice allow curator to update the curator address\n    /// @param _curator the new curator\n    function updateCurator(address _curator) external;\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) external view returns (uint256);\n}"
    },
    "contracts/external/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}