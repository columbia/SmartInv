{{
  "language": "Solidity",
  "sources": {
    "contracts/StabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ITroveManagerHelpers.sol\";\nimport \"./Interfaces/IDCHFToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ICommunityIssuance.sol\";\nimport \"./Dependencies/DfrancBase.sol\";\nimport \"./Dependencies/DfrancSafeMath128.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/SafetyTransfer.sol\";\nimport \"./Dependencies/Initializable.sol\";\n\ncontract StabilityPool is\n\tDfrancBase,\n\tCheckContract,\n\tReentrancyGuard,\n\tInitializable,\n\tIStabilityPool\n{\n\tusing SafeMath for uint256;\n\tusing DfrancSafeMath128 for uint128;\n\tusing SafeERC20 for IERC20;\n\n\tstring public constant NAME = \"StabilityPool\";\n\tbytes32 public constant STABILITY_POOL_NAME_BYTES =\n\t\t0xf704b47f65a99b2219b7213612db4be4a436cdf50624f4baca1373ef0de0aac7;\n\n\tIBorrowerOperations public borrowerOperations;\n\n\tITroveManager public troveManager;\n\n\tITroveManagerHelpers public troveManagerHelpers;\n\n\tIDCHFToken public dchfToken;\n\n\t// Needed to check if there are pending liquidations\n\tISortedTroves public sortedTroves;\n\n\tICommunityIssuance public communityIssuance;\n\n\taddress internal assetAddress;\n\n\tuint256 internal assetBalance; // deposited ether tracker\n\n\t// Tracker for DCHF held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n\tuint256 internal totalDCHFDeposits;\n\n\t// --- Data structures ---\n\n\tstruct Snapshots {\n\t\tuint256 S;\n\t\tuint256 P;\n\t\tuint256 G;\n\t\tuint128 scale;\n\t\tuint128 epoch;\n\t}\n\n\tmapping(address => uint256) public deposits; // depositor address -> Deposit struct\n\tmapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\n\n\tuint256 public totalStakes;\n\tSnapshots public systemSnapshots;\n\n\t/*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n\t * after a series of liquidations have occurred, each of which cancel some DCHF debt with the deposit.\n\t *\n\t * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n\t * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n\t */\n\tuint256 public P;\n\n\tuint256 public constant SCALE_FACTOR = 1e9;\n\n\t// Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n\tuint128 public currentScale;\n\n\t// With each offset that fully empties the Pool, the epoch is incremented by 1\n\tuint128 public currentEpoch;\n\n\t/* ETH Gain sum 'S': During its lifetime, each deposit d_t earns an ETH gain of ( d_t * [S - S_t] )/P_t, where S_t\n\t * is the depositor's snapshot of S taken at the time t when the deposit was made.\n\t *\n\t * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n\t *\n\t * - The inner mapping records the sum S at different scales\n\t * - The outer mapping records the (scale => sum) mappings, for different epochs.\n\t */\n\tmapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToSum;\n\n\t/*\n\t * Similarly, the sum 'G' is used to calculate MON gains. During it's lifetime, each deposit d_t earns a MON gain of\n\t *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n\t *\n\t *  MON reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n\t *  In each case, the MON reward is issued (i.e. G is updated), before other state changes are made.\n\t */\n\tmapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;\n\n\t// Error tracker for the error correction in the MON issuance calculation\n\tuint256 public lastMONError;\n\t// Error trackers for the error correction in the offset calculation\n\tuint256 public lastAssetError_Offset;\n\tuint256 public lastDCHFLossError_Offset;\n\n\tbool public isInitialized;\n\n\t// --- Contract setters ---\n\n\tfunction getNameBytes() external pure override returns (bytes32) {\n\t\treturn STABILITY_POOL_NAME_BYTES;\n\t}\n\n\tfunction getAssetType() external view override returns (address) {\n\t\treturn assetAddress;\n\t}\n\n\tfunction setAddresses(\n\t\taddress _assetAddress,\n\t\taddress _borrowerOperationsAddress,\n\t\taddress _troveManagerAddress,\n\t\taddress _troveManagerHelpersAddress,\n\t\taddress _dchfTokenAddress,\n\t\taddress _sortedTrovesAddress,\n\t\taddress _communityIssuanceAddress,\n\t\taddress _dfrancParamsAddress\n\t) external initializer onlyOwner {\n\t\trequire(!isInitialized, \"Already initialized\");\n\t\tcheckContract(_borrowerOperationsAddress);\n\t\tcheckContract(_troveManagerAddress);\n\t\tcheckContract(_troveManagerHelpersAddress);\n\t\tcheckContract(_dchfTokenAddress);\n\t\tcheckContract(_sortedTrovesAddress);\n\t\tcheckContract(_communityIssuanceAddress);\n\t\tcheckContract(_dfrancParamsAddress);\n\n\t\tisInitialized = true;\n\n\t\tif (_assetAddress != ETH_REF_ADDRESS) {\n\t\t\tcheckContract(_assetAddress);\n\t\t}\n\n\t\tassetAddress = _assetAddress;\n\t\tborrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n\t\ttroveManager = ITroveManager(_troveManagerAddress);\n\t\ttroveManagerHelpers = ITroveManagerHelpers(_troveManagerHelpersAddress);\n\t\tdchfToken = IDCHFToken(_dchfTokenAddress);\n\t\tsortedTroves = ISortedTroves(_sortedTrovesAddress);\n\t\tcommunityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n\t\tsetDfrancParameters(_dfrancParamsAddress);\n\n\t\tP = DECIMAL_PRECISION;\n\n\t\temit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n\t\temit TroveManagerAddressChanged(_troveManagerAddress);\n\t\temit DCHFTokenAddressChanged(_dchfTokenAddress);\n\t\temit SortedTrovesAddressChanged(_sortedTrovesAddress);\n\t\temit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\t}\n\n\t// --- Getters for public variables. Required by IPool interface ---\n\n\tfunction getAssetBalance() external view override returns (uint256) {\n\t\treturn assetBalance;\n\t}\n\n\tfunction getTotalDCHFDeposits() external view override returns (uint256) {\n\t\treturn totalDCHFDeposits;\n\t}\n\n\t// --- External Depositor Functions ---\n\n\t/*  provideToSP():\n\t *\n\t * - Triggers a MON issuance, based on time passed since the last issuance. The MON issuance is shared between *all* depositors\n\t * - Sends depositor's accumulated gains (MON, ETH) to depositor\n\t * - Increases deposit and system stake, and takes new snapshots for each.\n\t */\n\tfunction provideToSP(uint256 _amount) external override nonReentrant {\n\t\t_requireNonZeroAmount(_amount);\n\n\t\tuint256 initialDeposit = deposits[msg.sender];\n\n\t\tICommunityIssuance communityIssuanceCached = communityIssuance;\n\t\t_triggerMONIssuance(communityIssuanceCached);\n\n\t\tuint256 depositorAssetGain = getDepositorAssetGain(msg.sender);\n\t\tuint256 depositorAssetGainEther = getDepositorAssetGain1e18(msg.sender);\n\n\t\tuint256 compoundedDCHFDeposit = getCompoundedDCHFDeposit(msg.sender);\n\t\tuint256 DCHFLoss = initialDeposit.sub(compoundedDCHFDeposit); // Needed only for event log\n\n\t\t// First pay out any MON gains\n\t\t_payOutMONGains(communityIssuanceCached, msg.sender);\n\n\t\t// Update System stake\n\t\tuint256 compoundedStake = getCompoundedTotalStake();\n\t\tuint256 newStake = compoundedStake.add(_amount);\n\t\t_updateStakeAndSnapshots(newStake);\n\t\temit StakeChanged(newStake, msg.sender);\n\n\t\t_sendDCHFtoStabilityPool(msg.sender, _amount);\n\n\t\tuint256 newDeposit = compoundedDCHFDeposit.add(_amount);\n\t\t_updateDepositAndSnapshots(msg.sender, newDeposit);\n\n\t\temit UserDepositChanged(msg.sender, newDeposit);\n\t\temit AssetGainWithdrawn(msg.sender, depositorAssetGain, DCHFLoss); // DCHF Loss required for event log\n\n\t\t_sendAssetGainToDepositor(depositorAssetGain, depositorAssetGainEther);\n\t}\n\n\t/*  withdrawFromSP():\n\t *\n\t * - Triggers a MON issuance, based on time passed since the last issuance. The MON issuance is shared between *all* depositors\n\t * - Sends all depositor's accumulated gains (MON, ETH) to depositor\n\t * - Decreases deposit and system stake, and takes new snapshots for each.\n\t *\n\t * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n\t */\n\tfunction withdrawFromSP(uint256 _amount) external override nonReentrant {\n\t\tif (_amount != 0) {\n\t\t\t_requireNoUnderCollateralizedTroves();\n\t\t}\n\t\tuint256 initialDeposit = deposits[msg.sender];\n\t\t_requireUserHasDeposit(initialDeposit);\n\n\t\tICommunityIssuance communityIssuanceCached = communityIssuance;\n\n\t\t_triggerMONIssuance(communityIssuanceCached);\n\n\t\tuint256 depositorAssetGain = getDepositorAssetGain(msg.sender);\n\t\tuint256 depositorAssetGainEther = getDepositorAssetGain1e18(msg.sender);\n\n\t\tuint256 compoundedDCHFDeposit = getCompoundedDCHFDeposit(msg.sender);\n\t\tuint256 DCHFtoWithdraw = DfrancMath._min(_amount, compoundedDCHFDeposit);\n\t\tuint256 DCHFLoss = initialDeposit.sub(compoundedDCHFDeposit); // Needed only for event log\n\n\t\t// First pay out any MON gains\n\t\t_payOutMONGains(communityIssuanceCached, msg.sender);\n\n\t\t// Update System stake\n\t\tuint256 compoundedStake = getCompoundedTotalStake();\n\t\tuint256 newStake = compoundedStake.sub(DCHFtoWithdraw);\n\t\t_updateStakeAndSnapshots(newStake);\n\t\temit StakeChanged(newStake, msg.sender);\n\n\t\t_sendDCHFToDepositor(msg.sender, DCHFtoWithdraw);\n\n\t\t// Update deposit\n\t\tuint256 newDeposit = compoundedDCHFDeposit.sub(DCHFtoWithdraw);\n\t\t_updateDepositAndSnapshots(msg.sender, newDeposit);\n\t\temit UserDepositChanged(msg.sender, newDeposit);\n\n\t\temit AssetGainWithdrawn(msg.sender, depositorAssetGain, DCHFLoss); // DCHF Loss required for event log\n\n\t\t_sendAssetGainToDepositor(depositorAssetGain, depositorAssetGainEther);\n\t}\n\n\t/* withdrawETHGainToTrove:\n\t * - Triggers a MON issuance, based on time passed since the last issuance. The MON issuance is shared between *all* depositors\n\t * - Sends all depositor's MON gain to  depositor\n\t * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\n\t * - Leaves their compounded deposit in the Stability Pool\n\t * - Updates snapshots for deposit and system stake */\n\tfunction withdrawAssetGainToTrove(address _upperHint, address _lowerHint) external override {\n\t\tuint256 initialDeposit = deposits[msg.sender];\n\t\t_requireUserHasDeposit(initialDeposit);\n\t\t_requireUserHasTrove(msg.sender);\n\t\t_requireUserHasETHGain(msg.sender);\n\n\t\tICommunityIssuance communityIssuanceCached = communityIssuance;\n\n\t\t_triggerMONIssuance(communityIssuanceCached);\n\n\t\tuint256 depositorAssetGain = getDepositorAssetGain1e18(msg.sender);\n\n\t\tuint256 compoundedDCHFDeposit = getCompoundedDCHFDeposit(msg.sender);\n\t\tuint256 DCHFLoss = initialDeposit.sub(compoundedDCHFDeposit); // Needed only for event log\n\n\t\t// First pay out any MON gains\n\t\t_payOutMONGains(communityIssuanceCached, msg.sender);\n\n\t\t// Update System stake\n\t\tuint256 compoundedSystemStake = getCompoundedTotalStake();\n\t\t_updateStakeAndSnapshots(compoundedSystemStake);\n\t\temit StakeChanged(compoundedSystemStake, msg.sender);\n\n\t\t_updateDepositAndSnapshots(msg.sender, compoundedDCHFDeposit);\n\n\t\t/* Emit events before transferring ETH gain to Trove.\n         This lets the event log make more sense (i.e. so it appears that first the ETH gain is withdrawn\n        and then it is deposited into the Trove, not the other way around). */\n\t\temit AssetGainWithdrawn(msg.sender, depositorAssetGain, DCHFLoss);\n\t\temit UserDepositChanged(msg.sender, compoundedDCHFDeposit);\n\n\t\tassetBalance = assetBalance.sub(depositorAssetGain);\n\t\temit StabilityPoolAssetBalanceUpdated(assetBalance);\n\t\temit AssetSent(msg.sender, depositorAssetGain);\n\n\t\tborrowerOperations.moveETHGainToTrove{\n\t\t\tvalue: assetAddress == address(0) ? depositorAssetGain : 0\n\t\t}(assetAddress, depositorAssetGain, msg.sender, _upperHint, _lowerHint);\n\t}\n\n\t// --- MON issuance functions ---\n\n\tfunction _triggerMONIssuance(ICommunityIssuance _communityIssuance) internal {\n\t\tuint256 MONIssuance = _communityIssuance.issueMON();\n\t\t_updateG(MONIssuance);\n\t}\n\n\tfunction _updateG(uint256 _MONIssuance) internal {\n\t\tuint256 totalDCHF = totalDCHFDeposits; // cached to save an SLOAD\n\t\t/*\n\t\t * When total deposits is 0, G is not updated. In this case, the MON issued can not be obtained by later\n\t\t * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n\t\t *\n\t\t */\n\t\tif (totalDCHF == 0 || _MONIssuance == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tuint256 MONPerUnitStaked;\n\t\tMONPerUnitStaked = _computeMONPerUnitStaked(_MONIssuance, totalDCHF);\n\n\t\tuint256 marginalMONGain = MONPerUnitStaked.mul(P);\n\t\tepochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\n\t\t\t.add(marginalMONGain);\n\n\t\temit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n\t}\n\n\tfunction _computeMONPerUnitStaked(uint256 _MONIssuance, uint256 _totalDCHFDeposits)\n\t\tinternal\n\t\treturns (uint256)\n\t{\n\t\t/*\n\t\t * Calculate the MON-per-unit staked.  Division uses a \"feedback\" error correction, to keep the\n\t\t * cumulative error low in the running total G:\n\t\t *\n\t\t * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n\t\t * function was called.\n\t\t * 2) Calculate \"per-unit-staked\" ratio.\n\t\t * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n\t\t * 4) Store this error for use in the next correction when this function is called.\n\t\t * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n\t\t */\n\t\tuint256 MONNumerator = _MONIssuance.mul(DECIMAL_PRECISION).add(lastMONError);\n\n\t\tuint256 MONPerUnitStaked = MONNumerator.div(_totalDCHFDeposits);\n\t\tlastMONError = MONNumerator.sub(MONPerUnitStaked.mul(_totalDCHFDeposits));\n\n\t\treturn MONPerUnitStaked;\n\t}\n\n\t// --- Liquidation functions ---\n\n\t/*\n\t * Cancels out the specified debt against the DCHF contained in the Stability Pool (as far as possible)\n\t * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\n\t * Only called by liquidation functions in the TroveManager.\n\t */\n\tfunction offset(uint256 _debtToOffset, uint256 _collToAdd) external override {\n\t\t_requireCallerIsTroveManager();\n\t\tuint256 totalDCHF = totalDCHFDeposits; // cached to save an SLOAD\n\t\tif (totalDCHF == 0 || _debtToOffset == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t_triggerMONIssuance(communityIssuance);\n\n\t\t(\n\t\t\tuint256 AssetGainPerUnitStaked,\n\t\t\tuint256 DCHFLossPerUnitStaked\n\t\t) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalDCHF);\n\n\t\t_updateRewardSumAndProduct(AssetGainPerUnitStaked, DCHFLossPerUnitStaked); // updates S and P\n\n\t\t_moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\n\t}\n\n\t// --- Offset helper functions ---\n\n\tfunction _computeRewardsPerUnitStaked(\n\t\tuint256 _collToAdd,\n\t\tuint256 _debtToOffset,\n\t\tuint256 _totalDCHFDeposits\n\t) internal returns (uint256 AssetGainPerUnitStaked, uint256 DCHFLossPerUnitStaked) {\n\t\t/*\n\t\t * Compute the DCHF and ETH rewards. Uses a \"feedback\" error correction, to keep\n\t\t * the cumulative error in the P and S state variables low:\n\t\t *\n\t\t * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n\t\t * function was called.\n\t\t * 2) Calculate \"per-unit-staked\" ratios.\n\t\t * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n\t\t * 4) Store these errors for use in the next correction when this function is called.\n\t\t * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n\t\t */\n\t\tuint256 AssetNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(lastAssetError_Offset);\n\n\t\tassert(_debtToOffset <= _totalDCHFDeposits);\n\t\tif (_debtToOffset == _totalDCHFDeposits) {\n\t\t\tDCHFLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n\t\t\tlastDCHFLossError_Offset = 0;\n\t\t} else {\n\t\t\tuint256 DCHFLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\n\t\t\t\tlastDCHFLossError_Offset\n\t\t\t);\n\t\t\t/*\n\t\t\t * Add 1 to make error in quotient positive. We want \"slightly too much\" DCHF loss,\n\t\t\t * which ensures the error in any given compoundedDCHFDeposit favors the Stability Pool.\n\t\t\t */\n\t\t\tDCHFLossPerUnitStaked = (DCHFLossNumerator.div(_totalDCHFDeposits)).add(1);\n\t\t\tlastDCHFLossError_Offset = (DCHFLossPerUnitStaked.mul(_totalDCHFDeposits)).sub(\n\t\t\t\tDCHFLossNumerator\n\t\t\t);\n\t\t}\n\n\t\tAssetGainPerUnitStaked = AssetNumerator.div(_totalDCHFDeposits);\n\t\tlastAssetError_Offset = AssetNumerator.sub(AssetGainPerUnitStaked.mul(_totalDCHFDeposits));\n\n\t\treturn (AssetGainPerUnitStaked, DCHFLossPerUnitStaked);\n\t}\n\n\t// Update the Stability Pool reward sum S and product P\n\tfunction _updateRewardSumAndProduct(\n\t\tuint256 _AssetGainPerUnitStaked,\n\t\tuint256 _DCHFLossPerUnitStaked\n\t) internal {\n\t\tuint256 currentP = P;\n\t\tuint256 newP;\n\n\t\tassert(_DCHFLossPerUnitStaked <= DECIMAL_PRECISION);\n\t\t/*\n\t\t * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool DCHF in the liquidation.\n\t\t * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - DCHFLossPerUnitStaked)\n\t\t */\n\t\tuint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_DCHFLossPerUnitStaked);\n\n\t\tuint128 currentScaleCached = currentScale;\n\t\tuint128 currentEpochCached = currentEpoch;\n\t\tuint256 currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n\n\t\t/*\n\t\t * Calculate the new S first, before we update P.\n\t\t * The ETH gain for any given depositor from a liquidation depends on the value of their deposit\n\t\t * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n\t\t *\n\t\t * Since S corresponds to ETH gain, and P to deposit loss, we update S first.\n\t\t */\n\t\tuint256 marginalAssetGain = _AssetGainPerUnitStaked.mul(currentP);\n\t\tuint256 newS = currentS.add(marginalAssetGain);\n\t\tepochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\n\t\temit S_Updated(newS, currentEpochCached, currentScaleCached);\n\n\t\t// If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n\t\tif (newProductFactor == 0) {\n\t\t\tcurrentEpoch = currentEpochCached.add(1);\n\t\t\temit EpochUpdated(currentEpoch);\n\t\t\tcurrentScale = 0;\n\t\t\temit ScaleUpdated(currentScale);\n\t\t\tnewP = DECIMAL_PRECISION;\n\n\t\t\t// If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n\t\t} else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {\n\t\t\tnewP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\n\t\t\tcurrentScale = currentScaleCached.add(1);\n\t\t\temit ScaleUpdated(currentScale);\n\t\t} else {\n\t\t\tnewP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n\t\t}\n\n\t\tassert(newP > 0);\n\t\tP = newP;\n\n\t\temit P_Updated(newP);\n\t}\n\n\tfunction _moveOffsetCollAndDebt(uint256 _collToAdd, uint256 _debtToOffset) internal {\n\t\tIActivePool activePoolCached = dfrancParams.activePool();\n\n\t\t// Cancel the liquidated DCHF debt with the DCHF in the stability pool\n\t\tactivePoolCached.decreaseDCHFDebt(assetAddress, _debtToOffset);\n\t\t_decreaseDCHF(_debtToOffset);\n\n\t\t// Burn the debt that was successfully offset\n\t\tdchfToken.burn(address(this), _debtToOffset);\n\n\t\tactivePoolCached.sendAsset(assetAddress, address(this), _collToAdd);\n\t}\n\n\tfunction _decreaseDCHF(uint256 _amount) internal {\n\t\tuint256 newTotalDCHFDeposits = totalDCHFDeposits.sub(_amount);\n\t\ttotalDCHFDeposits = newTotalDCHFDeposits;\n\t\temit StabilityPoolDCHFBalanceUpdated(newTotalDCHFDeposits);\n\t}\n\n\t// --- Reward calculator functions for depositor ---\n\n\t/* Calculates the ETH gain earned by the deposit since its last snapshots were taken.\n\t * Given by the formula:  E = d0 * (S - S(0))/P(0)\n\t * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n\t * d0 is the last recorded deposit value.\n\t */\n\tfunction getDepositorAssetGain(address _depositor) public view override returns (uint256) {\n\t\tuint256 initialDeposit = deposits[_depositor];\n\n\t\tif (initialDeposit == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tSnapshots memory snapshots = depositSnapshots[_depositor];\n\n\t\treturn\n\t\t\tSafetyTransfer.decimalsCorrection(\n\t\t\t\tassetAddress,\n\t\t\t\t_getAssetGainFromSnapshots(initialDeposit, snapshots)\n\t\t\t);\n\t}\n\n\tfunction getDepositorAssetGain1e18(address _depositor) public view returns (uint256) {\n\t\tuint256 initialDeposit = deposits[_depositor];\n\n\t\tif (initialDeposit == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tSnapshots memory snapshots = depositSnapshots[_depositor];\n\n\t\treturn _getAssetGainFromSnapshots(initialDeposit, snapshots);\n\t}\n\n\tfunction _getAssetGainFromSnapshots(uint256 initialDeposit, Snapshots memory snapshots)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\t/*\n\t\t * Grab the sum 'S' from the epoch at which the stake was made. The ETH gain may span up to one scale change.\n\t\t * If it does, the second portion of the ETH gain is scaled by 1e9.\n\t\t * If the gain spans no scale change, the second portion will be 0.\n\t\t */\n\t\tuint128 epochSnapshot = snapshots.epoch;\n\t\tuint128 scaleSnapshot = snapshots.scale;\n\t\tuint256 S_Snapshot = snapshots.S;\n\t\tuint256 P_Snapshot = snapshots.P;\n\n\t\tuint256 firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(S_Snapshot);\n\t\tuint256 secondPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot.add(1)].div(\n\t\t\tSCALE_FACTOR\n\t\t);\n\n\t\tuint256 AssetGain = initialDeposit\n\t\t\t.mul(firstPortion.add(secondPortion))\n\t\t\t.div(P_Snapshot)\n\t\t\t.div(DECIMAL_PRECISION);\n\n\t\treturn AssetGain;\n\t}\n\n\t/*\n\t * Calculate the MON gain earned by a deposit since its last snapshots were taken.\n\t * Given by the formula:  MON = d0 * (G - G(0))/P(0)\n\t * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n\t * d0 is the last recorded deposit value.\n\t */\n\tfunction getDepositorMONGain(address _depositor) public view override returns (uint256) {\n\t\tuint256 initialDeposit = deposits[_depositor];\n\t\tif (initialDeposit == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tSnapshots memory snapshots = depositSnapshots[_depositor];\n\t\treturn _getMONGainFromSnapshots(initialDeposit, snapshots);\n\t}\n\n\tfunction _getMONGainFromSnapshots(uint256 initialStake, Snapshots memory snapshots)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\t/*\n\t\t * Grab the sum 'G' from the epoch at which the stake was made. The MON gain may span up to one scale change.\n\t\t * If it does, the second portion of the MON gain is scaled by 1e9.\n\t\t * If the gain spans no scale change, the second portion will be 0.\n\t\t */\n\t\tuint128 epochSnapshot = snapshots.epoch;\n\t\tuint128 scaleSnapshot = snapshots.scale;\n\t\tuint256 G_Snapshot = snapshots.G;\n\t\tuint256 P_Snapshot = snapshots.P;\n\n\t\tuint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n\t\tuint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(\n\t\t\tSCALE_FACTOR\n\t\t);\n\n\t\tuint256 MONGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n\t\t\tDECIMAL_PRECISION\n\t\t);\n\n\t\treturn MONGain;\n\t}\n\n\t// --- Compounded deposit and compounded System stake ---\n\n\t/*\n\t * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n\t * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n\t */\n\tfunction getCompoundedDCHFDeposit(address _depositor)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tuint256 initialDeposit = deposits[_depositor];\n\t\tif (initialDeposit == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn _getCompoundedStakeFromSnapshots(initialDeposit, depositSnapshots[_depositor]);\n\t}\n\n\t/*\n\t * Return the system's compounded stake. Given by the formula:  D = D0 * P/P(0)\n\t * where P(0) is the depositor's snapshot of the product P\n\t *\n\t * The system's compounded stake is equal to the sum of its depositors' compounded deposits.\n\t */\n\tfunction getCompoundedTotalStake() public view override returns (uint256) {\n\t\tuint256 cachedStake = totalStakes;\n\t\tif (cachedStake == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn _getCompoundedStakeFromSnapshots(cachedStake, systemSnapshots);\n\t}\n\n\t// Internal function, used to calculcate compounded deposits and compounded stakes.\n\tfunction _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots memory snapshots)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tuint256 snapshot_P = snapshots.P;\n\t\tuint128 scaleSnapshot = snapshots.scale;\n\t\tuint128 epochSnapshot = snapshots.epoch;\n\n\t\t// If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n\t\tif (epochSnapshot < currentEpoch) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 compoundedStake;\n\t\tuint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n\t\t/* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n\t\t * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n\t\t * at least 1e-9 -- so return 0.\n\t\t */\n\t\tif (scaleDiff == 0) {\n\t\t\tcompoundedStake = initialStake.mul(P).div(snapshot_P);\n\t\t} else if (scaleDiff == 1) {\n\t\t\tcompoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n\t\t} else {\n\t\t\tcompoundedStake = 0;\n\t\t}\n\n\t\t/*\n\t\t * If compounded deposit is less than a billionth of the initial deposit, return 0.\n\t\t *\n\t\t * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n\t\t * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n\t\t * than it's theoretical value.\n\t\t *\n\t\t * Thus it's unclear whether this line is still really needed.\n\t\t */\n\t\tif (compoundedStake < initialStake.div(1e9)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn compoundedStake;\n\t}\n\n\t// --- Sender functions for DCHF deposit, ETH gains and MON gains ---\n\n\t// Transfer the DCHF tokens from the user to the Stability Pool's address, and update its recorded DCHF\n\tfunction _sendDCHFtoStabilityPool(address _address, uint256 _amount) internal {\n\t\tdchfToken.sendToPool(_address, address(this), _amount);\n\t\tuint256 newTotalDCHFDeposits = totalDCHFDeposits.add(_amount);\n\t\ttotalDCHFDeposits = newTotalDCHFDeposits;\n\t\temit StabilityPoolDCHFBalanceUpdated(newTotalDCHFDeposits);\n\t}\n\n\tfunction _sendAssetGainToDepositor(uint256 _amount, uint256 _amountEther) internal {\n\t\tif (_amount == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tassetBalance = assetBalance.sub(_amountEther);\n\n\t\tif (assetAddress == ETH_REF_ADDRESS) {\n\t\t\t(bool success, ) = msg.sender.call{ value: _amountEther }(\"\");\n\t\t\trequire(success, \"StabilityPool: sending ETH failed\");\n\t\t} else {\n\t\t\tIERC20(assetAddress).safeTransfer(msg.sender, _amount);\n\t\t}\n\n\t\temit StabilityPoolAssetBalanceUpdated(assetBalance);\n\t\temit AssetSent(msg.sender, _amount);\n\t}\n\n\t// Send DCHF to user and decrease DCHF in Pool\n\tfunction _sendDCHFToDepositor(address _depositor, uint256 DCHFWithdrawal) internal {\n\t\tif (DCHFWithdrawal == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tdchfToken.returnFromPool(address(this), _depositor, DCHFWithdrawal);\n\t\t_decreaseDCHF(DCHFWithdrawal);\n\t}\n\n\t// --- Stability Pool Deposit Functionality ---\n\n\tfunction _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n\t\tdeposits[_depositor] = _newValue;\n\n\t\tif (_newValue == 0) {\n\t\t\tdelete depositSnapshots[_depositor];\n\t\t\temit DepositSnapshotUpdated(_depositor, 0, 0, 0);\n\t\t\treturn;\n\t\t}\n\t\tuint128 currentScaleCached = currentScale;\n\t\tuint128 currentEpochCached = currentEpoch;\n\t\tuint256 currentP = P;\n\n\t\t// Get S and G for the current epoch and current scale\n\t\tuint256 currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\n\t\tuint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n\t\tSnapshots storage depositSnap = depositSnapshots[_depositor];\n\n\t\t// Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n\t\tdepositSnap.P = currentP;\n\t\tdepositSnap.S = currentS;\n\t\tdepositSnap.G = currentG;\n\t\tdepositSnap.scale = currentScaleCached;\n\t\tdepositSnap.epoch = currentEpochCached;\n\n\t\temit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\n\t}\n\n\tfunction _updateStakeAndSnapshots(uint256 _newValue) internal {\n\t\tSnapshots storage snapshots = systemSnapshots;\n\t\ttotalStakes = _newValue;\n\n\t\tuint128 currentScaleCached = currentScale;\n\t\tuint128 currentEpochCached = currentEpoch;\n\t\tuint256 currentP = P;\n\n\t\t// Get G for the current epoch and current scale\n\t\tuint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n\t\t// Record new snapshots of the latest running product P and sum G for the system\n\t\tsnapshots.P = currentP;\n\t\tsnapshots.G = currentG;\n\t\tsnapshots.scale = currentScaleCached;\n\t\tsnapshots.epoch = currentEpochCached;\n\n\t\temit SystemSnapshotUpdated(currentP, currentG);\n\t}\n\n\tfunction _payOutMONGains(ICommunityIssuance _communityIssuance, address _depositor)\n\t\tinternal\n\t{\n\t\t// Pay out depositor's MON gain\n\t\tuint256 depositorMONGain = getDepositorMONGain(_depositor);\n\t\t_communityIssuance.sendMON(_depositor, depositorMONGain);\n\t\temit MONPaidToDepositor(_depositor, depositorMONGain);\n\t}\n\n\t// --- 'require' functions ---\n\n\tfunction _requireCallerIsActivePool() internal view {\n\t\trequire(\n\t\t\tmsg.sender == address(dfrancParams.activePool()),\n\t\t\t\"StabilityPool: Caller is not ActivePool\"\n\t\t);\n\t}\n\n\tfunction _requireCallerIsTroveManager() internal view {\n\t\trequire(\n\t\t\tmsg.sender == address(troveManager) || msg.sender == address(troveManagerHelpers),\n\t\t\t\"SortedTroves: Caller is not the TroveManager\"\n\t\t);\n\t}\n\n\tfunction _requireNoUnderCollateralizedTroves() public {\n\t\tuint256 price = dfrancParams.priceFeed().fetchPrice(assetAddress);\n\t\taddress lowestTrove = sortedTroves.getLast(assetAddress);\n\t\tuint256 ICR = troveManagerHelpers.getCurrentICR(assetAddress, lowestTrove, price);\n\t\trequire(\n\t\t\tICR >= dfrancParams.MCR(assetAddress),\n\t\t\t\"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\"\n\t\t);\n\t}\n\n\tfunction _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n\t\trequire(_initialDeposit > 0, \"StabilityPool: User must have a non-zero deposit\");\n\t}\n\n\tfunction _requireNonZeroAmount(uint256 _amount) internal pure {\n\t\trequire(_amount > 0, \"StabilityPool: Amount must be non-zero\");\n\t}\n\n\tfunction _requireUserHasTrove(address _depositor) internal view {\n\t\trequire(\n\t\t\ttroveManagerHelpers.getTroveStatus(assetAddress, _depositor) == 1,\n\t\t\t\"StabilityPool: caller must have an active trove to withdraw AssetGain to\"\n\t\t);\n\t}\n\n\tfunction _requireUserHasETHGain(address _depositor) internal view {\n\t\tuint256 AssetGain = getDepositorAssetGain(_depositor);\n\t\trequire(AssetGain > 0, \"StabilityPool: caller must have non-zero ETH Gain\");\n\t}\n\n\t// --- Fallback function ---\n\n\tfunction receivedERC20(address _asset, uint256 _amount) external override {\n\t\t_requireCallerIsActivePool();\n\n\t\trequire(_asset == assetAddress, \"Receiving the wrong asset in StabilityPool\");\n\n\t\tif (assetAddress != ETH_REF_ADDRESS) {\n\t\t\tassetBalance = assetBalance.add(_amount);\n\t\t\temit StabilityPoolAssetBalanceUpdated(assetBalance);\n\t\t}\n\t}\n\n\treceive() external payable {\n\t\t_requireCallerIsActivePool();\n\t\tassetBalance = assetBalance.add(msg.value);\n\t\temit StabilityPoolAssetBalanceUpdated(assetBalance);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/Interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\n// Common interface for the Trove Manager.\ninterface IBorrowerOperations {\n\t// --- Events ---\n\n\tevent TroveManagerAddressChanged(address _newTroveManagerAddress);\n\tevent StabilityPoolAddressChanged(address _stabilityPoolAddress);\n\tevent GasPoolAddressChanged(address _gasPoolAddress);\n\tevent CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n\tevent SortedTrovesAddressChanged(address _sortedTrovesAddress);\n\tevent DCHFTokenAddressChanged(address _dchfTokenAddress);\n\tevent MONStakingAddressChanged(address _MONStakingAddress);\n\n\tevent TroveCreated(address indexed _asset, address indexed _borrower, uint256 arrayIndex);\n\tevent TroveUpdated(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll,\n\t\tuint256 stake,\n\t\tuint8 operation\n\t);\n\tevent DCHFBorrowingFeePaid(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _DCHFFee\n\t);\n\n\t// --- Functions ---\n\n\tfunction setAddresses(\n\t\taddress _troveManagerAddress,\n\t\taddress _troveManagerHelpersAddress,\n\t\taddress _stabilityPoolAddress,\n\t\taddress _gasPoolAddress,\n\t\taddress _collSurplusPoolAddress,\n\t\taddress _sortedTrovesAddress,\n\t\taddress _dchfTokenAddress,\n\t\taddress _MONStakingAddress,\n\t\taddress _dfrancParamsAddress\n\t) external;\n\n\tfunction openTrove(\n\t\taddress _asset,\n\t\tuint256 _tokenAmount,\n\t\tuint256 _maxFee,\n\t\tuint256 _DCHFamount,\n\t\taddress _upperHint,\n\t\taddress _lowerHint\n\t) external payable;\n\n\tfunction addColl(\n\t\taddress _asset,\n\t\tuint256 _assetSent,\n\t\taddress _upperHint,\n\t\taddress _lowerHint\n\t) external payable;\n\n\tfunction moveETHGainToTrove(\n\t\taddress _asset,\n\t\tuint256 _amountMoved,\n\t\taddress _user,\n\t\taddress _upperHint,\n\t\taddress _lowerHint\n\t) external payable;\n\n\tfunction withdrawColl(\n\t\taddress _asset,\n\t\tuint256 _amount,\n\t\taddress _upperHint,\n\t\taddress _lowerHint\n\t) external;\n\n\tfunction withdrawDCHF(\n\t\taddress _asset,\n\t\tuint256 _maxFee,\n\t\tuint256 _amount,\n\t\taddress _upperHint,\n\t\taddress _lowerHint\n\t) external;\n\n\tfunction repayDCHF(\n\t\taddress _asset,\n\t\tuint256 _amount,\n\t\taddress _upperHint,\n\t\taddress _lowerHint\n\t) external;\n\n\tfunction closeTrove(address _asset) external;\n\n\tfunction adjustTrove(\n\t\taddress _asset,\n\t\tuint256 _assetSent,\n\t\tuint256 _maxFee,\n\t\tuint256 _collWithdrawal,\n\t\tuint256 _debtChange,\n\t\tbool isDebtIncrease,\n\t\taddress _upperHint,\n\t\taddress _lowerHint\n\t) external payable;\n\n\tfunction claimCollateral(address _asset) external;\n\n\tfunction getCompositeDebt(address _asset, uint256 _debt) external view returns (uint256);\n\n\tfunction isContractBorrowerOps() external pure returns (bool);\n}\n"
    },
    "contracts/Interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\nimport \"./IDeposit.sol\";\n\ninterface IStabilityPool is IDeposit {\n\t// --- Events ---\n\tevent StabilityPoolAssetBalanceUpdated(uint256 _newBalance);\n\tevent StabilityPoolDCHFBalanceUpdated(uint256 _newBalance);\n\n\tevent BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\tevent TroveManagerAddressChanged(address _newTroveManagerAddress);\n\tevent DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\tevent DCHFTokenAddressChanged(address _newDCHFTokenAddress);\n\tevent SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n\tevent CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n\tevent P_Updated(uint256 _P);\n\tevent S_Updated(uint256 _S, uint128 _epoch, uint128 _scale);\n\tevent G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n\tevent EpochUpdated(uint128 _currentEpoch);\n\tevent ScaleUpdated(uint128 _currentScale);\n\n\tevent DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _S, uint256 _G);\n\tevent SystemSnapshotUpdated(uint256 _P, uint256 _G);\n\tevent UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n\tevent StakeChanged(uint256 _newSystemStake, address _depositor);\n\n\tevent AssetGainWithdrawn(address indexed _depositor, uint256 _Asset, uint256 _DCHFLoss);\n\tevent MONPaidToDepositor(address indexed _depositor, uint256 _MON);\n\tevent AssetSent(address _to, uint256 _amount);\n\n\t// --- Functions ---\n\n\tfunction NAME() external view returns (string memory name);\n\n\t/*\n\t * Called only once on init, to set addresses of other Dfranc contracts\n\t * Callable only by owner, renounces ownership at the end\n\t */\n\tfunction setAddresses(\n\t\taddress _assetAddress,\n\t\taddress _borrowerOperationsAddress,\n\t\taddress _troveManagerAddress,\n\t\taddress _troveManagerHelperAddress,\n\t\taddress _dchfTokenAddress,\n\t\taddress _sortedTrovesAddress,\n\t\taddress _communityIssuanceAddress,\n\t\taddress _dfrancParamsAddress\n\t) external;\n\n\t/*\n\t * Initial checks:\n\t * - Frontend is registered or zero address\n\t * - Sender is not a registered frontend\n\t * - _amount is not zero\n\t * ---\n\t * - Triggers a MON issuance, based on time passed since the last issuance. The MON issuance is shared between *all* depositors and front ends\n\t * - Tags the deposit with the provided front end tag param, if it's a new deposit\n\t * - Sends depositor's accumulated gains (MON, ETH) to depositor\n\t * - Sends the tagged front end's accumulated MON gains to the tagged front end\n\t * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n\t */\n\tfunction provideToSP(uint256 _amount) external;\n\n\t/*\n\t * Initial checks:\n\t * - _amount is zero or there are no under collateralized troves left in the system\n\t * - User has a non zero deposit\n\t * ---\n\t * - Triggers a MON issuance, based on time passed since the last issuance. The MON issuance is shared between *all* depositors and front ends\n\t * - Removes the deposit's front end tag if it is a full withdrawal\n\t * - Sends all depositor's accumulated gains (MON, ETH) to depositor\n\t * - Sends the tagged front end's accumulated MON gains to the tagged front end\n\t * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n\t *\n\t * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n\t */\n\tfunction withdrawFromSP(uint256 _amount) external;\n\n\t/*\n\t * Initial checks:\n\t * - User has a non zero deposit\n\t * - User has an open trove\n\t * - User has some ETH gain\n\t * ---\n\t * - Triggers a MON issuance, based on time passed since the last issuance. The MON issuance is shared between *all* depositors and front ends\n\t * - Sends all depositor's MON gain to  depositor\n\t * - Sends all tagged front end's MON gain to the tagged front end\n\t * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\n\t * - Leaves their compounded deposit in the Stability Pool\n\t * - Updates snapshots for deposit and tagged front end stake\n\t */\n\tfunction withdrawAssetGainToTrove(address _upperHint, address _lowerHint) external;\n\n\t/*\n\t * Initial checks:\n\t * - Caller is TroveManager\n\t * ---\n\t * Cancels out the specified debt against the DCHF contained in the Stability Pool (as far as possible)\n\t * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\n\t * Only called by liquidation functions in the TroveManager.\n\t */\n\tfunction offset(uint256 _debt, uint256 _coll) external;\n\n\t/*\n\t * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\n\t * to exclude edge cases like ETH received from a self-destruct.\n\t */\n\tfunction getAssetBalance() external view returns (uint256);\n\n\t/*\n\t * Returns DCHF held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n\t */\n\tfunction getTotalDCHFDeposits() external view returns (uint256);\n\n\t/*\n\t * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\n\t */\n\tfunction getDepositorAssetGain(address _depositor) external view returns (uint256);\n\n\t/*\n\t * Calculate the MON gain earned by a deposit since its last snapshots were taken.\n\t * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n\t * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n\t * which they made their deposit.\n\t */\n\tfunction getDepositorMONGain(address _depositor) external view returns (uint256);\n\n\t/*\n\t * Return the user's compounded deposit.\n\t */\n\tfunction getCompoundedDCHFDeposit(address _depositor) external view returns (uint256);\n\n\t/*\n\t * Return the front end's compounded stake.\n\t *\n\t * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n\t */\n\tfunction getCompoundedTotalStake() external view returns (uint256);\n\n\tfunction getNameBytes() external view returns (bytes32);\n\n\tfunction getAssetType() external view returns (address);\n\n\t/*\n\t * Fallback function\n\t * Only callable by Active Pool, it just accounts for ETH received\n\t * receive() external payable;\n\t */\n}\n"
    },
    "contracts/Interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\nimport \"./IDfrancBase.sol\";\nimport \"./IStabilityPool.sol\";\nimport \"./IDCHFToken.sol\";\nimport \"./IMONStaking.sol\";\nimport \"./ICollSurplusPool.sol\";\nimport \"./ISortedTroves.sol\";\nimport \"./IActivePool.sol\";\nimport \"./IDefaultPool.sol\";\nimport \"./IStabilityPoolManager.sol\";\nimport \"./ITroveManagerHelpers.sol\";\n\n// Common interface for the Trove Manager.\ninterface ITroveManager is IDfrancBase {\n\tenum Status {\n\t\tnonExistent,\n\t\tactive,\n\t\tclosedByOwner,\n\t\tclosedByLiquidation,\n\t\tclosedByRedemption\n\t}\n\n\t// Store the necessary data for a trove\n\tstruct Trove {\n\t\taddress asset;\n\t\tuint256 debt;\n\t\tuint256 coll;\n\t\tuint256 stake;\n\t\tStatus status;\n\t\tuint128 arrayIndex;\n\t}\n\n\t/*\n\t * --- Variable container structs for liquidations ---\n\t *\n\t * These structs are used to hold, return and assign variables inside the liquidation functions,\n\t * in order to avoid the error: \"CompilerError: Stack too deep\".\n\t **/\n\n\tstruct LocalVariables_OuterLiquidationFunction {\n\t\tuint256 price;\n\t\tuint256 DCHFInStabPool;\n\t\tbool recoveryModeAtStart;\n\t\tuint256 liquidatedDebt;\n\t\tuint256 liquidatedColl;\n\t}\n\n\tstruct LocalVariables_InnerSingleLiquidateFunction {\n\t\tuint256 collToLiquidate;\n\t\tuint256 pendingDebtReward;\n\t\tuint256 pendingCollReward;\n\t}\n\n\tstruct LocalVariables_LiquidationSequence {\n\t\tuint256 remainingDCHFInStabPool;\n\t\tuint256 i;\n\t\tuint256 ICR;\n\t\taddress user;\n\t\tbool backToNormalMode;\n\t\tuint256 entireSystemDebt;\n\t\tuint256 entireSystemColl;\n\t}\n\n\tstruct LocalVariables_AssetBorrowerPrice {\n\t\taddress _asset;\n\t\taddress _borrower;\n\t\tuint256 _price;\n\t}\n\n\tstruct LiquidationValues {\n\t\tuint256 entireTroveDebt;\n\t\tuint256 entireTroveColl;\n\t\tuint256 collGasCompensation;\n\t\tuint256 DCHFGasCompensation;\n\t\tuint256 debtToOffset;\n\t\tuint256 collToSendToSP;\n\t\tuint256 debtToRedistribute;\n\t\tuint256 collToRedistribute;\n\t\tuint256 collSurplus;\n\t}\n\n\tstruct LiquidationTotals {\n\t\tuint256 totalCollInSequence;\n\t\tuint256 totalDebtInSequence;\n\t\tuint256 totalCollGasCompensation;\n\t\tuint256 totalDCHFGasCompensation;\n\t\tuint256 totalDebtToOffset;\n\t\tuint256 totalCollToSendToSP;\n\t\tuint256 totalDebtToRedistribute;\n\t\tuint256 totalCollToRedistribute;\n\t\tuint256 totalCollSurplus;\n\t}\n\n\tstruct ContractsCache {\n\t\tIActivePool activePool;\n\t\tIDefaultPool defaultPool;\n\t\tIDCHFToken dchfToken;\n\t\tIMONStaking monStaking;\n\t\tISortedTroves sortedTroves;\n\t\tICollSurplusPool collSurplusPool;\n\t\taddress gasPoolAddress;\n\t}\n\t// --- Variable container structs for redemptions ---\n\n\tstruct RedemptionTotals {\n\t\tuint256 remainingDCHF;\n\t\tuint256 totalDCHFToRedeem;\n\t\tuint256 totalAssetDrawn;\n\t\tuint256 ETHFee;\n\t\tuint256 ETHToSendToRedeemer;\n\t\tuint256 decayedBaseRate;\n\t\tuint256 price;\n\t\tuint256 totalDCHFSupplyAtStart;\n\t}\n\n\tstruct SingleRedemptionValues {\n\t\tuint256 DCHFLot;\n\t\tuint256 ETHLot;\n\t\tbool cancelledPartial;\n\t}\n\n\t// --- Events ---\n\n\tevent Liquidation(\n\t\taddress indexed _asset,\n\t\tuint256 _liquidatedDebt,\n\t\tuint256 _liquidatedColl,\n\t\tuint256 _collGasCompensation,\n\t\tuint256 _DCHFGasCompensation\n\t);\n\tevent Redemption(\n\t\taddress indexed _asset,\n\t\tuint256 _attemptedDCHFAmount,\n\t\tuint256 _actualDCHFAmount,\n\t\tuint256 _AssetSent,\n\t\tuint256 _AssetFee\n\t);\n\tevent TroveUpdated(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll,\n\t\tuint256 stake,\n\t\tuint8 operation\n\t);\n\tevent TroveLiquidated(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll,\n\t\tuint8 operation\n\t);\n\tevent BaseRateUpdated(address indexed _asset, uint256 _baseRate);\n\tevent LastFeeOpTimeUpdated(address indexed _asset, uint256 _lastFeeOpTime);\n\tevent TotalStakesUpdated(address indexed _asset, uint256 _newTotalStakes);\n\tevent SystemSnapshotsUpdated(\n\t\taddress indexed _asset,\n\t\tuint256 _totalStakesSnapshot,\n\t\tuint256 _totalCollateralSnapshot\n\t);\n\tevent LTermsUpdated(address indexed _asset, uint256 _L_ETH, uint256 _L_DCHFDebt);\n\tevent TroveSnapshotsUpdated(address indexed _asset, uint256 _L_ETH, uint256 _L_DCHFDebt);\n\tevent TroveIndexUpdated(address indexed _asset, address _borrower, uint256 _newIndex);\n\n\tevent TroveUpdated(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll,\n\t\tuint256 _stake,\n\t\tTroveManagerOperation _operation\n\t);\n\tevent TroveLiquidated(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll,\n\t\tTroveManagerOperation _operation\n\t);\n\n\tenum TroveManagerOperation {\n\t\tapplyPendingRewards,\n\t\tliquidateInNormalMode,\n\t\tliquidateInRecoveryMode,\n\t\tredeemCollateral\n\t}\n\n\t// --- Functions ---\n\tfunction isContractTroveManager() external pure returns (bool);\n\n\tfunction troveManagerHelpers() external view returns (ITroveManagerHelpers);\n\n\tfunction setAddresses(\n\t\taddress _stabilityPoolManagerAddress,\n\t\taddress _gasPoolAddress,\n\t\taddress _collSurplusPoolAddress,\n\t\taddress _dchfTokenAddress,\n\t\taddress _sortedTrovesAddress,\n\t\taddress _monStakingAddress,\n\t\taddress _dfrancParamsAddress,\n\t\taddress _troveManagerHelpersAddress\n\t) external;\n\n\tfunction stabilityPoolManager() external view returns (IStabilityPoolManager);\n\n\tfunction dchfToken() external view returns (IDCHFToken);\n\n\tfunction monStaking() external view returns (IMONStaking);\n\n\tfunction liquidate(address _asset, address borrower) external;\n\n\tfunction liquidateTroves(address _asset, uint256 _n) external;\n\n\tfunction batchLiquidateTroves(address _asset, address[] memory _troveArray) external;\n\n\tfunction redeemCollateral(\n\t\taddress _asset,\n\t\tuint256 _DCHFamount,\n\t\taddress _firstRedemptionHint,\n\t\taddress _upperPartialRedemptionHint,\n\t\taddress _lowerPartialRedemptionHint,\n\t\tuint256 _partialRedemptionHintNICR,\n\t\tuint256 _maxIterations,\n\t\tuint256 _maxFee\n\t) external;\n}\n"
    },
    "contracts/Interfaces/ITroveManagerHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\nimport \"./IDfrancBase.sol\";\nimport \"./IStabilityPool.sol\";\nimport \"./IDCHFToken.sol\";\nimport \"./IMONStaking.sol\";\nimport \"./ICollSurplusPool.sol\";\nimport \"./ISortedTroves.sol\";\nimport \"./IActivePool.sol\";\nimport \"./IDefaultPool.sol\";\nimport \"./IStabilityPoolManager.sol\";\n\n// Common interface for the Trove Manager.\ninterface ITroveManagerHelpers is IDfrancBase {\n\tenum Status {\n\t\tnonExistent,\n\t\tactive,\n\t\tclosedByOwner,\n\t\tclosedByLiquidation,\n\t\tclosedByRedemption\n\t}\n\n\t// Store the necessary data for a trove\n\tstruct Trove {\n\t\taddress asset;\n\t\tuint256 debt;\n\t\tuint256 coll;\n\t\tuint256 stake;\n\t\tStatus status;\n\t\tuint128 arrayIndex;\n\t}\n\n\t/*\n\t * --- Variable container structs for liquidations ---\n\t *\n\t * These structs are used to hold, return and assign variables inside the liquidation functions,\n\t * in order to avoid the error: \"CompilerError: Stack too deep\".\n\t **/\n\n\tstruct LocalVariables_OuterLiquidationFunction {\n\t\tuint256 price;\n\t\tuint256 DCHFInStabPool;\n\t\tbool recoveryModeAtStart;\n\t\tuint256 liquidatedDebt;\n\t\tuint256 liquidatedColl;\n\t}\n\n\tstruct LocalVariables_InnerSingleLiquidateFunction {\n\t\tuint256 collToLiquidate;\n\t\tuint256 pendingDebtReward;\n\t\tuint256 pendingCollReward;\n\t}\n\n\tstruct LocalVariables_LiquidationSequence {\n\t\tuint256 remainingDCHFInStabPool;\n\t\tuint256 i;\n\t\tuint256 ICR;\n\t\taddress user;\n\t\tbool backToNormalMode;\n\t\tuint256 entireSystemDebt;\n\t\tuint256 entireSystemColl;\n\t}\n\n\tstruct LocalVariables_AssetBorrowerPrice {\n\t\taddress _asset;\n\t\taddress _borrower;\n\t\tuint256 _price;\n\t}\n\n\tstruct LiquidationValues {\n\t\tuint256 entireTroveDebt;\n\t\tuint256 entireTroveColl;\n\t\tuint256 collGasCompensation;\n\t\tuint256 DCHFGasCompensation;\n\t\tuint256 debtToOffset;\n\t\tuint256 collToSendToSP;\n\t\tuint256 debtToRedistribute;\n\t\tuint256 collToRedistribute;\n\t\tuint256 collSurplus;\n\t}\n\n\tstruct LiquidationTotals {\n\t\tuint256 totalCollInSequence;\n\t\tuint256 totalDebtInSequence;\n\t\tuint256 totalCollGasCompensation;\n\t\tuint256 totalDCHFGasCompensation;\n\t\tuint256 totalDebtToOffset;\n\t\tuint256 totalCollToSendToSP;\n\t\tuint256 totalDebtToRedistribute;\n\t\tuint256 totalCollToRedistribute;\n\t\tuint256 totalCollSurplus;\n\t}\n\n\tstruct ContractsCache {\n\t\tIActivePool activePool;\n\t\tIDefaultPool defaultPool;\n\t\tIDCHFToken dchfToken;\n\t\tIMONStaking monStaking;\n\t\tISortedTroves sortedTroves;\n\t\tICollSurplusPool collSurplusPool;\n\t\taddress gasPoolAddress;\n\t}\n\t// --- Variable container structs for redemptions ---\n\n\tstruct RedemptionTotals {\n\t\tuint256 remainingDCHF;\n\t\tuint256 totalDCHFToRedeem;\n\t\tuint256 totalAssetDrawn;\n\t\tuint256 ETHFee;\n\t\tuint256 ETHToSendToRedeemer;\n\t\tuint256 decayedBaseRate;\n\t\tuint256 price;\n\t\tuint256 totalDCHFSupplyAtStart;\n\t}\n\n\tstruct SingleRedemptionValues {\n\t\tuint256 DCHFLot;\n\t\tuint256 ETHLot;\n\t\tbool cancelledPartial;\n\t}\n\n\t// Object containing the ETH and DCHF snapshots for a given active trove\n\tstruct RewardSnapshot {\n\t\tuint256 asset;\n\t\tuint256 DCHFDebt;\n\t}\n\n\t// --- Events ---\n\n\tevent Liquidation(\n\t\taddress indexed _asset,\n\t\tuint256 _liquidatedDebt,\n\t\tuint256 _liquidatedColl,\n\t\tuint256 _collGasCompensation,\n\t\tuint256 _DCHFGasCompensation\n\t);\n\tevent Redemption(\n\t\taddress indexed _asset,\n\t\tuint256 _attemptedDCHFAmount,\n\t\tuint256 _actualDCHFAmount,\n\t\tuint256 _AssetSent,\n\t\tuint256 _AssetFee\n\t);\n\tevent TroveUpdated(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll,\n\t\tuint256 stake,\n\t\tuint8 operation\n\t);\n\tevent TroveLiquidated(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll,\n\t\tuint8 operation\n\t);\n\tevent BaseRateUpdated(address indexed _asset, uint256 _baseRate);\n\tevent LastFeeOpTimeUpdated(address indexed _asset, uint256 _lastFeeOpTime);\n\tevent TotalStakesUpdated(address indexed _asset, uint256 _newTotalStakes);\n\tevent SystemSnapshotsUpdated(\n\t\taddress indexed _asset,\n\t\tuint256 _totalStakesSnapshot,\n\t\tuint256 _totalCollateralSnapshot\n\t);\n\tevent LTermsUpdated(address indexed _asset, uint256 _L_ETH, uint256 _L_DCHFDebt);\n\tevent TroveSnapshotsUpdated(address indexed _asset, uint256 _L_ETH, uint256 _L_DCHFDebt);\n\tevent TroveIndexUpdated(address indexed _asset, address _borrower, uint256 _newIndex);\n\n\tevent TroveUpdated(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll,\n\t\tuint256 _stake,\n\t\tTroveManagerOperation _operation\n\t);\n\tevent TroveLiquidated(\n\t\taddress indexed _asset,\n\t\taddress indexed _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll,\n\t\tTroveManagerOperation _operation\n\t);\n\n\tenum TroveManagerOperation {\n\t\tapplyPendingRewards,\n\t\tliquidateInNormalMode,\n\t\tliquidateInRecoveryMode,\n\t\tredeemCollateral\n\t}\n\n\t// Functions\n\n\tfunction addTroveOwnerToArray(address _asset, address _borrower)\n\t\texternal\n\t\treturns (uint256 index);\n\n\tfunction applyPendingRewards(address _asset, address _borrower) external;\n\n\tfunction checkRecoveryMode(address _asset, uint256 _price) external returns (bool);\n\n\tfunction closeTrove(address _asset, address _borrower) external;\n\n\tfunction decayBaseRateFromBorrowing(address _asset) external;\n\n\tfunction decreaseTroveColl(\n\t\taddress _asset,\n\t\taddress _borrower,\n\t\tuint256 _collDecrease\n\t) external returns (uint256);\n\n\tfunction decreaseTroveDebt(\n\t\taddress _asset,\n\t\taddress _borrower,\n\t\tuint256 _collDecrease\n\t) external returns (uint256);\n\n\tfunction getBorrowingFee(address _asset, uint256 DCHFDebt) external view returns (uint256);\n\n\tfunction getBorrowingRateWithDecay(address _asset) external view returns (uint256);\n\n\tfunction getBorrowingRate(address _asset) external view returns (uint256);\n\n\tfunction getCurrentICR(\n\t\taddress _asset,\n\t\taddress _borrower,\n\t\tuint256 _price\n\t) external view returns (uint256);\n\n\tfunction getEntireDebtAndColl(address _asset, address _borrower)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 debt,\n\t\t\tuint256 coll,\n\t\t\tuint256 pendingDCHFDebtReward,\n\t\t\tuint256 pendingAssetReward\n\t\t);\n\n\tfunction getNominalICR(address _asset, address _borrower) external view returns (uint256);\n\n\tfunction getPendingAssetReward(address _asset, address _borrower)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction getPendingDCHFDebtReward(address _asset, address _borrower)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction getRedemptionFeeWithDecay(address _asset, uint256 _assetDraw)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction getRedemptionRate(address _asset) external view returns (uint256);\n\n\tfunction getRedemptionRateWithDecay(address _asset) external view returns (uint256);\n\n\tfunction getTCR(address _asset, uint256 _price) external view returns (uint256);\n\n\tfunction getTroveColl(address _asset, address _borrower) external view returns (uint256);\n\n\tfunction getTroveDebt(address _asset, address _borrower) external view returns (uint256);\n\n\tfunction getTroveStake(address _asset, address _borrower) external view returns (uint256);\n\n\tfunction getTroveStatus(address _asset, address _borrower) external view returns (uint256);\n\n\tfunction hasPendingRewards(address _asset, address _borrower) external view returns (bool);\n\n\tfunction increaseTroveColl(\n\t\taddress _asset,\n\t\taddress _borrower,\n\t\tuint256 _collIncrease\n\t) external returns (uint256);\n\n\tfunction increaseTroveDebt(\n\t\taddress _asset,\n\t\taddress _borrower,\n\t\tuint256 _debtIncrease\n\t) external returns (uint256);\n\n\tfunction setTroveStatus(\n\t\taddress _asset,\n\t\taddress _borrower,\n\t\tuint256 num\n\t) external;\n\n\tfunction updateTroveRewardSnapshots(address _asset, address _borrower) external;\n\n\tfunction getBorrowingFeeWithDecay(address _asset, uint256 _DCHFDebt)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction getTroveOwnersCount(address _asset) external view returns (uint256);\n\n\tfunction getTroveFromTroveOwnersArray(address _asset, uint256 _index)\n\t\texternal\n\t\tview\n\t\treturns (address);\n\n\tfunction setTroveDeptAndColl(\n\t\taddress _asset,\n\t\taddress _borrower,\n\t\tuint256 _debt,\n\t\tuint256 _coll\n\t) external;\n\n\tfunction isTroveActive(address _asset, address _borrower) external view returns (bool);\n\n\tfunction movePendingTroveRewardsToActivePool(\n\t\taddress _asset,\n\t\tIActivePool _activePool,\n\t\tIDefaultPool _defaultPool,\n\t\tuint256 _DCHF,\n\t\tuint256 _amount\n\t) external;\n\n\tfunction removeStake(address _asset, address _borrower) external;\n\n\tfunction closeTrove(\n\t\t// access control\n\t\taddress _asset,\n\t\taddress _borrower,\n\t\tStatus closedStatus\n\t) external;\n\n\tfunction redistributeDebtAndColl(\n\t\taddress _asset,\n\t\tIActivePool _activePool,\n\t\tIDefaultPool _defaultPool,\n\t\tuint256 _debt,\n\t\tuint256 _coll\n\t) external;\n\n\tfunction updateSystemSnapshots_excludeCollRemainder(\n\t\t// access control\n\t\taddress _asset,\n\t\tIActivePool _activePool,\n\t\tuint256 _collRemainder\n\t) external;\n\n\tfunction _checkPotentialRecoveryMode(\n\t\t// access control\n\t\taddress _asset,\n\t\tuint256 _entireSystemColl,\n\t\tuint256 _entireSystemDebt,\n\t\tuint256 _price\n\t) external view returns (bool);\n\n\tfunction updateBaseRateFromRedemption(\n\t\taddress _asset,\n\t\tuint256 _ETHDrawn,\n\t\tuint256 _price,\n\t\tuint256 _totalDCHFSupply\n\t) external returns (uint256);\n\n\tfunction updateStakeAndTotalStakes(address _asset, address _borrower)\n\t\texternal\n\t\treturns (uint256);\n\n\tfunction _requireValidMaxFeePercentage(address _asset, uint256 _maxFeePercentage)\n\t\texternal\n\t\tview;\n\n\tfunction _requireTCRoverMCR(address _asset, uint256 _price) external view;\n\n\tfunction _requireAmountGreaterThanZero(uint256 _amount) external pure;\n\n\tfunction _requireDCHFBalanceCoversRedemption(\n\t\tIDCHFToken _dchfToken,\n\t\taddress _redeemer,\n\t\tuint256 _amount\n\t) external view;\n\n\tfunction applyPendingRewards(\n\t\taddress _asset,\n\t\tIActivePool _activePool,\n\t\tIDefaultPool _defaultPool,\n\t\taddress _borrower\n\t) external;\n\n\tfunction _getRedemptionFee(address _asset, uint256 _assetDraw)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction getTrove(address _asset, address _borrower)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\taddress,\n\t\t\tuint256,\n\t\t\tuint256,\n\t\t\tuint256,\n\t\t\tStatus,\n\t\t\tuint128\n\t\t);\n\n\tfunction getRewardSnapshots(address _asset, address _troveOwner)\n\t\texternal\n\t\tview\n\t\treturns (uint256 asset, uint256 DCHFDebt);\n}\n"
    },
    "contracts/Interfaces/IDCHFToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\nimport \"../Dependencies/ERC20Permit.sol\";\nimport \"../Interfaces/IStabilityPoolManager.sol\";\n\nabstract contract IDCHFToken is ERC20Permit {\n\t// --- Events ---\n\n\tevent StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\n\tevent DCHFTokenBalanceUpdated(address _user, uint256 _amount);\n\n\tfunction emergencyStopMinting(address _asset, bool status) external virtual;\n\n\tfunction addTroveManager(address _troveManager) external virtual;\n\n\tfunction removeTroveManager(address _troveManager) external virtual;\n\n\tfunction addBorrowerOps(address _borrowerOps) external virtual;\n\n\tfunction removeBorrowerOps(address _borrowerOps) external virtual;\n\n\tfunction mint(\n\t\taddress _asset,\n\t\taddress _account,\n\t\tuint256 _amount\n\t) external virtual;\n\n\tfunction burn(address _account, uint256 _amount) external virtual;\n\n\tfunction sendToPool(\n\t\taddress _sender,\n\t\taddress poolAddress,\n\t\tuint256 _amount\n\t) external virtual;\n\n\tfunction returnFromPool(\n\t\taddress poolAddress,\n\t\taddress user,\n\t\tuint256 _amount\n\t) external virtual;\n}\n"
    },
    "contracts/Interfaces/ISortedTroves.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\n// Common interface for the SortedTroves Doubly Linked List.\ninterface ISortedTroves {\n\t// --- Events ---\n\n\tevent SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\n\tevent BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n\tevent NodeAdded(address indexed _asset, address _id, uint256 _NICR);\n\tevent NodeRemoved(address indexed _asset, address _id);\n\n\t// --- Functions ---\n\n\tfunction setParams(\n\t\taddress _TroveManagerAddress,\n\t\taddress _troveManagerHelpersAddress,\n\t\taddress _borrowerOperationsAddress\n\t) external;\n\n\tfunction insert(\n\t\taddress _asset,\n\t\taddress _id,\n\t\tuint256 _ICR,\n\t\taddress _prevId,\n\t\taddress _nextId\n\t) external;\n\n\tfunction remove(address _asset, address _id) external;\n\n\tfunction reInsert(\n\t\taddress _asset,\n\t\taddress _id,\n\t\tuint256 _newICR,\n\t\taddress _prevId,\n\t\taddress _nextId\n\t) external;\n\n\tfunction contains(address _asset, address _id) external view returns (bool);\n\n\tfunction isFull(address _asset) external view returns (bool);\n\n\tfunction isEmpty(address _asset) external view returns (bool);\n\n\tfunction getSize(address _asset) external view returns (uint256);\n\n\tfunction getMaxSize(address _asset) external view returns (uint256);\n\n\tfunction getFirst(address _asset) external view returns (address);\n\n\tfunction getLast(address _asset) external view returns (address);\n\n\tfunction getNext(address _asset, address _id) external view returns (address);\n\n\tfunction getPrev(address _asset, address _id) external view returns (address);\n\n\tfunction validInsertPosition(\n\t\taddress _asset,\n\t\tuint256 _ICR,\n\t\taddress _prevId,\n\t\taddress _nextId\n\t) external view returns (bool);\n\n\tfunction findInsertPosition(\n\t\taddress _asset,\n\t\tuint256 _ICR,\n\t\taddress _prevId,\n\t\taddress _nextId\n\t) external view returns (address, address);\n}\n"
    },
    "contracts/Interfaces/ICommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\ninterface ICommunityIssuance {\n\t// --- Events ---\n\n\tevent MONTokenAddressSet(address _MONTokenAddress);\n\tevent StabilityPoolAddressSet(address _stabilityPoolAddress);\n\tevent TotalMONIssuedUpdated(address indexed stabilityPool, uint256 _totalMONIssued);\n\n\t// --- Functions ---\n\n\tfunction setAddresses(\n\t\taddress _MONTokenAddress,\n\t\taddress _stabilityPoolAddress,\n\t\taddress _adminContract\n\t) external;\n\n\tfunction issueMON() external returns (uint256);\n\n\tfunction sendMON(address _account, uint256 _MONamount) external;\n\n\tfunction addFundToStabilityPool(address _pool, uint256 _assignedSupply) external;\n\n\tfunction addFundToStabilityPoolFrom(\n\t\taddress _pool,\n\t\tuint256 _assignedSupply,\n\t\taddress _spender\n\t) external;\n\n\tfunction transferFundToAnotherStabilityPool(\n\t\taddress _target,\n\t\taddress _receiver,\n\t\tuint256 _quantity\n\t) external;\n\n\tfunction setWeeklyDfrancDistribution(address _stabilityPool, uint256 _weeklyReward) external;\n}\n"
    },
    "contracts/Dependencies/DfrancBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BaseMath.sol\";\nimport \"./DfrancMath.sol\";\nimport \"../Interfaces/IActivePool.sol\";\nimport \"../Interfaces/IDefaultPool.sol\";\nimport \"../Interfaces/IPriceFeed.sol\";\nimport \"../Interfaces/IDfrancBase.sol\";\n\n/*\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n * common functions.\n */\ncontract DfrancBase is BaseMath, IDfrancBase, Ownable {\n\tusing SafeMath for uint256;\n\taddress public constant ETH_REF_ADDRESS = address(0);\n\n\tIDfrancParameters public override dfrancParams;\n\n\tfunction setDfrancParameters(address _vaultParams) public onlyOwner {\n\t\tdfrancParams = IDfrancParameters(_vaultParams);\n\t\temit VaultParametersBaseChanged(_vaultParams);\n\t}\n\n\t// --- Gas compensation functions ---\n\n\t// Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n\tfunction _getCompositeDebt(address _asset, uint256 _debt) internal view returns (uint256) {\n\t\treturn _debt.add(dfrancParams.DCHF_GAS_COMPENSATION(_asset));\n\t}\n\n\tfunction _getNetDebt(address _asset, uint256 _debt) internal view returns (uint256) {\n\t\treturn _debt.sub(dfrancParams.DCHF_GAS_COMPENSATION(_asset));\n\t}\n\n\t// Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\n\tfunction _getCollGasCompensation(address _asset, uint256 _entireColl)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\treturn _entireColl / dfrancParams.PERCENT_DIVISOR(_asset);\n\t}\n\n\tfunction getEntireSystemColl(address _asset) public view returns (uint256 entireSystemColl) {\n\t\tuint256 activeColl = dfrancParams.activePool().getAssetBalance(_asset);\n\t\tuint256 liquidatedColl = dfrancParams.defaultPool().getAssetBalance(_asset);\n\n\t\treturn activeColl.add(liquidatedColl);\n\t}\n\n\tfunction getEntireSystemDebt(address _asset) public view returns (uint256 entireSystemDebt) {\n\t\tuint256 activeDebt = dfrancParams.activePool().getDCHFDebt(_asset);\n\t\tuint256 closedDebt = dfrancParams.defaultPool().getDCHFDebt(_asset);\n\n\t\treturn activeDebt.add(closedDebt);\n\t}\n\n\tfunction _getTCR(address _asset, uint256 _price) internal view returns (uint256 TCR) {\n\t\tuint256 entireSystemColl = getEntireSystemColl(_asset);\n\t\tuint256 entireSystemDebt = getEntireSystemDebt(_asset);\n\n\t\tTCR = DfrancMath._computeCR(entireSystemColl, entireSystemDebt, _price);\n\n\t\treturn TCR;\n\t}\n\n\tfunction _checkRecoveryMode(address _asset, uint256 _price) internal view returns (bool) {\n\t\tuint256 TCR = _getTCR(_asset, _price);\n\n\t\treturn TCR < dfrancParams.CCR(_asset);\n\t}\n\n\tfunction _requireUserAcceptsFee(\n\t\tuint256 _fee,\n\t\tuint256 _amount,\n\t\tuint256 _maxFeePercentage\n\t) internal view {\n\t\tuint256 feePercentage = _fee.mul(dfrancParams.DECIMAL_PRECISION()).div(_amount);\n\t\trequire(feePercentage <= _maxFeePercentage, \"FM\");\n\t}\n}\n"
    },
    "contracts/Dependencies/DfrancSafeMath128.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\n// uint128 addition and subtraction, with overflow protection.\n\nlibrary DfrancSafeMath128 {\n\tfunction add(uint128 a, uint128 b) internal pure returns (uint128) {\n\t\tuint128 c = a + b;\n\t\trequire(c >= a, \"DfrancSafeMath128: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\tfunction sub(uint128 a, uint128 b) internal pure returns (uint128) {\n\t\trequire(b <= a, \"DfrancSafeMath128: subtraction overflow\");\n\t\tuint128 c = a - b;\n\n\t\treturn c;\n\t}\n}\n"
    },
    "contracts/Dependencies/CheckContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\ncontract CheckContract {\n\tfunction checkContract(address _account) internal view {\n\t\trequire(_account != address(0), \"Account cannot be zero address\");\n\n\t\tuint256 size;\n\t\tassembly {\n\t\t\tsize := extcodesize(_account)\n\t\t}\n\t\trequire(size > 0, \"Account code size cannot be zero\");\n\t}\n}\n"
    },
    "contracts/Dependencies/SafetyTransfer.sol": {
      "content": "import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./ERC20Decimals.sol\";\n\nlibrary SafetyTransfer {\n\tusing SafeMath for uint256;\n\n\t//_amount is in ether (1e18) and we want to convert it to the token decimal\n\tfunction decimalsCorrection(address _token, uint256 _amount)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tif (_token == address(0)) return _amount;\n\t\tif (_amount == 0) return 0;\n\n\t\tuint8 decimals = ERC20Decimals(_token).decimals();\n\t\tif (decimals < 18) {\n\t\t\treturn _amount.div(10**(18 - decimals));\n\t\t} else {\n\t\t\treturn _amount.mul(10**(decimals - 18));\n\t\t}\n\t}\n}\n"
    },
    "contracts/Dependencies/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Interfaces/IDeposit.sol": {
      "content": "pragma solidity ^0.8.14;\n\ninterface IDeposit {\n\tfunction receivedERC20(address _asset, uint256 _amount) external;\n}\n"
    },
    "contracts/Interfaces/IDfrancBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\nimport \"./IDfrancParameters.sol\";\n\ninterface IDfrancBase {\n\tevent VaultParametersBaseChanged(address indexed newAddress);\n\n\tfunction dfrancParams() external view returns (IDfrancParameters);\n}\n"
    },
    "contracts/Interfaces/IMONStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IMONStaking {\n\t// --- Events --\n\n\tevent TreasuryAddressChanged(address _treausury);\n\tevent SentToTreasury(address indexed _asset, uint256 _amount);\n\tevent MONTokenAddressSet(address _MONTokenAddress);\n\tevent DCHFTokenAddressSet(address _dchfTokenAddress);\n\tevent TroveManagerAddressSet(address _troveManager);\n\tevent BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\n\tevent ActivePoolAddressSet(address _activePoolAddress);\n\n\tevent StakeChanged(address indexed staker, uint256 newStake);\n\tevent StakingGainsAssetWithdrawn(\n\t\taddress indexed staker,\n\t\taddress indexed asset,\n\t\tuint256 AssetGain\n\t);\n\tevent StakingGainsDCHFWithdrawn(address indexed staker, uint256 DCHFGain);\n\tevent F_AssetUpdated(address indexed _asset, uint256 _F_ASSET);\n\tevent F_DCHFUpdated(uint256 _F_DCHF);\n\tevent TotalMONStakedUpdated(uint256 _totalMONStaked);\n\tevent AssetSent(address indexed _asset, address indexed _account, uint256 _amount);\n\tevent StakerSnapshotsUpdated(address _staker, uint256 _F_Asset, uint256 _F_DCHF);\n\n\tfunction monToken() external view returns (IERC20);\n\n\t// --- Functions ---\n\n\tfunction setAddresses(\n\t\taddress _MONTokenAddress,\n\t\taddress _dchfTokenAddress,\n\t\taddress _troveManagerAddress,\n\t\taddress _troveManagerHelpersAddress,\n\t\taddress _borrowerOperationsAddress,\n\t\taddress _activePoolAddress,\n\t\taddress _treasury\n\t) external;\n\n\tfunction stake(uint256 _MONamount) external;\n\n\tfunction unstake(uint256 _MONamount) external;\n\n\tfunction increaseF_Asset(address _asset, uint256 _AssetFee) external;\n\n\tfunction increaseF_DCHF(uint256 _MONFee) external;\n\n\tfunction getPendingAssetGain(address _asset, address _user) external view returns (uint256);\n\n\tfunction getPendingDCHFGain(address _user) external view returns (uint256);\n}\n"
    },
    "contracts/Interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\nimport \"./IDeposit.sol\";\n\ninterface ICollSurplusPool is IDeposit {\n\t// --- Events ---\n\n\tevent BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\tevent TroveManagerAddressChanged(address _newTroveManagerAddress);\n\tevent ActivePoolAddressChanged(address _newActivePoolAddress);\n\n\tevent CollBalanceUpdated(address indexed _account, uint256 _newBalance);\n\tevent AssetSent(address _to, uint256 _amount);\n\n\t// --- Contract setters ---\n\n\tfunction setAddresses(\n\t\taddress _borrowerOperationsAddress,\n\t\taddress _troveManagerAddress,\n\t\taddress _troveManagerHelpersAddress,\n\t\taddress _activePoolAddress\n\t) external;\n\n\tfunction getAssetBalance(address _asset) external view returns (uint256);\n\n\tfunction getCollateral(address _asset, address _account) external view returns (uint256);\n\n\tfunction accountSurplus(\n\t\taddress _asset,\n\t\taddress _account,\n\t\tuint256 _amount\n\t) external;\n\n\tfunction claimColl(address _asset, address _account) external;\n}\n"
    },
    "contracts/Interfaces/IActivePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\nimport \"./IPool.sol\";\n\ninterface IActivePool is IPool {\n\t// --- Events ---\n\tevent BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\tevent TroveManagerAddressChanged(address _newTroveManagerAddress);\n\tevent ActivePoolDCHFDebtUpdated(address _asset, uint256 _DCHFDebt);\n\tevent ActivePoolAssetBalanceUpdated(address _asset, uint256 _balance);\n\n\t// --- Functions ---\n\tfunction sendAsset(\n\t\taddress _asset,\n\t\taddress _account,\n\t\tuint256 _amount\n\t) external;\n}\n"
    },
    "contracts/Interfaces/IDefaultPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\nimport \"./IPool.sol\";\n\ninterface IDefaultPool is IPool {\n\t// --- Events ---\n\tevent TroveManagerAddressChanged(address _newTroveManagerAddress);\n\tevent DefaultPoolDCHFDebtUpdated(address _asset, uint256 _DCHFDebt);\n\tevent DefaultPoolAssetBalanceUpdated(address _asset, uint256 _balance);\n\n\t// --- Functions ---\n\tfunction sendAssetToActivePool(address _asset, uint256 _amount) external;\n}\n"
    },
    "contracts/Interfaces/IStabilityPoolManager.sol": {
      "content": "pragma solidity ^0.8.14;\n\nimport \"./IStabilityPool.sol\";\n\ninterface IStabilityPoolManager {\n\tevent StabilityPoolAdded(address asset, address stabilityPool);\n\tevent StabilityPoolRemoved(address asset, address stabilityPool);\n\n\tfunction isStabilityPool(address stabilityPool) external view returns (bool);\n\n\tfunction addStabilityPool(address asset, address stabilityPool) external;\n\n\tfunction getAssetStabilityPool(address asset) external view returns (IStabilityPool);\n\n\tfunction unsafeGetAssetStabilityPool(address asset) external view returns (address);\n}\n"
    },
    "contracts/Interfaces/IDfrancParameters.sol": {
      "content": "pragma solidity ^0.8.14;\n\nimport \"./IActivePool.sol\";\nimport \"./IDefaultPool.sol\";\nimport \"./IPriceFeed.sol\";\nimport \"./IDfrancBase.sol\";\n\ninterface IDfrancParameters {\n\terror SafeCheckError(\n\t\tstring parameter,\n\t\tuint256 valueEntered,\n\t\tuint256 minValue,\n\t\tuint256 maxValue\n\t);\n\n\tevent MCRChanged(uint256 oldMCR, uint256 newMCR);\n\tevent CCRChanged(uint256 oldCCR, uint256 newCCR);\n\tevent GasCompensationChanged(uint256 oldGasComp, uint256 newGasComp);\n\tevent MinNetDebtChanged(uint256 oldMinNet, uint256 newMinNet);\n\tevent PercentDivisorChanged(uint256 oldPercentDiv, uint256 newPercentDiv);\n\tevent BorrowingFeeFloorChanged(uint256 oldBorrowingFloorFee, uint256 newBorrowingFloorFee);\n\tevent MaxBorrowingFeeChanged(uint256 oldMaxBorrowingFee, uint256 newMaxBorrowingFee);\n\tevent RedemptionFeeFloorChanged(\n\t\tuint256 oldRedemptionFeeFloor,\n\t\tuint256 newRedemptionFeeFloor\n\t);\n\tevent RedemptionBlockRemoved(address _asset);\n\tevent PriceFeedChanged(address indexed addr);\n\n\tfunction DECIMAL_PRECISION() external view returns (uint256);\n\n\tfunction _100pct() external view returns (uint256);\n\n\t// Minimum collateral ratio for individual troves\n\tfunction MCR(address _collateral) external view returns (uint256);\n\n\t// Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n\tfunction CCR(address _collateral) external view returns (uint256);\n\n\tfunction DCHF_GAS_COMPENSATION(address _collateral) external view returns (uint256);\n\n\tfunction MIN_NET_DEBT(address _collateral) external view returns (uint256);\n\n\tfunction PERCENT_DIVISOR(address _collateral) external view returns (uint256);\n\n\tfunction BORROWING_FEE_FLOOR(address _collateral) external view returns (uint256);\n\n\tfunction REDEMPTION_FEE_FLOOR(address _collateral) external view returns (uint256);\n\n\tfunction MAX_BORROWING_FEE(address _collateral) external view returns (uint256);\n\n\tfunction redemptionBlock(address _collateral) external view returns (uint256);\n\n\tfunction activePool() external view returns (IActivePool);\n\n\tfunction defaultPool() external view returns (IDefaultPool);\n\n\tfunction priceFeed() external view returns (IPriceFeed);\n\n\tfunction setAddresses(\n\t\taddress _activePool,\n\t\taddress _defaultPool,\n\t\taddress _priceFeed,\n\t\taddress _adminContract\n\t) external;\n\n\tfunction setPriceFeed(address _priceFeed) external;\n\n\tfunction setMCR(address _asset, uint256 newMCR) external;\n\n\tfunction setCCR(address _asset, uint256 newCCR) external;\n\n\tfunction sanitizeParameters(address _asset) external;\n\n\tfunction setAsDefault(address _asset) external;\n\n\tfunction setAsDefaultWithRemptionBlock(address _asset, uint256 blockInDays) external;\n\n\tfunction setDCHFGasCompensation(address _asset, uint256 gasCompensation) external;\n\n\tfunction setMinNetDebt(address _asset, uint256 minNetDebt) external;\n\n\tfunction setPercentDivisor(address _asset, uint256 precentDivisor) external;\n\n\tfunction setBorrowingFeeFloor(address _asset, uint256 borrowingFeeFloor) external;\n\n\tfunction setMaxBorrowingFee(address _asset, uint256 maxBorrowingFee) external;\n\n\tfunction setRedemptionFeeFloor(address _asset, uint256 redemptionFeeFloor) external;\n\n\tfunction removeRedemptionBlock(address _asset) external;\n}\n"
    },
    "contracts/Interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\npragma solidity ^0.8.14;\n\ninterface IPriceFeed {\n\tstruct ChainlinkResponse {\n\t\tuint80 roundId;\n\t\tint256 answer;\n\t\tuint256 timestamp;\n\t\tbool success;\n\t\tuint8 decimals;\n\t}\n\n\tstruct RegisterOracle {\n\t\tAggregatorV3Interface chainLinkOracle;\n\t\tAggregatorV3Interface chainLinkIndex;\n\t\tbool isRegistered;\n\t}\n\n\tenum Status {\n\t\tchainlinkWorking,\n\t\tchainlinkUntrusted\n\t}\n\n\t// --- Events ---\n\tevent PriceFeedStatusChanged(Status newStatus);\n\tevent LastGoodPriceUpdated(address indexed token, uint256 _lastGoodPrice);\n\tevent LastGoodIndexUpdated(address indexed token, uint256 _lastGoodIndex);\n\tevent RegisteredNewOracle(\n\t\taddress token,\n\t\taddress chainLinkAggregator,\n\t\taddress chianLinkIndex\n\t);\n\n\t// --- Function ---\n\tfunction addOracle(\n\t\taddress _token,\n\t\taddress _chainlinkOracle,\n\t\taddress _chainlinkIndexOracle\n\t) external;\n\n\tfunction fetchPrice(address _token) external returns (uint256);\n\n\tfunction getDirectPrice(address _asset) external returns (uint256);\n}\n"
    },
    "contracts/Interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\nimport \"./IDeposit.sol\";\n\n// Common interface for the Pools.\ninterface IPool is IDeposit {\n\t// --- Events ---\n\n\tevent AssetBalanceUpdated(uint256 _newBalance);\n\tevent DCHFBalanceUpdated(uint256 _newBalance);\n\tevent ActivePoolAddressChanged(address _newActivePoolAddress);\n\tevent DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n\tevent AssetAddressChanged(address _assetAddress);\n\tevent StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n\tevent AssetSent(address _to, address indexed _asset, uint256 _amount);\n\n\t// --- Functions ---\n\n\tfunction getAssetBalance(address _asset) external view returns (uint256);\n\n\tfunction getDCHFDebt(address _asset) external view returns (uint256);\n\n\tfunction increaseDCHFDebt(address _asset, uint256 _amount) external;\n\n\tfunction decreaseDCHFDebt(address _asset, uint256 _amount) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/Dependencies/ERC20Permit.sol": {
      "content": "pragma solidity ^0.8.14;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ninterface IERC2612Permit {\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n\t * given `owner`'s signed approval.\n\t *\n\t * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n\t * ordering also apply here.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `owner` cannot be the zero address.\n\t * - `spender` cannot be the zero address.\n\t * - `deadline` must be a timestamp in the future.\n\t * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n\t * over the EIP712-formatted function arguments.\n\t * - the signature must use ``owner``'s current nonce (see {nonces}).\n\t *\n\t * For more information on the signature format, see the\n\t * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n\t * section].\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/**\n\t * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n\t * included whenever a signature is generated for {permit}.\n\t *\n\t * Every successful call to {permit} increases ``owner``'s nonce by one. This\n\t * prevents a signature from being used multiple times.\n\t */\n\tfunction nonces(address owner) external view returns (uint256);\n}\n\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\n\tusing Counters for Counters.Counter;\n\n\tmapping(address => Counters.Counter) private _nonces;\n\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tbytes32 public constant PERMIT_TYPEHASH =\n\t\t0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\tbytes32 public DOMAIN_SEPARATOR;\n\n\tconstructor() {\n\t\tuint256 chainID;\n\t\tassembly {\n\t\t\tchainID := chainid()\n\t\t}\n\n\t\tDOMAIN_SEPARATOR = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tkeccak256(\n\t\t\t\t\t\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n\t\t\t\t),\n\t\t\t\tkeccak256(bytes(name())),\n\t\t\t\tkeccak256(bytes(\"1\")), // Version\n\t\t\t\tchainID,\n\t\t\t\taddress(this)\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev See {IERC2612Permit-permit}.\n\t *\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external virtual override {\n\t\trequire(block.timestamp <= deadline, \"Permit: expired deadline\");\n\n\t\tbytes32 hashStruct = keccak256(\n\t\t\tabi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline)\n\t\t);\n\n\t\tbytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));\n\n\t\taddress signer = ecrecover(_hash, v, r, s);\n\t\trequire(signer != address(0) && signer == owner, \"ERC20Permit: Invalid signature\");\n\n\t\t_nonces[owner].increment();\n\t\t_approve(owner, spender, amount);\n\t}\n\n\t/**\n\t * @dev See {IERC2612Permit-nonces}.\n\t */\n\tfunction nonces(address owner) public view override returns (uint256) {\n\t\treturn _nonces[owner].current();\n\t}\n\n\tfunction chainId() public view returns (uint256 chainID) {\n\t\tassembly {\n\t\t\tchainID := chainid()\n\t\t}\n\t}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/Dependencies/BaseMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nabstract contract BaseMath {\n\tuint256 public constant DECIMAL_PRECISION = 1 ether;\n}\n"
    },
    "contracts/Dependencies/DfrancMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary DfrancMath {\n\tusing SafeMath for uint256;\n\n\tuint256 internal constant DECIMAL_PRECISION = 1 ether;\n\n\t/* Precision for Nominal ICR (independent of price). Rationale for the value:\n\t *\n\t * - Making it too high could lead to overflows.\n\t * - Making it too low could lead to an ICR equal to zero, due to truncation from Solidity floor division.\n\t *\n\t * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\n\t * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n\t *\n\t */\n\tuint256 internal constant NICR_PRECISION = 1e20;\n\n\tfunction _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn (_a < _b) ? _a : _b;\n\t}\n\n\tfunction _max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn (_a >= _b) ? _a : _b;\n\t}\n\n\t/*\n\t * Multiply two decimal numbers and use normal rounding rules:\n\t * -round product up if 19'th mantissa digit >= 5\n\t * -round product down if 19'th mantissa digit < 5\n\t *\n\t * Used only inside the exponentiation, _decPow().\n\t */\n\tfunction decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\n\t\tuint256 prod_xy = x.mul(y);\n\n\t\tdecProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\n\t}\n\n\t/*\n\t * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n\t *\n\t * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n\t *\n\t * Called by two functions that represent time in units of minutes:\n\t * 1) TroveManager._calcDecayedBaseRate\n\t * 2) CommunityIssuance._getCumulativeIssuanceFraction\n\t *\n\t * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n\t * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n\t *\n\t * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n\t * negligibly different from just passing the cap, since:\n\t *\n\t * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n\t * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n\t */\n\tfunction _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {\n\t\tif (_minutes > 525600000) {\n\t\t\t_minutes = 525600000;\n\t\t} // cap to avoid overflow\n\n\t\tif (_minutes == 0) {\n\t\t\treturn DECIMAL_PRECISION;\n\t\t}\n\n\t\tuint256 y = DECIMAL_PRECISION;\n\t\tuint256 x = _base;\n\t\tuint256 n = _minutes;\n\n\t\t// Exponentiation-by-squaring\n\t\twhile (n > 1) {\n\t\t\tif (n % 2 == 0) {\n\t\t\t\tx = decMul(x, x);\n\t\t\t\tn = n.div(2);\n\t\t\t} else {\n\t\t\t\t// if (n % 2 != 0)\n\t\t\t\ty = decMul(x, y);\n\t\t\t\tx = decMul(x, x);\n\t\t\t\tn = (n.sub(1)).div(2);\n\t\t\t}\n\t\t}\n\n\t\treturn decMul(x, y);\n\t}\n\n\tfunction _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\t\treturn (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\n\t}\n\n\tfunction _computeNominalCR(uint256 _coll, uint256 _debt) internal pure returns (uint256) {\n\t\tif (_debt > 0) {\n\t\t\treturn _coll.mul(NICR_PRECISION).div(_debt);\n\t\t}\n\t\t// Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n\t\telse {\n\t\t\t// if (_debt == 0)\n\t\t\treturn 2**256 - 1;\n\t\t}\n\t}\n\n\tfunction _computeCR(\n\t\tuint256 _coll,\n\t\tuint256 _debt,\n\t\tuint256 _price\n\t) internal pure returns (uint256) {\n\t\tif (_debt > 0) {\n\n\t\t\treturn _coll.mul(_price).div(_debt);\n\t\t}\n\t\t// Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n\t\telse {\n\t\t\t// if (_debt == 0)\n\t\t\treturn type(uint256).max;\n\t\t}\n\t}\n}\n"
    },
    "contracts/Dependencies/ERC20Decimals.sol": {
      "content": "pragma solidity ^0.8.14;\n\ninterface ERC20Decimals {\n\tfunction decimals() external view returns (uint8);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}