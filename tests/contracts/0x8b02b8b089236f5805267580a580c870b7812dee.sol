{{
  "language": "Solidity",
  "sources": {
    "contracts/giveaway/RedeemableGiveaway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"../interfaces/IMintableERC721.sol\";\n\n/**\n * @title Reedemable ERC721 Giveaway\n *\n * @notice Reedemable ERC721 Giveaway is a smart contract that allow accounts that own a specific ERC721 token\n *         to get another ERC721 token for free, in a fixed period of time; the smart contract\n *         is generic and can support any type of mintable NFT (see MintableERC721 interface).\n *         For instance, suppose that users already own NFTs named A. Then, for each minted NFT A, the owner\n *         can also mint another NFT called B. The releationship is one-to-one and it can be only one NFT of type B\n *         minted for a distinct NFT of type A.\n *\n * @dev All the \"fixed\" parameters can be changed on the go after smart contract is deployed\n *      and operational, but this ability is reserved for quick fix-like adjustments, and to provide\n *      an ability to restart and run a giveaway after the previous one ends.\n *\n *      Note that both the `giveawayTokenContract` and `baseTokenContract` contracts must be mintble NFTS\n *      for this to work.\n *\n *      When redeem an NFT token by this contract, the token is minted by the recipient.\n *\n *      To successfully redeem a token, the caller must:\n *        1) Own NFTs minted using the `baseTokenContract`\n *        2) The NFTs minted using the `baseTokenContract` should already not been used to redeem NFTs\n *           of the `giveawayTokenContract`.\n *\n *      Deployment and setup:\n *      1. Deploy smart contract, specify the giveawat smart contract address during the deployment:\n *         - Mintable ER721 deployed instance address\n *      2. Execute `initialize` function and set up the giveaway parameters;\n *         giveaway is not active until it's initialized and a valid `baseTokenContract` address is provided.\n */\ncontract RedeemableGiveaway is Ownable {\n  /**\n   * @dev Next token ID to mint;\n   *      initially this is the first available ID which can be minted;\n   *      at any point in time this should point to a available, mintable ID\n   *      for the token.\n   *\n   *      `nextId` cannot be zero, we do not ever mint NFTs with zero IDs.\n   */\n  uint256 public nextId = 1;\n\n  /**\n   * @dev Last token ID to mint;\n   *      once `nextId` exceeds `finalId` the giveaway pauses.\n   */\n  uint256 public finalId;\n\n  // ----- SLOT.1 (96/256)\n  /**\n   * @notice Giveaway start at unix timestamp; the giveaway is active after the start (inclusive)\n   */\n  uint32 public giveawayStart;\n\n  /**\n   * @notice Giveaway end unix timestamp; the giveaway is active before the end (exclusive)\n   */\n  uint32 public giveawayEnd;\n\n  /**\n   * @notice Counter of the tokens gifted (minted) by this sale smart contract.\n   */\n  uint32 public giveawayCounter;\n\n  /**\n   * @notice The contract address of the giveaway token.\n   */\n  address public immutable giveawayTokenContract;\n\n  /**\n   * @notice The contract address of the base token.\n   */\n  address public baseTokenContract;\n\n  /**\n   * @notice Track redeemed base tokens.\n   * @dev This is usefull to prevent same tokens to be used again after redeem.\n   */\n  mapping(uint256 => bool) redeemedBaseTokens;\n\n  /**\n   * @dev Fired in initialize()\n   *\n   * @param _by an address which executed the initialization\n   * @param _nextId next ID of the giveaway token to mint\n   * @param _finalId final ID of the giveaway token to mint\n   * @param _giveawayStart start of the giveaway, unix timestamp\n   * @param _giveawayEnd end of the giveaway, unix timestamp\n   * @param _baseTokenContract base token contract address used for redeeming\n   */\n  event Initialized(\n    address indexed _by,\n    uint256 _nextId,\n    uint256 _finalId,\n    uint32 _giveawayStart,\n    uint32 _giveawayEnd,\n    address _baseTokenContract\n  );\n\n  /**\n   * @dev Fired in redeem(), redeemTo(), redeemSingle(), and redeemSingleTo()\n   *\n   * @param _by an address which executed the transaction, probably a base NFT owner\n   * @param _to an address which received token(s) minted\n   * @param _giveawayTokens array with IDS of the minted tokens\n   */\n  event Redeemed(address indexed _by, address indexed _to, uint256[] _giveawayTokens);\n\n  /**\n   * @dev Creates/deploys RedeemableERC721Giveaway and binds it to Mintable ERC721\n   *      smart contract on construction\n   *\n   * @param _giveawayTokenContract deployed Mintable ERC721 smart contract; giveaway will mint ERC721\n   *      tokens of that type to the recipient\n   */\n  constructor(address _giveawayTokenContract) {\n    // Verify the input is set.\n    require(_giveawayTokenContract != address(0), \"giveaway token contract is not set\");\n\n    // Verify input is valid smart contract of the expected interfaces.\n    require(\n      IERC165(_giveawayTokenContract).supportsInterface(type(IMintableERC721).interfaceId) &&\n        IERC165(_giveawayTokenContract).supportsInterface(type(IMintableERC721).interfaceId),\n      \"unexpected token contract type\"\n    );\n\n    // Assign the addresses.\n    giveawayTokenContract = _giveawayTokenContract;\n  }\n\n  /**\n   * @notice Number of tokens left on giveaway.\n   *\n   * @dev Doesn't take into account if giveway is active or not,\n   *      if `nextId - finalId < 1` returns zero.\n   *\n   * @return Number of tokens left on giveway.\n   */\n  function itemsOnGiveaway() public view returns (uint256) {\n    // Calculate items left on givewaway, taking into account that\n    // `finalId` is givewaway (inclusive bound).\n    return finalId >= nextId ? finalId + 1 - nextId : 0;\n  }\n\n  /**\n   * @notice Number of tokens available on giveaway.\n   *\n   * @dev Takes into account if giveaway is active or not, doesn't throw,\n   *      returns zero if giveaway is inactive\n   *\n   * @return Number of tokens available on giveaway.\n   */\n  function itemsAvailable() public view returns (uint256) {\n    // Delegate to itemsOnSale() if giveaway is active, returns zero otherwise.\n    return isActive() ? itemsOnGiveaway() : 0;\n  }\n\n  /**\n   * @notice Active giveaway is an operational giveaway capable of minting tokens.\n   *\n   * @dev The giveaway is active when all the requirements below are met:\n   *      1. `baseTokenContract` is set\n   *      2. `finalId` is not reached (`nextId <= finalId`)\n   *      3. current timestamp is between `giveawayStart` (inclusive) and `giveawayEnd` (exclusive)\n   *\n   *      Function is marked as virtual to be overridden in the helper test smart contract (mock)\n   *      in order to test how it affects the giveaway process\n   *\n   * @return true if giveaway is active (operational) and can mint tokens, false otherwise.\n   */\n  function isActive() public view virtual returns (bool) {\n    // Evaluate giveaway state based on the internal state variables and return.\n    return\n      baseTokenContract != address(0) &&\n      nextId <= finalId &&\n      giveawayStart <= block.timestamp &&\n      giveawayEnd > block.timestamp;\n  }\n\n  /**\n   * @dev Restricted access function to set up giveaway parameters, all at once,\n   *      or any subset of them.\n   *\n   *      To skip parameter initialization, set it to the biggest number for the corresponding type;\n   *      for `_baseTokenContract`, use address(0) or '0x0000000000000000000000000000000000000000' from Javascript.\n   *\n   *      Example: The following initialization will update only _giveawayStart and _giveawayEnd,\n   *      leaving the rest of the fields unchanged:\n   *\n   *      initialize(\n   *          type(uint256).max,\n   *          type(uint256).max,\n   *          1637080155850,\n   *          1639880155950,\n   *          address(0)\n   *      )\n   *\n   *      Requires next ID to be greater than zero (strict): `_nextId > 0`\n   *\n   *      Requires transaction sender to be the deployer of this contract.\n   *\n   * @param _nextId next ID of the token to mint, will be increased\n   *      in smart contract storage after every successful giveaway\n   * @param _finalId final ID of the token to mint; giveaway is capable of producing\n   *      `_finalId - _nextId + 1` tokens\n   * @param _giveawayStart start of the giveaway, unix timestamp\n   * @param _giveawayEnd end of the giveaway, unix timestamp; sale is active only\n   *      when current time is within _giveawayStart (inclusive) and _giveawayEnd (exclusive)\n   * @param _baseTokenContract end of the sale, unix timestamp; sale is active only\n   *      when current time is within _giveawayStart (inclusive) and _giveawayEnd (exclusive)\n   */\n  function initialize(\n    uint256 _nextId, // <<<--- keep type in sync with the body type(uint256).max !!!\n    uint256 _finalId, // <<<--- keep type in sync with the body type(uint256).max !!!\n    uint32 _giveawayStart, // <<<--- keep type in sync with the body type(uint32).max !!!\n    uint32 _giveawayEnd, // <<<--- keep type in sync with the body type(uint32).max !!!\n    address _baseTokenContract // <<<--- keep type in sync with the body address(0) !!!\n  ) public onlyOwner {\n    // Verify the inputs.\n    // No need to verify extra parameters - \"incorrect\" values will deactivate the sale.\n\n    require(_nextId > 0, \"zero nextId\");\n\n    // Initialize contract state based on the values supplied.\n    // Take into account our convention that value `-1` means \"do not set\"\n\n    if (_nextId != type(uint256).max) {\n      nextId = _nextId;\n    }\n\n    if (_finalId != type(uint256).max) {\n      finalId = _finalId;\n    }\n\n    if (_giveawayStart != type(uint32).max) {\n      giveawayStart = _giveawayStart;\n    }\n\n    if (_giveawayEnd != type(uint32).max) {\n      giveawayEnd = _giveawayEnd;\n    }\n\n    if (_baseTokenContract != address(0)) {\n      // The base contract must implement the Mintable NFT interface.\n      require(\n        IERC165(_baseTokenContract).supportsInterface(type(IMintableERC721).interfaceId) &&\n          IERC165(_baseTokenContract).supportsInterface(type(IMintableERC721).interfaceId),\n        \"unexpected token contract type\"\n      );\n\n      baseTokenContract = _baseTokenContract;\n    }\n\n    // Emit initialize event - read values from the storage since not all of them might be set.\n    emit Initialized(msg.sender, nextId, finalId, giveawayStart, giveawayEnd, baseTokenContract);\n  }\n\n  /**\n   * @notice Given an array of base tokens, check if any of the tokens were previously redeemed.\n   * @param _baseTokens Array with base tokens ID.\n   * @return true if any base token was previously redeemed, false otherwise.\n   */\n  function areRedeemed(uint256[] calldata _baseTokens) external view returns (bool[] memory) {\n    bool[] memory redeemed = new bool[](_baseTokens.length);\n    \n    for (uint256 i = 0; i < _baseTokens.length; i++) {\n      redeemed[i] = redeemedBaseTokens[_baseTokens[i]];\n    }\n\n    return redeemed;\n  }\n\n  /**\n   * @notice Redeem several tokens using the caller address. This function will fail if the provided `_baseTokens`\n   *         are not owned by the caller or have previously redeemed.\n   *\n   * @param _baseTokens Array with base tokens ID.\n   */\n  function redeem(uint256[] memory _baseTokens) public {\n    redeemTo(msg.sender, _baseTokens);\n  }\n\n  /**\n   * @notice Redeem several tokens into the address specified by `_to`. This function will fail\n   *         if the provided `_baseTokens` are not owned by the caller or have previously redeemed.\n   *\n   * @param _to Address where the minted tokens will be assigned.\n   * @param _baseTokens Array with base tokens ID.\n   */\n  function redeemTo(address _to, uint256[] memory _baseTokens) public {\n    // Verify the recipient's address.\n    require(_to != address(0), \"recipient not set\");\n\n    // Verify more than 1 tokens were provided, else the caller can use\n    // the single variants of the redeem functions.\n    require(_baseTokens.length > 1, \"incorrect amount\");\n\n    // Verify that all the specified base tokens IDs are owned by the transaction caller\n    // and does not have already been redeemed.\n    for (uint256 i = 0; i < _baseTokens.length; i++) {\n      require(IERC721(baseTokenContract).ownerOf(_baseTokens[i]) == msg.sender, \"wrong owner\");\n      require(!redeemedBaseTokens[_baseTokens[i]], \"token already redeemed\");\n    }\n\n\n    // Verify there is enough items available to giveaway.\n    // Verifies giveaway is in active state under the hood.\n    require(itemsAvailable() >= _baseTokens.length, \"inactive giveaway or not enough items available\");\n\n    // Store the minted giveaway tokens.\n    uint256[] memory giveawayTokens = new uint256[](_baseTokens.length);\n\n    // For each base token provided, mint a giveaway token.\n    for (uint256 i = 0; i < _baseTokens.length; i++) {\n      // Mint token to to the recipient.\n      IMintableERC721(giveawayTokenContract).mint(_to, nextId);\n\n      // Save the minted token ID.\n      giveawayTokens[i] = nextId;\n\n      // Set the next token ID to mint.\n      nextId += 1;\n\n      // Increase the giveaway counter.\n      giveawayCounter += 1;\n\n      // Record the base token, so that it cannot be used again for redeeming.\n      redeemedBaseTokens[_baseTokens[i]] = true;\n    }\n\n    // All the tokens were redeemed, emit the corresponding event.\n    emit Redeemed(msg.sender, _to, giveawayTokens);\n  }\n\n  /**\n   * @notice Redeem a single token using the caller address. This function will fail if the provided `_baseToken`\n   *         is not owned by the caller or have previously redeemed.\n   *\n   * @param _baseToken Base token ID to redeem.\n   */\n  function redeemSingle(uint256 _baseToken) public {\n    redeemSingleTo(msg.sender, _baseToken);\n  }\n\n  /**\n   * @notice Redeem a single token into the address specified by `_to`. This function will fail\n   *         if the provided `_baseToken` is not owned by the caller or have previously redeemed.\n   *\n   * @param _to Address where the minted token will be assigned.\n   * @param _baseToken Base token ID to redeem.\n   */\n  function redeemSingleTo(address _to, uint256 _baseToken) public {\n    // Verify the recipient's address.\n    require(_to != address(0), \"recipient not set\");\n\n    // Verify that the specified base tokens ID is owned by the transaction caller\n    // and does not have already been redeemed.\n    require(IERC721(baseTokenContract).ownerOf(_baseToken) == msg.sender, \"wrong owner\");\n    require(!redeemedBaseTokens[_baseToken], \"token already redeemed\");\n\n    // Verify there is enough items available to giveaway.\n    // Verifies giveaway is in active state under the hood.\n    require(itemsAvailable() >= 1, \"inactive giveaway or not enough items available\");\n\n    // Store the minted giveaway token.\n    uint256[] memory giveawayTokens = new uint256[](1);\n\n    // Mint token to to the recipient.\n    IMintableERC721(giveawayTokenContract).mint(_to, nextId);\n\n    // Save the minted token ID.\n    giveawayTokens[0] = nextId;\n\n    // Set the next token ID to mint.\n    nextId += 1;\n\n    // Increase the giveaway counter.\n    giveawayCounter += 1;\n\n    // Record the base token, so that it cannot be used again for redeeming.\n    redeemedBaseTokens[_baseToken] = true;\n\n    // All the tokens were redeemed, emit the corresponding event.\n    emit Redeemed(msg.sender, _to, giveawayTokens);\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "contracts/interfaces/IMintableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n/**\n * @notice ERC721-compliant interface with added\n *         function for minting new NFTs to addresses\n *\n * See {IERC721}\n */\ninterface IMintableERC721 {\n  /**\n   * @notice Checks if specified token exists\n   *\n   * @dev Returns whether the specified token ID has an ownership\n   *      information associated with it\n   *\n   * @param _tokenId ID of the token to query existence for\n   * @return whether the token exists (true - exists, false - doesn't exist)\n   */\n  function exists(uint256 _tokenId) external view returns (bool);\n\n  /**\n   * @dev Creates new token with token ID specified\n   *      and assigns an ownership `_to` for this token\n   *\n   * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n   *      Prefer the use of `saveMint` instead of `mint`.\n   *\n   * @dev Should have a restricted access handled by the implementation\n   *\n   * @param _to an address to mint token to\n   * @param _tokenId ID of the token to mint\n   */\n  function mint(address _to, uint256 _tokenId) external;\n\n  /**\n   * @dev Creates new tokens starting with token ID specified\n   *      and assigns an ownership `_to` for these tokens\n   *\n   * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n   *\n   * @dev n must be greater or equal 2: `n > 1`\n   *\n   * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n   *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n   *\n   * @dev Should have a restricted access handled by the implementation\n   *\n   * @param _to an address to mint tokens to\n   * @param _tokenId ID of the first token to mint\n   * @param _n how many tokens to mint, sequentially increasing the _tokenId\n   */\n  function mintBatch(\n    address _to,\n    uint256 _tokenId,\n    uint256 _n\n  ) external;\n\n  /**\n   * @dev Creates new token with token ID specified\n   *      and assigns an ownership `_to` for this token\n   *\n   * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n   *      `onERC721Received` on `_to` and throws if the return value is not\n   *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n   *\n   * @dev Should have a restricted access handled by the implementation\n   *\n   * @param _to an address to mint token to\n   * @param _tokenId ID of the token to mint\n   */\n  function safeMint(address _to, uint256 _tokenId) external;\n\n  /**\n   * @dev Creates new token with token ID specified\n   *      and assigns an ownership `_to` for this token\n   *\n   * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n   *      `onERC721Received` on `_to` and throws if the return value is not\n   *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n   *\n   * @dev Should have a restricted access handled by the implementation\n   *\n   * @param _to an address to mint token to\n   * @param _tokenId ID of the token to mint\n   * @param _data additional data with no specified format, sent in call to `_to`\n   */\n  function safeMint(\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  ) external;\n\n  /**\n   * @dev Creates new tokens starting with token ID specified\n   *      and assigns an ownership `_to` for these tokens\n   *\n   * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n   *\n   * @dev n must be greater or equal 2: `n > 1`\n   *\n   * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n   *      `onERC721Received` on `_to` and throws if the return value is not\n   *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n   *\n   * @dev Should have a restricted access handled by the implementation\n   *\n   * @param _to an address to mint token to\n   * @param _tokenId ID of the token to mint\n   * @param _n how many tokens to mint, sequentially increasing the _tokenId\n   */\n  function safeMintBatch(\n    address _to,\n    uint256 _tokenId,\n    uint256 _n\n  ) external;\n\n  /**\n   * @dev Creates new tokens starting with token ID specified\n   *      and assigns an ownership `_to` for these tokens\n   *\n   * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n   *\n   * @dev n must be greater or equal 2: `n > 1`\n   *\n   * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n   *      `onERC721Received` on `_to` and throws if the return value is not\n   *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n   *\n   * @dev Should have a restricted access handled by the implementation\n   *\n   * @param _to an address to mint token to\n   * @param _tokenId ID of the token to mint\n   * @param _n how many tokens to mint, sequentially increasing the _tokenId\n   * @param _data additional data with no specified format, sent in call to `_to`\n   */\n  function safeMintBatch(\n    address _to,\n    uint256 _tokenId,\n    uint256 _n,\n    bytes memory _data\n  ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}