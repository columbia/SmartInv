{"SafeMath.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c \u003e= a, \u0027SafeMath:INVALID_ADD\u0027);\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b \u003c= a, \u0027SafeMath:OVERFLOW_SUB\u0027);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b, uint decimal) internal pure returns (uint) {\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"SafeMath: multiple overflow\");\r\n        uint c1 = c0 + (dc / 2);\r\n        require(c1 \u003e= c0, \"SafeMath: multiple overflow\");\r\n        uint c2 = c1 / dc;\r\n        return c2;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, uint decimal) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * dc;\r\n        require(a == 0 || c0 / a == dc, \"SafeMath: division internal\");\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 \u003e= c0, \"SafeMath: division internal\");\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n}\r\n"},"TubeToken.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\nimport \u0027./SafeMath.sol\u0027;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\nabstract contract ERC20Interface {\r\n  function totalSupply() public virtual view returns (uint);\r\n  function balanceOf(address tokenOwner) public virtual view returns (uint balance);\r\n  function allowance(address tokenOwner, address spender) public virtual view returns (uint remaining);\r\n  function transfer(address to, uint tokens) public virtual returns (bool success);\r\n  function approve(address spender, uint tokens) public virtual returns (bool success);\r\n  function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint tokens);\r\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\nabstract contract ApproveAndCallFallBack {\r\n  function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public virtual;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n  address public owner;\r\n  address public newOwner;\r\n\r\n  event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n  constructor() public {\r\n      owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    newOwner = _newOwner;\r\n  }\r\n  function acceptOwnership() public {\r\n    require(msg.sender == newOwner);\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n    newOwner = address(0);\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and an\r\n// initial fixed supply\r\n// ----------------------------------------------------------------------------\r\ncontract TubeToken is ERC20Interface, Owned {\r\n  using SafeMath for uint;\r\n\r\n  address public chief; // the Tube Chief address\r\n\r\n  string public symbol;\r\n  string public  name;\r\n  uint8 public decimals;\r\n  uint public _totalSupply;\r\n\r\n  mapping(address =\u003e uint) balances;\r\n  mapping(address =\u003e mapping(address =\u003e uint)) allowed;\r\n\r\n  // only cheif contract able to interact the important function !\r\n  modifier onlyChief {\r\n      require(chief != address(0), \u0027CHIEF MISSING\u0027);\r\n      require(msg.sender == chief, \u0027ACCESS_FORBIDDEN\u0027);\r\n      _;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Constructor\r\n  // ------------------------------------------------------------------------\r\n  constructor() public {\r\n    symbol   = \"TUBE2\";\r\n    name     = \"TUBE2\";\r\n    decimals = 18;\r\n    _totalSupply    = 0 * 10**uint(decimals);\r\n    balances[owner] = _totalSupply;\r\n    emit Transfer(address(0), owner, _totalSupply);\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Total supply\r\n  // ------------------------------------------------------------------------\r\n  function totalSupply() public override view returns (uint) {\r\n    return _totalSupply  - balances[address(0)];\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Get the token balance for account `tokenOwner`\r\n  // ------------------------------------------------------------------------\r\n  function balanceOf(address tokenOwner) public override view returns (uint balance) {\r\n    return balances[tokenOwner];\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Transfer the balance from token owner\u0027s account to `to` account\r\n  // - Owner\u0027s account must have sufficient balance to transfer\r\n  // - 0 value transfers are allowed\r\n  // ------------------------------------------------------------------------\r\n  function transfer(address to, uint tokens) public override returns (bool success) {\r\n    balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n    balances[to] = balances[to].add(tokens);\r\n    emit Transfer(msg.sender, to, tokens);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n  // from the token owner\u0027s account\r\n  //\r\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n  // recommends that there are no checks for the approval double-spend attack\r\n  // as this should be implemented in user interfaces\r\n  // ------------------------------------------------------------------------\r\n  function approve(address spender, uint tokens) public override returns (bool success) {\r\n    allowed[msg.sender][spender] = tokens;\r\n    emit Approval(msg.sender, spender, tokens);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Transfer `tokens` from the `from` account to the `to` account\r\n  //\r\n  // The calling account must already have sufficient tokens approve(...)-d\r\n  // for spending from the `from` account and\r\n  // - From account must have sufficient balance to transfer\r\n  // - Spender must have sufficient allowance to transfer\r\n  // - 0 value transfers are allowed\r\n  // ------------------------------------------------------------------------\r\n  function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\r\n    balances[from] = balances[from].sub(tokens);\r\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n    balances[to] = balances[to].add(tokens);\r\n    emit Transfer(from, to, tokens);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Returns the amount of tokens approved by the owner that can be\r\n  // transferred to the spender\u0027s account\r\n  // ------------------------------------------------------------------------\r\n  function allowance(address tokenOwner, address spender) public view override returns (uint remaining) {\r\n    return allowed[tokenOwner][spender];\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n  // from the token owner\u0027s account. The `spender` contract function\r\n  // `receiveApproval(...)` is then executed\r\n  // ------------------------------------------------------------------------\r\n  function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\r\n    allowed[msg.sender][spender] = tokens;\r\n    emit Approval(msg.sender, spender, tokens);\r\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Update chief address from chief contract\r\n  // ------------------------------------------------------------------------\r\n  function updateChief(address _chief) public onlyOwner {\r\n      chief = _chief;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Mint token\r\n  // ------------------------------------------------------------------------\r\n  function mint(address _address, uint amount) public onlyOwner {\r\n      _mint(_address, amount);\r\n  }\r\n\r\n  function farmMint(address _address, uint amount) external onlyChief {\r\n      _mint(_address, amount);\r\n  }\r\n\r\n  function _mint(address account, uint256 amount) internal {\r\n    require(account != address(0), \"ERC20: mint to the zero address\");\r\n    _totalSupply = _totalSupply.add(amount);\r\n    balances[account] = balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Burn token\r\n  // ------------------------------------------------------------------------\r\n  function burn(address account, uint256 amount) public onlyOwner {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        require(balances[account] \u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        balances[account] = balances[account].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Don\u0027t accept ETH\r\n  // ------------------------------------------------------------------------\r\n  fallback() external payable {\r\n    revert();\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Owner can transfer out any accidentally sent ERC20 tokens\r\n  // ------------------------------------------------------------------------\r\n  function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n    return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n  }\r\n}\r\n"}}