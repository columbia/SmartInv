{{
  "language": "Solidity",
  "sources": {
    "contracts/modules/cover/Quotation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../../abstract/MasterAware.sol\";\nimport \"../../interfaces/IClaimsReward.sol\";\nimport \"../../interfaces/IIncidents.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/IPooledStaking.sol\";\nimport \"../../interfaces/IQuotation.sol\";\nimport \"../../interfaces/IQuotationData.sol\";\nimport \"../../interfaces/ITokenController.sol\";\nimport \"../../interfaces/ITokenData.sol\";\n\ncontract Quotation is IQuotation, MasterAware, ReentrancyGuard {\n  using SafeMath for uint;\n\n  IClaimsReward public cr;\n  IPool public pool;\n  IPooledStaking public pooledStaking;\n  IQuotationData public qd;\n  ITokenController public tc;\n  ITokenData public td;\n  IIncidents public incidents;\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public onlyInternal {\n    cr = IClaimsReward(master.getLatestAddress(\"CR\"));\n    pool = IPool(master.getLatestAddress(\"P1\"));\n    pooledStaking = IPooledStaking(master.getLatestAddress(\"PS\"));\n    qd = IQuotationData(master.getLatestAddress(\"QD\"));\n    tc = ITokenController(master.getLatestAddress(\"TC\"));\n    td = ITokenData(master.getLatestAddress(\"TD\"));\n    incidents = IIncidents(master.getLatestAddress(\"IC\"));\n  }\n\n  // solhint-disable-next-line no-empty-blocks\n  function sendEther() public payable {}\n\n  /**\n   * @dev Expires a cover after a set period of time and changes the status of the cover\n   * @dev Reduces the total and contract sum assured\n   * @param coverId Cover Id.\n   */\n  function expireCover(uint coverId) external {\n\n    uint expirationDate = qd.getValidityOfCover(coverId);\n    require(expirationDate < now, \"Quotation: cover is not due to expire\");\n\n    uint coverStatus = qd.getCoverStatusNo(coverId);\n    require(coverStatus != uint(IQuotationData.CoverStatus.CoverExpired), \"Quotation: cover already expired\");\n\n    (/* claim count */, bool hasOpenClaim, /* accepted */) = tc.coverInfo(coverId);\n    require(!hasOpenClaim, \"Quotation: cover has an open claim\");\n\n    if (coverStatus != uint(IQuotationData.CoverStatus.ClaimAccepted)) {\n      (,, address contractAddress, bytes4 currency, uint amount,) = qd.getCoverDetailsByCoverID1(coverId);\n      qd.subFromTotalSumAssured(currency, amount);\n      qd.subFromTotalSumAssuredSC(contractAddress, currency, amount);\n    }\n\n    qd.changeCoverStatusNo(coverId, uint8(IQuotationData.CoverStatus.CoverExpired));\n  }\n\n  function withdrawCoverNote(address coverOwner, uint[] calldata coverIds, uint[] calldata reasonIndexes) external {\n\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\n\n    for (uint i = 0; i < coverIds.length; i++) {\n      uint expirationDate = qd.getValidityOfCover(coverIds[i]);\n      require(expirationDate.add(gracePeriod) < now, \"Quotation: cannot withdraw before grace period expiration\");\n    }\n\n    tc.withdrawCoverNote(coverOwner, coverIds, reasonIndexes);\n  }\n\n  function getWithdrawableCoverNoteCoverIds(\n    address coverOwner\n  ) public view returns (\n    uint[] memory expiredCoverIds,\n    bytes32[] memory lockReasons\n  ) {\n\n    uint[] memory coverIds = qd.getAllCoversOfUser(coverOwner);\n    uint[] memory expiredIdsQueue = new uint[](coverIds.length);\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\n    uint expiredQueueLength = 0;\n\n    for (uint i = 0; i < coverIds.length; i++) {\n\n      uint coverExpirationDate = qd.getValidityOfCover(coverIds[i]);\n      uint gracePeriodExpirationDate = coverExpirationDate.add(gracePeriod);\n      (/* claimCount */, bool hasOpenClaim, /* hasAcceptedClaim */) = tc.coverInfo(coverIds[i]);\n\n      if (!hasOpenClaim && gracePeriodExpirationDate < now) {\n        expiredIdsQueue[expiredQueueLength] = coverIds[i];\n        expiredQueueLength++;\n      }\n    }\n\n    expiredCoverIds = new uint[](expiredQueueLength);\n    lockReasons = new bytes32[](expiredQueueLength);\n\n    for (uint i = 0; i < expiredQueueLength; i++) {\n      expiredCoverIds[i] = expiredIdsQueue[i];\n      lockReasons[i] = keccak256(abi.encodePacked(\"CN\", coverOwner, expiredIdsQueue[i]));\n    }\n  }\n\n  function getWithdrawableCoverNotesAmount(address coverOwner) external view returns (uint) {\n\n    uint withdrawableAmount;\n    bytes32[] memory lockReasons;\n    (/*expiredCoverIds*/, lockReasons) = getWithdrawableCoverNoteCoverIds(coverOwner);\n\n    for (uint i = 0; i < lockReasons.length; i++) {\n      uint coverNoteAmount = tc.tokensLocked(coverOwner, lockReasons[i]);\n      withdrawableAmount = withdrawableAmount.add(coverNoteAmount);\n    }\n\n    return withdrawableAmount;\n  }\n\n  /**\n   * @dev Makes Cover funded via NXM tokens.\n   * @param smartCAdd Smart Contract Address\n   */\n  function makeCoverUsingNXMTokens(\n    uint[] calldata coverDetails,\n    uint16 coverPeriod,\n    bytes4 coverCurr,\n    address smartCAdd,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external onlyMember whenNotPaused {\n    tc.burnFrom(msg.sender, coverDetails[2]); // needs allowance\n    _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s, true);\n  }\n\n  /**\n   * @dev Verifies cover details signed off chain.\n   * @param from address of funder.\n   * @param scAddress Smart Contract Address\n   */\n  function verifyCoverDetails(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public onlyInternal {\n    _verifyCoverDetails(\n      from,\n      scAddress,\n      coverCurr,\n      coverDetails,\n      coverPeriod,\n      _v,\n      _r,\n      _s,\n      false\n    );\n  }\n\n  /**\n   * @dev Verifies signature.\n   * @param coverDetails details related to cover.\n   * @param coverPeriod validity of cover.\n   * @param contractAddress smart contract address.\n   * @param _v argument from vrs hash.\n   * @param _r argument from vrs hash.\n   * @param _s argument from vrs hash.\n   */\n  function verifySignature(\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    bytes4 currency,\n    address contractAddress,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public view returns (bool) {\n    require(contractAddress != address(0));\n    bytes32 hash = getOrderHash(coverDetails, coverPeriod, currency, contractAddress);\n    return isValidSignature(hash, _v, _r, _s);\n  }\n\n  /**\n   * @dev Gets order hash for given cover details.\n   * @param coverDetails details realted to cover.\n   * @param coverPeriod validity of cover.\n   * @param contractAddress smart contract address.\n   */\n  function getOrderHash(\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    bytes4 currency,\n    address contractAddress\n  ) public view returns (bytes32) {\n    return keccak256(\n      abi.encodePacked(\n        coverDetails[0],\n        currency,\n        coverPeriod,\n        contractAddress,\n        coverDetails[1],\n        coverDetails[2],\n        coverDetails[3],\n        coverDetails[4],\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @dev Verifies signature.\n   * @param hash order hash\n   * @param v argument from vrs hash.\n   * @param r argument from vrs hash.\n   * @param s argument from vrs hash.\n   */\n  function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\n    address a = ecrecover(prefixedHash, v, r, s);\n    return (a == qd.getAuthQuoteEngine());\n  }\n\n  /**\n   * @dev Creates cover of the quotation, changes the status of the quotation ,\n   * updates the total sum assured and locks the tokens of the cover against a quote.\n   * @param from Quote member Ethereum address.\n   */\n  function _makeCover(//solhint-disable-line\n    address payable from,\n    address contractAddress,\n    bytes4 coverCurrency,\n    uint[] memory coverDetails,\n    uint16 coverPeriod\n  ) internal {\n\n    address underlyingToken = incidents.underlyingToken(contractAddress);\n\n    if (underlyingToken != address(0)) {\n      address coverAsset = cr.getCurrencyAssetAddress(coverCurrency);\n      require(coverAsset == underlyingToken, \"Quotation: Unsupported cover asset for this product\");\n    }\n\n    uint cid = qd.getCoverLength();\n\n    qd.addCover(\n      coverPeriod,\n      coverDetails[0],\n      from,\n      coverCurrency,\n      contractAddress,\n      coverDetails[1],\n      coverDetails[2]\n    );\n\n    uint coverNoteAmount = coverDetails[2].mul(qd.tokensRetained()).div(100);\n\n    uint gracePeriod = tc.claimSubmissionGracePeriod();\n    uint claimSubmissionPeriod = uint(coverPeriod).mul(1 days).add(gracePeriod);\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", from, cid));\n\n    // mint and lock cover note\n    td.setDepositCNAmount(cid, coverNoteAmount);\n    tc.mintCoverNote(from, reason, coverNoteAmount, claimSubmissionPeriod);\n\n    qd.addInTotalSumAssured(coverCurrency, coverDetails[0]);\n    qd.addInTotalSumAssuredSC(contractAddress, coverCurrency, coverDetails[0]);\n\n    uint coverPremiumInNXM = coverDetails[2];\n    uint stakersRewardPercentage = td.stakerCommissionPer();\n    uint rewardValue = coverPremiumInNXM.mul(stakersRewardPercentage).div(100);\n    pooledStaking.accumulateReward(contractAddress, rewardValue);\n  }\n\n  /**\n   * @dev Makes a cover.\n   * @param from address of funder.\n   * @param scAddress Smart Contract Address\n   */\n  function _verifyCoverDetails(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s,\n    bool isNXM\n  ) internal {\n\n    require(coverDetails[3] > now, \"Quotation: Quote has expired\");\n    require(coverPeriod >= 30 && coverPeriod <= 365, \"Quotation: Cover period out of bounds\");\n    require(!qd.timestampRepeated(coverDetails[4]), \"Quotation: Quote already used\");\n    qd.setTimestampRepeated(coverDetails[4]);\n\n    address asset = cr.getCurrencyAssetAddress(coverCurr);\n    if (coverCurr != \"ETH\" && !isNXM) {\n      pool.transferAssetFrom(asset, from, coverDetails[1]);\n    }\n\n    require(verifySignature(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s), \"Quotation: signature mismatch\");\n    _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\n  }\n\n  function createCover(\n    address payable from,\n    address scAddress,\n    bytes4 currency,\n    uint[] calldata coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external onlyInternal {\n\n    require(coverDetails[3] > now, \"Quotation: Quote has expired\");\n    require(coverPeriod >= 30 && coverPeriod <= 365, \"Quotation: Cover period out of bounds\");\n    require(!qd.timestampRepeated(coverDetails[4]), \"Quotation: Quote already used\");\n    qd.setTimestampRepeated(coverDetails[4]);\n\n    require(verifySignature(coverDetails, coverPeriod, currency, scAddress, _v, _r, _s), \"Quotation: signature mismatch\");\n    _makeCover(from, scAddress, currency, coverDetails, coverPeriod);\n  }\n\n  // referenced in master, keeping for now\n  // solhint-disable-next-line no-empty-blocks\n  function transferAssetsToNewContract(address) external pure {}\n\n  function freeUpHeldCovers() external nonReentrant {\n\n    IERC20 dai = IERC20(cr.getCurrencyAssetAddress(\"DAI\"));\n    uint membershipFee = td.joiningFee();\n    uint lastCoverId = 106;\n\n    for (uint id = 1; id <= lastCoverId; id++) {\n\n      if (qd.holdedCoverIDStatus(id) != uint(IQuotationData.HCIDStatus.kycPending)) {\n        continue;\n      }\n\n      (/*id*/, /*sc*/, bytes4 currency, /*period*/) = qd.getHoldedCoverDetailsByID1(id);\n      (/*id*/, address payable userAddress, uint[] memory coverDetails) = qd.getHoldedCoverDetailsByID2(id);\n\n      uint refundedETH = membershipFee;\n      uint coverPremium = coverDetails[1];\n\n      if (qd.refundEligible(userAddress)) {\n        qd.setRefundEligible(userAddress, false);\n      }\n\n      qd.setHoldedCoverIDStatus(id, uint(IQuotationData.HCIDStatus.kycFailedOrRefunded));\n\n      if (currency == \"ETH\") {\n        refundedETH = refundedETH.add(coverPremium);\n      } else {\n        require(dai.transfer(userAddress, coverPremium), \"Quotation: DAI refund transfer failed\");\n      }\n\n      userAddress.transfer(refundedETH);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "contracts/abstract/MasterAware.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.5.0;\n\nimport \"../interfaces/INXMMaster.sol\";\n\ncontract MasterAware {\n\n  INXMMaster public master;\n\n  modifier onlyMember {\n    require(master.isMember(msg.sender), \"Caller is not a member\");\n    _;\n  }\n\n  modifier onlyInternal {\n    require(master.isInternal(msg.sender), \"Caller is not an internal contract\");\n    _;\n  }\n\n  modifier onlyMaster {\n    if (address(master) != address(0)) {\n      require(address(master) == msg.sender, \"Not master\");\n    }\n    _;\n  }\n\n  modifier onlyGovernance {\n    require(\n      master.checkIsAuthToGoverned(msg.sender),\n      \"Caller is not authorized to govern\"\n    );\n    _;\n  }\n\n  modifier whenPaused {\n    require(master.isPause(), \"System is not paused\");\n    _;\n  }\n\n  modifier whenNotPaused {\n    require(!master.isPause(), \"System is paused\");\n    _;\n  }\n\n  function changeDependentContractAddress() external;\n\n  function changeMasterAddress(address masterAddress) public onlyMaster {\n    master = INXMMaster(masterAddress);\n  }\n}\n"
    },
    "contracts/interfaces/IClaimsReward.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IClaimsReward {\n\n  /// @dev Decides the next course of action for a given claim.\n  function changeClaimStatus(uint claimid) external;\n\n  function getCurrencyAssetAddress(bytes4 currency) external view returns (address);\n\n  function getRewardToBeGiven(\n    uint check,\n    uint voteid,\n    uint flag\n  )\n  external\n  view\n  returns (\n    uint tokenCalculated,\n    bool lastClaimedCheck,\n    uint tokens,\n    uint perc\n  );\n\n  function upgrade(address _newAdd) external;\n\n  function getRewardToBeDistributedByUser(address _add) external view returns (uint total);\n\n  function getRewardAndClaimedStatus(uint check, uint claimId) external view returns (uint reward, bool claimed);\n\n  function claimAllPendingReward(uint records) external;\n\n  function getAllPendingRewardOfUser(address _add) external view returns (uint);\n\n  function unlockCoverNote(uint coverId) external;\n}\n"
    },
    "contracts/interfaces/IIncidents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IIncidents {\n\n  function underlyingToken(address) external view returns (address);\n\n  function coveredToken(address) external view returns (address);\n\n  function claimPayout(uint) external view returns (uint);\n\n  function incidentCount() external view returns (uint);\n\n  function addIncident(\n    address productId,\n    uint incidentDate,\n    uint priceBefore\n  ) external;\n\n  function redeemPayoutForMember(\n    uint coverId,\n    uint incidentId,\n    uint coveredTokenAmount,\n    address member\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken);\n\n  function redeemPayout(\n    uint coverId,\n    uint incidentId,\n    uint coveredTokenAmount\n  ) external returns (uint claimId, uint payoutAmount, address payoutToken);\n\n  function pushBurns(address productId, uint maxIterations) external;\n\n  function withdrawAsset(address asset, address destination, uint amount) external;\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./IPriceFeedOracle.sol\";\n\ninterface IPool {\n  function sellNXM(uint tokenAmount, uint minEthOut) external;\n\n  function sellNXMTokens(uint tokenAmount) external returns (bool);\n\n  function minPoolEth() external returns (uint);\n\n  function transferAssetToSwapOperator(address asset, uint amount) external;\n\n  function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) external;\n\n  function getAssetDetails(address _asset) external view returns (\n    uint112 min,\n    uint112 max,\n    uint32 lastAssetSwapTime,\n    uint maxSlippageRatio\n  );\n\n  function sendClaimPayout (\n    address asset,\n    address payable payoutAddress,\n    uint amount\n  ) external returns (bool success);\n\n  function transferAsset(\n    address asset,\n    address payable destination,\n    uint amount\n  ) external;\n\n  function upgradeCapitalPool(address payable newPoolAddress) external;\n\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\n\n  function getPoolValueInEth() external view returns (uint);\n\n\n  function transferAssetFrom(address asset, address from, uint amount) external;\n\n  function getEthForNXM(uint nxmAmount) external view returns (uint ethAmount);\n\n  function calculateEthForNXM(\n    uint nxmAmount,\n    uint currentTotalAssetValue,\n    uint mcrEth\n  ) external pure returns (uint);\n\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\n\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) external pure returns (uint tokenPrice);\n\n  function getTokenPrice(address asset) external view returns (uint tokenPrice);\n\n  function getMCRRatio() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IPooledStaking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IPooledStaking {\n\n  function accumulateReward(address contractAddress, uint amount) external;\n\n  function pushBurn(address contractAddress, uint amount) external;\n\n  function hasPendingActions() external view returns (bool);\n\n  function processPendingActions(uint maxIterations) external returns (bool finished);\n\n  function contractStake(address contractAddress) external view returns (uint);\n\n  function stakerReward(address staker) external view returns (uint);\n\n  function stakerDeposit(address staker) external view returns (uint);\n\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\n\n  function withdraw(uint amount) external;\n\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\n\n  function withdrawReward(address stakerAddress) external;\n}\n"
    },
    "contracts/interfaces/IQuotation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IQuotation {\n  function verifyCoverDetails(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] calldata coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external;\n\n  function createCover(\n    address payable from,\n    address scAddress,\n    bytes4 currency,\n    uint[] calldata coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external;\n}\n"
    },
    "contracts/interfaces/IQuotationData.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IQuotationData {\n\n  function authQuoteEngine() external view returns (address);\n  function stlp() external view returns (uint);\n  function stl() external view returns (uint);\n  function pm() external view returns (uint);\n  function minDays() external view returns (uint);\n  function tokensRetained() external view returns (uint);\n  function kycAuthAddress() external view returns (address);\n\n  function refundEligible(address) external view returns (bool);\n  function holdedCoverIDStatus(uint) external view returns (uint);\n  function timestampRepeated(uint) external view returns (bool);\n\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\n\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\n\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\n\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external;\n\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external;\n\n  function setTimestampRepeated(uint _timestamp) external;\n\n  /// @dev Creates a blank new cover.\n  function addCover(\n    uint16 _coverPeriod,\n    uint _sumAssured,\n    address payable _userAddress,\n    bytes4 _currencyCode,\n    address _scAddress,\n    uint premium,\n    uint premiumNXM\n  ) external;\n\n\n  function addHoldCover(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] calldata coverDetails,\n    uint16 coverPeriod\n  ) external;\n\n  function setRefundEligible(address _add, bool status) external;\n\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external;\n\n  function setKycAuthAddress(address _add) external;\n\n  function changeAuthQuoteEngine(address _add) external;\n\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\n\n  function getProductDetails()\n  external\n  view\n  returns (\n    uint _minDays,\n    uint _pm,\n    uint _stl,\n    uint _stlp\n  );\n\n  function getCoverLength() external view returns (uint len);\n\n  function getAuthQuoteEngine() external view returns (address _add);\n\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount);\n\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover);\n\n  function getUserCoverLength(address _add) external view returns (uint len);\n\n  function getCoverStatusNo(uint _cid) external view returns (uint8);\n\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp);\n\n  function getCoverSumAssured(uint _cid) external view returns (uint sa);\n\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr);\n\n  function getValidityOfCover(uint _cid) external view returns (uint date);\n\n  function getscAddressOfCover(uint _cid) external view returns (uint, address);\n\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add);\n\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM);\n\n  function getCoverDetailsByCoverID1(\n    uint _cid\n  )\n  external\n  view\n  returns (\n    uint cid,\n    address _memberAddress,\n    address _scAddress,\n    bytes4 _currencyCode,\n    uint _sumAssured,\n    uint premiumNXM\n  );\n\n  function getCoverDetailsByCoverID2(\n    uint _cid\n  )\n  external\n  view\n  returns (\n    uint cid,\n    uint8 status,\n    uint sumAssured,\n    uint16 coverPeriod,\n    uint validUntil\n  );\n\n  function getHoldedCoverDetailsByID1(\n    uint _hcid\n  )\n  external\n  view\n  returns (\n    uint hcid,\n    address scAddress,\n    bytes4 coverCurr,\n    uint16 coverPeriod\n  );\n\n  function getUserHoldedCoverLength(address _add) external view returns (uint);\n\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint);\n\n  function getHoldedCoverDetailsByID2(\n    uint _hcid\n  )\n  external\n  view\n  returns (\n    uint hcid,\n    address payable memberAddress,\n    uint[] memory coverDetails\n  );\n\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount);\n\n  function changeCoverStatusNo(uint _cid, uint8 _stat) external;\n\n}\n"
    },
    "contracts/interfaces/ITokenController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface ITokenController {\n\n  function coverInfo(uint id) external view returns (uint16 claimCount, bool hasOpenClaim, bool hasAcceptedClaim);\n\n  function claimSubmissionGracePeriod() external view returns (uint);\n\n  function withdrawCoverNote(\n    address _of,\n    uint[] calldata _coverIds,\n    uint[] calldata _indexes\n  ) external;\n\n  function markCoverClaimOpen(uint coverId) external;\n\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external;\n\n  function changeOperator(address _newOperator) external;\n\n  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\n\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external;\n\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time) external returns (bool);\n\n  function mintCoverNote(\n    address _of,\n    bytes32 _reason,\n    uint256 _amount,\n    uint256 _time\n  ) external;\n\n  function extendClaimAssessmentLock(uint256 _time) external;\n\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time) external returns (bool);\n\n  function increaseClaimAssessmentLock(uint256 _amount) external;\n\n  function burnFrom(address _of, uint amount) external returns (bool);\n\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\n\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) external;\n\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\n\n  function addToWhitelist(address _member) external;\n\n  function removeFromWhitelist(address _member) external;\n\n  function mint(address _member, uint _amount) external;\n\n  function lockForMemberVote(address _of, uint _days) external;\n  function withdrawClaimAssessmentTokens(address _of) external;\n\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons);\n\n  function getLockedTokensValidity(address _of, bytes32 reason) external view returns (uint256 validity);\n\n  function getUnlockableTokens(address _of) external view returns (uint256 unlockableTokens);\n\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\n\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\n  external\n  view\n  returns (uint256 amount, uint256 validity);\n\n  function tokensUnlockable(address _of, bytes32 _reason) external view returns (uint256 amount);\n\n  function totalSupply() external view returns (uint256);\n\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) external view returns (uint256 amount);\n  function totalBalanceOf(address _of) external view returns (uint256 amount);\n\n  function totalLockedBalance(address _of) external view returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/ITokenData.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface ITokenData {\n\n  function walletAddress() external view returns (address payable);\n  function lockTokenTimeAfterCoverExp() external view returns (uint);\n  function bookTime() external view returns (uint);\n  function lockCADays() external view returns (uint);\n  function lockMVDays() external view returns (uint);\n  function scValidDays() external view returns (uint);\n  function joiningFee() external view returns (uint);\n  function stakerCommissionPer() external view returns (uint);\n  function stakerMaxCommissionPer() external view returns (uint);\n  function tokenExponent() external view returns (uint);\n  function priceStep() external view returns (uint);\n\n  function depositedCN(uint) external view returns (uint amount, bool isDeposited);\n\n  function lastCompletedStakeCommission(address) external view returns (uint);\n\n  function changeWalletAddress(address payable _address) external;\n\n  function getStakerStakedContractByIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  external\n  view\n  returns (address stakedContractAddress);\n\n  function getStakerStakedBurnedByIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  external\n  view\n  returns (uint burnedAmount);\n\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  external\n  view\n  returns (uint unlockable);\n\n  function getStakerStakedContractIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  external\n  view\n  returns (uint scIndex);\n\n  function getStakedContractStakerIndex(\n    address _stakedContractAddress,\n    uint _stakedContractIndex\n  )\n  external\n  view\n  returns (uint sIndex);\n\n  function getStakerInitialStakedAmountOnContract(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  external\n  view\n  returns (uint amount);\n\n  function getStakerStakedContractLength(\n    address _stakerAddress\n  )\n  external\n  view\n  returns (uint length);\n\n  function getStakerUnlockedStakedTokens(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  external\n  view\n  returns (uint amount);\n\n  function pushUnlockedStakedTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  ) external;\n\n\n  function pushBurnedTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  ) external;\n\n  function pushUnlockableBeforeLastBurnTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  ) external;\n\n  function setUnlockableBeforeLastBurnTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  ) external;\n\n  function pushEarnedStakeCommissions(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _stakedContractIndex,\n    uint _commissionAmount\n  ) external;\n\n  function pushRedeemedStakeCommissions(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  ) external;\n\n  function getStakerEarnedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  external\n  view\n  returns (uint);\n\n  function getStakerRedeemedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  external\n  view\n  returns (uint);\n\n  function getStakerTotalEarnedStakeCommission(\n    address _stakerAddress\n  )\n  external\n  view\n  returns (uint totalCommissionEarned);\n\n  function getStakerTotalReedmedStakeCommission(\n    address _stakerAddress\n  )\n  external\n  view\n  returns (uint totalCommissionRedeemed);\n\n  function setDepositCN(uint coverId, bool flag) external;\n\n  function getStakedContractStakerByIndex(\n    address _stakedContractAddress,\n    uint _stakedContractIndex\n  )\n  external\n  view\n  returns (address stakerAddress);\n\n  function getStakedContractStakersLength(\n    address _stakedContractAddress\n  ) external view returns (uint length);\n\n  function addStake(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _amount\n  ) external returns (uint scIndex);\n\n  function bookCATokens(address _of) external;\n\n  function isCATokensBooked(address _of) external view returns (bool res);\n\n  function setStakedContractCurrentCommissionIndex(\n    address _stakedContractAddress,\n    uint _index\n  ) external;\n\n  function setLastCompletedStakeCommissionIndex(\n    address _stakerAddress,\n    uint _index\n  ) external;\n\n\n  function setStakedContractCurrentBurnIndex(\n    address _stakedContractAddress,\n    uint _index\n  ) external;\n\n  function setDepositCNAmount(uint coverId, uint amount) external;\n}\n"
    },
    "contracts/interfaces/INXMMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface INXMMaster {\n\n  function tokenAddress() external view returns (address);\n\n  function owner() external view returns (address);\n\n  function masterInitialized() external view returns (bool);\n\n  function isInternal(address _add) external view returns (bool);\n\n  function isPause() external view returns (bool check);\n\n  function isOwner(address _add) external view returns (bool);\n\n  function isMember(address _add) external view returns (bool);\n\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\n\n  function dAppLocker() external view returns (address _add);\n\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\n\n  function upgradeMultipleContracts(\n    bytes2[] calldata _contractCodes,\n    address payable[] calldata newAddresses\n  ) external;\n\n  function removeContracts(bytes2[] calldata contractCodesToRemove) external;\n\n  function addNewInternalContracts(\n    bytes2[] calldata _contractCodes,\n    address payable[] calldata newAddresses,\n    uint[] calldata _types\n  ) external;\n\n  function updateOwnerParameters(bytes8 code, address payable val) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeedOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IPriceFeedOracle {\n\n  function daiAddress() external view returns (address);\n  function stETH() external view returns (address);\n  function ETH() external view returns (address);\n\n  function getAssetToEthRate(address asset) external view returns (uint);\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}