{"bigsb-token.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\n// ANDRZEJU! NIE DENERWUJ SIĘ!\n\n/**\nApes Together Strong!\n\nAbout BigShortBets DeFi project:\n\nWe are creating a social\u0026trading p2p platform that guarantees encrypted interaction between investors.\nLogging in is possible via a cryptocurrency wallet (e.g. Metamask).\nThe security level is one comparable to the Tor network.\n\nhttps://bigsb.io/ - Our Tool\nhttps://bigshortbets.com - Project\u0026Team info\n\nVideo explainer:\nhttps://youtu.be/wbhUo5IvKdk\n\nIdea: \nhttps://bigshortbets.com/idea/\n\nThe stock exchange is an emanation of the highest form of market freedom related to the natural and inalienable right of every human being to possess.\n\nIt is the freedom – the basic and most precious good, which allows us (people who take responsibility for their actions) to decide about property in a free and unhindered way, regardless of our internal or external motivation.\n\nThis is how the stock exchange was understood in the early 17th century, when the first modern stock exchange, established in 1611 by Dutch merchants in Amsterdam, made its debut. It was established by Dutch merchants in Amsterdam. As Joseph de la Vega, speculator, investor, merchant and author of Confusion de Confusiones 1688, the oldest book on speculation published in 1688, wrote:\n\n“Among the plays which men perform in taking different parts in this magnificent world theatre, the greatest comedy is played at the Exchange. There, in an inimitable fashion, the speculators excel in tricks, they do business and find excuses wherein hiding-places, concealment of facts , quarrels, provocations, mockery, idle talk, violent desires, collusion, artful deception, betrayals, cheatings, and even the tragic end are to be found.”\n\nIn the early days of the stock market, trading was based on mutual trust – (Only since he published in 1688, i.e. he must have noticed much earlier what he noticed, does the statement “in the early days of the stock market, trading was based on mutual trust” have anything to do with the truth at all? Are we talking about beginnings in the sense of the first few minutes? Because de la Vega proves that the dirty games started right from the beginning).\n\nOver time, especially since the end of the 1920s, when Wallstreet had its big crash, trade gradually began to be subject to various regulations, the aim of which was, above all, to protect small investors and level their chances in “clashing” with big “fish”, or “whales” as we call them now. What should be regulated by the market itself, began to be the domain of officials who, despite their best intentions, rather than helping small investors, harmed them more, gradually increasing the advantage of Wallstret over Mainstreet. This led to a clear restriction of freedom of speech – from now on you had to be careful with whom you spoke, what you spoke about and how you spoke. All this to avoid being accused of manipulation and acting against the new law.\n\nThe short squeeze action on GameStop carried out by the Reddit community connected to the Wallstreetbets forum made us realise that fair play is a fantasy and market reality proves that there are equal and more equal investors. Thus, the head of a hedge fund with X investors under him, i.e. being in “agreement” with them or making investment decisions on their behalf, is better treated than investors acting independently on their own account and on their behalf, supporting each other and consulting their investment movements with each other.\n\nSupervisory authorities such as ESMA (the European Securities and Markets Authority) criticised the action on GameStop, but focused their criticism on the weakest and smallest players, who were, after all, acting lawfully in exercising their rights to have opinions and to share them with other free people.\n\nIn our opinion, this approach violates the natural and inalienable right to decide on one’s own property. It has emerged that private investors exercising their fundamental right to have an opinion and act accordingly on the market are being restricted, their freedom of expression curtailed and their perfectly legal activities demonised. In the cases cited above, it was the fund that acted to the detriment of small investors by manipulating GameStop’s shares (and it was by no means the first such manipulation). In the face of such ‘tricks’, small investors do not stand much of a chance against the rich whales of Wall Street, especially when the bodies set up to protect the weak actually favour the strong, giving their enormous capital an advantage.\n\nFor this reason, the idea was born to build a decentralised and encrypted tool in which users’ privacy would be protected in the name of the values that belong to us naturally, that we all possess and that we consider to be the greatest good. To achieve this, we must take risks and oppose oppressive, unfair and unjust laws that restrict freedom.\n\nA final, but equally important advantage is the size of the capital and this can only be levelled in the way it was with the last action on GameStop – it must result from coordinated efforts by individual investors. In response to the above situation, we are building a “bottom-up” tool that enables encrypted and fully secure communication between users based on a token and blockchain network. The free exchange of data in the information market will allow the same or even faster access to news than from giants such as Reuters and Bloomberg, thus breaking their monopoly on first-hand knowledge.\n\nBigShortBets tools will allow to coordinate the activities of groups of smaller investors, which in turn will contribute to reducing the advantage of investment funds and their more effective play.\n\nZaorski, You Son of a bitch I’m in …\n*/\n\nimport \"./owned.sol\";\nimport \"./interfaces.sol\";\n\npragma solidity 0.8.7;\n\n// BigShortBets.com deflationary token\ncontract BigSB is IERC20, Owned {\n    // You SOB, I\u0027m in!\n    constructor(address _owner) {\n        (uint256 rAmount, , , , , , ) = _getValues(INITIAL_SUPPLY);\n        _rOwned[_owner] = rAmount;\n        emit Transfer(ZERO, _owner, INITIAL_SUPPLY);\n        owner = _owner;\n    }\n\n    string public constant name = \"BigShortBets\";\n    string public constant symbol = \"BigSB\";\n    uint8 public constant decimals = 18;\n\n    uint256 private constant MAX = type(uint256).max;\n    uint256 private constant INITIAL_SUPPLY = 100_000_000 * (10**18);\n    uint256 private constant BURN_STOP_SUPPLY = INITIAL_SUPPLY / 10;\n    uint256 private _tTotal = INITIAL_SUPPLY;\n    uint256 private _rTotal = (MAX - (MAX % INITIAL_SUPPLY));\n    uint256 private _tFeeTotal;\n\n    address private constant ZERO = address(0);\n    mapping(address =\u003e uint256) private _rOwned;\n    mapping(address =\u003e uint256) private _tOwned;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public override allowance;\n\n    mapping(address =\u003e bool) public isFeeFree;\n\n    mapping(address =\u003e bool) public isExcluded;\n    address[] private _excluded;\n\n    // ERC20 totalSupply\n    function totalSupply() external view override returns (uint256) {\n        return _tTotal;\n    }\n\n    /// Total fees collected\n    function totalFees() external view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    // ERC20 balanceOf\n    function balanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    // ERC20 transfer\n    function transfer(address recipient, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // ERC20 approve\n    function approve(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    // ERC20 transferFrom\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        uint256 amt = allowance[sender][msg.sender];\n        require(amt \u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n        // reduce only if not permament allowance (uniswap etc)\n        if (amt \u003c MAX) {\n            allowance[sender][msg.sender] -= amount;\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // ERC20 increaseAllowance\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender] + addedValue\n        );\n        return true;\n    }\n\n    // ERC20 decreaseAllowance\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        returns (bool)\n    {\n        require(\n            allowance[msg.sender][spender] \u003e= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender] - subtractedValue\n        );\n\n        return true;\n    }\n\n    // ERC20 burn\n    function burn(uint256 amount) external {\n        require(msg.sender != ZERO, \"ERC20: burn from the zero address\");\n        (uint256 rAmount, , , , , , ) = _getValues(amount);\n        _burn(msg.sender, amount, rAmount);\n    }\n\n    // ERC20 burnFrom\n    function burnFrom(address account, uint256 amount) external {\n        require(account != ZERO, \"ERC20: burn from the zero address\");\n        require(\n            allowance[account][msg.sender] \u003e= amount,\n            \"ERC20: burn amount exceeds allowance\"\n        );\n        allowance[account][msg.sender] -= amount;\n        (uint256 rAmount, , , , , , ) = _getValues(amount);\n        _burn(account, amount, rAmount);\n    }\n\n    /**\n        Burn tokens into fee (aka airdrop)\n        @param tAmount number of tokens to destroy\n     */\n    function reflect(uint256 tAmount) external {\n        address sender = msg.sender;\n        require(\n            !isExcluded[sender],\n            \"Excluded addresses cannot call this function\"\n        );\n        (uint256 rAmount, , , , , , ) = _getValues(tAmount);\n        _rOwned[sender] -= rAmount;\n        _rTotal -= rAmount;\n        _tFeeTotal += tAmount;\n    }\n\n    /**\n        Reflection amount for given amount of token, can deduct fees\n        @param tAmount number of tokens to transfer\n        @param deductTransferFee true or false\n        @return amount reflection amount\n     */\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\n        external\n        view\n        returns (uint256 amount)\n    {\n        require(tAmount \u003c= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            //rAmount\n            (amount, , , , , , ) = _getValues(tAmount);\n        } else {\n            //rTransferAmount\n            (, amount, , , , , ) = _getValues(tAmount);\n        }\n    }\n\n    /**\n        Calculate number of tokens by current reflection rate\n        @param rAmount reflected amount\n        @return number of tokens\n     */\n    function tokenFromReflection(uint256 rAmount)\n        public\n        view\n        returns (uint256)\n    {\n        require(\n            rAmount \u003c= _rTotal,\n            \"Amount must be less than total reflections\"\n        );\n        uint256 currentRate = _getRate();\n        return rAmount / currentRate;\n    }\n\n    /**\n        Internal approve function, emit Approval event\n        @param _owner approving address\n        @param spender delegated spender\n        @param amount amount of tokens\n     */\n    function _approve(\n        address _owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(_owner != ZERO, \"ERC20: approve from the zero address\");\n        require(spender != ZERO, \"ERC20: approve to the zero address\");\n\n        allowance[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    /**\n        Internal transfer function, calling feeFree if needed\n        @param sender sender address\n        @param recipient destination address\n        @param tAmount transfer amount\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        require(sender != ZERO, \"ERC20: transfer from the zero address\");\n        require(recipient != ZERO, \"ERC20: transfer to the zero address\");\n        if (tAmount \u003e 0) {\n            if (isFeeFree[sender]) {\n                _feeFreeTransfer(sender, recipient, tAmount);\n            } else {\n                (\n                    uint256 rAmount,\n                    uint256 rTransferAmount,\n                    uint256 rFee,\n                    uint256 rBurn,\n                    uint256 tTransferAmount,\n                    uint256 tFee,\n                    uint256 tBurn\n                ) = _getValues(tAmount);\n\n                _rOwned[sender] -= rAmount;\n                if (isExcluded[sender]) {\n                    _tOwned[sender] -= tAmount;\n                }\n                _rOwned[recipient] += rTransferAmount;\n                if (isExcluded[recipient]) {\n                    _tOwned[recipient] += tTransferAmount;\n                }\n\n                _reflectFee(rFee, tFee);\n                if (tBurn \u003e 0) {\n                    _reflectBurn(rBurn, tBurn, sender);\n                }\n                emit Transfer(sender, recipient, tTransferAmount);\n            }\n        } else emit Transfer(sender, recipient, 0);\n    }\n\n    /**\n        Function provide fee-free transfer for selected addresses\n        @param sender sender address\n        @param recipient destination address\n        @param tAmount transfer amount\n     */\n    function _feeFreeTransfer(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        (uint256 rAmount, , , , , , ) = _getValues(tAmount);\n        _rOwned[sender] -= rAmount;\n        if (isExcluded[sender]) {\n            _tOwned[sender] -= tAmount;\n        }\n        _rOwned[recipient] += rAmount;\n        if (isExcluded[recipient]) {\n            _tOwned[recipient] += tAmount;\n        }\n        emit Transfer(sender, recipient, tAmount);\n    }\n\n    /// reflect fee amounts in global values\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal -= rFee;\n        _tFeeTotal += tFee;\n    }\n\n    /// reflect burn amounts in global values\n    function _reflectBurn(\n        uint256 rBurn,\n        uint256 tBurn,\n        address account\n    ) private {\n        _rTotal -= rBurn;\n        _tTotal -= tBurn;\n        emit Transfer(account, ZERO, tBurn);\n    }\n\n    /// calculate reflect values for given transfer amount\n    function _getValues(uint256 tAmount)\n        private\n        view\n        returns (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 rBurn,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tBurn\n        )\n    {\n        tFee = tAmount / 100; //1% transfer fee\n        tTransferAmount = tAmount - tFee;\n        if (_tTotal \u003e BURN_STOP_SUPPLY) {\n            tBurn = tAmount / 200; //0.5% burn fee\n            if (_tTotal \u003c BURN_STOP_SUPPLY + tBurn) {\n                tBurn = _tTotal - BURN_STOP_SUPPLY;\n            }\n            tTransferAmount -= tBurn;\n        }\n        uint256 currentRate = _getRate();\n        rAmount = tAmount * currentRate;\n        rFee = tFee * currentRate;\n        rTransferAmount = rAmount - rFee;\n        if (tBurn \u003e 0) {\n            rBurn = tBurn * currentRate;\n            rTransferAmount -= rBurn;\n        }\n    }\n\n    function getRate() external view returns (uint256) {\n        return _getRate();\n    }\n\n    /// calculate current reflect rate\n    function _getRate() private view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply / tSupply;\n    }\n\n    /// calculate current token supply\n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        uint256 i;\n        for (i; i \u003c _excluded.length; i++) {\n            if (\n                _rOwned[_excluded[i]] \u003e rSupply ||\n                _tOwned[_excluded[i]] \u003e tSupply\n            ) return (_rTotal, _tTotal);\n            rSupply -= _rOwned[_excluded[i]];\n            tSupply -= _tOwned[_excluded[i]];\n        }\n        if (rSupply \u003c _rTotal / _tTotal) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    /// internal burn function\n    function _burn(\n        address account,\n        uint256 tAmount,\n        uint256 rAmount\n    ) private {\n        require(\n            _rOwned[account] \u003e= rAmount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        _rOwned[account] -= rAmount;\n        if (isExcluded[account]) {\n            require(\n                _tOwned[account] \u003e= tAmount,\n                \"ERC20: burn amount exceeds balance\"\n            );\n\n            _tOwned[account] -= tAmount;\n        }\n        _reflectBurn(rAmount, tAmount, account);\n    }\n\n    //\n    // Rick mode\n    //\n\n    /**\n        Add address that will not pay transfer fees\n        @param user address to mark as fee-free\n     */\n    function addFeeFree(address user) external onlyOwner {\n        isFeeFree[user] = true;\n    }\n\n    /**\n        Remove address form privileged list\n        @param user user to remove\n     */\n    function removeFeeFree(address user) external onlyOwner {\n        isFeeFree[user] = false;\n    }\n\n    /**\n        Exclude address form earing transfer fees\n        @param account address to exclude from earning\n     */\n    function excludeAccount(address account) external onlyOwner {\n        require(!isExcluded[account], \"Account is already excluded\");\n        if (_rOwned[account] \u003e 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    /**\n        Include address back to earn transfer fees\n        @param account address to include\n     */\n    function includeAccount(address account) external onlyOwner {\n        require(isExcluded[account], \"Account is already included\");\n        uint256 i;\n        for (i; i \u003c _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    /**\n        Take ETH accidentally send to contract\n    */\n    function withdrawEth() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    /**\n        Take any ERC20 sent to contract\n        @param token token address\n    */\n    function withdrawErc20(address token) external onlyOwner {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        require(balance \u003e 0, \"Nothing to withdraw\");\n        // use broken IERC20\n        IUsdt(token).transfer(owner, balance);\n    }\n}\n\n//rav3n_pl was here\n\n//This is fine!\n"},"interfaces.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// Reflection\ninterface IReflect {\n    function tokenFromReflection(uint256 rAmount)\n        external\n        view\n        returns (uint256);\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\n        external\n        view\n        returns (uint256);\n\n    function getRate() external view returns (uint256);\n}\n\n/// ChainLink ETH/USD oracle\ninterface IChainLink {\n    // chainlink ETH/USD oracle\n    // answer|int256 :  216182781556 - 8 decimals\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/// USDT is not ERC-20 compliant, not returning true on transfers\ninterface IUsdt {\n    function transfer(address, uint256) external;\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\n// Check ETH send to first presale\n// Yes, there is a typo\ninterface IPresale1 {\n    function blanceOf(address user) external view returns (uint256 amt);\n}\n\n// Check tokens bought in second presale\n// There is bug in ETH deposits, we need handle it\n// Also \"tokensBoughtOf\" calculation is broken, so we do all math\ninterface IPresale2 {\n    function ethDepositOf(address user) external view returns (uint256 amt);\n\n    function usdDepositOf(address user) external view returns (uint256 amt);\n}\n\n// Check final sale tokens bought\ninterface ISale {\n    function tokensBoughtOf(address user) external view returns (uint256 amt);\n}\n\ninterface IClaimSale {\n    function addLock(\n        address user,\n        uint256 reflection,\n        uint256 locktime\n    ) external;\n}\n"},"owned.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipChanged(address from, address to);\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipChanged(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    // owner can give super-rights to someone\n    function giveOwnership(address user) external onlyOwner {\n        require(user != address(0), \"User renounceOwnership\");\n        newOwner = user;\n    }\n\n    // new owner need to accept\n    function acceptOwnership() external {\n        require(msg.sender == newOwner, \"Only NewOwner\");\n        emit OwnershipChanged(owner, newOwner);\n        owner = msg.sender;\n        delete newOwner;\n    }\n}\n"}}