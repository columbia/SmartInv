{"AddrMInterface.sol":{"content":"pragma solidity ^0.5.7;\n\ninterface AddrMInterface {\n     function getAddr(string calldata name_) external view returns(address);\n}"},"MainPool.sol":{"content":"pragma solidity 0.5.7;\n\nimport \"./SafeMath.sol\";\nimport \"./AddrMInterface.sol\";\n\ninterface TickectInerface{\n    function calDeductionADC(uint256 _value,bool isIn_) external returns(uint256 disADC_);\n}\n\ninterface ERC20 {\n  function balanceOf(address) external view returns (uint256);\n  function distroy(address _owner,uint256 _value) external;\n}\n\nlibrary gameDataSet{\n    struct PlyRelationship{\n        uint256 parentPID;         //parent PID\n        uint256 topPID;\n        uint256 sonNumber;\n        uint256 bigPotSonPID;    // big pot son ID \n        uint256 totalRecmdplys; // total recommanded players \n        uint256 totalRecmdAmount;     // total Recommended ETH  without  himself\n        uint8   nodeLevel;       // this is node level for V1-V6\n        //mapping(uint256 =\u003e uint256)  sonPIDList;     // son number -\u003e son PID list\n        mapping(uint256 =\u003e bool)  sonPIDListMap;     //son PID list mapping\n        mapping(uint256 =\u003e uint256) sonTotalBalance; // PID-\u003e total balance \n       \n    }\n    \n    struct Player{\n        //uint256 pID;\n        uint256 ticketInCost;     // how many eth can join\n        uint256   withdrawAmount;     // how many eth can join\n        uint256 startTime;      // join the game time\n        uint256 totalSettled;   // rturn  funds\n        uint256 staticIncome;\n        uint256 lastCalcSITime;      // last Calc staticIncome Time  \n        //uint256 lastCalcDITime; //  last Calc dynamicIncome Time\n        uint256 dynamicIncome; //  last Calc dynamicIncome\n        uint256 stepIncome;\n        bool isActive; // 1 mean is 10eth,2 have new one son,3,\n        bool isAlreadGetIns;// already get insePoolBalance income;\n    }\n    \n    \n    struct Round{\n        uint256 rID;            //Round ID\n        uint256 rStartTime;      //Round start ID\n        uint256 rPlys;           // new round players\n        uint256 lastPID;         // last Player ID pID\n        uint256 totalInseAmount; // \n        uint256 fritInsePoint;\n        uint256 fritInseAmount;\n        uint256[] plyInList;\n    }\n}\n\ncontract MainPool{\n    using SafeMath for *;\n    \n    //address manager \n    AddrMInterface addrM ;\n    TickectInerface  tickect;\n    ERC20  adcERC20;\n    \n    // pool\n    mapping(uint256 =\u003e uint256)     public allInBalance;\n    mapping(uint256 =\u003e uint256)     public mainPoolLockBal; // lock balance do not sub\n    mapping(uint256 =\u003e uint256)     public mainPoolBalance; // RID -\u003e balance total Main pool balance \n    mapping(uint256 =\u003e uint256)     public mainPoolWithdrawBalance; // RID -\u003e balance total Main pool balance \n    mapping(uint256 =\u003e uint256)     public alreadyWithDrawBal; // RID -\u003e balance total Main pool balance \n    mapping(uint256 =\u003e uint256)     public insePoolBalance; // total insurance pool Banacle \n    \n    uint256 public mainPoolSTime ;\n    uint256 public totalDistroyADC;\n    \n    uint256 public constant oneDay = 86400 seconds ;\n    \n    \n    //node level\n    mapping(uint8 =\u003e uint256)       private nlThdAmount; // node level threshold amount\n    mapping(uint8 =\u003e uint8)         private nlIncome; // node level threshold amount\n    mapping(uint256 =\u003e uint256 )    private doubleV6PID; // id -\u003e pID ,is start is 1 ;\n    mapping(uint256 =\u003e bool )       private isDoubleV6; // PID -\u003e TRUE ,is start is 1 ;\n    mapping(uint256 =\u003e mapping(uint256 =\u003e uint256 )) private plydV6Income; // rid -\u003e pid-\u003ebalance ,is start is 1 ;\n    uint256 totalV6Number;\n    \n    // Round \n    uint256 public RID;\n    mapping(uint256 =\u003e gameDataSet.Round) public round; // RID =\u003e round Info\n    mapping(uint256 =\u003e mapping(uint256=\u003ebool)) public luckPID;\n    \n    // Player\n    uint256 lastPID;\n    mapping(uint256 =\u003e gameDataSet.PlyRelationship) public plyRShip;\n    mapping(uint256 =\u003e mapping(uint256 =\u003e gameDataSet.Player)) public plyr; // rid-\u003e pid-\u003e player\n    mapping(address =\u003e uint256) public plyrID; // address -\u003e pid-\u003e playerID\n    mapping(uint256 =\u003e address) private plyrAddr; // pid -\u003e addr-\u003e playerID\n    //mapping(uint256 =\u003emapping(uint256 =\u003e uint256)) public plyBalance; // player total can without balance  \n    mapping(uint256 =\u003emapping(uint256 =\u003e uint256)) private plyWithdrawBalance; // player total can without balance  \n    mapping(uint256 =\u003emapping(uint256 =\u003e uint256)) public playBiggertReward; // player total can without balance \n    mapping(uint256 =\u003euint256) private playDistroyADC; // PID-ADC balance player total can without balance \n    mapping(address=\u003ebool) private vipPly;\n    mapping(uint256=\u003ebool) private vipPlayerID;\n    mapping(uint256=\u003emapping(uint256 =\u003e uint256))     public  plyLucklyAmount; //rid-pid-amount\n    \n    // ambassador \n   mapping(address =\u003e bool) public ambassadorList; //addr-true-BOOL\n    //uint256[] ambRewardList;// PID list\n    mapping(uint256=\u003ebool) private ambRewardMap;\n    //mapping(uint256=\u003euint256) ambRewardIdx;\n    mapping(uint256 =\u003e mapping(uint256=\u003euint256)) public ambRewardBalance;\n    \n    //vip\n    address constant vip1Addr = address(0x953ad059b61aA4A23fa48d5eca617D4920E3343e);\n    //address constant vip1Addr = address(0xa9A2CbA5d5d16DE370375B42662F3272279B2b89);\n    //address constant vip2Addr = address(0x6bE9780954580FCC268944e9D6271B3Dfc886997);\n    address constant vip2Addr = address(0xfbcB561D76a622341E6e537a17c5C17af33c4628);\n    address constant vip3Addr = address(0x669f366427ea8184FdCDCda6D6201a6bAAf9b156);\n    address constant vip4Addr = address(0xBcA44B04e10e04b7FeD7F262cAd70A683D753981);\n    address constant vip5Addr = address(0x0D3c20D9102200242398dE26fdF09F29f435421b);\n    address constant vip6Addr = address(0xbb3c82CD454911F140B68FE2E67504af9A2b5D16);\n    //address constant vip6Addr = address(0xa9A2CbA5d5d16DE370375B42662F3272279B2b89);\n   \n    address constant vip7Addr = address(0xbE6DFD74AF0848b9cf6C6DFBc8bb24d2920e6aDe);\n    address constant vip8Addr = address(0x5b9347799602D0164DF3926c10f237543eaa5b9F);\n    address constant vip9Addr = address(0xa2221dE49E4085Be8098d1A8B4538734ce4977C7);\n    address constant vip10Addr = address(0xAc1c0B39F3A1450E53BA0dA1bCAB5D9572DCed57);\n    address constant vip11Addr = address(0x7721a0C6eb2F2a056C48D107d0a2C4Cff261e98c);\n    //address constant vip11Addr = address(0xa9A2CbA5d5d16DE370375B42662F3272279B2b89);\n\n    \n    constructor(address addressM_) public{\n        \n        addrM = AddrMInterface(addressM_);\n        tickect = TickectInerface(addrM.getAddr(\"TICKET\"));\n        adcERC20 = ERC20(addrM.getAddr(\"ADC\"));\n        \n        mainPoolSTime = now;\n        RID = 1;\n        uint256[] memory temparry;\n        round[RID] = gameDataSet.Round(RID,now,0,11,0,1,0,temparry);\n        lastPID = 11;\n        nlThdAmount[1] = 200000000000000000000; //bigger then 200 eth \n        nlThdAmount[2] = 600000000000000000000;\n        nlThdAmount[3] = 2000000000000000000000;\n        nlThdAmount[4] = 6000000000000000000000;\n        nlThdAmount[5] = 12000000000000000000000;\n        nlThdAmount[6] = 25000000000000000000000;\n        \n        nlIncome[1] = 5; // 5% 5/100\n        nlIncome[2] = 7;\n        nlIncome[3] = 9;\n        nlIncome[4] = 11;\n        nlIncome[5] = 13;\n        nlIncome[6] = 15;\n        //initVip();\n        initVipPlay();\n    }\n    \n    function initVipPlay() internal{\n        vipPly[vip1Addr] = true;\n        vipPly[vip2Addr] = true;\n        vipPly[vip3Addr] = true;\n        vipPly[vip4Addr] = true;\n        vipPly[vip5Addr] = true;\n        vipPly[vip6Addr] = true;\n        vipPly[vip7Addr] = true;\n        vipPly[vip8Addr] = true;\n        \n        vipPly[vip9Addr] = true;\n        vipPly[vip10Addr] = true;\n        vipPly[vip11Addr] = true;\n        \n        \n        \n    }\n    \n    modifier notContract(address _addr){\n        uint size;\n        assembly { size := extcodesize(_addr) }\n        require(size == 0,\"\") ;\n        _;\n    }\n    \n    function joinGame(address parentAddr) public payable notContract(msg.sender){\n        // check ticket\n        uint256 tmPid = plyrID[msg.sender];\n        if(tmPid ==0){\n            require(msg.sender != parentAddr,\"parent same as msg sender\");\n        }\n        require(checkTicket(msg.sender,msg.value),\"check ticket fail\");\n        \n        // check invite\n        uint256 pID =plyrID[msg.sender];\n        \n        uint256 parentPid_ = plyrID[parentAddr];\n        uint256 inBalance = plyr[RID][pID].ticketInCost;\n        \n        allInBalance[RID] += inBalance;\n        \n        if(tmPid == 0 \u0026\u0026 !vipPly[msg.sender]){\n            plyRShip[pID].parentPID = parentPid_;\n            // topPID\n            if(parentPid_ == 0){\n                plyRShip[pID].topPID = pID;\n            }else{\n                plyRShip[pID].topPID = plyRShip[parentPid_].topPID;\n            }\n        }\n        \n        /*if(plyr[RID][parentPid_].lastCalcDITime == 0){\n            plyr[RID][parentPid_].lastCalcDITime = now;\n        }*/\n        \n        if (RID \u003e 1 \u0026\u0026 !vipPly[msg.sender] \u0026\u0026 !vipPlayerID[parentPid_]){\n            activeParent(pID,parentPid_,plyr[RID][pID].ticketInCost);\n        } \n    \n        // the pool  5% for insurance pool\n        if(insePoolBalance[RID] \u003e= 50000*10**18){\n           mainPoolBalance[RID] += inBalance; \n           mainPoolLockBal[RID] += inBalance;\n           mainPoolWithdrawBalance[RID] += inBalance;\n        }else{\n            uint256 temp = inBalance*95/100;\n            insePoolBalance[RID] += inBalance*5/100;\n            mainPoolBalance[RID] += temp;\n            mainPoolLockBal[RID] += temp;\n            mainPoolWithdrawBalance[RID] += temp;\n        }\n        \n        \n    \n        // find parents calc earn\n        calcEarn(pID,inBalance);\n        \n        //check pool state\n        setRoundInfo(pID);\n        \n    }\n    \n    function withdraw() public{\n        //check ADC \n        uint256 pid = plyrID[msg.sender];\n        uint256 bunlers = 0;\n        //if(pid \u003e 11){\n            require(plyr[RID][pid].isActive,\"ply not active\");\n        //}\n        require(mainPoolWithdrawBalance[RID]\u003e0,\"pool not withdraw balance\");\n        if(RID \u003e 1 \u0026\u0026 !plyr[RID-1][pid].isAlreadGetIns){\n            //check last round \n            if(luckPID[RID-1][pid]\u0026\u0026 insePoolBalance[RID-1] \u003e 0 ){\n                if(pid == round[RID-1].plyInList[round[RID-1].fritInsePoint]){\n                    bunlers = round[RID-1].fritInseAmount;\n                    insePoolBalance[RID-1] -= bunlers;\n                }else{\n                    bunlers = plyr[RID-1][pid].ticketInCost*2;\n                    if(bunlers \u003e insePoolBalance[RID-1]){\n                        insePoolBalance[RID-1] = 0;\n                        bunlers = insePoolBalance[RID-1] ;\n                    }else{\n                        insePoolBalance[RID-1] -= bunlers;\n                    }\n                    \n                }\n                \n                mainPoolBalance[RID] -= bunlers;\n                plyr[RID-1][pid].isAlreadGetIns = true;\n                plyLucklyAmount[RID-1][pid] = bunlers;\n            }\n        }/*else{\n            require(plyWithdrawBalance[RID][pid] \u003c= plyBalance[RID][pid],\"not enought balance can withdraw\");\n        }*/\n        \n        uint256 wdBalance;\n        if(plyr[RID][pid].totalSettled\u003eplyWithdrawBalance[RID][pid] ){\n            wdBalance = plyr[RID][pid].totalSettled-plyWithdrawBalance[RID][pid] ;\n        }\n        if(bunlers == 0){\n            require(wdBalance \u003e 0,\"not enought balance can withdraw\");\n        }\n        \n        \n        uint256 totalWdBal = wdBalance + bunlers;\n        //wdBalance += bunlers;\n        if(totalWdBal \u003e mainPoolWithdrawBalance[RID]){\n            totalWdBal = mainPoolWithdrawBalance[RID];\n        }\n        uint256 disAmount  = tickect.calDeductionADC(totalWdBal,false);\n        require(adcERC20.balanceOf(msg.sender)\u003edisAmount,\"not adc to buy out tikcet\");\n        adcERC20.distroy(msg.sender,disAmount);\n        playDistroyADC[pid] += disAmount;\n        totalDistroyADC += disAmount;\n        if(totalWdBal \u003e= mainPoolWithdrawBalance[RID]){\n            mainPoolWithdrawBalance[RID] = 0;\n            plyr[RID][pid].withdrawAmount += mainPoolWithdrawBalance[RID];\n            alreadyWithDrawBal[RID] += mainPoolWithdrawBalance[RID];\n            msg.sender.transfer(mainPoolWithdrawBalance[RID]);\n            \n        }else{\n            mainPoolWithdrawBalance[RID] -= totalWdBal;\n            plyr[RID][pid].withdrawAmount += wdBalance;\n            alreadyWithDrawBal[RID] += totalWdBal;\n            msg.sender.transfer(totalWdBal);\n            \n        }\n        \n        plyWithdrawBalance[RID][pid] += wdBalance;\n        \n        plyr[RID][pid].staticIncome = 0;\n        plyr[RID][pid].dynamicIncome = 0;\n        plyr[RID][pid].stepIncome = 0;\n        ambRewardBalance[RID][pid] = 0;\n        plydV6Income[RID][pid] = 0;\n    }\n    \n    // settlement Static income by web\n    function settlementStatic() public {// that is temp balance\n        \n        //uint256 reward;\n        uint256 pid = plyrID[msg.sender];\n        uint256 temp = 0;\n        gameDataSet.Player storage  rPlyer = plyr[RID][pid];\n        //require(pid\u003e11,\"is vip\");\n        require(rPlyer.isActive,\"not active\");\n        require(rPlyer.ticketInCost \u003e0,\"not charge\");\n        require(rPlyer.totalSettled \u003c playBiggertReward[RID][pid],\"already to top reward\");\n        \n        \n        require(now-rPlyer.lastCalcSITime \u003e oneDay,\"not enought one day\");\n        if(rPlyer.lastCalcSITime == 0){\n            temp = calcS_T(rPlyer.startTime,rPlyer.ticketInCost);\n        }else if(now - rPlyer.lastCalcSITime \u003e oneDay){\n            temp = calcS_T(rPlyer.lastCalcSITime,rPlyer.ticketInCost);\n        }\n        //temp = temp*50;\n        if(rPlyer.totalSettled + temp \u003e playBiggertReward[RID][pid]){\n            temp = playBiggertReward[RID][pid] - rPlyer.totalSettled;\n        }\n        if(temp == 0){\n            return ;\n        }\n       \n        if(mainPoolBalance[RID] \u003e temp){\n            //plyBalance[RID][pid] += reward;\n            rPlyer.staticIncome += temp;\n            rPlyer.totalSettled += temp;\n            mainPoolBalance[RID] -=temp;\n            \n            calcDynamic(pid,temp); \n        }else{\n           // plyBalance[RID][pid] += mainPoolBalance[RID];\n            rPlyer.staticIncome += mainPoolBalance[RID];\n            rPlyer.totalSettled += mainPoolBalance[RID];\n            mainPoolBalance[RID] =0;\n            \n            // need start new rand\n            startNewRount();\n            \n        }\n        \n        \n        rPlyer.lastCalcSITime = rPlyer.startTime + ((now - rPlyer.startTime) / oneDay) * oneDay; // remark the last calc income time\n        \n    }\n    \n    function calcDynamic(uint256 plyid_,uint256 staticIncome_) internal{\n        uint256 parenID = plyRShip[plyid_].parentPID;\n        uint256 sonLen = plyRShip[parenID].sonNumber;\n        uint256 dIncome = 0;\n        \n        uint256 temp = staticIncome_;\n        //if((sonLen_ == 1 \u0026\u0026 treeHight_\u003c=2) || (sonLen_ == 2 \u0026\u0026 treeHight_ \u003c= 4) || (sonLen_ == 3 \u0026\u0026 treeHight_\u003c= 6) || (sonLen_ == 4 \u0026\u0026 treeHight_\u003c= 8)){\n        for(uint8 i=1; i\u003c= 8;i++){\n            //find parent\n            temp = staticIncome_;\n            if(parenID == 0){\n                return;\n            }\n            //if(!vipPlayerID[parenID]){\n            if(plyr[RID][parenID].totalSettled \u003e= playBiggertReward[RID][parenID] || !plyr[RID][parenID].isActive){\n                parenID = plyRShip[parenID].parentPID;\n                sonLen = plyRShip[parenID].sonNumber;\n                continue;\n            }//}\n            //if(parenID !=0 ){\n                /*if(plyr[RID][parenID].ticketInCost == 0 \u0026\u0026 RID \u003e 1 ){\n                    if(!vipPlayerID[parenID] \u0026\u0026 plyr[RID-1][parenID].ticketInCost \u003c=10*10**18 \u0026\u0026 plyr[RID-1][parenID].ticketInCost \u003c plyr[RID][plyid_].ticketInCost){\n                 \n                        if(plyr[RID][plyid_].lastCalcSITime == 0){\n                            temp = calcS_T(plyr[RID][plyid_].startTime,plyr[RID-1][parenID].ticketInCost);\n                        }else if(now - plyr[RID][plyid_].lastCalcSITime \u003e oneDay){\n                            temp = calcS_T(plyr[RID][plyid_].lastCalcSITime,plyr[RID-1][parenID].ticketInCost);\n                        }\n                    }\n                        \n                }else{*/\n                    if(!vipPlayerID[parenID] \u0026\u0026 plyr[RID][parenID].ticketInCost \u003c=10*10**18 \u0026\u0026 plyr[RID][parenID].ticketInCost \u003c plyr[RID][plyid_].ticketInCost){\n                    \n                        if(plyr[RID][plyid_].lastCalcSITime == 0){\n                            temp = calcS_T(plyr[RID][plyid_].startTime,plyr[RID][parenID].ticketInCost);\n                        }else if(now - plyr[RID][plyid_].lastCalcSITime \u003e oneDay){\n                            temp = calcS_T(plyr[RID][plyid_].lastCalcSITime,plyr[RID][parenID].ticketInCost);\n                        }\n                    }\n               // }\n                if(i == 1){\n                    dIncome = (temp*20)/100;\n                }else if(i\u003e=2 \u0026\u0026 i\u003c=3){\n                    dIncome = (temp*10)/100;\n                }else if(i\u003e=4 \u0026\u0026 i\u003c=8){\n                    dIncome = (temp*5)/100;\n                }\n                if(i==3 ||i==4){\n                    if(sonLen\u003c2){\n                       dIncome = 0; \n                    }\n                }else if(i==5 || i==6){\n                    if(sonLen \u003c3){\n                        dIncome = 0;\n                    } \n                }else if(i==7 || i==8){\n                    if(sonLen \u003c 4){\n                        dIncome = 0;\n                    }\n                }\n                \n                if(dIncome \u003e 0){\n                    if(plyr[RID][parenID].totalSettled + dIncome \u003e playBiggertReward[RID][parenID]){\n                       dIncome = playBiggertReward[RID][parenID] - plyr[RID][parenID].totalSettled;\n                   }\n                   \n                   if(mainPoolBalance[RID] \u003e dIncome){\n                        //plyBalance[RID][parenID] += dIncome;\n                        plyr[RID][parenID].dynamicIncome += dIncome;\n                        plyr[RID][parenID].totalSettled += dIncome;\n                        mainPoolBalance[RID] -= dIncome;\n                        \n                    }else{\n                        //plyBalance[RID][parenID] += mainPoolBalance[RID];\n                        plyr[RID][parenID].dynamicIncome += mainPoolBalance[RID];\n                        plyr[RID][parenID].totalSettled += mainPoolBalance[RID];\n                        mainPoolBalance[RID] =0;\n            \n                    // need start new rand\n                        startNewRount();\n                        break;\n                    } \n                }\n            \n            dIncome = 0;\n            parenID = plyRShip[parenID].parentPID;\n            sonLen = plyRShip[parenID].sonNumber;\n            \n        }\n    }\n    \n    function setAmbFlag(address ply_) public{\n        require(msg.sender == addrM.getAddr(\"TICKET\"),\"msg sender not TICKET\");\n       \n        ambassadorList[ply_] = true;\n        \n    }\n    \n    //ambassador\n    function getPlayerInfo(address ply_,uint256 rid_) public view returns(\n        uint256 stIncome_,\n        uint256 dtIncome_,\n        uint256 stepIncome_,\n        uint256 ambIncome_,\n        uint256 doubV6Income_,\n        uint256 totoalIncome_,\n        uint256 withdrawAmount_,\n        uint256 ticketIn_,\n        uint256 canWithdrawAmount_,\n        uint256 startTime_,\n        uint256 liveRountAmount_)\n    {\n            uint256 pid = plyrID[ply_];\n            \n            stIncome_ = plyr[rid_][pid].staticIncome;\n            dtIncome_ = plyr[rid_][pid].dynamicIncome;\n            stepIncome_ =  plyr[rid_][pid].stepIncome;\n            ambIncome_ = ambRewardBalance[rid_][pid];\n            doubV6Income_ = plydV6Income[rid_][pid];\n            totoalIncome_ = plyr[rid_][pid].totalSettled;//plyBalance[rid_][pid];\n            ticketIn_ = plyr[rid_][pid].ticketInCost;\n            withdrawAmount_ = plyr[rid_][pid].withdrawAmount;\n            //canWithdrawAmount_ =  rPlyer.staticIncome + rPlyer.stepIncome+ ambRewardBalance[rid_][pid] + plydV6Income[RID][pid] + rPlyer.dynamicIncome;\n            if(plyr[rid_][pid].totalSettled \u003e plyr[rid_][pid].withdrawAmount){\n                canWithdrawAmount_ = plyr[rid_][pid].totalSettled - plyr[rid_][pid].withdrawAmount;\n            }else{\n                canWithdrawAmount_ = 0;\n            }\n            startTime_ = plyr[rid_][pid].startTime;\n            //if(playBiggertReward[RID][pid] \u003e plyr[rid_][pid].totalSettled){\n            liveRountAmount_ = playBiggertReward[rid_][pid] - plyr[rid_][pid].totalSettled;\n            //}\n            \n    }\n    \n    function getPlayerRelship(address ply_) public view returns(\n        uint256 sonNumber_,\n        uint256 allNumber_,\n        uint256 curLevel_,\n        bool    isamb_,\n        uint256 bigPotBalance_,\n        uint256 smailPotBalance_,\n        bool isDoubleV6_,\n        uint256 distroyADC_)\n    {\n        uint256 pid = plyrID[ply_]; \n        sonNumber_= plyRShip[pid].sonNumber;\n        allNumber_= plyRShip[pid].totalRecmdplys;\n        curLevel_=plyRShip[pid].nodeLevel;\n        \n        bigPotBalance_=plyRShip[pid].sonTotalBalance[plyRShip[pid].bigPotSonPID];\n        isDoubleV6_ = isDoubleV6[pid];\n        distroyADC_ = playDistroyADC[pid];\n        smailPotBalance_ = plyRShip[pid].totalRecmdAmount - plyRShip[pid].sonTotalBalance[plyRShip[pid].bigPotSonPID];\n        isamb_ = ambRewardMap[pid];\n    }\n    \n   \n    \n    function getPoolInfo(uint256 rid_) public view returns(\n        uint256 totalInBalance_, // all in balanace\n        uint256 totalDivBalance_, // Dividend  pool balance\n        uint256 totalInsBalance_,//Insurance pool balance\n        uint256 totalPlayers_,\n        uint256 totalDisADC_)\n    {\n        totalInBalance_ = allInBalance[rid_];\n        totalDivBalance_ = mainPoolBalance[rid_];\n        totalInsBalance_ = insePoolBalance[rid_];\n        totalPlayers_ = round[rid_].lastPID;\n        totalDisADC_ = totalDistroyADC;\n    }\n    \n    function getRID() public view returns(uint256 rid_){\n        rid_ = RID;\n    }\n    \n    \n    function activeParent(uint256 sonID_,uint256 parentPid_,uint256 value_) internal{\n        \n        if(!plyr[RID][parentPid_].isActive){\n            if(value_ \u003e= 10*10**18 \u0026\u0026 !plyRShip[parentPid_].sonPIDListMap[sonID_]){\n                plyr[RID][parentPid_].isActive = true;\n                if(playBiggertReward[RID-1][parentPid_] \u003e plyr[RID-1][parentPid_].totalSettled){\n                    playBiggertReward[RID][parentPid_] += (playBiggertReward[RID-1][parentPid_] - plyr[RID-1][parentPid_].totalSettled);\n                    plyr[RID][parentPid_].ticketInCost = plyr[RID-1][parentPid_].ticketInCost;\n                    plyr[RID][parentPid_].lastCalcSITime = plyr[RID-1][parentPid_].lastCalcSITime;\n                }\n                \n            }\n        }\n       \n    }\n    \n    function checkTicket(address payable ply_,uint256 value_) internal returns(bool){ \n        \n       \n       if(vipPly[ply_]){\n           initVip(ply_);\n       }\n       \n       uint256 pid =plyrID[ply_];\n       uint256 disAmount;\n       \n        if(pid != 0 ){\n           if(plyr[RID][pid].totalSettled \u003e= playBiggertReward[RID][pid]){\n                   \n               plyr[RID][pid].totalSettled = 0;\n               plyr[RID][pid].withdrawAmount = 0;\n               plyr[RID][pid].ticketInCost = 0;\n               plyr[RID][pid].staticIncome = 0;\n               plyr[RID][pid].dynamicIncome = 0;\n               plyr[RID][pid].stepIncome = 0;\n               playBiggertReward[RID][pid] = 0;\n               ambRewardBalance[RID][pid] = 0;\n               plydV6Income[RID][pid] = 0;\n               plyWithdrawBalance[RID][pid] = 0;\n            } \n        }\n        \n        if (plyr[RID][pid].ticketInCost \u003e 0 ){\n            return false;\n        }\n       \n        require(value_ \u003e= 1*10**18,\"transfer to smail\");\n        disAmount = tickect.calDeductionADC(value_,true);\n        //require(adcERC20.balanceOf(ply_)\u003edisAmount,\"not adc to buy in tikcet\");\n        adcERC20.distroy(ply_,disAmount);\n        totalDistroyADC += disAmount;\n        \n        \n        if(pid == 0){\n            lastPID += 1;\n            pid = lastPID;\n            \n            plyrID[ply_] = pid; \n            plyrAddr[pid] = ply_;\n            plyr[RID][pid].isActive = true;\n            if(ambassadorList[ply_]){\n                ambRewardMap[pid] = true;\n            }\n            \n        }\n        \n        playDistroyADC[pid] += disAmount;\n        plyr[RID][pid].startTime = now;\n        plyr[RID][pid].ticketInCost = value_;\n        if(vipPly[ply_]){\n            playBiggertReward[RID][pid] += value_*20000;\n            vipPlayerID[pid] = true;\n        }else{\n           if(value_ \u003e= 31*10**18){\n                playBiggertReward[RID][pid] += value_*3;\n            }else if(value_ \u003c 31*10**18 \u0026\u0026 value_ \u003e= 11*10**18){\n                playBiggertReward[RID][pid] +=value_*25/10;\n            }else{\n                playBiggertReward[RID][pid] += value_*2;\n            } \n        }\n        \n        return true;\n        \n    }\n    \n    function setRoundInfo(uint256 plyID_) internal{\n        \n        if(vipPlayerID[plyID_]){\n            return;\n        }\n        round[RID].rPlys += 1;\n        round[RID].lastPID = plyID_;\n        round[RID].plyInList.push(plyID_);\n        \n    }\n    \n    function calcEarn(uint256 plyID_,uint256 value_) internal{\n        //check Insurance pool\n        \n        uint256 aveIncome ;\n       // uint256 len = ambRewardList.length;\n        //uint256  reward;\n        if(totalV6Number \u003e 0){\n            aveIncome= (value_*3/100) /totalV6Number;\n            uint256 doubpid;\n            for(uint256 i = 1; i \u003c= totalV6Number; i++){\n                doubpid = doubleV6PID[i];\n                if(RID == 1 || (RID \u003e1 \u0026\u0026 plyr[RID][doubpid].isActive) /*|| vipPlayerID[plyID_]*/){\n                    if(plyr[RID][doubpid].totalSettled \u003e= playBiggertReward[RID][doubpid]){\n                        continue;\n                    }else{\n                        if( plyr[RID][doubpid].totalSettled + aveIncome \u003e playBiggertReward[RID][doubpid]){\n                            uint256  temp = playBiggertReward[RID][doubpid] - plyr[RID][doubpid].totalSettled;\n                            \n                            plyr[RID][doubpid].totalSettled +=temp;\n                            plydV6Income[RID][doubpid] += temp;\n                            mainPoolBalance[RID] -= temp;\n                        }else{\n                             plydV6Income[RID][doubpid] += aveIncome;\n                            //plyBalance[RID][doubpid] += aveIncome;\n                            plyr[RID][doubpid].totalSettled += aveIncome; \n                            mainPoolBalance[RID] -= aveIncome;\n                        }\n                    }\n                    \n                    \n                }\n            }\n        }\n        \n        findParentByFor(plyID_,value_);\n    }\n    \n    function findParentByFor(uint256 plyID_,uint256 value_) internal{\n            \n            uint256 parentPID_ ;\n            uint256 pp = plyID_;\n            //uint8 dividendAccount = nlIncome[plyRShip[toppid].nodeLevel]; \n            uint256 haveOneV6;\n            uint8 parnetNodeLevel;\n            uint8 biggestNodeLevel=0;\n            uint256[] memory stepPlyerList = new uint256[](120);\n            uint256 stepPlyNum;\n            \n            uint256 ambPid = 0 ;\n            \n            for(uint8 i=0;i\u003c120;i++){\n                parentPID_ = plyRShip[pp].parentPID;\n                parnetNodeLevel = plyRShip[parentPID_].nodeLevel;\n                if(parentPID_ == 0){\n                    break;\n                }\n                \n                if(ambRewardMap[parentPID_] \u0026\u0026 ambPid == 0\u0026\u0026plyr[RID][parentPID_].isActive){\n                    ambPid = parentPID_;\n                }\n                //if(parentPID_ !=0){\n                    //set releaseship\n                    setRelationship(pp,parentPID_,value_);\n                \n                    //double v6\n                    if(parnetNodeLevel \u003e 0){\n                        if(parnetNodeLevel == 6 \u0026\u0026 haveOneV6 \u003e=1 \u0026\u0026 !isDoubleV6[parentPID_]){\n                            isDoubleV6[parentPID_] = true;\n                            totalV6Number +=1;\n                            doubleV6PID[totalV6Number] = parentPID_;\n                        }\n                        if(parnetNodeLevel == 6 \u0026\u0026 !isDoubleV6[parentPID_]){\n                            haveOneV6++;\n                        }\n                    \n                        //step income calc \n                        if(plyr[RID][parentPID_].isActive){\n                            if(parnetNodeLevel \u003e biggestNodeLevel){\n                                biggestNodeLevel = parnetNodeLevel;\n                                stepPlyerList[stepPlyNum] = parentPID_;\n                                stepPlyNum++;\n                            }\n                        }\n                    }\n                    //check level\n                    if((plyr[RID][parentPID_].ticketInCost \u003e= 11*10**18 \u0026\u0026 plyRShip[parentPID_].sonNumber \u003e= 5)){\n                        for (uint8 j = 1; j \u003c= 6; j++) {\n                            if(plyRShip[parentPID_].totalRecmdAmount - plyRShip[parentPID_].sonTotalBalance[plyRShip[parentPID_].bigPotSonPID] \u003e nlThdAmount[j]){\n                                plyRShip[parentPID_].nodeLevel = j;\n                            }\n                        }\n                    }\n                    \n                    pp = parentPID_;\n                \n                //}\n            }\n            \n            //calc step income\n            if(stepPlyNum \u003e0){\n                calcStepByList(stepPlyNum,stepPlyerList,biggestNodeLevel,value_);\n                \n            }\n             \n            //calc ambReward \n            if(ambPid \u003e 0){\n                setAmbRewardBalance(ambPid,value_);\n            }\n            \n            \n    }\n    \n    function calcStepByList(uint256 stepNum_,uint256[] memory stepPlyerList,uint8 biggestNodeLevel,uint256 value_) internal{\n                uint8 dividendAccount  = nlIncome[biggestNodeLevel];\n                uint8 totalDiv;\n                uint8 curDiv;\n                uint8 plyNlevel;\n                uint256 steppid;\n                for(uint8 i=0;i\u003cstepNum_;i++){\n                    steppid = stepPlyerList[i];\n                    \n                    plyNlevel = plyRShip[steppid].nodeLevel;\n                    if(totalDiv == 0){\n                        curDiv = nlIncome[plyNlevel];\n                    }else{\n                        if(dividendAccount \u003enlIncome[plyNlevel] - totalDiv){\n                            curDiv = nlIncome[plyNlevel] - totalDiv;\n                        }else{\n                            curDiv = dividendAccount;\n                        }\n                    } \n                   \n                    calcStepIncome(steppid,value_,curDiv);\n                    \n                    totalDiv += curDiv;\n                    if(dividendAccount \u003e curDiv){\n                        dividendAccount -=curDiv;\n                    }else{\n                        break;\n                    }\n                }\n            \n    }\n    \n    function setAmbRewardBalance(uint256 pid_,uint256 value_) internal{\n       \n        uint256 ambincom;\n        if(plyr[RID][pid_].totalSettled \u003c playBiggertReward[RID][pid_]){\n            ambincom = plyr[RID][pid_].totalSettled + (value_*5)/100 \u003e playBiggertReward[RID][pid_]? playBiggertReward[RID][pid_]-plyr[RID][pid_].totalSettled:(value_*5)/100;\n            plyr[RID][pid_].totalSettled += ambincom;//(value_*5)/100;\n            ambRewardBalance[RID][pid_] += ambincom;// (value_*5)/100;\n            mainPoolBalance[RID] -=  ambincom;}//(value_*5)/100;}\n             \n    }\n    \n    \n    \n    function setRelationship(uint256 sonID_,uint256 plyID_,uint256 value_) internal{\n    \n        gameDataSet.PlyRelationship storage  rship = plyRShip[plyID_];\n       \n            \n        if(!rship.sonPIDListMap[sonID_]){\n            rship.sonNumber += 1;\n            //rship.sonPIDList[rship.sonNumber] = sonID_;//add son\n            rship.sonPIDListMap[sonID_] = true;\n        }\n        //rship.totalRecmdplys++;\n        rship.sonTotalBalance[sonID_] += value_; // add son toto balance value\n        rship.totalRecmdAmount += value_;\n        \n        //check the big one some\n        if(rship.sonTotalBalance[sonID_] \u003e rship.sonTotalBalance[rship.bigPotSonPID]){\n            rship.bigPotSonPID = sonID_;\n        }\n        \n    }\n    \n    \n    \n    \n    function calcS_T(uint256 lastTime_,uint256 value_) internal view returns(uint256 _earnAmount){\n        \n        \n            if(now - mainPoolSTime \u003c= (60 * oneDay)){ // 2 month\n                \n                _earnAmount = (((now -  lastTime_  ) / oneDay ) * value_ * (70))/10000;\n            }else if(now - mainPoolSTime \u003c= (120 * oneDay)){ // 4 month\n                uint256 oneTime = mainPoolSTime + 60*oneDay;\n                if(lastTime_ \u003c oneTime){\n                    _earnAmount = (((oneTime - lastTime_)/oneDay) * value_ * 70)/10000 + (((now - oneTime) / oneDay  ) * value_ * (65))/10000;\n                }else{\n                    _earnAmount = (((now -  lastTime_  ) / oneDay ) * value_ * (65))/10000;\n                }\n                \n            }else{// langer then 6 month\n                uint256 oneTime = mainPoolSTime + 60*oneDay;\n                uint256 twoTime = mainPoolSTime+ 120*oneDay;\n                if(lastTime_ \u003c oneTime){\n                    _earnAmount = (((oneTime - lastTime_)/oneDay) * value_ * 70)/10000 + (60  * value_ * 65)/10000 + (((now - twoTime) / oneDay ) * value_ * 50)/10000;\n                }else if(lastTime_ \u003c twoTime){\n                    _earnAmount = (((twoTime - lastTime_)/oneDay) * value_ * 65)/10000 + (((now - twoTime) / oneDay ) * value_ * (50))/10000;\n                }else{\n                    _earnAmount = (((now -  lastTime_  ) / oneDay ) * value_ * (50))/10000;\n                } \n        \n        }   \n        \n        \n        \n    }\n    \n    function calcStepIncome(uint256 pid_,uint256 value_,uint8 dividendAccount_) public{\n    \n        \n            uint256    spIncome = (value_*dividendAccount_)/100;\n                if(plyr[RID][pid_].totalSettled \u003e= playBiggertReward[RID][pid_]){\n                    return;\n                }\n                if(plyr[RID][pid_].totalSettled+spIncome\u003eplayBiggertReward[RID][pid_]){\n                    spIncome = playBiggertReward[RID][pid_]-plyr[RID][pid_].totalSettled;\n                }\n                //if(mainPoolBalance[RID] \u003e spIncome){\n                    plyr[RID][pid_].stepIncome += spIncome;\n                    //plyBalance[RID][pid_] += spIncome;\n                    plyr[RID][pid_].totalSettled += spIncome;\n                    mainPoolBalance[RID] -= spIncome;\n                /*}else{\n                    \n                    plyr[RID][pid_].stepIncome += mainPoolBalance[RID];\n                    //plyBalance[RID][pid_] += mainPoolBalance[RID];\n                    plyr[RID][pid_].totalSettled += mainPoolBalance[RID];\n                    mainPoolBalance[RID] =0;\n                }*/\n            \n        \n        \n    }\n    \n    \n    function startNewRount() internal {\n        \n        uint256 tisbalance;\n        uint256 pid ;\n        uint256 len = round[RID].rPlys;\n        uint256 starti ;\n        if(len \u003e 100){\n            starti = round[RID].rPlys-100;\n        }\n        for(uint256 i=starti ; i\u003clen; i++){\n            pid = round[RID].plyInList[len-i-1];\n            luckPID[RID][pid] = true;\n            tisbalance += plyr[RID][pid].ticketInCost *2;\n            if(tisbalance\u003e=insePoolBalance[RID]){\n                //luckPID[RID][pid] = true;\n                round[RID].fritInsePoint = len-i-1;\n                round[RID].fritInseAmount = insePoolBalance[RID] - (tisbalance-plyr[RID][pid].ticketInCost *2);\n                round[RID].totalInseAmount = insePoolBalance[RID];\n                break;\n            }else{\n                \n                if(i==len-1){\n                    round[RID].fritInsePoint = starti;\n                    round[RID].totalInseAmount = tisbalance ;\n                }\n            }\n            \n        }\n        \n        RID++;\n        round[RID].rID = RID;\n        round[RID].rStartTime = now;\n        round[RID].rPlys = 0;\n        mainPoolBalance[RID] = insePoolBalance[RID-1];\n        mainPoolWithdrawBalance[RID] = insePoolBalance[RID-1];\n        \n        if(mainPoolLockBal[RID-1] \u003e alreadyWithDrawBal[RID-1]   ){\n            mainPoolBalance[RID] += mainPoolLockBal[RID-1]-alreadyWithDrawBal[RID-1];\n            mainPoolWithdrawBalance[RID] += mainPoolLockBal[RID-1]-alreadyWithDrawBal[RID-1];\n        }\n        \n        newRoundVIP();\n    \n    }\n    \n    function initVip(address ply_) internal{\n       \n        \n        //lastPID = 18;\n         \n        //1\n        if(ply_ == vip1Addr){initVIPInfo(vip1Addr,1,0);}\n        if(ply_ == vip2Addr){initVIPInfo(vip2Addr,2,0);}\n        if(ply_ == vip3Addr){initVIPInfo(vip3Addr,3,0);}\n        if(ply_ == vip4Addr){initVIPInfo(vip4Addr,4,0); }\n        if(ply_ == vip5Addr){initVIPInfo(vip5Addr,5,2);}\n        \n        if(ply_ == vip6Addr){initVIPInfo(vip6Addr,6,2);}\n        if(ply_ == vip7Addr){initVIPInfo(vip7Addr,7,2);}\n        if(ply_ == vip8Addr){initVIPInfo(vip8Addr,8,3);}\n        if(ply_ == vip9Addr){initVIPInfo(vip9Addr,9,3);}\n        if(ply_ == vip10Addr){initVIPInfo(vip10Addr,10,4);}\n        if(ply_ == vip11Addr){initVIPInfo(vip11Addr,11,4);}\n        \n    \n    }\n    \n    \n    function initVIPInfo(address ply_,uint256 pid_ ,uint256 parentid_) internal{\n        \n        plyrID[ply_] = pid_;\n        //plyr[RID][pid_].pID = pid_;\n        plyrAddr[pid_] = ply_;\n        plyr[RID][pid_].isActive = true;\n        \n        \n        if(pid_ == 1){\n            plyRShip[pid_].parentPID = 0;\n            plyRShip[pid_].sonNumber = 3;\n            plyRShip[pid_].sonPIDListMap[2] = true;\n            plyRShip[pid_].sonPIDListMap[3] = true;\n            plyRShip[pid_].sonPIDListMap[4] = true;\n            //plyRShip[pid_].sonPIDList[1] = 2;\n            //plyRShip[pid_].sonPIDList[2] = 3;\n            //plyRShip[pid_].sonPIDList[3] = 4;\n        }else if(pid_ == 2){\n            plyRShip[pid_].parentPID = 1;\n            plyRShip[pid_].sonNumber = 3;\n            plyRShip[pid_].sonPIDListMap[5] = true;\n            plyRShip[pid_].sonPIDListMap[6] = true;\n            plyRShip[pid_].sonPIDListMap[7] = true;\n            //plyRShip[pid_].sonPIDList[1] = 5;\n            //plyRShip[pid_].sonPIDList[2] = 6;\n            //plyRShip[pid_].sonPIDList[3] = 7;\n        }else if(pid_ == 3 ){\n            plyRShip[pid_].parentPID = 1;\n            plyRShip[pid_].sonNumber = 2;\n            plyRShip[pid_].sonPIDListMap[8] = true;\n            plyRShip[pid_].sonPIDListMap[9] = true;\n            //plyRShip[pid_].sonPIDList[1] = 8;\n            //plyRShip[pid_].sonPIDList[2] = 9;\n        }else if(pid_ == 4){\n            plyRShip[pid_].parentPID = 1;\n            plyRShip[pid_].sonNumber = 2;\n            plyRShip[pid_].sonPIDListMap[10] = true;\n            plyRShip[pid_].sonPIDListMap[11] = true;\n            //plyRShip[pid_].sonPIDList[1] = 10;\n            //plyRShip[pid_].sonPIDList[2] = 11;\n        }else if(pid_ \u003e=5 \u0026\u0026 pid_ \u003c= 11){\n           plyRShip[pid_].parentPID = parentid_; \n           ambRewardMap[pid_] = true;\n           ambassadorList[ply_] = true;\n       \n        }\n        \n        plyRShip[pid_].topPID = 1;\n        \n    }\n    \n    function newRoundVIP() internal{\n        for(uint8 i=1;i\u003c=11;i++){\n            playBiggertReward[RID][i] = playBiggertReward[RID-1][i];\n            plyr[RID][i].isActive = true;\n            plyr[RID][i].ticketInCost = plyr[RID][i-1].ticketInCost;\n            plyr[RID][i].lastCalcSITime = plyr[RID-1][i].lastCalcSITime;\n        }   \n    }\n    \n    \n    \n}"},"SafeMath.sol":{"content":"pragma solidity ^0.5.7;\n\n\nlibrary SafeMath {\n \n    function mul(uint256 a, uint256 b) \n        internal \n        pure \n        returns (uint256 c) \n    {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        require(c / a == b, \"SafeMath mul failed\");\n        return c;\n    }\n\n  \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n        return c;\n    }\n    \n  \n    function sub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256) \n    {\n        require(b \u003c= a, \"SafeMath sub failed\");\n        return a - b;\n    }\n\n\n    function add(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256 c) \n    {\n        c = a + b;\n        require(c \u003e= a, \"SafeMath add failed\");\n        return c;\n    }\n    \n\n    function sqrt(uint256 x)\n        internal\n        pure\n        returns (uint256 y) \n    {\n        uint256 z = ((add(x,1)) / 2);\n        y = x;\n        while (z \u003c y) \n        {\n            y = z;\n            z = ((add((x / z),z)) / 2);\n        }\n    }\n    \n    function sq(uint256 x)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (mul(x,x));\n    }\n\n    function pwr(uint256 x, uint256 y)\n        internal \n        pure \n        returns (uint256)\n    {\n        if (x==0)\n            return (0);\n        else if (y==0)\n            return (1);\n        else \n        {\n            uint256 z = x;\n            for (uint256 i=1; i \u003c y; i++)\n                z = mul(z,x);\n            return (z);\n        }\n    }\n}"}}