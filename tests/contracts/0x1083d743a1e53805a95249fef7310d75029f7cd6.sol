{{
  "language": "Solidity",
  "sources": {
    "contracts/callManagers/LendingManager/DepositLogicDecimalWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"../../interfaces/IDecimalWrapper.sol\";\nimport \"./LendingRegistry.sol\";\n\ncontract DepositLogicDecimalWrapper is ILendingLogic {\n    LendingRegistry public immutable lendingRegistry;\n    bytes32 public immutable protocolKey;\n\n    constructor(address _lendingRegistry, bytes32 _protocolKey) {\n        require(_lendingRegistry != address(0), \"INVALID_LENDING_REGISTRY\");\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        protocolKey = _protocolKey;\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        address wrapped = lendingRegistry.underlyingToProtocolWrapped(_underlying, protocolKey);\n        require(wrapped != address(0), \"NO_WRAPPED_FOUND\");\n        targets = new address[](3);\n        data = new bytes[](3);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, wrapped, 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, wrapped, _amount);\n\n        // Deposit into DecimalWrapper\n        targets[2] = wrapped;\n        data[2] =  abi.encodeWithSelector(IDecimalWrapper.deposit.selector, _amount);\n\n        return(targets, data);\n    }\n\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(IDecimalWrapper.withdraw.selector, _amount);\n\n        return(targets, data);\n    }\n\n    function exchangeRate(address _wrapped) external override returns(uint256) {\n        IDecimalWrapper wrapped = IDecimalWrapper(_wrapped);\n        return 10**18 / wrapped.conversion();\n    }\n    function exchangeRateView(address _wrapped) external view override returns(uint256) {\n        IDecimalWrapper wrapped = IDecimalWrapper(_wrapped);\n        return 10**18 / wrapped.conversion();\n    }\n\n    function getAPRFromUnderlying(address _token) external view override returns(uint256) {\n        return 0;\n    }\n\n    function getAPRFromWrapped(address _token) external view override returns(uint256) {\n        return 0;\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/ILendingLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\ninterface ILendingLogic {\n    /**\n        @notice Get the APR based on underlying token.\n        @param _token Address of the underlying token\n        @return Interest with 18 decimals\n    */\n    function getAPRFromUnderlying(address _token) external view returns(uint256);\n\n    /**\n        @notice Get the APR based on wrapped token.\n        @param _token Address of the wrapped token\n        @return Interest with 18 decimals\n    */\n    function getAPRFromWrapped(address _token) external view returns(uint256);\n\n    /**\n        @notice Get the calls needed to lend.\n        @param _underlying Address of the underlying token\n        @param _amount Amount of the underlying token\n        @return targets Addresses of the contracts to call\n        @return data Calldata of the calls\n    */\n    function lend(address _underlying, uint256 _amount) external view returns(address[] memory targets, bytes[] memory data);\n\n    /**\n        @notice Get the calls needed to unlend\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of the underlying tokens\n        @return targets Addresses of the contracts to call\n        @return data Calldata of the calls\n    */\n    function unlend(address _wrapped, uint256 _amount) external view returns(address[] memory targets, bytes[] memory data);\n\n    /**\n        @notice Get the underlying wrapped exchange rate\n        @param _wrapped Address of the wrapped token\n        @return The exchange rate\n    */\n    function exchangeRate(address _wrapped) external returns(uint256);\n\n    /**\n        @notice Get the underlying wrapped exchange rate in a view (non state changing) way\n        @param _wrapped Address of the wrapped token\n        @return The exchange rate\n    */\n    function exchangeRateView(address _wrapped) external view returns(uint256);\n}"
    },
    "contracts/interfaces/IDecimalWrapper.sol": {
      "content": "  \n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDecimalWrapper is IERC20 {\n  event Deposit(address indexed dst, uint wad);\n  event Withdrawal(address indexed src, uint wad);\n\n  function deposit(uint256 _amount) external;\n  function withdraw(uint256 _amount) external;\n\n  function conversion() external view returns(uint256);\n  function underlying() external view returns(address);\n}"
    },
    "contracts/callManagers/LendingManager/LendingRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\n\n// TODO consider making this contract upgradeable\ncontract LendingRegistry is Ownable {\n\n    // Maps wrapped token to protocol\n    mapping(address => bytes32) public wrappedToProtocol;\n    // Maps wrapped token to underlying\n    mapping(address => address) public wrappedToUnderlying;\n\n    mapping(address => mapping(bytes32 => address)) public underlyingToProtocolWrapped;\n\n    // Maps protocol to addresses containing lend and unlend logic\n    mapping(bytes32 => address) public protocolToLogic;\n\n    event WrappedToProtocolSet(address indexed wrapped, bytes32 indexed protocol);\n    event WrappedToUnderlyingSet(address indexed wrapped, address indexed underlying);\n    event ProtocolToLogicSet(bytes32 indexed protocol, address indexed logic);\n    event UnderlyingToProtocolWrappedSet(address indexed underlying, bytes32 indexed protocol, address indexed wrapped);\n\n    /**\n        @notice Set which protocl a wrapped token belongs to\n        @param _wrapped Address of the wrapped token\n        @param _protocol Bytes32 key of the protocol\n    */\n    function setWrappedToProtocol(address _wrapped, bytes32 _protocol) onlyOwner external {\n        wrappedToProtocol[_wrapped] = _protocol;\n        emit WrappedToProtocolSet(_wrapped, _protocol);\n    }\n\n    /**\n        @notice Set what is the underlying for a wrapped token\n        @param _wrapped Address of the wrapped token\n        @param _underlying Address of the underlying token\n    */\n    function setWrappedToUnderlying(address _wrapped, address _underlying) onlyOwner external {\n        wrappedToUnderlying[_wrapped] = _underlying;\n        emit WrappedToUnderlyingSet(_wrapped, _underlying);\n    }\n\n    /**\n        @notice Set the logic contract for the protocol\n        @param _protocol Bytes32 key of the procol\n        @param _logic Address of the lending logic contract for that protocol\n    */\n    function setProtocolToLogic(bytes32 _protocol, address _logic) onlyOwner external {\n        protocolToLogic[_protocol] = _logic;\n        emit ProtocolToLogicSet(_protocol, _logic);\n    }\n\n    /**\n        @notice Set the wrapped token for the underlying deposited in this protocol\n        @param _underlying Address of the unerlying token\n        @param _protocol Bytes32 key of the protocol\n        @param _wrapped Address of the wrapped token\n    */\n    function setUnderlyingToProtocolWrapped(address _underlying, bytes32 _protocol, address _wrapped) onlyOwner external {\n        underlyingToProtocolWrapped[_underlying][_protocol] = _wrapped;\n        emit UnderlyingToProtocolWrappedSet(_underlying, _protocol, _wrapped);\n    }\n\n    /**\n        @notice Get tx data to lend the underlying amount in a specific protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount to lend\n        @param _protocol Bytes32 key of the protocol\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getLendTXData(address _underlying, uint256 _amount, bytes32 _protocol) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[_protocol]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.lend(_underlying, _amount);\n    }\n\n    /**\n        @notice Get the tx data to unlend the wrapped amount\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of wrapped token to unlend\n        @return targets Addresses of the contracts to call\n        @return data Calldata for the calls\n    */\n    function getUnlendTXData(address _wrapped, uint256 _amount) external view returns(address[] memory targets, bytes[] memory data) {\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[wrappedToProtocol[_wrapped]]);\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n        return lendingLogic.unlend(_wrapped, _amount);\n    }\n\n    /**\n        @notice Get the beste apr for the give protocols\n        @dev returns default values if lending logic not found\n        @param _underlying Address of the underlying token\n        @param _protocols Array of protocols to include\n        @return apr The APR\n        @return protocol Protocol that provides the APR\n    */\n    function getBestApr(address _underlying, bytes32[] memory _protocols) external view returns(uint256 apr, bytes32 protocol) {\n        uint256 bestApr;\n        bytes32 bestProtocol;\n\n        for(uint256 i = 0; i < _protocols.length; i++) {\n            bytes32 protocol = _protocols[i];\n            ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[protocol]);\n            require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\n\n            uint256 apr = lendingLogic.getAPRFromUnderlying(_underlying);\n            if (apr > bestApr) {\n                bestApr = apr;\n                bestProtocol = protocol;\n            }\n        }\n\n        return (bestApr, bestProtocol);\n    }\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/callManagers/LendingManager/LendingLogicAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/IAaveLendingPool.sol\";\n\ncontract AToken is IAToken {\n    address public underlyingAssetAddress;\n    function redeem(uint256 _amount) external override {}\n}\n\ncontract LendingLogicAave is ILendingLogic {\n    using SafeMath for uint256;\n\n    IAaveLendingPool public lendingPool;\n    uint16 public referralCode;\n\n    constructor(address _lendingPool, uint16 _referralCode) {\n        require(_lendingPool != address(0), \"LENDING_POOL_INVALID\");\n        lendingPool = IAaveLendingPool(_lendingPool);\n        referralCode = _referralCode;\n    }\n\n    function getAPRFromWrapped(address _token) external view override returns(uint256) {\n        address underlying = AToken(_token).underlyingAssetAddress();\n        return getAPRFromUnderlying(underlying);\n    }\n\n    function getAPRFromUnderlying(address _token) public view override returns(uint256) {\n        address _lendingPool = address(lendingPool);\n        uint256[5] memory ret;\n\n        // https://ethereum.stackexchange.com/questions/84597/ilendingpool-getreservedata-function-gives-yulexception-stack-too-deep-when-com\n        bytes memory data = abi.encodeWithSelector(bytes4(keccak256(\"getReserveData(address)\")), _token);\n        assembly {\n            let success := staticcall(\n                gas(),         // gas remaining\n                _lendingPool,  // destination address\n                add(data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\n                mload(data),   // input length (loaded from the first 32 bytes in the `data` array)\n                ret,           // output buffer\n                160             // output length\n            )\n            if iszero(success) {\n                revert(0, 0)\n            }\n        }\n        return ret[4].div(1000000000);\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        address core = lendingPool.core();\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, address(core), 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, address(core), _amount);\n\n        // Deposit into Aave\n        targets[2] = address(lendingPool);\n        data[2] =  abi.encodeWithSelector(lendingPool.deposit.selector, _underlying, _amount, referralCode);\n\n        return(targets, data);\n    }\n\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(IAToken.redeem.selector, _amount);\n\n        return(targets, data);\n    }\n\n    function exchangeRate(address) external pure override returns(uint256) {\n        return 10**18;\n    }\n\n    function exchangeRateView(address) external pure override returns(uint256) {\n        return 10**18;\n    }\n\n}"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\ninterface IAToken {\n    function redeem(uint256 _amount) external;\n}\n\n"
    },
    "contracts/interfaces/IAaveLendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\ninterface IAaveLendingPool {\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external;\n    function core() external view returns(address);\n    function getReserveData(address _reserve)\n        external\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 availableLiquidity,\n            uint256 totalBorrowsStable,\n            uint256 totalBorrowsVariable,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 utilizationRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            address aTokenAddress,\n            uint40 lastUpdateTimestamp\n        );\n}"
    },
    "contracts/callManagers/LendingManager/LendingLogicAaveV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"../../interfaces/IATokenV2.sol\";\nimport \"../../interfaces/IAaveLendingPoolV2.sol\";\n\ncontract ATokenV2 is IATokenV2 {\n    address public UNDERLYING_ASSET_ADDRESS;\n}\n\ncontract LendingLogicAaveV2 is ILendingLogic {\n    using SafeMath for uint128;\n\n    IAaveLendingPoolV2 public lendingPool;\n    uint16 public referralCode;\n    address public tokenHolder;\n\n    constructor(address _lendingPool, uint16 _referralCode, address _tokenHolder) {\n        require(_lendingPool != address(0), \"LENDING_POOL_INVALID\");\n        lendingPool = IAaveLendingPoolV2(_lendingPool);\n        referralCode = _referralCode;\n        tokenHolder = _tokenHolder;\n    }\n\n    function getAPRFromWrapped(address _token) external view override returns(uint256) {\n        address underlying = ATokenV2(_token).UNDERLYING_ASSET_ADDRESS();\n        return getAPRFromUnderlying(underlying);\n    }\n\n    function getAPRFromUnderlying(address _token) public view override returns(uint256) {\n        DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(_token);\n        return reserveData.currentLiquidityRate.div(1000000000);\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, address(lendingPool), 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, address(lendingPool), _amount);\n\n        // Deposit into Aave\n        targets[2] = address(lendingPool);\n        data[2] =  abi.encodeWithSelector(lendingPool.deposit.selector, _underlying, _amount, tokenHolder, referralCode);\n\n        return(targets, data);\n    }\n\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        ATokenV2 wrapped = ATokenV2(_wrapped);\n\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = address(lendingPool);\n        data[0] = abi.encodeWithSelector(\n            lendingPool.withdraw.selector,\n            wrapped.UNDERLYING_ASSET_ADDRESS(),\n            _amount,\n            tokenHolder\n        );\n\n        return(targets, data);\n    }\n\n    function exchangeRate(address) external pure override returns(uint256) {\n        return 10**18;\n    }\n\n    function exchangeRateView(address) external pure override returns(uint256) {\n        return 10**18;\n    }\n\n}"
    },
    "contracts/interfaces/IATokenV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\ninterface IATokenV2 {\n\n}\n\n"
    },
    "contracts/interfaces/IAaveLendingPoolV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n\ninterface IAaveLendingPoolV2 {\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external;\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (DataTypes.ReserveData memory);\n}\n"
    },
    "contracts/callManagers/LendingManager/LendingLogicCompound.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/ICToken.sol\";\n\ncontract LendingLogicCompound is Ownable, ILendingLogic {\n    using SafeMath for uint256;\n\n    LendingRegistry public lendingRegistry;\n    bytes32 public immutable protocolKey;\n    uint256 public blocksPerYear;\n\n    constructor(address _lendingRegistry, bytes32 _protocolKey) {\n        require(_lendingRegistry != address(0), \"INVALID_LENDING_REGISTRY\");\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        protocolKey = _protocolKey;\n    }\n\n    function setBlocksPerYear(uint256 _blocks) external onlyOwner {\n        // calculated by taking APY onn compound.finance  / dividing by supplyrate per block\n        // this is apparently the amount of blocks compound expects to be minted this year\n        // 2145683;\n        blocksPerYear = _blocks;\n    }\n\n    function getAPRFromWrapped(address _token) public view override returns(uint256) {\n        return ICToken(_token).supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function getAPRFromUnderlying(address _token) external view override returns(uint256) {\n        address cToken = lendingRegistry.underlyingToProtocolWrapped(_token, protocolKey);\n        return getAPRFromWrapped(cToken);\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n\n        address cToken = lendingRegistry.underlyingToProtocolWrapped(_underlying, protocolKey);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, cToken, 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, cToken, _amount);\n\n        // Deposit into Compound\n        targets[2] = cToken;\n\n        data[2] =  abi.encodeWithSelector(ICToken.mint.selector, _amount);\n\n        return(targets, data);\n    }\n\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(ICToken.redeem.selector, _amount);\n\n        return(targets, data);\n    }\n\n    function exchangeRate(address _wrapped) external override returns(uint256) {\n        return ICToken(_wrapped).exchangeRateCurrent();\n    }\n\n    function exchangeRateView(address _wrapped) external view override returns(uint256) {\n        return ICToken(_wrapped).exchangeRateStored();\n    }\n\n}"
    },
    "contracts/interfaces/ICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\ninterface ICToken {\n    function mint(uint _mintAmount) external returns (uint256);\n    function redeem(uint _redeemTokens) external returns (uint256);\n    function supplyRatePerBlock() external view returns (uint256);\n    function exchangeRateCurrent() external returns (uint256);\n    function exchangeRateStored() external view returns(uint256);\n}"
    },
    "contracts/callManagers/LendingManager/LendingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/IExperiPie.sol\";\n\ncontract LendingManager is Ownable, ReentrancyGuard {\n    using Math for uint256;\n\n    LendingRegistry public lendingRegistry;\n    IExperiPie public basket;\n\n    event Lend(address indexed underlying, uint256 amount, bytes32 indexed protocol);\n    event UnLend(address indexed wrapped, uint256 amount);\n    /**\n        @notice Constructor\n        @param _lendingRegistry Address of the lendingRegistry contract\n        @param _basket Address of the pool/pie/basket to manage\n    */\n    constructor(address _lendingRegistry, address _basket) public {\n        require(_lendingRegistry != address(0), \"INVALID_LENDING_REGISTRY\");\n        require(_basket != address(0), \"INVALID_BASKET\");\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        basket = IExperiPie(_basket);\n    }\n\n    /**\n        @notice Move underlying to a lending protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount of underlying to lend\n        @param _protocol Bytes32 protocol key to lend to\n    */\n    function lend(address _underlying, uint256 _amount, bytes32 _protocol) public onlyOwner nonReentrant {\n        // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_underlying).balanceOf(address(basket)));\n\n        //lend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getLendTXData(_underlying, amount, _protocol);\n\n        basket.callNoValue(_targets, _data);\n\n        // if needed remove underlying from basket\n        removeToken(_underlying);\n\n        // add wrapped token\n        addToken(lendingRegistry.underlyingToProtocolWrapped(_underlying, _protocol));\n\n        emit Lend(_underlying, _amount, _protocol);\n    }\n\n    /**\n        @notice Unlend wrapped token from its lending protocol\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of the wrapped token to unlend\n    */\n    function unlend(address _wrapped, uint256 _amount) public onlyOwner nonReentrant {\n        // unlend token\n         // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_wrapped).balanceOf(address(basket)));\n\n        //Unlend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getUnlendTXData(_wrapped, amount);\n        basket.callNoValue(_targets, _data);\n\n        // if needed add underlying\n        addToken(lendingRegistry.wrappedToUnderlying(_wrapped));\n\n        // if needed remove wrapped\n        removeToken(_wrapped);\n\n        emit UnLend(_wrapped, _amount);\n    }\n\n    /**\n        @notice Unlend and immediately lend in a different protocol\n        @param _wrapped Address of the wrapped token to bounce to another protocol\n        @param _amount Amount of the wrapped token to bounce to the other protocol\n        @param _toProtocol Protocol to deposit bounced tokens in\n        @dev Uses reentrency protection of unlend() and lend()\n    */\n    function bounce(address _wrapped, uint256 _amount, bytes32 _toProtocol) external {\n       unlend(_wrapped, _amount);\n       // Bounce all to new protocol\n       lend(lendingRegistry.wrappedToUnderlying(_wrapped), uint256(-1), _toProtocol);\n    }\n\n    function removeToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        //if there is a token balance of the token is not in the pool, skip\n        if(balance != 0 || !inPool) {\n            return;\n        }\n\n        // remove token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.removeToken.selector, _token), 0);\n    }\n\n    function addToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        // If token has no balance or is already in the pool, skip\n        if(balance == 0 || inPool) {\n            return;\n        }\n\n        // add token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.addToken.selector, _token), 0);\n    }\n \n}"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/interfaces/IExperiPie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@pie-dao/diamond/contracts/interfaces/IERC173.sol\";\nimport \"@pie-dao/diamond/contracts/interfaces/IDiamondLoupe.sol\";\nimport \"@pie-dao/diamond/contracts/interfaces/IDiamondCut.sol\";\nimport \"./IBasketFacet.sol\";\nimport \"./IERC20Facet.sol\";\nimport \"./ICallFacet.sol\";\n\n/**\n    @title ExperiPie Interface\n    @dev Combines all ExperiPie facet interfaces into one\n*/\ninterface IExperiPie is IERC20, IBasketFacet, IERC20Facet, IERC173, ICallFacet, IDiamondLoupe, IDiamondCut {\n}"
    },
    "@pie-dao/diamond/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n/* is ERC165 */\r\ninterface IERC173 {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n"
    },
    "@pie-dao/diamond/contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n"
    },
    "@pie-dao/diamond/contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n"
    },
    "contracts/interfaces/IBasketFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface IBasketFacet {\n\n    event TokenAdded(address indexed _token);\n    event TokenRemoved(address indexed _token);\n    event EntryFeeSet(uint256 fee);\n    event ExitFeeSet(uint256 fee);\n    event AnnualizedFeeSet(uint256 fee);\n    event FeeBeneficiarySet(address indexed beneficiary);\n    event EntryFeeBeneficiaryShareSet(uint256 share);\n    event ExitFeeBeneficiaryShareSet(uint256 share);\n\n    event PoolJoined(address indexed who, uint256 amount);\n    event PoolExited(address indexed who, uint256 amount);\n    event FeeCharged(uint256 amount);\n    event LockSet(uint256 lockBlock);\n    event CapSet(uint256 cap);\n\n    /** \n        @notice Sets entry fee paid when minting\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\n    */\n    function setEntryFee(uint256 _fee) external;\n\n    /**\n        @notice Get the entry fee\n        @return Current entry fee\n    */\n    function getEntryFee() external view returns(uint256);\n\n    /**\n        @notice Set the exit fee paid when exiting\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\n    */\n    function setExitFee(uint256 _fee) external;\n\n    /**\n        @notice Get the exit fee\n        @return Current exit fee\n    */\n    function getExitFee() external view returns(uint256);\n\n    /**\n        @notice Set the annualized fee. Often referred to as streaming fee\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\n    */\n    function setAnnualizedFee(uint256 _fee) external;\n\n    /**\n        @notice Get the annualized fee.\n        @return Current annualized fee.\n    */\n    function getAnnualizedFee() external view returns(uint256);\n\n    /**\n        @notice Set the address receiving the fees.\n    */\n    function setFeeBeneficiary(address _beneficiary) external;\n\n    /**\n        @notice Get the fee benificiary\n        @return The current fee beneficiary\n    */\n    function getFeeBeneficiary() external view returns(address);\n\n    /**\n        @notice Set the fee beneficiaries share of the entry fee\n        @notice _share Share of the fee. 1e18 == 100%. Capped at 100% \n    */\n    function setEntryFeeBeneficiaryShare(uint256 _share) external;\n\n    /**\n        @notice Get the entry fee beneficiary share\n        @return Feeshare amount\n    */\n    function getEntryFeeBeneficiaryShare() external view returns(uint256);\n\n    /**\n        @notice Set the fee beneficiaries share of the exit fee\n        @notice _share Share of the fee. 1e18 == 100%. Capped at 100% \n    */\n    function setExitFeeBeneficiaryShare(uint256 _share) external;\n\n    /**\n        @notice Get the exit fee beneficiary share\n        @return Feeshare amount\n    */\n    function getExitFeeBeneficiaryShare() external view returns(uint256);\n\n    /**\n        @notice Calculate the oustanding annualized fee\n        @return Amount of pool tokens to be minted to charge the annualized fee\n    */\n    function calcOutStandingAnnualizedFee() external view returns(uint256);\n\n    /**\n        @notice Charges the annualized fee\n    */\n    function chargeOutstandingAnnualizedFee() external;\n\n    /**\n        @notice Pulls underlying from caller and mints the pool token\n        @param _amount Amount of pool tokens to mint\n    */\n    function joinPool(uint256 _amount) external;\n\n    /**\n        @notice Burns pool tokens from the caller and returns underlying assets\n    */\n    function exitPool(uint256 _amount) external;\n\n    /**\n        @notice Get if the pool is locked or not. (not accepting exit and entry)\n        @return Boolean indicating if the pool is locked\n    */\n    function getLock() external view returns (bool);\n\n    /**\n        @notice Get the block until which the pool is locked\n        @return The lock block\n    */\n    function getLockBlock() external view returns (uint256);\n\n    /**\n        @notice Set the lock block\n        @param _lock Block height of the lock\n    */\n    function setLock(uint256 _lock) external;\n\n    /**\n        @notice Get the maximum of pool tokens that can be minted\n        @return Cap\n    */\n    function getCap() external view returns (uint256);\n\n    /**\n        @notice Set the maximum of pool tokens that can be minted\n        @param _maxCap Max cap \n    */\n    function setCap(uint256 _maxCap) external;\n\n    /**\n        @notice Get the amount of tokens owned by the pool\n        @param _token Addres of the token\n        @return Amount owned by the contract\n    */\n    function balance(address _token) external view returns (uint256);\n\n    /**\n        @notice Get the tokens in the pool\n        @return Array of tokens in the pool\n    */\n    function getTokens() external view returns (address[] memory);\n\n    /**\n        @notice Add a token to the pool. Should have at least a balance of 10**6\n        @param _token Address of the token to add\n    */\n    function addToken(address _token) external;\n\n    /**\n        @notice Removes a token from the pool\n        @param _token Address of the token to remove\n    */\n    function removeToken(address _token) external;\n\n    /**\n        @notice Checks if a token was added to the pool\n        @param _token address of the token\n        @return If token is in the pool or not\n    */\n    function getTokenInPool(address _token) external view returns (bool);\n\n    /**\n        @notice Calculate the amounts of underlying needed to mint that pool amount.\n        @param _amount Amount of pool tokens to mint\n        @return tokens Tokens needed\n        @return amounts Amounts of underlying needed\n    */\n    function calcTokensForAmount(uint256 _amount)\n        external\n        view\n        returns (address[] memory tokens, uint256[] memory amounts);\n\n    /**\n        @notice Calculate the amounts of underlying to receive when burning that pool amount\n        @param _amount Amount of pool tokens to burn\n        @return tokens Tokens returned\n        @return amounts Amounts of underlying returned\n    */\n    function calcTokensForAmountExit(uint256 _amount)\n        external\n        view\n        returns (address[] memory tokens, uint256[] memory amounts);\n}"
    },
    "contracts/interfaces/IERC20Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface IERC20Facet {\n    \n    /**\n        @notice Get the token name\n        @return The token name\n    */\n    function name() external view returns (string memory);\n\n    /**\n        @notice Get the token symbol\n        @return The token symbol \n    */\n    function symbol() external view returns (string memory);\n\n    /**\n        @notice Get the amount of decimals\n        @return Amount of decimals\n    */\n    function decimals() external view returns (uint8);\n\n    /**\n        @notice Mints tokens. Can only be called by the contract owner or the contract itself\n        @param _receiver Address receiving the tokens\n        @param _amount Amount to mint\n    */\n    function mint(address _receiver, uint256 _amount) external;\n\n    /**\n        @notice Burns tokens. Can only be called by the contract owner or the contract itself\n        @param _from Address to burn from\n        @param _amount Amount to burn\n    */\n    function burn(address _from, uint256 _amount) external;\n\n    /**\n        @notice Sets up the metadata and initial supply. Can be called by the contract owner\n        @param _initialSupply Initial supply of the token\n        @param _name Name of the token\n        @param _symbol Symbol of the token\n    */\n    function initialize(\n        uint256 _initialSupply,\n        string memory _name,\n        string memory _symbol\n    ) external;\n\n    /**\n        @notice Set the token name of the contract. Can only be called by the contract owner or the contract itself\n        @param _name New token name\n    */\n    function setName(string calldata _name) external;\n\n    /**\n        @notice Set the token symbol of the contract. Can only be called by the contract owner or the contract itself\n        @param _symbol New token symbol\n    */\n    function setSymbol(string calldata _symbol) external;\n    \n    /**\n        @notice Increase the amount of tokens another address can spend\n        @param _spender Spender\n        @param _amount Amount to increase by\n    */\n    function increaseApproval(address _spender, uint256 _amount) external returns (bool);\n\n    /**\n        @notice Decrease the amount of tokens another address can spend\n        @param _spender Spender\n        @param _amount Amount to decrease by\n    */\n    function decreaseApproval(address _spender, uint256 _amount) external returns (bool);\n\n}"
    },
    "contracts/interfaces/ICallFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface ICallFacet {\n\n    event CallerAdded(address indexed caller);\n    event CallerRemoved(address indexed caller);\n    event Call(address indexed caller, address indexed target, bytes data, uint256 value);\n\n    /**\n        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool. Reverts if one of the calls fails\n        @param _targets Array of addresses of targets to call\n        @param _calldata Array of calldata for each call\n        @param _values Array of amounts of ETH to send with the call\n    */\n    function call(\n        address[] memory _targets,\n        bytes[] memory _calldata,\n        uint256[] memory _values\n    ) external;\n\n    /**\n        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool without sending any Ether. Reverts if one of the calls fail\n        @param _targets Array of addresses of targets to call\n        @param _calldata Array of calldata for each call\n    */\n    function callNoValue(\n        address[] memory _targets,\n        bytes[] memory _calldata\n    ) external;\n\n    /**\n        @notice Lets whitelisted callers execute a single arbitrary call from the pool. Reverts if the call fails\n        @param _target Address of the target to call\n        @param _calldata Calldata of the call\n        @param _value Amount of ETH to send with the call\n    */\n    function singleCall(\n        address _target,\n        bytes calldata _calldata,\n        uint256 _value\n    ) external;\n\n    /**\n        @notice Add a whitelisted caller. Can only be called by the contract owner\n        @param _caller Caller to add\n    */\n    function addCaller(address _caller) external;\n\n    /**\n        @notice Remove a whitelisted caller. Can only be called by the contract owner\n    */\n    function removeCaller(address _caller) external;\n\n    /**\n        @notice Checks if an address is a whitelisted caller\n        @param _caller Address to check\n        @return If the address is whitelisted\n    */\n    function canCall(address _caller) external view returns (bool);\n\n    /**\n        @notice Get all whitelisted callers\n        @return Array of whitelisted callers\n    */\n    function getCallers() external view returns (address[] memory);\n}"
    },
    "contracts/callManagers/LendingManager/StakeSushi.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/IXSushi.sol\";\n\ncontract StakingLogicSushi is ILendingLogic {\n\n    LendingRegistry public lendingRegistry;\n    bytes32 public immutable protocolKey;\n\n    constructor(address _lendingRegistry, bytes32 _protocolKey) {\n        require(_lendingRegistry != address(0), \"INVALID_LENDING_REGISTRY\");\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        protocolKey = _protocolKey;\n    }\n\n    function getAPRFromWrapped(address _token) public view override returns(uint256) {\n        return uint256(-1);\n    }\n\n    function getAPRFromUnderlying(address _token) external view override returns(uint256) {\n        return uint256(-1);\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n\n        address SushiBar = lendingRegistry.underlyingToProtocolWrapped(_underlying, protocolKey);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, SushiBar, 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, SushiBar, _amount);\n\n        // Stake in Sushi Bar\n        targets[2] = SushiBar;\n\n        data[2] =  abi.encodeWithSelector(IXSushi.enter.selector, _amount);\n\n        return(targets, data);\n    }\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(IXSushi.leave.selector, _amount);\n\n        return(targets, data);\n    }\n\n    function exchangeRate(address _wrapped) external view override returns(uint256) {\n        return _exchangeRate(_wrapped);\n    }\n\n    function exchangeRateView(address _wrapped) external view override returns(uint256) {\n        return _exchangeRate(_wrapped);\n    }\n\n    function _exchangeRate(address _wrapped) internal view returns(uint256) {\n        IERC20 xToken = IERC20(_wrapped);\n        IERC20 token = IERC20(lendingRegistry.wrappedToUnderlying(_wrapped));\n        return token.balanceOf(_wrapped) * 10**18 / xToken.totalSupply();\n    }\n\n}"
    },
    "contracts/interfaces/IXSushi.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\ninterface IXSushi {\n    function enter(uint256 _amount) external;\n    function leave(uint256 _share) external;\n}"
    },
    "contracts/callManagers/LendingManager/StakingLogicYGov.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/IYVault.sol\";\n\ncontract StakingLogicYGov is ILendingLogic {\n\n    LendingRegistry public lendingRegistry;\n    bytes32 public immutable protocolKey;\n\n    constructor(address _lendingRegistry, bytes32 _protocolKey) {\n        require(_lendingRegistry != address(0), \"INVALID_LENDING_REGISTRY\");\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        protocolKey = _protocolKey;\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n\n        address YGov = lendingRegistry.underlyingToProtocolWrapped(_underlying, protocolKey);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, YGov, 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, YGov, _amount);\n\n        // Stake in Sushi Bar\n        targets[2] = YGov;\n\n        data[2] =  abi.encodeWithSelector(IYVault.deposit.selector, _amount);\n\n        return(targets, data);\n    }\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(IYVault.withdraw.selector, _amount);\n\n        return(targets, data);\n    }\n\n    function getAPRFromUnderlying(address _token) external view override returns(uint256) {\n        return uint256(-1);\n    }\n\n    function getAPRFromWrapped(address _token) external view override returns(uint256) {\n        return uint256(-1);\n    }\n    \n    function exchangeRate(address _wrapped) external view override returns(uint256) {\n        return IYVault(_wrapped).getPricePerFullShare();\n    }\n\n    function exchangeRateView(address _wrapped) external view override returns(uint256) {\n        return IYVault(_wrapped).getPricePerFullShare();\n    }\n\n}"
    },
    "contracts/interfaces/IYVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\ninterface IYVault {\n    function depositAll() external;\n    function deposit(uint _amount) external;\n    function withdraw(uint _shares) external;\n    function getPricePerFullShare() external view returns (uint);\n}"
    },
    "contracts/callManagers/RSIManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ISynthetix.sol\";\nimport \"../interfaces/IExperiPie.sol\";\nimport \"../interfaces/IPriceReferenceFeed.sol\";\n\ncontract RSISynthetixManager {\n\n    address public immutable assetShort;\n    address public immutable assetLong;\n    bytes32 public immutable assetShortKey;\n    bytes32 public immutable assetLongKey;\n\n    // Value under which to go long (30 * 10**18 == 30)\n    int256 public immutable rsiBottom;\n    // Value under which to go short\n    int256 public immutable rsiTop;\n\n    IPriceReferenceFeed public immutable priceFeed;\n    IExperiPie public immutable basket;\n    ISynthetix public immutable synthetix;\n\n    struct RoundData {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt; \n        uint256 updatedAt; \n        uint80 answeredInRound;\n    }\n\n    event Rebalanced(address indexed basket, address indexed fromToken, address indexed toToken);\n\n    constructor(\n        address _assetShort,\n        address _assetLong,\n        bytes32 _assetShortKey,\n        bytes32 _assetLongKey,\n        int256 _rsiBottom,\n        int256 _rsiTop,\n        address _priceFeed,\n        address _basket,\n        address _synthetix\n    ) {\n        assetShort = _assetShort;\n        assetLong = _assetLong;\n        assetShortKey = _assetShortKey;\n        assetLongKey = _assetLongKey;\n\n        require(_assetShort != address(0), \"INVALID_ASSET_SHORT\");\n        require(_assetLong != address(0), \"INVALID_ASSET_LONG\");\n        require(_assetShortKey != bytes32(0), \"INVALID_ASSET_SHORT_KEY\");\n        require(_assetLongKey != bytes32(0), \"INVALID_ASSET_LONG_KEY\");\n\n        require(_rsiBottom < _rsiTop, \"RSI bottom should be bigger than RSI top\");\n        require(_rsiBottom > 0, \"RSI bottom should be bigger than 0\");\n        require(_rsiTop < 100 * 10**18, \"RSI top should be less than 100\");\n\n        require(_priceFeed != address(0), \"INVALID_PRICE_FEED\");\n        require(_basket != address(0), \"INVALID_BASKET\");\n        require(_synthetix != address(0), \"INVALID_SYNTHETIX\");\n\n        rsiBottom = _rsiBottom;\n        rsiTop = _rsiTop;\n\n        priceFeed = IPriceReferenceFeed(_priceFeed);\n        basket = IExperiPie(_basket);\n        synthetix = ISynthetix(_synthetix);\n    }\n\n\n    function rebalance() external {\n        RoundData memory roundData = readLatestRound();\n        require(roundData.updatedAt > 0, \"Round not complete\");\n\n        if(roundData.answer <= rsiBottom) {\n            // long\n            long();\n            return;\n        } else if(roundData.answer >= rsiTop) {\n            // Short\n            short();\n            return;\n        }\n    }\n\n    function long() internal {\n        IERC20 currentToken = IERC20(getCurrentToken());\n        require(address(currentToken) == assetShort, \"Can only long when short\");\n\n        uint256 currentTokenBalance = currentToken.balanceOf(address(basket));\n\n        address[] memory targets = new address[](4);\n        bytes[] memory data = new bytes[](4);\n        uint256[] memory values = new uint256[](4);\n\n        // lock pool\n        targets[0] = address(basket);\n        // lock for 30\n        data[0] = setLockData(block.number + 30);\n\n        // Swap on synthetix\n        targets[1] = address(synthetix);\n        data[1] = abi.encodeWithSelector(synthetix.exchange.selector, assetShortKey, currentTokenBalance, assetLongKey);\n\n\n        // Remove current token\n        targets[2] = address(basket);\n        data[2] = abi.encodeWithSelector(basket.removeToken.selector, assetShort);\n\n        // Add new token\n        targets[3] = address(basket);\n        data[3] = abi.encodeWithSelector(basket.addToken.selector, assetLong);\n\n        // Do calls\n        basket.call(targets, data, values);\n\n        // sanity checks\n        require(currentToken.balanceOf(address(basket)) == 0, \"Current token balance should be zero\");\n        require(IERC20(assetLong).balanceOf(address(basket)) >= 10**6, \"Amount too small\");\n\n        emit Rebalanced(address(basket), assetShort, assetLong);\n    }\n\n    function short() internal {\n        IERC20 currentToken = IERC20(getCurrentToken());\n        require(address(currentToken) == assetLong, \"Can only short when long\");\n\n        uint256 currentTokenBalance = currentToken.balanceOf(address(basket));\n\n        address[] memory targets = new address[](4);\n        bytes[] memory data = new bytes[](4);\n        uint256[] memory values = new uint256[](4);\n\n        // lock pool\n        targets[0] = address(basket);\n        // lock for 30\n        data[0] = setLockData(block.number + 30);\n\n        // Swap on synthetix\n        targets[1] = address(synthetix);\n        data[1] = abi.encodeWithSelector(synthetix.exchange.selector, assetLongKey, currentTokenBalance, assetShortKey);\n\n        // Remove current token\n        targets[2] = address(basket);\n        data[2] = abi.encodeWithSelector(basket.removeToken.selector, assetLong);\n\n        // Add new token\n        targets[3] = address(basket);\n        data[3] = abi.encodeWithSelector(basket.addToken.selector, assetShort);\n\n        // Do calls\n        basket.call(targets, data, values);\n\n        // sanity checks\n        require(currentToken.balanceOf(address(basket)) == 0, \"Current token balance should be zero\");\n        \n        // Catched by addToken in the basket itself\n        // require(IERC20(assetShort).balanceOf(address(basket)) >= 10**6, \"Amount too small\");\n\n        emit Rebalanced(address(basket), assetShort, assetLong);\n    }\n\n    function getCurrentToken() public view returns(address) {\n        address[] memory tokens = basket.getTokens();\n        require(tokens.length == 1, \"RSI Pie can only have 1 asset at the time\");\n        return tokens[0];\n    }\n\n\n    function setLockData(uint256 _block) internal returns(bytes memory data) {\n        bytes memory data = abi.encodeWithSelector(basket.setLock.selector, _block);\n        return data;\n    }\n    function readRound(uint256 _round) public view returns(RoundData memory data) {\n        (\n            uint80 roundId, \n            int256 answer, \n            uint256 startedAt, \n            uint256 updatedAt, \n            uint80 answeredInRound\n        ) = priceFeed.getRoundData(uint80(_round));\n\n        return RoundData({\n            roundId: roundId,\n            answer: answer,\n            startedAt: startedAt,\n            updatedAt: updatedAt,\n            answeredInRound: answeredInRound\n        });\n    }\n\n    function readLatestRound() public view returns(RoundData memory data) {\n        (\n            uint80 roundId, \n            int256 answer, \n            uint256 startedAt, \n            uint256 updatedAt, \n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        return RoundData({\n            roundId: roundId,\n            answer: answer,\n            startedAt: startedAt,\n            updatedAt: updatedAt,\n            answeredInRound: answeredInRound\n        });\n    }\n\n}"
    },
    "contracts/interfaces/ISynthetix.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface ISynthetix {\n    function exchange(bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey) external;\n}"
    },
    "contracts/interfaces/IPriceReferenceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\n\ninterface IPriceReferenceFeed {\n    function getRoundData(uint80 _roundId) external view returns (\n        uint80 roundId, \n        int256 answer, \n        uint256 startedAt, \n        uint256 updatedAt, \n        uint80 answeredInRound\n    );\n    function latestRoundData() external view returns (\n        uint80 roundId, \n        int256 answer, \n        uint256 startedAt, \n        uint256 updatedAt, \n        uint80 answeredInRound\n    );\n}"
    },
    "contracts/facets/Basket/BasketFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../interfaces/IBasketFacet.sol\";\nimport \"../ERC20/LibERC20Storage.sol\";\nimport \"../ERC20/LibERC20.sol\";\nimport \"../shared/Reentry/ReentryProtection.sol\";\nimport \"../shared/Access/CallProtection.sol\";\nimport \"./LibBasketStorage.sol\";\n\ncontract BasketFacet is ReentryProtection, CallProtection, IBasketFacet {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MIN_AMOUNT = 10**6;\n    uint256 public constant MAX_ENTRY_FEE = 10**17; // 10%\n    uint256 public constant MAX_EXIT_FEE = 10**17; // 10%\n    uint256 public constant MAX_ANNUAL_FEE = 10**17; // 10%\n    uint256 public constant HUNDRED_PERCENT = 10 ** 18;\n\n    // Assuming a block gas limit of 12M this allows for a gas consumption per token of roughly 333k allowing 2M of overhead for addtional operations\n    uint256 public constant MAX_TOKENS = 30;\n\n    function addToken(address _token) external override protectedCall {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        require(!bs.inPool[_token], \"TOKEN_ALREADY_IN_POOL\");\n        require(bs.tokens.length < MAX_TOKENS, \"TOKEN_LIMIT_REACHED\");\n        // Enforce minimum to avoid rounding errors; (Minimum value is the same as in Balancer)\n        require(balance(_token) >= MIN_AMOUNT, \"BALANCE_TOO_SMALL\");\n\n        bs.inPool[_token] = true;\n        bs.tokens.push(IERC20(_token));\n\n        emit TokenAdded(_token);\n    }\n\n    function removeToken(address _token) external override protectedCall {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n\n        require(bs.inPool[_token], \"TOKEN_NOT_IN_POOL\");\n\n        bs.inPool[_token] = false;\n\n        // remove token from array\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            if(address(bs.tokens[i]) == _token) {\n                bs.tokens[i] = bs.tokens[bs.tokens.length - 1];\n                bs.tokens.pop();\n                emit TokenRemoved(_token);\n                break;\n            }\n        }\n    }\n\n    function setEntryFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_ENTRY_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().entryFee = _fee;\n        emit EntryFeeSet(_fee);\n    }\n\n    function getEntryFee() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().entryFee;\n    }\n\n    function setExitFee(uint256 _fee) external override protectedCall {\n        require(_fee <= MAX_EXIT_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().exitFee = _fee;\n        emit ExitFeeSet(_fee);\n    }\n\n    function getExitFee() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().exitFee;\n    }\n\n    function setAnnualizedFee(uint256 _fee) external override protectedCall {\n        chargeOutstandingAnnualizedFee();\n        require(_fee <= MAX_ANNUAL_FEE, \"FEE_TOO_BIG\");\n        LibBasketStorage.basketStorage().annualizedFee = _fee;\n        emit AnnualizedFeeSet(_fee);\n    }\n\n    function getAnnualizedFee() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().annualizedFee;\n    }\n\n    function setFeeBeneficiary(address _beneficiary) external override protectedCall {\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.basketStorage().feeBeneficiary = _beneficiary;\n        emit FeeBeneficiarySet(_beneficiary);\n    }\n\n    function getFeeBeneficiary() external view override returns(address) {\n        return LibBasketStorage.basketStorage().feeBeneficiary;\n    }\n\n    function setEntryFeeBeneficiaryShare(uint256 _share) external override protectedCall {\n        require(_share <= HUNDRED_PERCENT, \"FEE_SHARE_TOO_BIG\");\n        LibBasketStorage.basketStorage().entryFeeBeneficiaryShare = _share;\n        emit EntryFeeBeneficiaryShareSet(_share);\n    }\n\n    function getEntryFeeBeneficiaryShare() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().entryFeeBeneficiaryShare;\n    }\n\n    function setExitFeeBeneficiaryShare(uint256 _share) external override protectedCall {\n        require(_share <= HUNDRED_PERCENT, \"FEE_SHARE_TOO_BIG\");\n        LibBasketStorage.basketStorage().exitFeeBeneficiaryShare = _share;\n        emit ExitFeeBeneficiaryShareSet(_share);\n    }\n\n    function getExitFeeBeneficiaryShare() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().exitFeeBeneficiaryShare;\n    }\n\n\n    function joinPool(uint256 _amount) external override noReentry {\n        require(!this.getLock(), \"POOL_LOCKED\");\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n        require(totalSupply.add(_amount) <= this.getCap(), \"MAX_POOL_CAP_REACHED\");\n\n        uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenAmount = balance(address(token)).mul(_amount.add(feeAmount)).div(totalSupply);\n            require(tokenAmount != 0, \"AMOUNT_TOO_SMALL\");\n            token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n        }\n\n        // If there is any fee that should go to the beneficiary mint it\n        if(\n            feeAmount != 0 &&\n            bs.entryFeeBeneficiaryShare != 0 &&\n            bs.feeBeneficiary != address(0)\n        ) {\n            uint256 feeBeneficiaryShare = feeAmount.mul(bs.entryFeeBeneficiaryShare).div(10**18);\n            if(feeBeneficiaryShare != 0) {\n                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);\n            }\n        }\n\n        LibERC20.mint(msg.sender, _amount);\n        emit PoolJoined(msg.sender, _amount);\n    }\n\n    // Must be overwritten to withdraw from strategies\n    function exitPool(uint256 _amount) external override virtual noReentry {\n        require(!this.getLock(), \"POOL_LOCKED\");\n        chargeOutstandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n\n        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            // redeem less tokens if there is an exit fee\n            uint256 tokenAmount = tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);\n            require(tokenBalance.sub(tokenAmount) >= MIN_AMOUNT, \"TOKEN_BALANCE_TOO_LOW\");\n            token.safeTransfer(msg.sender, tokenAmount);\n        }\n\n         // If there is any fee that should go to the beneficiary mint it\n        if(\n            feeAmount != 0 &&\n            bs.exitFeeBeneficiaryShare != 0 &&\n            bs.feeBeneficiary != address(0)\n        ) {\n            uint256 feeBeneficiaryShare = feeAmount.mul(bs.exitFeeBeneficiaryShare).div(10**18);\n            if(feeBeneficiaryShare != 0) {\n                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);\n            }\n        }\n\n        require(totalSupply.sub(_amount) >= MIN_AMOUNT, \"POOL_TOKEN_BALANCE_TOO_LOW\");\n        LibERC20.burn(msg.sender, _amount);\n        emit PoolExited(msg.sender, _amount);\n    }\n\n\n    function calcOutStandingAnnualizedFee() public view override returns(uint256) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;\n\n        uint256 lastFeeClaimed = bs.lastAnnualizedFeeClaimed;\n        uint256 annualizedFee = bs.annualizedFee;\n\n        if(\n            annualizedFee == 0 ||\n            bs.feeBeneficiary == address(0) ||\n            lastFeeClaimed == 0\n        ) {\n            return 0;\n        }\n\n        uint256 timePassed = block.timestamp.sub(lastFeeClaimed);\n\n        return totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(365 days);\n    }\n\n    function chargeOutstandingAnnualizedFee() public override {\n        uint256 outStandingFee = calcOutStandingAnnualizedFee();\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n\n        bs.lastAnnualizedFeeClaimed = block.timestamp;\n\n        // if there is any fee to mint and the beneficiary is set\n        // note: feeBeneficiary is already checked in calc function\n        if(\n            outStandingFee != 0\n        ) {\n            LibERC20.mint(bs.feeBeneficiary, outStandingFee);\n        }\n\n        emit FeeCharged(outStandingFee);\n    }\n\n    // returns true when locked\n    function getLock() external view override returns(bool) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        return bs.lockBlock == 0 || bs.lockBlock >= block.number;\n    }\n\n    function getTokenInPool(address _token) external view override returns(bool) {\n        return LibBasketStorage.basketStorage().inPool[_token];\n    }\n\n    function getLockBlock() external view override returns(uint256) {\n        return LibBasketStorage.basketStorage().lockBlock;\n    }\n\n    // lock up to and including _lock blocknumber\n    function setLock(uint256 _lock) external override protectedCall {\n        LibBasketStorage.basketStorage().lockBlock = _lock;\n        emit LockSet(_lock);\n    }\n\n    function setCap(uint256 _maxCap) external override protectedCall {\n        LibBasketStorage.basketStorage().maxCap = _maxCap;\n        emit CapSet(_maxCap);\n    }\n\n    // Seperated balance function to allow yearn like strategies to be hooked up by inheriting from this contract and overriding\n    function balance(address _token) public view override returns(uint256) {\n        return IERC20(_token).balanceOf(address(this));\n    }\n\n    function getTokens() external view override returns (address[] memory) {\n        IERC20[] memory tokens = LibBasketStorage.basketStorage().tokens;\n        address[] memory result = new address[](tokens.length);\n\n        for(uint256 i = 0; i < tokens.length; i ++) {\n            result[i] = address(tokens[i]);\n        }\n\n        return(result);\n    }\n\n    function getCap() external view override returns(uint256){\n        return LibBasketStorage.basketStorage().maxCap;\n    }\n\n    function calcTokensForAmount(uint256 _amount) external view override returns (address[] memory tokens, uint256[] memory amounts) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply.add(calcOutStandingAnnualizedFee());\n\n        tokens = new address[](bs.tokens.length);\n        amounts = new uint256[](bs.tokens.length);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            uint256 tokenAmount = tokenBalance.mul(_amount).div(totalSupply);\n            // Add entry fee\n            tokenAmount = tokenAmount.add(tokenAmount.mul(bs.entryFee).div(10**18));\n\n            tokens[i] = address(token);\n            amounts[i] = tokenAmount;\n        }\n\n        return(tokens, amounts);\n    }\n\n    function calcTokensForAmountExit(uint256 _amount) external view override returns (address[] memory tokens, uint256[] memory amounts) {\n        LibBasketStorage.BasketStorage storage bs = LibBasketStorage.basketStorage();\n        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);\n        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply.add(calcOutStandingAnnualizedFee());\n\n        tokens = new address[](bs.tokens.length);\n        amounts = new uint256[](bs.tokens.length);\n\n        for(uint256 i; i < bs.tokens.length; i ++) {\n            IERC20 token = bs.tokens[i];\n            uint256 tokenBalance = balance(address(token));\n            uint256 tokenAmount = tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);\n\n            tokens[i] = address(token);\n            amounts[i] = tokenAmount;\n        }\n\n        return(tokens, amounts);\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/facets/ERC20/LibERC20Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nlibrary LibERC20Storage {\n  bytes32 constant ERC_20_STORAGE_POSITION = keccak256(\n    // Compatible with pie-smart-pools\n    \"PCToken.storage.location\"\n  );\n\n  struct ERC20Storage {\n    string name;\n    string symbol;\n    uint256 totalSupply;\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowances;\n  }\n\n  function erc20Storage() internal pure returns (ERC20Storage storage es) {\n    bytes32 position = ERC_20_STORAGE_POSITION;\n    assembly {\n      es.slot := position\n    }\n  }\n}\n"
    },
    "contracts/facets/ERC20/LibERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"./LibERC20Storage.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary LibERC20 {\n  using SafeMath for uint256;\n\n  // Need to include events locally because `emit Interface.Event(params)` does not work\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function mint(address _to, uint256 _amount) internal {\n    require(_to != address(0), \"INVALID_TO_ADDRESS\");\n\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_to] = es.balances[_to].add(_amount);\n    es.totalSupply = es.totalSupply.add(_amount);\n    emit Transfer(address(0), _to, _amount);\n  }\n\n  function burn(address _from, uint256 _amount) internal {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_from] = es.balances[_from].sub(_amount);\n    es.totalSupply = es.totalSupply.sub(_amount);\n    emit Transfer(_from, address(0), _amount);\n  }\n}\n"
    },
    "contracts/facets/shared/Reentry/ReentryProtection.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"./LibReentryProtectionStorage.sol\";\n\ncontract ReentryProtection {\n  modifier noReentry {\n    // Use counter to only write to storage once\n    LibReentryProtectionStorage.RPStorage storage s = LibReentryProtectionStorage.rpStorage();\n    s.lockCounter++;\n    uint256 lockValue = s.lockCounter;\n    _;\n    require(\n      lockValue == s.lockCounter,\n      \"ReentryProtectionFacet.noReentry: reentry detected\"\n    );\n  }\n}\n"
    },
    "contracts/facets/shared/Reentry/LibReentryProtectionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nlibrary LibReentryProtectionStorage {\n  bytes32 constant REENTRY_STORAGE_POSITION = keccak256(\n    \"diamond.standard.reentry.storage\"\n  );\n\n  struct RPStorage {\n    uint256 lockCounter;\n  }\n\n  function rpStorage() internal pure returns (RPStorage storage bs) {\n    bytes32 position = REENTRY_STORAGE_POSITION;\n    assembly {\n      bs.slot := position\n    }\n  }\n}\n"
    },
    "contracts/facets/shared/Access/CallProtection.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@pie-dao/diamond/contracts/libraries/LibDiamond.sol\";\n\ncontract CallProtection {\n    modifier protectedCall() {\n        require(\n            msg.sender == LibDiamond.diamondStorage().contractOwner ||\n            msg.sender == address(this), \"NOT_ALLOWED\"\n        );\n        _;\n    }\n}"
    },
    "@pie-dao/diamond/contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge\r\n*\r\n* Implementation of Diamond facet.\r\n* This is gas optimized by reducing storage reads and storage writes.\r\n* This code is as complex as it is to reduce gas costs.\r\n/******************************************************************************/\r\n\r\nimport \"../interfaces/IDiamondCut.sol\";\r\n\r\nlibrary LibDiamond {\r\n        bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct DiamondStorage {\r\n        // maps function selectors to the facets that execute the functions.\r\n        // and maps the selectors to their position in the selectorSlots array.        \r\n        // func selector => address facet, selector position\r\n        mapping(bytes4 => bytes32) facets;\r\n        // array of slots of function selectors.\r\n        // each slot holds 8 function selectors.\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        // The number of function selectors in selectorSlots\r\n        uint16 selectorCount;\r\n        // owner of the contract\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // owner of the contract\r\n        address contractOwner;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n   \r\n   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n   function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() view internal {\r\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n        _;\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    // Internal function version of diamondCut\r\n    // This code is almost the same as the external diamondCut,\r\n    // except it is using 'Facet[] memory _diamondCut' instead of\r\n    // 'Facet[] calldata _diamondCut'.\r\n    // The code is duplicated to prevent copying calldata to memory which\r\n    // causes an error for a two dimensional array.\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        if (selectorCount % 8 > 0) {\r\n            // get last selectorSlot\r\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        if (selectorCount % 8 > 0) {\r\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");        \r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n            require(_newFacetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];                \r\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n                // add facet for selector                                \r\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);                \r\n                uint256 selectorInSlotPosition = (_selectorCount % 8) * 32;\r\n                // clear selector position in slot and add selector\r\n                _selectorSlot =\r\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\r\n                    (bytes32(selector) >> selectorInSlotPosition);\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    ds.selectorSlots[_selectorCount / 8] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n                _selectorCount++;\r\n            }\r\n        } else if(_action == IDiamondCut.FacetCutAction.Replace) {\r\n            require(_newFacetAddress != address(0), \"LibDiamondCut: Replace facet can't be address(0)\");\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];  \r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n                // only useful if immutable functions exist\r\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\r\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\r\n                // replace old facet address\r\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\r\n            }\r\n        } else if(_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n            uint256 selectorSlotCount = _selectorCount / 8;\r\n            uint256 selectorInSlotIndex = (_selectorCount % 8) - 1;\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                if (_selectorSlot == 0) {\r\n                    // get last selectorSlot\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = ds.facets[selector];\r\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\r\n                    // only useful if immutable functions exist\r\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\r\n                    // replace selector with last selector in ds.facets\r\n                    // gets the last selector\r\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex * 32));\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\r\n                    }\r\n                    delete ds.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    oldSelectorsSlotCount = oldSelectorCount / 8;\r\n                    oldSelectorInSlotPosition = (oldSelectorCount % 8) * 32;\r\n                }\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                    // update storage with the modified slot\r\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    _selectorSlot =\r\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete ds.selectorSlots[selectorSlotCount];\r\n                    _selectorSlot = 0;\r\n                }\r\n                selectorInSlotIndex--;\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex + 1;\r\n        } else {\r\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n        }       \r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\r\n        } else {\r\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"LibDiamondCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}\r\n"
    },
    "contracts/facets/Basket/LibBasketStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary LibBasketStorage {\n  bytes32 constant BASKET_STORAGE_POSITION = keccak256(\n    \"diamond.standard.basket.storage\"\n  );\n\n  struct BasketStorage {\n    uint256 lockBlock;\n    uint256 maxCap;\n    IERC20[] tokens;\n    mapping(address => bool) inPool;\n    uint256 entryFee;\n    uint256 entryFeeBeneficiaryShare; // amount of entry fee that goes to feeBeneficiary\n    uint256 exitFee;\n    uint256 exitFeeBeneficiaryShare; // amount of exit fee that goes to the pool itself\n    uint256 annualizedFee;\n    uint256 lastAnnualizedFeeClaimed;\n    address feeBeneficiary;\n  }\n\n  function basketStorage() internal pure returns (BasketStorage storage bs) {\n    bytes32 position = BASKET_STORAGE_POSITION;\n    assembly {\n      bs.slot := position\n    }\n  }\n}\n"
    },
    "contracts/facets/Call/CallFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@pie-dao/diamond/contracts/libraries/LibDiamond.sol\";\nimport \"../../interfaces/ICallFacet.sol\";\nimport \"../shared/Reentry/ReentryProtection.sol\";\nimport \"../shared/Access/CallProtection.sol\";\nimport \"./LibCallStorage.sol\";\n\ncontract CallFacet is ReentryProtection, ICallFacet {\n\n  uint256 public constant MAX_CALLERS = 50;\n\n  // uses modified call protection modifier to also allow whitelisted addresses to call\n  modifier protectedCall() {\n    require(\n        msg.sender == LibDiamond.diamondStorage().contractOwner ||\n        LibCallStorage.callStorage().canCall[msg.sender] ||\n        msg.sender == address(this), \"NOT_ALLOWED\"\n    );\n    _;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == LibDiamond.diamondStorage().contractOwner, \"NOT_ALLOWED\");\n    _;\n  }\n\n  function addCaller(address _caller) external override onlyOwner {\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(callStorage.callers.length < MAX_CALLERS, \"TOO_MANY_CALLERS\");\n    require(!callStorage.canCall[_caller], \"IS_ALREADY_CALLER\");\n    require(_caller != address(0), \"INVALID_CALLER\");\n\n    callStorage.callers.push(_caller);\n    callStorage.canCall[_caller] = true;\n\n    emit CallerAdded(_caller);\n  }\n\n  function removeCaller(address _caller) external override onlyOwner {\n    LibCallStorage.CallStorage storage callStorage = LibCallStorage.callStorage();\n\n    require(callStorage.canCall[_caller], \"IS_NOT_CALLER\");\n\n    callStorage.canCall[_caller] = false;\n\n    for(uint256 i = 0; i < callStorage.callers.length; i ++) {\n      address currentCaller = callStorage.callers[i];\n\n      // if found remove it\n      if(currentCaller == _caller) {\n        callStorage.callers[i] = callStorage.callers[callStorage.callers.length - 1];\n        callStorage.callers.pop();\n        break;\n      }\n    }\n\n    emit CallerRemoved(_caller);\n  }\n\n  function call(\n    address[] memory _targets,\n    bytes[] memory _calldata,\n    uint256[] memory _values\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length && _values.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], _values[i]);\n    }\n  }\n\n  function callNoValue(\n    address[] memory _targets,\n    bytes[] memory _calldata\n  ) public override noReentry protectedCall {\n    require(\n      _targets.length == _calldata.length,\n      \"ARRAY_LENGTH_MISMATCH\"\n    );\n\n    for (uint256 i = 0; i < _targets.length; i++) {\n      _call(_targets[i], _calldata[i], 0);\n    }\n  }\n\n  function singleCall(\n    address _target,\n    bytes calldata _calldata,\n    uint256 _value\n  ) external override noReentry protectedCall {\n    _call(_target, _calldata, _value);\n  }\n\n  function _call(\n    address _target,\n    bytes memory _calldata,\n    uint256 _value\n  ) internal {\n    require(address(this).balance >= _value, \"ETH_BALANCE_TOO_LOW\");\n    (bool success, ) = _target.call{ value: _value }(_calldata);\n    require(success, \"CALL_FAILED\");\n    emit Call(msg.sender, _target, _calldata, _value);\n  }\n\n  function canCall(address _caller) external view override returns (bool) {\n    return LibCallStorage.callStorage().canCall[_caller];\n  }\n\n  function getCallers() external view override returns (address[] memory) {\n    return LibCallStorage.callStorage().callers;\n  }\n}\n"
    },
    "contracts/facets/Call/LibCallStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nlibrary LibCallStorage {\n  bytes32 constant CALL_STORAGE_POSITION = keccak256(\n    \"diamond.standard.call.storage\"\n  );\n\n  struct CallStorage {\n    mapping(address => bool) canCall;\n    address[] callers;\n  }\n\n  function callStorage() internal pure returns (CallStorage storage cs) {\n    bytes32 position = CALL_STORAGE_POSITION;\n    assembly {\n      cs.slot := position\n    }\n  }\n}\n"
    },
    "contracts/facets/ERC20/ERC20Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@pie-dao/diamond/contracts/libraries/LibDiamond.sol\";\n\nimport \"../../interfaces/IERC20Facet.sol\";\nimport \"./LibERC20Storage.sol\";\nimport \"./LibERC20.sol\";\nimport \"../shared/Access/CallProtection.sol\";\n\ncontract ERC20Facet is IERC20, IERC20Facet, CallProtection {\n  using SafeMath for uint256;\n\n  function initialize(\n    uint256 _initialSupply,\n    string memory _name,\n    string memory _symbol\n  ) external override {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    require(\n      bytes(es.name).length == 0 &&\n      bytes(es.symbol).length == 0,\n      \"ALREADY_INITIALIZED\"\n    );\n\n    require(\n      bytes(_name).length != 0 &&\n      bytes(_symbol).length != 0,\n      \"INVALID_PARAMS\"\n    );\n\n    require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n    LibERC20.mint(msg.sender, _initialSupply);\n\n    es.name = _name;\n    es.symbol = _symbol;\n  }\n\n  function name() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().name;\n  }\n\n  function setName(string calldata _name) external override protectedCall {\n    LibERC20Storage.erc20Storage().name = _name;\n  }\n\n  function symbol() external view override returns (string memory) {\n    return LibERC20Storage.erc20Storage().symbol;\n  }\n\n  function setSymbol(string calldata _symbol) external override protectedCall {\n    LibERC20Storage.erc20Storage().symbol = _symbol;\n  }\n\n  function decimals() external pure override returns (uint8) {\n    return 18;\n  }\n\n  function mint(address _receiver, uint256 _amount) external override protectedCall {\n    LibERC20.mint(_receiver, _amount);\n  }\n\n  function burn(address _from, uint256 _amount) external override protectedCall {\n    LibERC20.burn(_from, _amount);\n  }\n\n  function approve(address _spender, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    require(_spender != address(0), \"SPENDER_INVALID\");\n    LibERC20Storage.erc20Storage().allowances[msg.sender][_spender] = _amount;\n    emit Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  function increaseApproval(address _spender, uint256 _amount) external override returns (bool) {\n    require(_spender != address(0), \"SPENDER_INVALID\");\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n    es.allowances[msg.sender][_spender] = es.allowances[msg.sender][_spender].add(_amount);\n    emit Approval(msg.sender, _spender, es.allowances[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint256 _amount) external override returns (bool) {\n    require(_spender != address(0), \"SPENDER_INVALID\");\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n    uint256 oldValue = es.allowances[msg.sender][_spender];\n    if (_amount > oldValue) {\n      es.allowances[msg.sender][_spender] = 0;\n    } else {\n      es.allowances[msg.sender][_spender] = oldValue.sub(_amount);\n    }\n    emit Approval(msg.sender, _spender, es.allowances[msg.sender][_spender]);\n    return true;\n  }\n\n  function transfer(address _to, uint256 _amount)\n    external\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, _to, _amount);\n    return true;\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external override returns (bool) {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n    require(_from != address(0), \"FROM_INVALID\");\n\n    // Update approval if not set to max uint256\n    if (es.allowances[_from][msg.sender] != uint256(-1)) {\n      uint256 newApproval = es.allowances[_from][msg.sender].sub(_amount);\n      es.allowances[_from][msg.sender] = newApproval;\n      emit Approval(_from, msg.sender, newApproval);\n    }\n\n    _transfer(_from, _to, _amount);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return LibERC20Storage.erc20Storage().allowances[_owner][_spender];\n  }\n\n  function balanceOf(address _of) external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().balances[_of];\n  }\n\n  function totalSupply() external view override returns (uint256) {\n    return LibERC20Storage.erc20Storage().totalSupply;\n  }\n\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal {\n    LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n    es.balances[_from] = es.balances[_from].sub(_amount);\n    es.balances[_to] = es.balances[_to].add(_amount);\n\n    emit Transfer(_from, _to, _amount);\n  }\n}"
    },
    "contracts/factories/PieFactoryContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@pie-dao/diamond/contracts/Diamond.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@pie-dao/proxy/contracts/PProxy.sol\";\n\nimport \"../interfaces/IExperiPie.sol\";\n\ncontract PieFactoryContract is Ownable {\n    using SafeERC20 for IERC20;\n\n    address[] public pies;\n    mapping(address => bool) public isPie;\n    address public defaultController;\n    address public diamondImplementation;\n\n    IDiamondCut.FacetCut[] public defaultCut;\n\n    event PieCreated(\n        address indexed pieAddress,\n        address indexed deployer,\n        uint256 indexed index\n    );\n\n    event DefaultControllerSet(address indexed controller);\n    event FacetAdded(IDiamondCut.FacetCut);\n    event FacetRemoved(IDiamondCut.FacetCut);\n\n    constructor() {\n        defaultController = msg.sender;\n    }\n\n    function setDefaultController(address _controller) external onlyOwner {\n        defaultController = _controller;\n        emit DefaultControllerSet(_controller);\n    }\n\n    function removeFacet(uint256 _index) external onlyOwner {\n        require(_index < defaultCut.length, \"INVALID_INDEX\");\n        emit FacetRemoved(defaultCut[_index]);\n        defaultCut[_index] = defaultCut[defaultCut.length - 1];\n        defaultCut.pop();\n    }\n\n    function addFacet(IDiamondCut.FacetCut memory _facet) external onlyOwner {\n        defaultCut.push(_facet);\n        emit FacetAdded(_facet);\n    }\n\n    // Diamond should be Initialized to prevent it from being selfdestructed\n    function setDiamondImplementation(address _diamondImplementation) external onlyOwner {\n        diamondImplementation = _diamondImplementation;\n    }\n\n    function bakePie(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _initialSupply,\n        string memory _symbol,\n        string memory _name\n    ) external {\n        PProxy proxy = new PProxy();\n        Diamond d = Diamond(address(proxy));\n\n        proxy.setImplementation(diamondImplementation);\n\n        d.initialize(defaultCut, address(this));\n\n        pies.push(address(d));\n        isPie[address(d)] = true;\n\n        // emit DiamondCreated(address(d));\n        require(_tokens.length != 0, \"CANNOT_CREATE_ZERO_TOKEN_LENGTH_PIE\");\n        require(_tokens.length == _amounts.length, \"ARRAY_LENGTH_MISMATCH\");\n\n        IExperiPie pie = IExperiPie(address(d));\n\n        // Init erc20 facet\n        pie.initialize(_initialSupply, _name, _symbol);\n\n        // Transfer and add tokens\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20 token = IERC20(_tokens[i]);\n            token.safeTransferFrom(msg.sender, address(pie), _amounts[i]);\n            pie.addToken(_tokens[i]);\n        }\n\n        // Unlock pool\n        pie.setLock(1);\n\n        // Uncap pool\n        pie.setCap(uint256(-1));\n\n        // Send minted pie to msg.sender\n        pie.transfer(msg.sender, _initialSupply);\n        pie.transferOwnership(defaultController);\n        proxy.setProxyOwner(defaultController);\n\n        emit PieCreated(address(d), msg.sender, pies.length - 1);\n    }\n\n    function getDefaultCut()\n        external\n        view\n        returns (IDiamondCut.FacetCut[] memory)\n    {\n        return defaultCut;\n    }\n\n    function getDefaultCutCount() external view returns (uint256) {\n        return defaultCut.length;\n    }\n}\n"
    },
    "@pie-dao/diamond/contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n*\r\n* Implementation of a diamond.\r\n/******************************************************************************/\r\n\r\nimport \"./libraries/LibDiamond.sol\";\r\nimport \"./libraries/LibDiamondInitialize.sol\";\r\nimport \"./interfaces/IDiamondLoupe.sol\";\r\nimport \"./interfaces/IDiamondCut.sol\";\r\nimport \"./interfaces/IERC173.sol\";\r\nimport \"./interfaces/IERC165.sol\";\r\n\r\ncontract Diamond {\r\n    function initialize(IDiamondCut.FacetCut[] memory _diamondCut, address _owner) external payable {\r\n        require(LibDiamondInitialize.diamondInitializeStorage().initialized == false, \"ALREADY_INITIALIZED\");\r\n        LibDiamondInitialize.diamondInitializeStorage().initialized = true;\r\n        LibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\r\n        LibDiamond.setContractOwner(_owner);\r\n\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n\r\n        // adding ERC165 data\r\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        LibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        address facet = address(bytes20(ds.facets[msg.sig]));\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n                case 0 {\r\n                    revert(0, returndatasize())\r\n                }\r\n                default {\r\n                    return(0, returndatasize())\r\n                }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "@pie-dao/diamond/contracts/libraries/LibDiamondInitialize.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Mick de Graaf\r\n*\r\n* Tracks if the contract is already intialized or not\r\n/******************************************************************************/\r\n\r\nimport \"../interfaces/IDiamondCut.sol\";\r\n\r\nlibrary LibDiamondInitialize {\r\n    bytes32 constant DIAMOND_INITIALIZE_STORAGE_POSITION = keccak256(\"diamond.standard.initialize.diamond.storage\");\r\n\r\n    struct InitializedStorage {\r\n        bool initialized;\r\n    }\r\n\r\n    function diamondInitializeStorage() internal pure returns (InitializedStorage storage ids) {\r\n        bytes32 position = DIAMOND_INITIALIZE_STORAGE_POSITION;\r\n        assembly {\r\n            ids.slot := position\r\n        }\r\n    }\r\n\r\n}"
    },
    "@pie-dao/diamond/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
    },
    "@pie-dao/proxy/contracts/PProxy.sol": {
      "content": "pragma solidity ^0.7.1;\r\n\r\nimport \"./PProxyStorage.sol\";\r\n\r\ncontract PProxy is PProxyStorage {\r\n\r\n    bytes32 constant IMPLEMENTATION_SLOT = keccak256(abi.encodePacked(\"IMPLEMENTATION_SLOT\"));\r\n    bytes32 constant OWNER_SLOT = keccak256(abi.encodePacked(\"OWNER_SLOT\"));\r\n\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == readAddress(OWNER_SLOT), \"PProxy.onlyProxyOwner: msg sender not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor () public {\r\n        setAddress(OWNER_SLOT, msg.sender);\r\n    }\r\n\r\n    function getProxyOwner() public view returns (address) {\r\n       return readAddress(OWNER_SLOT);\r\n    }\r\n\r\n    function setProxyOwner(address _newOwner) onlyProxyOwner public {\r\n        setAddress(OWNER_SLOT, _newOwner);\r\n    }\r\n\r\n    function getImplementation() public view returns (address) {\r\n        return readAddress(IMPLEMENTATION_SLOT);\r\n    }\r\n\r\n    function setImplementation(address _newImplementation) onlyProxyOwner public {\r\n        setAddress(IMPLEMENTATION_SLOT, _newImplementation);\r\n    }\r\n\r\n\r\n    fallback () external payable {\r\n       return internalFallback();\r\n    }\r\n\r\n    function internalFallback() internal virtual {\r\n        address contractAddr = readAddress(IMPLEMENTATION_SLOT);\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), contractAddr, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n\r\n}"
    },
    "@pie-dao/proxy/contracts/PProxyStorage.sol": {
      "content": "pragma solidity ^0.7.1;\r\n\r\ncontract PProxyStorage {\r\n\r\n    function readBool(bytes32 _key) public view returns(bool) {\r\n        return storageRead(_key) == bytes32(uint256(1));\r\n    }\r\n\r\n    function setBool(bytes32 _key, bool _value) internal {\r\n        if(_value) {\r\n            storageSet(_key, bytes32(uint256(1)));\r\n        } else {\r\n            storageSet(_key, bytes32(uint256(0)));\r\n        }\r\n    }\r\n\r\n    function readAddress(bytes32 _key) public view returns(address) {\r\n        return bytes32ToAddress(storageRead(_key));\r\n    }\r\n\r\n    function setAddress(bytes32 _key, address _value) internal {\r\n        storageSet(_key, addressToBytes32(_value));\r\n    }\r\n\r\n    function storageRead(bytes32 _key) public view returns(bytes32) {\r\n        bytes32 value;\r\n        //solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            value := sload(_key)\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function storageSet(bytes32 _key, bytes32 _value) internal {\r\n        // targetAddress = _address;  // No!\r\n        bytes32 implAddressStorageKey = _key;\r\n        //solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            sstore(implAddressStorageKey, _value)\r\n        }\r\n    }\r\n\r\n    function bytes32ToAddress(bytes32 _value) public pure returns(address) {\r\n        return address(uint160(uint256(_value)));\r\n    }\r\n\r\n    function addressToBytes32(address _value) public pure returns(bytes32) {\r\n        return bytes32(uint256(_value));\r\n    }\r\n\r\n}"
    },
    "contracts/Imports.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"@pie-dao/diamond/contracts/facets/DiamondCutFacet.sol\";\nimport \"@pie-dao/diamond/contracts/facets/DiamondLoupeFacet.sol\";\nimport \"@pie-dao/diamond/contracts/facets/OwnershipFacet.sol\";\n\n\n// Get the compiler and typechain to pick up these facets\ncontract Imports {\n    DiamondCutFacet public diamondCutFacet;\n    DiamondLoupeFacet public diamondLoupeFacet;\n    OwnershipFacet public ownershipFacet;\n}"
    },
    "@pie-dao/diamond/contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n/******************************************************************************/\r\n\r\nimport \"../interfaces/IDiamondCut.sol\";\r\nimport \"../libraries/LibDiamond.sol\";\r\n\r\ncontract DiamondCutFacet is IDiamondCut {\r\n    // Standard diamondCut external function\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        if (selectorCount % 8 > 0) {\r\n            // get last selectorSlot\r\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        if (selectorCount % 8 > 0) {\r\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        LibDiamond.initializeDiamondCut(_init, _calldata);\r\n    }\r\n}\r\n"
    },
    "@pie-dao/diamond/contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n/******************************************************************************/\r\n\r\nimport \"../libraries/LibDiamond.sol\";\r\nimport \"../interfaces/IDiamondLoupe.sol\";\r\nimport \"../interfaces/IERC165.sol\";\r\n\r\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\r\n    // Diamond Loupe Functions\r\n    ////////////////////////////////////////////////////////////////////\r\n    /// These functions are expected to be called frequently by tools.\r\n    //\r\n    // struct Facet {\r\n    //     address facetAddress;\r\n    //     bytes4[] functionSelectors;\r\n    // }\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external override view returns (Facet[] memory facets_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facets_ = new Facet[](ds.selectorCount);\r\n        uint8[] memory numFacetSelectors = new uint8[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex * 32));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop = false;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\r\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\r\n                        // probably will never have more than 256 functions from one facet contract\r\n                        require(numFacetSelectors[facetIndex] < 255);\r\n                        numFacetSelectors[facetIndex]++;\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continueLoop = false;\r\n                    continue;\r\n                }\r\n                facets_[numFacets].facetAddress = facetAddress_;\r\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\r\n                facets_[numFacets].functionSelectors[0] = selector;\r\n                numFacetSelectors[numFacets] = 1;\r\n                numFacets++;\r\n            }\r\n        }\r\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n            uint256 numSelectors = numFacetSelectors[facetIndex];\r\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\r\n            // setting the number of selectors\r\n            assembly {\r\n                mstore(selectors, numSelectors)\r\n            }\r\n        }\r\n        // setting the number of facets\r\n        assembly {\r\n            mstore(facets_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\r\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 numSelectors;\r\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex * 32));\r\n                address facet = address(bytes20(ds.facets[selector]));\r\n                if (_facet == facet) {\r\n                    _facetFunctionSelectors[numSelectors] = selector;\r\n                    numSelectors++;\r\n                }\r\n            }\r\n        }\r\n        // Set the number of selectors in the array\r\n        assembly {\r\n            mstore(_facetFunctionSelectors, numSelectors)\r\n        }\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddresses_ = new address[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex * 32));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop = false;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continueLoop = false;\r\n                    continue;\r\n                }\r\n                facetAddresses_[numFacets] = facetAddress_;\r\n                numFacets++;\r\n            }\r\n        }\r\n        // Set the number of facet addresses in the array\r\n        assembly {\r\n            mstore(facetAddresses_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        return ds.supportedInterfaces[_interfaceId];\r\n    }\r\n}\r\n"
    },
    "@pie-dao/diamond/contracts/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\n\r\nimport \"../libraries/LibDiamond.sol\";\r\nimport \"../interfaces/IERC173.sol\";\r\n\r\ncontract OwnershipFacet is IERC173 {\r\n    function transferOwnership(address _newOwner) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.setContractOwner(_newOwner);\r\n    }\r\n\r\n    function owner() external override view returns (address owner_) {\r\n        owner_ = LibDiamond.contractOwner();\r\n    }\r\n}"
    },
    "contracts/test/DiamondFactoryContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport \"@pie-dao/diamond/contracts/Diamond.sol\";\n\ncontract DiamondFactoryContract {\n    event DiamondCreated(address tokenAddress);\n\n    address[] public diamonds;\n    mapping(address => bool) public isDiamond;\n\n    function deployNewDiamond(\n        address _owner,\n        IDiamondCut.FacetCut[] memory _diamondCut\n    ) public returns (address) {\n        Diamond d = new Diamond();\n        d.initialize(_diamondCut, _owner);\n\n        diamonds.push(address(d));\n        isDiamond[address(d)] = true;\n\n        emit DiamondCreated(address(d));\n    }\n\n    function getDiamondCount() external view returns (uint256) {\n        return diamonds.length;\n    }\n}\n"
    },
    "contracts/test/ERC20FactoryContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./MockToken.sol\";\n\ncontract ERC20FactoryContract {\n    event TokenCreated(address tokenAddress);\n\n    function deployNewToken(\n        string memory _name,\n        string memory _symbol,\n        uint256 _totalSupply,\n        address _issuer\n    ) public returns (address) {\n        MockToken t = new MockToken(_name, _symbol);\n        t.mint(_totalSupply, _issuer);\n        emit TokenCreated(address(t));\n    }\n}\n"
    },
    "contracts/test/MockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n\n    constructor(string memory _name, string memory _symbol)\n        ERC20(_name, _symbol)\n    {}\n\n    function mint(uint256 _amount, address _issuer) external {\n        _mint(_issuer, _amount);\n    }\n\n    function burn(uint256 _amount, address _from) external {\n        _burn(_from, _amount);\n    }\n\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/test/ManualPriceReferenceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IPriceReferenceFeed.sol\";\n\ncontract ManualPriceReferenceFeed is Ownable, IPriceReferenceFeed {\n    uint256 public latestResult;\n    uint256 public lastUpdate;\n\n    function update(uint256 _value) external onlyOwner {\n        latestResult = _value;\n        lastUpdate = block.timestamp;\n    }\n\n    function getRoundData(uint80 _roundId) external override view returns (\n        uint80 roundId, \n        int256 answer, \n        uint256 startedAt, \n        uint256 updatedAt, \n        uint80 answeredInRound\n    ) {\n        require(false, \"NOT_SUPPORTED\");\n    }\n    function latestRoundData() external override view returns (\n        uint80 roundId, \n        int256 answer, \n        uint256 startedAt, \n        uint256 updatedAt, \n        uint80 answeredInRound\n    ) {\n        updatedAt = lastUpdate;\n        answer = int256(latestResult);\n    }\n}"
    },
    "contracts/test/MockAaveLendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"../interfaces/IAaveLendingPool.sol\";\nimport \"./MockToken.sol\";\n\ncontract MockAaveLendingPool is IAaveLendingPool {\n    IERC20 public token;\n    MockToken public aToken;\n\n    bool public revertDeposit;\n\n    constructor(address _token, address _aToken) public {\n        token = IERC20(_token);\n        aToken = MockToken(_aToken);\n    }\n\n    function deposit(address _reserve, uint256 _amount, uint16 _refferalCode) external override {\n        require(!revertDeposit, \"Deposited revert\");\n        require(token.transferFrom(msg.sender, address(aToken), _amount), \"Transfer failed\");\n        aToken.mint(_amount, msg.sender);\n    }\n\n    function setRevertDeposit(bool _doRevert) external {\n        revertDeposit = _doRevert;\n    }\n\n    function core() external view override returns(address) {\n        return address(this);\n    }\n\n    function getReserveData(address _reserve)\n        external\n        override\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 availableLiquidity,\n            uint256 totalBorrowsStable,\n            uint256 totalBorrowsVariable,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 utilizationRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            address aTokenAddress,\n            uint40 lastUpdateTimestamp\n        ) {\n            return(\n                0,\n                0,\n                0,\n                0,\n                10000000000000000000000000, //1%\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                address(0),\n                0\n            );\n        }\n}\n"
    },
    "contracts/test/MockAaveLendingPoolV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"../interfaces/IAaveLendingPoolV2.sol\";\nimport \"./MockToken.sol\";\n\ncontract MockAaveLendingPoolV2 is IAaveLendingPoolV2 {\n    IERC20 public token;\n    MockToken public aToken;\n\n    bool public revertDeposit;\n    bool public revertWithdraw;\n\n    constructor(address _token, address _aToken) public {\n        token = IERC20(_token);\n        aToken = MockToken(_aToken);\n    }\n\n    function deposit(\n        address _asset,\n        uint256 _amount,\n        address _onBehalfOf,\n        uint16 _referralCode\n    ) external override {\n        require(!revertDeposit, \"Deposited revert\");\n        require(token.transferFrom(msg.sender, address(this), _amount), \"Transfer failed\");\n        aToken.mint(_amount, msg.sender);\n    }\n\n    function withdraw(\n        address _asset,\n        uint256 _amount,\n        address _to\n    ) external override {\n        require(!revertWithdraw, \"Reverted\");\n\n        if (_amount == uint256(-1)) {\n            _amount = aToken.balanceOf(msg.sender);\n        }\n\n        aToken.burn(_amount, msg.sender);\n        require(token.transfer(msg.sender, _amount), \"Transfer failed\");\n    }\n\n    function getReserveData(address asset)\n        external\n        view\n        override\n        returns (DataTypes.ReserveData memory) {\n        return DataTypes.ReserveData({\n            configuration: DataTypes.ReserveConfigurationMap(0),\n            liquidityIndex: 0,\n            variableBorrowIndex: 0,\n            currentLiquidityRate: 10000000000000000000000000, //1%\n            currentVariableBorrowRate: 0,\n            currentStableBorrowRate: 0,\n            lastUpdateTimestamp: 0,\n            aTokenAddress: address(0),\n            stableDebtTokenAddress: address(0),\n            variableDebtTokenAddress: address(0),\n            interestRateStrategyAddress: address(0),\n            id: 0\n        });\n    }\n\n\n\n    function setRevertDeposit(bool _doRevert) external {\n        revertDeposit = _doRevert;\n    }\n    function setRevertWithdraw(bool _doRevert) external {\n        revertWithdraw = _doRevert;\n    }\n}\n"
    },
    "contracts/test/MockAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"../interfaces/IAaveLendingPool.sol\";\nimport \"./MockToken.sol\";\n\ncontract MockAToken is MockToken {\n    IERC20 public token;\n\n    address public underlyingAssetAddress;\n    bool public revertRedeem;\n\n    constructor(address _token) public MockToken(\"MockAToken\", \"MATKN\") {\n        token = IERC20(_token);\n        underlyingAssetAddress = _token;\n    }\n\n    function redeem(uint256 _amount) external {\n        require(!revertRedeem, \"Reverted\");\n\n        if (_amount == uint256(-1)) {\n            _amount = balanceOf(msg.sender);\n        }\n\n        _burn(msg.sender, _amount);\n        require(token.transfer(msg.sender, _amount), \"Transfer failed\");\n    }\n\n    function setRevertRedeem(bool _doRevert) external {\n        revertRedeem = _doRevert;\n    }\n}\n"
    },
    "contracts/test/MockATokenV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"../interfaces/IAaveLendingPool.sol\";\nimport \"./MockToken.sol\";\n\ncontract MockATokenV2 is MockToken {\n    IERC20 public token;\n\n    address public UNDERLYING_ASSET_ADDRESS;\n\n    constructor(address _token) public MockToken(\"MockATokenV2\", \"MATKNV2\") {\n        token = IERC20(_token);\n        UNDERLYING_ASSET_ADDRESS = _token;\n    }\n\n}\n"
    },
    "contracts/test/MockCToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"./MockToken.sol\";\nimport \"../interfaces/ICToken.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract MockCToken is MockToken, ICToken {\n    using SafeMath for uint256;\n    // representable value taken from cEth\n    uint256 public exchangeRate = 1 ether / 5;\n    MockToken public underlying;\n    uint256 someValue;\n\n    uint256 public errorCode;\n    constructor(address _underlying) MockToken(\"cTOKEN\", \"cToken\") public {\n        underlying = MockToken(_underlying);\n    }\n\n    function mint(uint256 _amount) external override returns(uint256) {\n        require(underlying.transferFrom(msg.sender, address(this), _amount), \"MockCToken.mint: transferFrom failed\");\n\n        uint256 mintAmount = _amount.mul(10**18).div(exchangeRate);\n        _mint(msg.sender, mintAmount);\n\n        return errorCode;\n    }\n\n    function redeem(uint256 _amount) external override returns(uint256) {\n        _burn(msg.sender, _amount);\n\n        uint256 underlyingAmount = _amount.mul(exchangeRate).div(10**18);\n        underlying.mint(underlyingAmount, msg.sender);\n\n        return errorCode;\n    }\n\n    function redeemUnderlying(uint256 _amount) external returns(uint256) {\n        uint256 internalAmount = _amount.mul(10**18).div(exchangeRate);\n        _burn(msg.sender, internalAmount);\n\n        underlying.mint(_amount, msg.sender);\n\n        return errorCode;\n    }\n\n    function balanceOfUnderlying(address _owner) external returns(uint256) {\n        return balanceOf(_owner).mul(exchangeRate).div(10**18);\n    }\n\n    function setErrorCode(uint256 _value) public {\n        errorCode = _value;\n    }\n\n    function supplyRatePerBlock() external override view returns (uint256) {\n        return 20000000000;\n    }\n\n    function exchangeRateCurrent() external override returns(uint256) {\n        // To make function state changing\n        someValue ++;\n        return exchangeRate;\n    }\n\n    function exchangeRateStored() external override view returns(uint256) {\n        // To make function non pure;\n        someValue;\n        return exchangeRate;\n    }\n}"
    },
    "contracts/test/MockDecimalWrapper.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract MockDecimalWrapper is ERC20 {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  uint256 public conversion;\n  IERC20 public underlying;\n\n  event Deposit(address indexed dst, uint wad);\n  event Withdrawal(address indexed src, uint wad);\n\n  constructor(string memory _name, string memory _symbol, address _underlying, uint256 _conversion) ERC20(_name, _symbol) {\n    underlying = IERC20(_underlying);\n    conversion = _conversion;\n  }\n\n  function deposit(uint256 _amount) external {\n    underlying.safeTransferFrom(msg.sender, address(this), _amount);\n    _mint(msg.sender, _amount.mul(conversion));\n    emit Deposit(msg.sender, _amount);\n  }\n\n  function withdraw(uint256 _amount) external {\n    _burn(msg.sender, _amount);\n    underlying.safeTransfer(msg.sender, _amount.div(conversion));\n    emit Withdrawal(msg.sender, _amount);\n  }\n}"
    },
    "contracts/test/MockLendingLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"../interfaces/ILendingLogic.sol\";\n\ncontract MockLendingLogic is ILendingLogic {\n    uint256 private apr;\n\n    function setAPR(uint256 _apr) public {\n        apr = _apr;\n    }\n\n    function getAPRFromWrapped(address _token) external view override returns(uint256) {\n        return apr;\n    }\n\n    function getAPRFromUnderlying(address _token) public view override returns(uint256) {\n        return apr;\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _underlying;\n        data[0] = bytes(abi.encode(_amount));\n    }\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = bytes(abi.encode(_amount));\n    }\n\n    function exchangeRate(address) external pure override returns(uint256) {\n        return 10**18;\n    }\n\n    function exchangeRateView(address) external pure override returns(uint256) {\n        return 10**18;\n    }\n}"
    },
    "contracts/test/MockSynthetix.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/ISynthetix.sol\";\nimport \"./MockToken.sol\";\n\ncontract MockSynthetix is ISynthetix {\n    using SafeMath for uint256;\n\n    mapping(bytes32=>MockToken) public keyToToken;\n    mapping(bytes32=>uint256) public tokenPrice;\n\n    // Mock variables to create edge cases\n    uint256 public subtractSourceAmount;\n    uint256 public subtractOutputAmount;\n\n    function setSubtractSourceAmount(uint256 _amount) external {\n        subtractSourceAmount = _amount;\n    }\n\n    function setSubtractOutputAmount(uint256 _amount) external {\n        subtractOutputAmount = _amount;\n    }\n\n    function exchange(bytes32 _sourceCurrencyKey, uint256 _sourceAmount, bytes32 _destinationCurrencyKey) external override {\n        uint256 sourcePrice = tokenPrice[_sourceCurrencyKey];\n        uint256 destinationPrice = tokenPrice[_destinationCurrencyKey];\n        uint256 outputAmount = _sourceAmount.mul(sourcePrice).div(destinationPrice);\n\n        getOrSetToken(_sourceCurrencyKey).burn(_sourceAmount.sub(subtractSourceAmount), msg.sender);\n        getOrSetToken(_destinationCurrencyKey).mint(outputAmount.sub(subtractOutputAmount), msg.sender);\n    }\n\n    function getOrSetToken(bytes32 _currencyKey) public returns(MockToken) {\n        if(address(keyToToken[_currencyKey]) == address(0)) {\n            keyToToken[_currencyKey] = new MockToken(string(abi.encode(_currencyKey)), string(abi.encode(_currencyKey)));\n            tokenPrice[_currencyKey] = 1 ether;\n        }\n\n        return keyToToken[_currencyKey];\n    }\n\n    function setPrice(bytes32 _currencyKey, uint256 _price) external {\n        tokenPrice[_currencyKey] = _price;\n    }\n\n    function getToken(bytes32 _currencyKey) external view returns(address) {\n        return address(keyToToken[_currencyKey]);\n    }\n}"
    },
    "contracts/test/MockXSushi.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"./MockToken.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract MockXSushi is MockToken {\n    using SafeMath for uint256;\n    uint256 public exchangeRate = 1 ether / 5;\n    MockToken public underlying;\n\n    uint256 public errorCode;\n    constructor(address _underlying) MockToken(\"xSUSHI\", \"xSUSHI\") public {\n        underlying = MockToken(_underlying);\n    }\n\n    function mint(uint256 _amount) external {\n        require(underlying.transferFrom(msg.sender, address(this), _amount), \"MockXSushi.mint: transferFrom failed\");\n\n        uint256 mintAmount = _amount.mul(10**18).div(exchangeRate);\n        _mint(msg.sender, mintAmount);\n    }\n\n    function enter(uint256 _amount) external {\n        require(underlying.transferFrom(msg.sender, address(this), _amount), \"MockXSushi.enter: transferFrom failed\");\n\n        uint256 mintAmount = _amount.mul(10**18).div(exchangeRate);\n        _mint(msg.sender, mintAmount);\n    }\n\n    function exchangeRateStored() external view returns(uint256) {\n        return exchangeRate;\n    }\n\n    function leave(uint256 _amount) external{\n        _burn(msg.sender, _amount);\n\n        uint256 underlyingAmount = _amount.mul(exchangeRate).div(10**18);\n        underlying.mint(underlyingAmount, msg.sender);\n    }\n}"
    },
    "contracts/test/MockYVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"./MockToken.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract MockYVault is MockToken {\n    using SafeMath for uint256;\n    uint256 public exchangeRate = 1 ether / 5;\n    MockToken public underlying;\n\n    constructor(address _underlying) MockToken(\"yVAULT\", \"yVAULT\") public {\n        underlying = MockToken(_underlying);\n    }\n\n    function mint(uint256 _amount) external {\n        require(underlying.transferFrom(msg.sender, address(this), _amount), \"MockXSushi.mint: transferFrom failed\");\n\n        uint256 mintAmount = _amount.mul(10**18).div(exchangeRate);\n        _mint(msg.sender, mintAmount);\n    }\n\n    function deposit(uint256 _amount) external {\n        require(underlying.transferFrom(msg.sender, address(this), _amount), \"MockYVault.enter: transferFrom failed\");\n\n        uint256 mintAmount = _amount.mul(10**18).div(exchangeRate);\n        _mint(msg.sender, mintAmount);\n    }\n\n    function getPricePerFullShare() external view returns(uint) {\n        return exchangeRate;\n    }\n\n    function withdraw(uint256 _amount) external{\n        _burn(msg.sender, _amount);\n\n        uint256 underlyingAmount = _amount.mul(exchangeRate).div(10**18);\n        underlying.mint(underlyingAmount, msg.sender);\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}