{"CyberGorillaBabies.sol":{"content":"// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.10;\n\nimport \"./Ownable.sol\";\nimport \"./Strings.sol\";\nimport \"./ERC721.sol\";\n\n/*\n   ______      __              ______           _ ____          \n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\n / /   / / / / __ \\/ _ \\/ ___/ / __/ __ \\/ ___/ / / / __ `/ ___/\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \n\\____/\\__, /_.___/\\___/_/   \\____/\\____/_/  /_/_/_/\\__,_/____/  \n     /____/                                                     \n\n*/\n\n/// @title Cyber Gorillas Babies\n/// @author delta devs (https://twitter.com/deltadevelopers)\ncontract CyberGorillaBabies is ERC721, Ownable {\n    using Strings for uint256;\n\n    /// @notice The address which is allowed to breed Cyber Gorillas.\n    address private gorillaBreeder;\n    /// @notice Base URI pointing to CyberGorillaBabies metadata.\n    string public baseURI;\n    /// @notice Returns true if the requested gorilla baby has the genesis trait, false otherwise.\n    mapping(uint256 =\u003e bool) public isGenesis;\n\n    constructor(string memory initialBaseURI)\n        ERC721(\"Cyber Gorilla Babies\", \"CyberGorillaBabies\")\n    {\n        baseURI = initialBaseURI;\n    }\n\n    /// @notice Set the address which is allowed to breed gorillas.\n    /// @param newGorillaBreeder The target address, authorized to breed.\n    function setGorillaBreeder(address newGorillaBreeder) public onlyOwner {\n        gorillaBreeder = newGorillaBreeder;\n    }\n\n    /// @notice Allows the contract deployer to set the Base URI for CyberGorillaBabies\u0027 metadata.\n    /// @param newBaseURI The new Base URI.\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseURI = newBaseURI;\n    }\n\n    /// @notice Allows the authorized breeder address to mint a gorilla baby to a specific address.\n    /// @param to The address to receive the minted gorilla baby.\n    /// @param _isGenesis Whether the baby to be minted has the genesis trait or not.\n    function mintBaby(address to, bool _isGenesis) public {\n        require(msg.sender == gorillaBreeder, \"Not Authorized\");\n        isGenesis[totalSupply] = _isGenesis;\n        _mint(to, totalSupply);\n    }\n\n    /// @notice Returns the token URI of a specific gorilla baby.\n    /// @param tokenId The token ID of the requested gorilla baby.\n    /// @return The full URI of the requested gorilla baby.\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        return\n            bytes(baseURI).length \u003e 0\n                ? string(abi.encodePacked(baseURI, tokenId.toString(), \".json\"))\n                : \"\";\n    }\n\n\n    function supportsInterface(bytes4 interfaceId) public pure override(ERC721, Ownable) returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata\n            interfaceId == 0x7f5828d0;   // ERC165 Interface ID for ERC173\n    }\n}\n"},"CyberGorillas.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./Strings.sol\";\nimport \"./ERC721.sol\";\nimport \"./Ownable.sol\";\n\nerror SoldOut();\nerror SaleClosed();\nerror InvalidMintParameters();\nerror MintingTooMany();\nerror NotWhitelisted();\nerror NotAuthorized();\n\n/*\n   ______      __              ______           _ ____          \n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\n / /   / / / / __ \\/ _ \\/ ___/ / __/ __ \\/ ___/ / / / __ `/ ___/\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \n\\____/\\__, /_.___/\\___/_/   \\____/\\____/_/  /_/_/_/\\__,_/____/  \n     /____/                                                     \n\n*/\n\n/// @author distractedm1nd\ncontract CyberGorillas is ERC721, Ownable {\n    using Strings for uint256;\n    address private passwordSigner;\n    address private gorillaBurner;\n\n    bool publicSaleActive;\n\n    uint256 constant PRESALE_MAX_TX = 2;\n    uint256 constant PUBLIC_MAX_TX = 5;\n    uint256 public constant MAX_SUPPLY = 3333;\n    uint256 constant PRICE = 0.08 ether;\n\n    string public baseURI;\n\n    mapping(address =\u003e uint256) private presaleWalletLimits;\n    mapping(address =\u003e uint256) private mainsaleWalletLimits;\n\n    constructor(string memory initialBaseURI, address initialPasswordSigner)\n        ERC721(\"Cyber Gorillas\", \"CyberGorillas\")\n    {\n        baseURI = initialBaseURI;\n        passwordSigner = initialPasswordSigner;\n    }\n\n    function airdrop(address[] calldata airdropAddresses) public onlyOwner {\n        for (uint256 i = 0; i \u003c airdropAddresses.length; i++) {\n            _mint(airdropAddresses[i], totalSupply);\n        }\n    }\n\n    function setGorilliaBurner(address newGorillaBurner) public onlyOwner {\n        gorillaBurner = newGorillaBurner;\n    }\n\n    function setPasswordSigner(address signer) public onlyOwner {\n        passwordSigner = signer;\n    }\n\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseURI = newBaseURI;\n    }\n\n    function setPublicSale(bool publicSale) public onlyOwner {\n        publicSaleActive = publicSale;\n    }\n\n    function specialMintForTests(address to, uint256 tokenId) public {\n        if (ownerOf[tokenId] == address(0)) _mint(to, tokenId);\n    }\n\n    function purchase(uint256 amount) public payable {\n        if (!publicSaleActive) revert SaleClosed();\n        if (totalSupply + amount \u003e MAX_SUPPLY) revert SoldOut();\n        if (\n            mainsaleWalletLimits[msg.sender] + amount \u003e PUBLIC_MAX_TX ||\n            msg.value \u003c PRICE * amount\n        ) revert InvalidMintParameters();\n\n        mainsaleWalletLimits[msg.sender] += amount;\n        for (uint256 i = 0; i \u003c amount; i++) {\n            _mint(msg.sender, totalSupply);\n        }\n    }\n\n    function presale(uint256 amount, bytes memory signature) public payable {\n        if (publicSaleActive) revert SaleClosed();\n        if (totalSupply + amount \u003e MAX_SUPPLY) revert SoldOut();\n        if (!isWhitelisted(msg.sender, signature)) revert NotWhitelisted();\n        if (\n            presaleWalletLimits[msg.sender] + amount \u003e PRESALE_MAX_TX ||\n            msg.value \u003c PRICE * amount\n        ) revert InvalidMintParameters();\n\n        presaleWalletLimits[msg.sender] += amount;\n        for (uint256 i = 0; i \u003c amount; i++) {\n            _mint(msg.sender, totalSupply);\n        }\n    }\n\n    function unstake(address payable recipient) external onlyOwner {\n        recipient.transfer(address(this).balance);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        return\n            bytes(baseURI).length \u003e 0\n                ? string(abi.encodePacked(baseURI, tokenId.toString(), \".json\"))\n                : \"\";\n    }\n\n    function isWhitelisted(address user, bytes memory signature)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 messageHash = keccak256(abi.encode(user));\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethSignedMessageHash, signature) == passwordSigner;\n    }\n\n    function getEthSignedMessageHash(bytes32 _messageHash)\n        private\n        pure\n        returns (bytes32)\n    {\n        /*\n        Signature is produced by signing a keccak256 hash with the following format:\n        \"\\x19Ethereum Signed Message\\n\" + len(msg) + msg\n        */\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    _messageHash\n                )\n            );\n    }\n\n    function recoverSigner(\n        bytes32 _ethSignedMessageHash,\n        bytes memory _signature\n    ) private pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function recoverSignerTest(\n        bytes32 _ethSignedMessageHash,\n        bytes memory _signature\n    ) private pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        private\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        require(sig.length == 65, \"sig invalid\");\n\n        assembly {\n            /*\n        First 32 bytes stores the length of the signature\n\n        add(sig, 32) = pointer of sig + 32\n        effectively, skips first 32 bytes of signature\n\n        mload(p) loads next 32 bytes starting at the memory address p into memory\n        */\n\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n\n\n    function supportsInterface(bytes4 interfaceId) public pure override(ERC721, Ownable) returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata\n            interfaceId == 0x7f5828d0;   // ERC165 Interface ID for ERC173\n    }\n\n    function burn(uint256 tokenId) public {\n        if (msg.sender != gorillaBurner) revert NotAuthorized();\n        _burn(tokenId);\n    }\n}\n"},"CyberGorillasStaking.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./CyberGorillas.sol\";\nimport \"./GrillaToken.sol\";\nimport \"./ERC721.sol\";\nimport \"./Strings.sol\";\nimport \"./RewardBoostProvider.sol\";\nimport \"./Ownable.sol\";\n\n/*\n   ______      __              ______           _ ____          \n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\n / /   / / / / __ \\/ _ \\/ ___/ / __/ __ \\/ ___/ / / / __ `/ ___/\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \n\\____/\\__, /_.___/\\___/_/   \\____/\\____/_/  /_/_/_/\\__,_/____/  \n     /____/                                                     \n\n*/\n\n/// @title Cyber Gorillas Staking\n/// @author delta devs (https://twitter.com/deltadevelopers)\ncontract CyberGorillasStaking is Ownable {\n    /*///////////////////////////////////////////////////////////////\n                        CONTRACT STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice An instance of the GRILLA token, paid out as staking reward.\n    GrillaToken public rewardsToken;\n    /// @notice An ERC721 instance of the Cyber Gorillas contract.\n    ERC721 public gorillaContract;\n\n    /// @notice An address slot for a future contract to allow users to withdraw their rewards from multiple staking contracts in one call.\n    address public rewardAggregator;\n\n    /// @notice The reward rate for staking a regular gorilla.\n    /// @dev The reward rate is fixed to 10 * 1E18 GRILLA every 86400 seconds, 1157407407407400 per second.\n    uint256 constant normalRate = (100 * 1E18) / uint256(1 days);\n\n    /// @notice The reward rate for staking a genesis gorilla.\n    /// @dev The reward rate is fixed to 15 * 1E18 GRILLA every 86400 seconds, 1736111111111110 per second.\n    uint256 constant genesisRate = (150 * 1E18) / uint256(1 days);\n\n    /*///////////////////////////////////////////////////////////////\n                    GORILLA METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Keeps track of which gorilla\u0027s have the genesis trait.\n    mapping(uint256 =\u003e bool) private genesisTokens;\n    /// @notice A list of reward boost providers.\n    RewardBoostProvider[] rewardBoostProviders;\n\n    /*///////////////////////////////////////////////////////////////\n                        STAKING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the owner of the specified gorilla.\n    mapping(uint256 =\u003e address) public tokenToAddr;\n    /// @notice Returns the reward amount for the specified address.\n    mapping(address =\u003e uint256) public rewards;\n    /// @notice Returns the number of normal gorillas staked by specified address.\n    mapping(address =\u003e uint256) public _balancesNormal;\n    /// @notice Returns the number of genesis gorillas staked by specified address.\n    mapping(address =\u003e uint256) public _balancesGenesis;\n    /// @notice Returns the start time of staking rewards accumulation for a specified address.\n    /// @dev The UNIX timestamp in seconds in which staking rewards were last claimed.\n    /// This is later compared with block.timestamp to calculate the accumulated staking rewards.\n    mapping(address =\u003e uint256) public _updateTimes;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _gorillaContract, address _rewardsToken) {\n        gorillaContract = ERC721(_gorillaContract);\n        rewardsToken = GrillaToken(_rewardsToken);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            SETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows the contract deployer to specify which gorillas are to be considered of type genesis.\n    /// @param genesisIndexes An array of indexes specifying which gorillas are of type genesis.\n    function uploadGenesisArray(uint256[] memory genesisIndexes)\n        public\n        onlyOwner\n    {\n        for (uint256 i = 0; i \u003c genesisIndexes.length; i++) {\n            genesisTokens[genesisIndexes[i]] = true;\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the accumulated staking rewards of the function caller.\n    /// @return The amount of GRILLA earned while staking.\n    function viewReward() public view returns (uint256) {\n        return rewards[msg.sender] + rewardDifferential(msg.sender);\n    }\n\n    /// @notice Calculates the accumulated staking reward for the requested address.\n    /// @param account The address of the staker.\n    /// @return The amount of GRILLA earned while staking.\n    function rewardDifferential(address account) public view returns (uint256) {\n        uint256 accum = 0;\n        uint256 bal = 0;\n        for (uint256 boosterId = 0; boosterId \u003c rewardBoostProviders.length; ) {\n            bal = _balancesNormal[account];\n            if (bal \u003e 0)\n                accum +=\n                    rewardBoostProviders[boosterId].getPercentBoostAdultNormal(\n                        account\n                    ) *\n                    bal;\n            bal = _balancesGenesis[account];\n            if (bal \u003e 0)\n                accum +=\n                    rewardBoostProviders[boosterId].getPercentBoostAdultGenesis(\n                        account\n                    ) *\n                    bal;\n            unchecked {\n                boosterId++;\n            }\n        }\n        uint256 baseDiff = (((block.timestamp - _updateTimes[account]) *\n            normalRate *\n            _balancesNormal[account]) +\n            ((block.timestamp - _updateTimes[account]) *\n                genesisRate *\n                _balancesGenesis[account]));\n        return baseDiff + (baseDiff * accum) / 100;\n    }\n\n    /// @notice Returns true if gorilla has the genesis trait, false otherwise.\n    /// @return Whether the requested gorilla has the genesis trait.\n    function isGenesis(uint256 tokenId) private view returns (bool) {\n        return genesisTokens[tokenId];\n    }\n\n    /// @notice Returns true if the requested address is staking at least one genesis gorilla, false otherwise.\n    /// @return Whether the requested address is staking genesis gorillas.\n    function isStakingGenesis(address account) public view returns (bool) {\n        return _balancesGenesis[account] \u003e 0;\n    }\n\n    /// @notice Returns true if the requested address is staking normal gorillas, false otherwise.\n    /// @return Whether the requested address is staking normal gorillas.\n    function isStakingNormal(address account) public view returns (bool) {\n        return _balancesNormal[account] \u003e 0;\n    }\n\n    /// @notice Modifier which updates the timestamp of when a staker last withdrew staking rewards.\n    /// @param account The address of the staker.\n    modifier updateReward(address account) {\n        uint256 reward = rewardDifferential(account);\n        _updateTimes[account] = block.timestamp;\n        rewards[account] += reward;\n        _;\n    }\n\n    /// @notice Sets the reward aggregator.\n    /// @param _rewardAggregator The address of the reward aggregation contract.\n    function setRewardAggregator(address _rewardAggregator) public onlyOwner {\n        rewardAggregator = _rewardAggregator;\n    }\n\n    /// @notice Adds a reward booster.\n    /// @param booster The address of the booster.\n    function addRewardBoostProvider(address booster) public onlyOwner {\n        rewardBoostProviders.push(RewardBoostProvider(booster));\n    }\n\n    /// @notice Remove a specific reward booster at a specific index.\n    /// @param index Index of the booster to remove.\n    function removeRewardBoostProvider(uint256 index) public onlyOwner {\n        delete rewardBoostProviders[index];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            STAKING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    // TODO: This function is only for testing, can be removed\n    // REASONING: Nothing else calls it, and a user would not spend the gas\n    //            necessary in order to updateReward()\n    function earned(address account)\n        public\n        updateReward(account)\n        returns (uint256)\n    {\n        return rewards[account];\n    }\n\n    /// @notice Allows a staker to withdraw their rewards.\n    /// @return The amount of GRILLA earned from staking.\n    function withdrawReward()\n        public\n        updateReward(msg.sender)\n        returns (uint256)\n    {\n        uint256 reward = rewards[msg.sender];\n        rewards[msg.sender] = 0;\n        rewardsToken.stakerMint(msg.sender, reward);\n        return reward;\n    }\n\n    /// @notice Allows a contract to withdraw the rewards on behalf of a user.\n    /// @return The amount of GRILLA earned from staking.\n    function withdrawReward(address user)\n        public\n        updateReward(user)\n        returns (uint256)\n    {\n        require(msg.sender == rewardAggregator, \"Unauthorized\");\n        uint256 reward = rewards[user];\n        rewards[user] = 0;\n        rewardsToken.stakerMint(user, reward);\n        return reward;\n    }\n\n    /// @notice Allows a holder to stake a gorilla.\n    /// @dev First checks whether the specified gorilla has the genesis trait. Updates balances accordingly.\n    /// unchecked, because no arithmetic overflow is possible.\n    /// @param _tokenId A specific gorilla, identified by its token ID.\n    function stake(uint256 _tokenId) public updateReward(msg.sender) {\n        bool isGen = isGenesis(_tokenId);\n        unchecked {\n            if (isGen) {\n                _balancesGenesis[msg.sender]++;\n            } else {\n                _balancesNormal[msg.sender]++;\n            }\n        }\n        tokenToAddr[_tokenId] = msg.sender;\n        gorillaContract.transferFrom(msg.sender, address(this), _tokenId);\n    }\n\n    /// @notice Allows a staker to stake multiple gorillas at once.\n    /// @param tokenIds An array of token IDs, representing multiple gorillas.\n    function stakeMultiple(uint256[] memory tokenIds)\n        public\n        updateReward(msg.sender)\n    {\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            stake(tokenIds[i]);\n        }\n    }\n\n    /// @notice Allows a staker to unstake a staked gorilla.\n    /// @param _tokenId A specific gorilla, identified by its token ID.\n    function unstake(uint256 _tokenId) public updateReward(msg.sender) {\n        require(tokenToAddr[_tokenId] == msg.sender, \"Owner Invalid\");\n        bool isGen = isGenesis(_tokenId);\n        unchecked {\n            if (isGen) {\n                _balancesGenesis[msg.sender]--;\n            } else {\n                _balancesNormal[msg.sender]--;\n            }\n        }\n        delete tokenToAddr[_tokenId];\n        gorillaContract.transferFrom(address(this), msg.sender, _tokenId);\n    }\n\n    /// @notice Allows a staker to unstake multiple gorillas at once.\n    /// @param tokenIds An array of token IDs, representing multiple gorillas.\n    function unstakeMultiple(uint256[] memory tokenIds)\n        public\n        updateReward(msg.sender)\n    {\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            unstake(tokenIds[i]);\n        }\n    }\n}\n"},"ERC1155.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*///////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        for (uint256 i = 0; i \u003c idsLength; ) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can\u0027t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 ownersLength = owners.length; // Saves MLOADs.\n\n        require(ownersLength == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i \u003c ownersLength; i++) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i \u003c idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can\u0027t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i \u003c idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can\u0027t have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\ninterface ERC1155TokenReceiver {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address =\u003e uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"ERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(uint256 =\u003e address) public ownerOf;\n\n    mapping(uint256 =\u003e address) public getApproved;\n\n    mapping(address =\u003e mapping(address =\u003e bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender\u0027s balance is impossible because we check for\n        // ownership above and the recipient\u0027s balance can\u0027t realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            totalSupply++;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            totalSupply--;\n\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"GrillaToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./ERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./JungleSerum.sol\";\nimport \"./CyberGorillasStaking.sol\";\n\n/*\n   ______      __              ______           _ ____          \n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\n / /   / / / / __ \\/ _ \\/ ___/ / __/ __ \\/ ___/ / / / __ `/ ___/\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \n\\____/\\__, /_.___/\\___/_/   \\____/\\____/_/  /_/_/_/\\__,_/____/  \n     /____/                                                     \n\n*/\n\n/// @title Grilla Token\n/// @author delta devs (https://twitter.com/deltadevelopers)\ncontract GrillaToken is ERC20, Ownable {\n    /*///////////////////////////////////////////////////////////////\n                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted by `buyOffChainUtility` function.\n    /// @dev Event logging when utility has been purchased.\n    /// @param sender Address of purchaser.\n    /// @param itemId Item identifier tied to utility.\n    event UtilityPurchase(address indexed sender, uint256 indexed itemId);\n\n    /*///////////////////////////////////////////////////////////////\n                            STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice An instance of the JungleSerum contract.\n    JungleSerum serumContract;\n\n    /// @notice Retrieves price tied to specific utility item ID.\n    mapping(uint256 =\u003e uint256) utilityPrices;\n\n    /// @notice Returns true if address is authorized to make stake function calls.\n    mapping(address =\u003e bool) authorizedStakingContracts;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    constructor() ERC20(\"GRILLA\", \"GRILLA\", 18) {}\n\n    /*///////////////////////////////////////////////////////////////\n                            MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows the contract deployer to mint GRILLA.\n    /// @param account The address which will receive the minted amount.\n    /// @param amount The amount of tokens to mint.\n    function ownerMint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }\n\n    /// @notice Allows authorized staking contracts to mint GRILLA.\n    /// @param account The address which will receive the minted amount.\n    /// @param amount The amount of tokens to mint.\n    function stakerMint(address account, uint256 amount) public {\n        require(\n            authorizedStakingContracts[msg.sender],\n            \"Request only valid from staking contract\"\n        );\n        _mint(account, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        CONTRACT SETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows the contract deployer to authorize a contract to stake.\n    /// @param staker The address to authorize.\n    function addStakingContract(address staker) public onlyOwner {\n        authorizedStakingContracts[staker] = true;\n    }\n\n    /// @notice Allows the contract deployer to unauthorize a contract to stake.\n    /// @param staker The address to remove authority from.\n    function removeStakingContract(address staker) public onlyOwner {\n        authorizedStakingContracts[staker] = false;\n    }\n\n    /// @notice Sets the address of the JungleSerum contract.\n    /// @param serumContractAddress The address of the JungleSerum contract.\n    function setSerumContract(address serumContractAddress) public onlyOwner {\n        serumContract = JungleSerum(serumContractAddress);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        UTILITY PURCHASING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Purchase JungleSerum.\n    function buySerum() public {\n        transfer(address(serumContract), serumContract.serumPrice());\n        serumContract.mint(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    OFFCHAIN UTILITY PURCHASING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Retrieves the price of a specific utility.\n    /// @param itemId The identifier of the utility item.\n    /// @return The price of a specific utility.\n    function getUtilityPrice(uint256 itemId) public view returns (uint256) {\n        return utilityPrices[itemId];\n    }\n\n    /// @notice Allows the contract deployer to add off-chain utility data.\n    /// @param itemId The identifier of the utility item.\n    /// @param itemPrice The price of the utility item.\n    function addOffchainUtility(uint256 itemId, uint256 itemPrice)\n        public\n        onlyOwner\n    {\n        utilityPrices[itemId] = itemPrice;\n    }\n\n    /// @notice Allows the contract deployer to remove off-chain utility data.\n    /// @param itemId The identifier of the utility item.\n    function deleteUtilityPrice(uint256 itemId) public onlyOwner {\n        delete utilityPrices[itemId];\n    }\n\n    /// @notice Allows the contract deployer to add off-chain utility data for multiple items.\n    /// @param items List of multiple utility item identifiers.\n    /// @param prices List of multiple utility item prices.\n    function uploadUtilityPrices(\n        uint256[] memory items,\n        uint256[] memory prices\n    ) public onlyOwner {\n        for (uint256 i = 0; i \u003c items.length; i++) {\n            utilityPrices[items[i]] = prices[i];\n        }\n    }\n\n    /// @notice Buy the requested off chain utility.\n    /// @param itemId The identifier of the utility item.\n    function buyOffchainUtility(uint256 itemId) public {\n        require(utilityPrices[itemId] \u003e 0, \"Invalid utility id\");\n        transfer(address(serumContract), utilityPrices[itemId]);\n        emit UtilityPurchase(msg.sender, itemId);\n    }\n}\n"},"JungleSerum.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./ERC1155.sol\";\nimport \"./Ownable.sol\";\nimport \"./Strings.sol\";\nimport \"./CyberGorillas.sol\";\nimport \"./CyberGorillaBabies.sol\";\nimport \"./CyberGorillasStaking.sol\";\nimport \"./GrillaToken.sol\";\n\n/*\n   ______      __              ______           _ ____          \n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\n / /   / / / / __ \\/ _ \\/ ___/ / __/ __ \\/ ___/ / / / __ `/ ___/\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \n\\____/\\__, /_.___/\\___/_/   \\____/\\____/_/  /_/_/_/\\__,_/____/  \n     /____/                                                     \n*/\n\n/// @title Jungle Serum\n/// @author delta devs (https://twitter.com/deltadevelopers)\n/// @dev Inspired by BoredApeChemistryClub.sol (https://etherscan.io/address/0x22c36bfdcef207f9c0cc941936eff94d4246d14a)\nabstract contract JungleSerum is ERC1155, Ownable {\n    using Strings for uint256;\n    /*///////////////////////////////////////////////////////////////\n                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted by `breed` function.\n    /// @dev Event logging when breeding occurs.\n    /// @param firstGorilla First Cyber Gorilla parent used for breeding.\n    /// @param secondGorilla Second Cyber Gorilla parent used for breeding.\n    event MutateGorilla(\n        uint256 indexed firstGorilla,\n        uint256 indexed secondGorilla,\n        bool indexed babyGenesis\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                        METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Keeps track of which gorilla adults have the genesis trait.\n    mapping(uint256 =\u003e bool) private genesisTokens;\n\n    /// @notice String pointing to Jungle Serum URI.\n    string serumURI;\n    /// @notice Set name as Jungle Serum.\n    string public constant name = \"Jungle Serum\";\n    /// @notice The symbol of Jungle Serum.\n    string public constant symbol = \"JS\";\n\n    /*///////////////////////////////////////////////////////////////\n                            STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The price of a Jungle Serum.\n    uint256 public serumPrice;\n    /// @notice An instance of the CyberGorilla contract.\n    CyberGorillas cyberGorillaContract;\n    /// @notice An instance of the CyberGorillaBabies contract.\n    CyberGorillaBabies cyberBabiesContract;\n    /// @notice An instance of the CyberGorillasStaking contract.\n    CyberGorillasStaking stakingContract;\n    /// @notice An instance of the GrillaToken contract.\n    GrillaToken public grillaTokenContract;\n    /// @notice Returns true if specified gorilla is mutated, false otherwise.\n    mapping(uint256 =\u003e bool) mutatedGorillas;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _serumURI,\n        uint256 _serumPrice,\n        address _cyberGorillaContract,\n        address _cyberBabiesContract,\n        address _stakingContract\n    ) {\n        serumURI = _serumURI;\n        serumPrice = _serumPrice;\n        cyberGorillaContract = CyberGorillas(_cyberGorillaContract);\n        cyberBabiesContract = CyberGorillaBabies(_cyberBabiesContract);\n        stakingContract = CyberGorillasStaking(_stakingContract);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        STORAGE SETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set the URI pointing to Jungle Serum metadata.\n    /// @param _serumURI the target URI.\n    function setSerumURI(string memory _serumURI) public onlyOwner {\n        serumURI = _serumURI;\n    }\n\n    /// @notice Set the price for a Jungle Serum.\n    /// @param _serumPrice the price to set it to.\n    function setSerumPrice(uint256 _serumPrice) public onlyOwner {\n        serumPrice = _serumPrice;\n    }\n\n    /// @notice Sets the address of the GrillaToken contract.\n    /// @param _grillaTokenContract The address of the GrillaToken contract.\n    function setGrillaTokenContract(address _grillaTokenContract)\n        public\n        onlyOwner\n    {\n        grillaTokenContract = GrillaToken(_grillaTokenContract);\n    }\n\n    /// @notice Sets the address of the CyberGorilla contract.\n    /// @param _cyberGorillaContract The address of the CyberGorilla contract.\n    function setCyberGorillaContract(address _cyberGorillaContract)\n        public\n        onlyOwner\n    {\n        cyberGorillaContract = CyberGorillas(_cyberGorillaContract);\n    }\n\n    /// @notice Sets the address of the CyberGorillaBabies contract.\n    /// @param _cyberGorillaBabiesContract The address of the CyberGorillaBabies contract.\n    function setCyberBabiesContract(address _cyberGorillaBabiesContract)\n        public\n        onlyOwner\n    {\n        cyberBabiesContract = CyberGorillaBabies(_cyberGorillaBabiesContract);\n    }\n\n    /// @notice Sets the address of the CyberGorillasStaking contract.\n    /// @param _stakingContract The address of the GrillaToken contract.\n    function setStakingContract(address _stakingContract) public onlyOwner {\n        stakingContract = CyberGorillasStaking(_stakingContract);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows the contract deployer to withdraw the GRILLA held by this contract to a specified address.\n    /// @param receiver The address which receives the funds.\n    function withdrawGrilla(address receiver) public onlyOwner {\n        grillaTokenContract.transfer(\n            receiver,\n            grillaTokenContract.balanceOf(address(this))\n        );\n    }\n\n    /// @notice Allows the contract deployer to specify which adult gorillas are to be considered of type genesis.\n    /// @param genesisIndexes An array of indexes specifying which adult gorillas are of type genesis.\n    function uploadGenesisArray(uint256[] memory genesisIndexes)\n        public\n        onlyOwner\n    {\n        for (uint256 i = 0; i \u003c genesisIndexes.length; i++) {\n            genesisTokens[genesisIndexes[i]] = true;\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view override returns (string memory) {\n        return\n            bytes(serumURI).length \u003e 0\n                ? string(abi.encodePacked(serumURI, id.toString(), \".json\"))\n                : \"\";\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows the GrillaToken contract to mint a Jungle Serum for a specified address.\n    /// @param gorillaOwner The gorilla owner that will receive the minted Serum.\n    function mint(address gorillaOwner) public {\n        require(msg.sender == address(grillaTokenContract), \"Not authorized\");\n        _mint(gorillaOwner, 1, 1, \"\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            BREEDING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows a gorilla holder to breed a baby gorilla.\n    /// @dev One of the parents dies after the total supply of baby gorillas reaches 1667.\n    /// @param firstGorilla The tokenID of the first parent used for breeding.\n    /// @param secondGorilla The tokenID of the second parent used for breeding.\n    function breed(uint256 firstGorilla, uint256 secondGorilla) public virtual;\n\n    /// @notice Psuedorandom number to determine which parent dies during breeding.\n    function randomGorilla() private view returns (bool) {\n        unchecked {\n            return\n                uint256(\n                    keccak256(abi.encodePacked(block.timestamp, block.number))\n                ) %\n                    2 ==\n                0;\n        }\n    }\n\n\n    function supportsInterface(bytes4 interfaceId) public pure override(ERC1155, Ownable) returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c || // ERC165 Interface ID for ERC1155MetadataURI\n            interfaceId == 0x7f5828d0;   // ERC165 Interface ID for ERC173\n    }\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nerror NotOwner();\n\n// https://github.com/m1guelpf/erc721-drop/blob/main/src/LilOwnable.sol\nabstract contract Ownable {\n    address internal _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function owner() external view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address _newOwner) external {\n        if (msg.sender != _owner) revert NotOwner();\n\n        _owner = _newOwner;\n    }\n\n    function renounceOwnership() public {\n        if (msg.sender != _owner) revert NotOwner();\n\n        _owner = address(0);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        returns (bool)\n    {\n        return interfaceId == 0x7f5828d0; // ERC165 Interface ID for ERC173\n    }\n}"},"RewardBoostProvider.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/*\n   ______      __              ______           _ ____          \n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\n / /   / / / / __ \\/ _ \\/ ___/ / __/ __ \\/ ___/ / / / __ `/ ___/\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \n\\____/\\__, /_.___/\\___/_/   \\____/\\____/_/  /_/_/_/\\__,_/____/  \n     /____/                                                     \n\n*/\n\n/// @title Reward Boost Provider\n/// @author delta devs (https://twitter.com/deltadevelopers)\nabstract contract RewardBoostProvider {\n    /// @notice Retrieves the additional percentage boost for staking a genesis adult gorilla.\n    /// @dev Each NFT type consists of a ERC1155, which in turn consists of several sub-types.\n    /// By calculating the total balance for each sub-type, the total boost can be calculated.\n    /// @param account The address of the account to which the boost is eligible.\n    /// @return Returns the total boost.\n    function getPercentBoostAdultGenesis(address account)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    /// @notice Retrieves the additional percentage boost for staking a normal adult gorilla.\n    /// @dev Each NFT type consists of a ERC1155, which in turn consists of several sub-types.\n    /// By calculating the total balance for each sub-type, the total boost can be calculated.\n    /// @param account The address of the account to which the boost is eligible.\n    /// @return Returns the total boost.\n    function getPercentBoostAdultNormal(address account)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    /// @notice Retrieves the additional percentage boost for staking a genesis baby gorilla.\n    /// @dev Each NFT type consists of a ERC1155, which in turn consists of several sub-types.\n    /// By calculating the total balance for each sub-type, the total boost can be calculated.\n    /// @param account The address of the account to which the boost is eligible.\n    /// @return Returns the total boost.\n    function getPercentBoostBabyGenesis(address account)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    /// @notice Retrieves the additional percentage boost for staking a normal baby gorilla.\n    /// @dev Each NFT type consists of a ERC1155, which in turn consists of several sub-types.\n    /// By calculating the total balance for each sub-type, the total boost can be calculated.\n    /// @param account The address of the account to which the boost is eligible.\n    /// @return Returns the total boost.\n    function getPercentBoostBabyNormal(address account)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return 0;\n    }\n}\n"},"Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp \u003e\u003e= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\n            value \u003e\u003e= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"}}