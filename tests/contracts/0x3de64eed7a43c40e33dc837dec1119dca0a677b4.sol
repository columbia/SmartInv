{{
  "language": "Solidity",
  "sources": {
    "contracts/access/AccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract AccessController is AccessControl {\n  bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  constructor() public {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MANAGER_ROLE, msg.sender);\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/upgrade/MerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IMerkleDistributor.sol\";\n\ncontract MerkleDistributor is IMerkleDistributor, Ownable {\n  address public immutable override token;\n  bytes32 public immutable override merkleRoot;\n  uint256 public immutable override endTime;\n\n  // This is a packed array of booleans.\n  mapping(uint256 => uint256) private _claimedBitMap;\n\n  constructor(\n    address _token,\n    bytes32 _merkleRoot,\n    uint256 _endTime\n  ) public {\n    token = _token;\n    merkleRoot = _merkleRoot;\n    require(block.timestamp < _endTime, \"Invalid endTime\");\n    endTime = _endTime;\n  }\n\n  /** @dev Modifier to check that claim period is active.*/\n  modifier whenActive() {\n    require(isActive(), \"Claim period has ended\");\n    _;\n  }\n\n  function claim(\n    uint256 _index,\n    address _account,\n    uint256 _amount,\n    bytes32[] calldata merkleProof\n  ) external override whenActive {\n    require(!isClaimed(_index), \"Drop already claimed\");\n\n    // Verify the merkle proof.\n    bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\n    require(MerkleProof.verify(merkleProof, merkleRoot, node), \"Invalid proof\");\n\n    // Mark it claimed and send the token.\n    _setClaimed(_index);\n    require(IERC20(token).transfer(_account, _amount), \"Transfer failed\");\n\n    emit Claimed(_index, _account, _amount);\n  }\n\n  function isClaimed(uint256 _index) public view override returns (bool) {\n    uint256 claimedWordIndex = _index / 256;\n    uint256 claimedBitIndex = _index % 256;\n    uint256 claimedWord = _claimedBitMap[claimedWordIndex];\n    uint256 mask = (1 << claimedBitIndex);\n    return claimedWord & mask == mask;\n  }\n\n  function isActive() public view override returns (bool) {\n    return block.timestamp < endTime;\n  }\n\n  function recoverERC20(address _tokenAddress, uint256 _tokenAmount) public onlyOwner {\n    IERC20(_tokenAddress).transfer(owner(), _tokenAmount);\n  }\n\n  function _setClaimed(uint256 _index) private {\n    uint256 claimedWordIndex = _index / 256;\n    uint256 claimedBitIndex = _index % 256;\n    _claimedBitMap[claimedWordIndex] = _claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/interfaces/IMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n// Allows anyone to claim a token if they exist in a merkle root.\ninterface IMerkleDistributor {\n  // This event is triggered whenever a call to #claim succeeds.\n  event Claimed(uint256 index, address account, uint256 amount);\n\n  // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.\n  function claim(\n    uint256 index,\n    address account,\n    uint256 amount,\n    bytes32[] calldata merkleProof\n  ) external;\n\n  // Returns the address of the token distributed by this contract.\n  function token() external view returns (address);\n\n  // Returns the merkle root of the merkle tree containing account balances available to claim.\n  function merkleRoot() external view returns (bytes32);\n\n  // Returns true if the index has been marked claimed.\n  function isClaimed(uint256 index) external view returns (bool);\n\n  // Returns the block timestamp when claims will end\n  function endTime() external view returns (uint256);\n\n  // Returns true if the claim period has not ended.\n  function isActive() external view returns (bool);\n}\n"
    },
    "contracts/v1/VaultsCoreV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../libraries/WadRayMath.sol\";\nimport \"./interfaces/IVaultsCoreV1.sol\";\nimport \"./interfaces/ILiquidationManagerV1.sol\";\nimport \"./interfaces/IAddressProviderV1.sol\";\n\ncontract VaultsCoreV1 is IVaultsCoreV1, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  uint256 public constant MAX_INT = 2**256 - 1;\n\n  mapping(address => uint256) public override cumulativeRates;\n  mapping(address => uint256) public override lastRefresh;\n\n  IAddressProviderV1 public override a;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\n    _;\n  }\n\n  modifier onlyVaultOwner(uint256 _vaultId) {\n    require(a.vaultsData().vaultOwner(_vaultId) == msg.sender);\n    _;\n  }\n\n  modifier onlyConfig() {\n    require(msg.sender == address(a.config()));\n    _;\n  }\n\n  constructor(IAddressProviderV1 _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /*\n    Allow smooth upgrading of the vaultscore.\n    @dev this function approves token transfers to the new vaultscore of\n    both stablex and all configured collateral types\n    @param _newVaultsCore address of the new vaultscore\n  */\n  function upgrade(address _newVaultsCore) public override onlyManager {\n    require(address(_newVaultsCore) != address(0));\n    require(a.stablex().approve(_newVaultsCore, MAX_INT));\n\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      IERC20 asset = IERC20(collateralType);\n      asset.safeApprove(_newVaultsCore, MAX_INT);\n    }\n  }\n\n  /**\n    Calculate the available income\n    @return available income that has not been minted yet.\n  **/\n  function availableIncome() public view override returns (uint256) {\n    return a.vaultsData().debt().sub(a.stablex().totalSupply());\n  }\n\n  /**\n    Refresh the cumulative rates and debts of all vaults and all collateral types.\n  **/\n  function refresh() public override {\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      refreshCollateral(collateralType);\n    }\n  }\n\n  /**\n    Initialize the cumulative rates to 1 for a new collateral type.\n    @param _collateralType the address of the new collateral type to be initialized\n  **/\n  function initializeRates(address _collateralType) public override onlyConfig {\n    require(_collateralType != address(0));\n    lastRefresh[_collateralType] = now;\n    cumulativeRates[_collateralType] = WadRayMath.ray();\n  }\n\n  /**\n    Refresh the cumulative rate of a collateraltype.\n    @dev this updates the debt for all vaults with the specified collateral type.\n    @param _collateralType the address of the collateral type to be refreshed.\n  **/\n  function refreshCollateral(address _collateralType) public override {\n    require(_collateralType != address(0));\n    require(a.config().collateralIds(_collateralType) != 0);\n    uint256 timestamp = now;\n    uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);\n    _refreshCumulativeRate(_collateralType, timeElapsed);\n    lastRefresh[_collateralType] = timestamp;\n  }\n\n  /**\n    Internal function to increase the cumulative rate over a specified time period\n    @dev this updates the debt for all vaults with the specified collateral type.\n    @param _collateralType the address of the collateral type to be updated\n    @param _timeElapsed the amount of time in seconds to add to the cumulative rate\n  **/\n  function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {\n    uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);\n    uint256 oldCumulativeRate = cumulativeRates[_collateralType];\n    cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(\n      borrowRate,\n      oldCumulativeRate,\n      _timeElapsed\n    );\n    emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);\n  }\n\n  /**\n    Deposit an ERC20 token into the vault of the msg.sender as collateral\n    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.\n    this function used `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _collateralType the address of the collateral type to be deposited\n    @param _amount the amount of tokens to be deposited in WEI.\n  **/\n  function deposit(address _collateralType, uint256 _amount) public override {\n    require(a.config().collateralIds(_collateralType) != 0);\n    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);\n    if (vaultId == 0) {\n      vaultId = a.vaultsData().createVault(_collateralType, msg.sender);\n    }\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(vaultId);\n    a.vaultsData().setCollateralBalance(vaultId, v.collateralBalance.add(_amount));\n\n    IERC20 asset = IERC20(v.collateralType);\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Deposited(vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Withdraws ERC20 tokens from a vault.\n    @dev Only te owner of a vault can withdraw collateral from it.\n    `withdraw()` will fail if it would bring the vault below the liquidation treshold.\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\n    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.\n  **/\n  function withdraw(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n    require(_amount <= v.collateralBalance);\n    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);\n    a.vaultsData().setCollateralBalance(_vaultId, newCollateralBalance);\n    if (v.baseDebt > 0) {\n      //save gas cost when withdrawing from 0 debt vault\n      refreshCollateral(v.collateralType);\n      uint256 newCollateralValue = a.priceFeed().convertFrom(v.collateralType, newCollateralBalance);\n      bool _isHealthy = ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(\n        v.collateralType,\n        newCollateralValue,\n        a.vaultsData().vaultDebt(_vaultId)\n      );\n      require(_isHealthy);\n    }\n\n    IERC20 asset = IERC20(v.collateralType);\n    asset.safeTransfer(msg.sender, _amount);\n    emit Withdrawn(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Convenience function to withdraw all collateral of a vault\n    @dev Only te owner of a vault can withdraw collateral from it.\n    `withdrawAll()` will fail if the vault has any outstanding debt attached to it.\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\n  **/\n  function withdrawAll(uint256 _vaultId) public override onlyVaultOwner(_vaultId) {\n    uint256 collateralBalance = a.vaultsData().vaultCollateralBalance(_vaultId);\n    withdraw(_vaultId, collateralBalance);\n  }\n\n  /**\n    Borrow new StableX (Eg: PAR) tokens from a vault.\n    @dev Only te owner of a vault can borrow from it.\n    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.\n     and will fail if it would bring the vault below the liquidation treshold.\n    @param _vaultId the ID of the vault from which to borrow.\n    @param _amount the amount of borrowed StableX tokens in WEI.\n  **/\n  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    //make sure current rate is up to date\n    refreshCollateral(v.collateralType);\n\n    uint256 originationFeePercentage = a.config().collateralOriginationFee(v.collateralType);\n    uint256 newDebt = _amount;\n    if (originationFeePercentage > 0) {\n      newDebt = newDebt.add(_amount.wadMul(originationFeePercentage));\n    }\n\n    // Increment vault borrow balance\n    uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(newDebt, cumulativeRates[v.collateralType]);\n\n    a.vaultsData().setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));\n\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\n    uint256 newVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n\n    require(a.vaultsData().collateralDebt(v.collateralType) <= a.config().collateralDebtLimit(v.collateralType));\n\n    bool isHealthy = ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(\n      v.collateralType,\n      collateralValue,\n      newVaultDebt\n    );\n    require(isHealthy);\n\n    a.stablex().mint(msg.sender, _amount);\n    emit Borrowed(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Convenience function to repay all debt of a vault\n    @dev `repayAll()` will update the outstanding vault debt to the current time.\n    @param _vaultId the ID of the vault for which to repay the debt.\n  **/\n  function repayAll(uint256 _vaultId) public override {\n    repay(_vaultId, 2**256 - 1);\n  }\n\n  /**\n    Repay an outstanding StableX balance to a vault.\n    @dev `repay()` will update the outstanding vault debt to the current time.\n    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.\n    @param _amount the amount of StableX tokens in WEI to be repaid.\n  **/\n  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\n\n    // Make sure current rate is up to date\n    refreshCollateral(collateralType);\n\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n    // Decrement vault borrow balance\n    if (_amount >= currentVaultDebt) {\n      //full repayment\n      _amount = currentVaultDebt; //only pay back what's outstanding\n    }\n    _reduceVaultDebt(_vaultId, _amount);\n    a.stablex().burn(msg.sender, _amount);\n\n    emit Repaid(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Internal helper function to reduce the debt of a vault.\n    @dev assumes cumulative rates for the vault's collateral type are up to date.\n    please call `refreshCollateral()` before calling this function.\n    @param _vaultId the ID of the vault for which to reduce the debt.\n    @param _amount the amount of debt to be reduced.\n  **/\n  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\n\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n    uint256 remainder = currentVaultDebt.sub(_amount);\n    uint256 cumulativeRate = cumulativeRates[collateralType];\n\n    if (remainder == 0) {\n      a.vaultsData().setBaseDebt(_vaultId, 0);\n    } else {\n      uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(remainder, cumulativeRate);\n      a.vaultsData().setBaseDebt(_vaultId, newBaseDebt);\n    }\n  }\n\n  /**\n    Liquidate a vault that is below the liquidation treshold by repaying it's outstanding debt.\n    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\n    to the liquidator. `liquidate()` can be called by anyone.\n    @param _vaultId the ID of the vault to be liquidated.\n  **/\n  function liquidate(uint256 _vaultId) public override nonReentrant {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    refreshCollateral(v.collateralType);\n\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n\n    require(\n      !ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(\n        v.collateralType,\n        collateralValue,\n        currentVaultDebt\n      )\n    );\n\n    uint256 discountedValue = ILiquidationManagerV1(address(a.liquidationManager())).applyLiquidationDiscount(\n      collateralValue\n    );\n    uint256 collateralToReceive;\n    uint256 stableXToPay = currentVaultDebt;\n\n    if (discountedValue < currentVaultDebt) {\n      //Insurance Case\n      uint256 insuranceAmount = currentVaultDebt.sub(discountedValue);\n      require(a.stablex().balanceOf(address(this)) >= insuranceAmount);\n      a.stablex().burn(address(this), insuranceAmount);\n      emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);\n      collateralToReceive = v.collateralBalance;\n      stableXToPay = currentVaultDebt.sub(insuranceAmount);\n    } else {\n      collateralToReceive = a.priceFeed().convertTo(v.collateralType, currentVaultDebt);\n      collateralToReceive = collateralToReceive.add(\n        ILiquidationManagerV1(address(a.liquidationManager())).liquidationBonus(collateralToReceive)\n      );\n    }\n    // reduce the vault debt to 0\n    _reduceVaultDebt(_vaultId, currentVaultDebt);\n    a.stablex().burn(msg.sender, stableXToPay);\n\n    // send the collateral to the liquidator\n    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));\n    IERC20 asset = IERC20(v.collateralType);\n    asset.safeTransfer(msg.sender, collateralToReceive);\n\n    emit Liquidated(_vaultId, stableXToPay, collateralToReceive, v.owner, msg.sender);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/******************\n@title WadRayMath library\n@author Aave\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n */\n\nlibrary WadRayMath {\n  using SafeMath for uint256;\n\n  uint256 internal constant _WAD = 1e18;\n  uint256 internal constant _HALF_WAD = _WAD / 2;\n\n  uint256 internal constant _RAY = 1e27;\n  uint256 internal constant _HALF_RAY = _RAY / 2;\n\n  uint256 internal constant _WAD_RAY_RATIO = 1e9;\n\n  function ray() internal pure returns (uint256) {\n    return _RAY;\n  }\n\n  function wad() internal pure returns (uint256) {\n    return _WAD;\n  }\n\n  function halfRay() internal pure returns (uint256) {\n    return _HALF_RAY;\n  }\n\n  function halfWad() internal pure returns (uint256) {\n    return _HALF_WAD;\n  }\n\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return _HALF_WAD.add(a.mul(b)).div(_WAD);\n  }\n\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 halfB = b / 2;\n\n    return halfB.add(a.mul(_WAD)).div(b);\n  }\n\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return _HALF_RAY.add(a.mul(b)).div(_RAY);\n  }\n\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 halfB = b / 2;\n\n    return halfB.add(a.mul(_RAY)).div(b);\n  }\n\n  function rayToWad(uint256 a) internal pure returns (uint256) {\n    uint256 halfRatio = _WAD_RAY_RATIO / 2;\n\n    return halfRatio.add(a).div(_WAD_RAY_RATIO);\n  }\n\n  function wadToRay(uint256 a) internal pure returns (uint256) {\n    return a.mul(_WAD_RAY_RATIO);\n  }\n\n  /**\n   * @dev calculates x^n, in ray. The code uses the ModExp precompile\n   * @param x base\n   * @param n exponent\n   * @return z = x^n, in ray\n   */\n  function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n    z = n % 2 != 0 ? x : _RAY;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x = rayMul(x, x);\n\n      if (n % 2 != 0) {\n        z = rayMul(z, x);\n      }\n    }\n  }\n}\n"
    },
    "contracts/v1/interfaces/IVaultsCoreV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\nimport './IAddressProviderV1.sol';\n\ninterface IVaultsCoreV1 {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawAll(uint256 _vaultId) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  //Refresh\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  //upgrade\n  function upgrade(address _newVaultsCore) external;\n\n  //Read only\n\n  function a() external view returns (IAddressProviderV1);\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/v1/interfaces/ILiquidationManagerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport './IAddressProviderV1.sol';\n\ninterface ILiquidationManagerV1 {\n  function a() external view returns (IAddressProviderV1);\n\n  function calculateHealthFactor(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(uint256 _amount) external view returns (uint256 discountedAmount);\n\n  function isHealthy(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (bool);\n}\n"
    },
    "contracts/v1/interfaces/IAddressProviderV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport './IConfigProviderV1.sol';\nimport './ILiquidationManagerV1.sol';\nimport './IVaultsCoreV1.sol';\nimport '../../interfaces/IVaultsCore.sol';\nimport '../../interfaces/IAccessController.sol';\nimport '../../interfaces/ISTABLEX.sol';\nimport '../../interfaces/IPriceFeed.sol';\nimport '../../interfaces/IRatesManager.sol';\nimport '../../interfaces/IVaultsDataProvider.sol';\nimport '../../interfaces/IFeeDistributor.sol';\n\ninterface IAddressProviderV1 {\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProviderV1 _config) external;\n\n  function setVaultsCore(IVaultsCoreV1 _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManagerV1 _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProviderV1);\n\n  function core() external view returns (IVaultsCoreV1);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManagerV1);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n}\n"
    },
    "contracts/v1/interfaces/IConfigProviderV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport './IAddressProviderV1.sol';\n\ninterface IConfigProviderV1 {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n  }\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setLiquidationBonus(uint256 _bonus) external;\n\n  function a() external view returns (IAddressProviderV1);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function liquidationBonus() external view returns (uint256);\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IVaultsCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVaultsCoreState.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../liquidityMining/interfaces/IDebtNotifier.sol\";\n\ninterface IVaultsCore {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function depositETH() external payable;\n\n  function depositByVaultId(uint256 _vaultId, uint256 _amount) external;\n\n  function depositETHByVaultId(uint256 _vaultId) external payable;\n\n  function depositAndBorrow(\n    address _collateralType,\n    uint256 _depositAmount,\n    uint256 _borrowAmount\n  ) external;\n\n  function depositETHAndBorrow(uint256 _borrowAmount) external payable;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawETH(uint256 _vaultId, uint256 _amount) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  function liquidatePartial(uint256 _vaultId, uint256 _amount) external;\n\n  function upgrade(address payable _newVaultsCore) external;\n\n  function acceptUpgrade(address payable _oldVaultsCore) external;\n\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\n\n  //Read only\n  function a() external view returns (IAddressProvider);\n\n  function WETH() external view returns (IWETH);\n\n  function debtNotifier() external view returns (IDebtNotifier);\n\n  function state() external view returns (IVaultsCoreState);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IAccessController {\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function renounceRole(bytes32 role, address account) external;\n\n  function MANAGER_ROLE() external view returns (bytes32);\n\n  function MINTER_ROLE() external view returns (bytes32);\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/ISTABLEX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface ISTABLEX is IERC20 {\n  function mint(address account, uint256 amount) external;\n\n  function burn(address account, uint256 amount) external;\n\n  function a() external view returns (IAddressProvider);\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../chainlink/AggregatorV3Interface.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IPriceFeed {\n  event OracleUpdated(address indexed asset, address oracle, address sender);\n  event EurOracleUpdated(address oracle, address sender);\n\n  function setAssetOracle(address _asset, address _oracle) external;\n\n  function setEurOracle(address _oracle) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function assetOracles(address _asset) external view returns (AggregatorV3Interface);\n\n  function eurOracle() external view returns (AggregatorV3Interface);\n\n  function getAssetPrice(address _asset) external view returns (uint256);\n\n  function convertFrom(address _asset, uint256 _amount) external view returns (uint256);\n\n  function convertTo(address _asset, uint256 _amount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRatesManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IRatesManager {\n  function a() external view returns (IAddressProvider);\n\n  //current annualized borrow rate\n  function annualizedBorrowRate(uint256 _currentBorrowRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate totalDebt based on baseDebt at time T0\n  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate baseDebt at time T0\n  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //calculate a new cumulative rate\n  function calculateCumulativeRate(\n    uint256 _borrowRate,\n    uint256 _cumulativeRate,\n    uint256 _timeElapsed\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IVaultsDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IVaultsDataProvider {\n  struct Vault {\n    // borrowedType support USDX / PAR\n    address collateralType;\n    address owner;\n    uint256 collateralBalance;\n    uint256 baseDebt;\n    uint256 createdAt;\n  }\n\n  //Write\n  function createVault(address _collateralType, address _owner) external returns (uint256);\n\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\n\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\n\n  // Read\n  function a() external view returns (IAddressProvider);\n\n  function baseDebt(address _collateralType) external view returns (uint256);\n\n  function vaultCount() external view returns (uint256);\n\n  function vaults(uint256 _id) external view returns (Vault memory);\n\n  function vaultOwner(uint256 _id) external view returns (address);\n\n  function vaultCollateralType(uint256 _id) external view returns (address);\n\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\n\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\n\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\n\n  function vaultExists(uint256 _id) external view returns (bool);\n\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function collateralDebt(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IFeeDistributor {\n  event PayeeAdded(address indexed account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  function release() external;\n\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function lastReleasedAt() external view returns (uint256);\n\n  function getPayees() external view returns (address[] memory);\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address payee) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"./IAccessController.sol\";\nimport \"./IConfigProvider.sol\";\nimport \"./ISTABLEX.sol\";\nimport \"./IPriceFeed.sol\";\nimport \"./IRatesManager.sol\";\nimport \"./ILiquidationManager.sol\";\nimport \"./IVaultsCore.sol\";\nimport \"./IVaultsDataProvider.sol\";\nimport \"./IFeeDistributor.sol\";\n\ninterface IAddressProvider {\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProvider _config) external;\n\n  function setVaultsCore(IVaultsCore _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManager _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProvider);\n\n  function core() external view returns (IVaultsCore);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManager);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n}\n"
    },
    "contracts/interfaces/IVaultsCoreState.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\nimport \"./IAddressProvider.sol\";\nimport \"../v1/interfaces/IVaultsCoreV1.sol\";\n\ninterface IVaultsCoreState {\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\n\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  function syncState(IVaultsCoreState _stateAddress) external;\n\n  function syncStateFromV1(IVaultsCoreV1 _core) external;\n\n  //Read only\n  function a() external view returns (IAddressProvider);\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n\n  function synced() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\ninterface IWETH {\n  function deposit() external payable;\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/liquidityMining/interfaces/IDebtNotifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport '../../governance/interfaces/IGovernanceAddressProvider.sol';\nimport './ISupplyMiner.sol';\n\ninterface IDebtNotifier {\n  function debtChanged(uint256 _vaultId) external;\n\n  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) external;\n\n  function a() external view returns (IGovernanceAddressProvider);\n\n  function collateralSupplyMinerMapping(address collateral) external view returns (ISupplyMiner);\n}\n"
    },
    "contracts/interfaces/IConfigProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IConfigProvider {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 liquidationRatio;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n    uint256 liquidationBonus;\n    uint256 liquidationFee;\n  }\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 liquidationRatio,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee,\n    uint256 liquidationBonus,\n    uint256 liquidationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _liquidationRatio,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee,\n    uint256 _liquidationBonus,\n    uint256 _liquidationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus) external;\n\n  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) external;\n\n  function setMinVotingPeriod(uint256 _minVotingPeriod) external;\n\n  function setMaxVotingPeriod(uint256 _maxVotingPeriod) external;\n\n  function setVotingQuorum(uint256 _votingQuorum) external;\n\n  function setProposalThreshold(uint256 _proposalThreshold) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function minVotingPeriod() external view returns (uint256);\n\n  function maxVotingPeriod() external view returns (uint256);\n\n  function votingQuorum() external view returns (uint256);\n\n  function proposalThreshold() external view returns (uint256);\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationRatio(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationBonus(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationFee(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILiquidationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface ILiquidationManager {\n  function a() external view returns (IAddressProvider);\n\n  function calculateHealthFactor(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(address _collateralType, uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(address _collateralType, uint256 _amount)\n    external\n    view\n    returns (uint256 discountedAmount);\n\n  function isHealthy(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) external view returns (bool);\n}\n"
    },
    "contracts/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/governance/interfaces/IGovernanceAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport './IGovernorAlpha.sol';\nimport './ITimelock.sol';\nimport './IVotingEscrow.sol';\nimport '../../interfaces/IAccessController.sol';\nimport '../../interfaces/IAddressProvider.sol';\nimport '../../liquidityMining/interfaces/IMIMO.sol';\nimport '../../liquidityMining/interfaces/IDebtNotifier.sol';\n\ninterface IGovernanceAddressProvider {\n  function setParallelAddressProvider(IAddressProvider _parallel) external;\n\n  function setMIMO(IMIMO _mimo) external;\n\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\n\n  function setGovernorAlpha(IGovernorAlpha _governorAlpha) external;\n\n  function setTimelock(ITimelock _timelock) external;\n\n  function setVotingEscrow(IVotingEscrow _votingEscrow) external;\n\n  function controller() external view returns (IAccessController);\n\n  function parallel() external view returns (IAddressProvider);\n\n  function mimo() external view returns (IMIMO);\n\n  function debtNotifier() external view returns (IDebtNotifier);\n\n  function governorAlpha() external view returns (IGovernorAlpha);\n\n  function timelock() external view returns (ITimelock);\n\n  function votingEscrow() external view returns (IVotingEscrow);\n}\n"
    },
    "contracts/liquidityMining/interfaces/ISupplyMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\ninterface ISupplyMiner {\n  function baseDebtChanged(address user, uint256 newBaseDebt) external;\n}\n"
    },
    "contracts/governance/interfaces/IGovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\ninterface IGovernorAlpha {\n  /// @notice Possible states that a proposal may be in\n  enum ProposalState { Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }\n\n  struct Proposal {\n    // Unique id for looking up a proposal\n    uint256 id;\n    // Creator of the proposal\n    address proposer;\n    // The timestamp that the proposal will be available for execution, set once the vote succeeds\n    uint256 eta;\n    // the ordered list of target addresses for calls to be made\n    address[] targets;\n    // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n    uint256[] values;\n    // The ordered list of function signatures to be called\n    string[] signatures;\n    // The ordered list of calldata to be passed to each call\n    bytes[] calldatas;\n    // The timestamp at which voting begins: holders must delegate their votes prior to this timestamp\n    uint256 startTime;\n    // The timestamp at which voting ends: votes must be cast prior to this timestamp\n    uint256 endTime;\n    // Current number of votes in favor of this proposal\n    uint256 forVotes;\n    // Current number of votes in opposition to this proposal\n    uint256 againstVotes;\n    // Flag marking whether the proposal has been canceled\n    bool canceled;\n    // Flag marking whether the proposal has been executed\n    bool executed;\n    // Receipts of ballots for the entire set of voters\n    mapping(address => Receipt) receipts;\n  }\n\n  /// @notice Ballot receipt record for a voter\n  struct Receipt {\n    // Whether or not a vote has been cast\n    bool hasVoted;\n    // Whether or not the voter supports the proposal\n    bool support;\n    // The number of votes the voter had, which were cast\n    uint256 votes;\n  }\n\n  /// @notice An event emitted when a new proposal is created\n  event ProposalCreated(\n    uint256 id,\n    address proposer,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint256 startTime,\n    uint256 endTime,\n    string description\n  );\n\n  /// @notice An event emitted when a vote has been cast on a proposal\n  event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n  /// @notice An event emitted when a proposal has been canceled\n  event ProposalCanceled(uint256 id);\n\n  /// @notice An event emitted when a proposal has been queued in the Timelock\n  event ProposalQueued(uint256 id, uint256 eta);\n\n  /// @notice An event emitted when a proposal has been executed in the Timelock\n  event ProposalExecuted(uint256 id);\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description,\n    uint256 endTime\n  ) external returns (uint256);\n\n  function queue(uint256 proposalId) external;\n\n  function execute(uint256 proposalId) external payable;\n\n  function cancel(uint256 proposalId) external;\n\n  function castVote(uint256 proposalId, bool support) external;\n\n  function getActions(uint256 proposalId)\n    external\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    );\n\n  function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);\n\n  function state(uint256 proposalId) external view returns (ProposalState);\n\n  function quorumVotes() external view returns (uint256);\n\n  function proposalThreshold() external view returns (uint256);\n}\n"
    },
    "contracts/governance/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\ninterface ITimelock {\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  function acceptAdmin() external;\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n}\n"
    },
    "contracts/governance/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '../../liquidityMining/interfaces/IGenericMiner.sol';\n\ninterface IVotingEscrow {\n  enum LockAction { CREATE_LOCK, INCREASE_LOCK_AMOUNT, INCREASE_LOCK_TIME }\n\n  struct LockedBalance {\n    uint256 amount;\n    uint256 end;\n  }\n\n  /** Shared Events */\n  event Deposit(address indexed provider, uint256 value, uint256 locktime, LockAction indexed action, uint256 ts);\n  event Withdraw(address indexed provider, uint256 value, uint256 ts);\n  event Expired();\n\n  function createLock(uint256 _value, uint256 _unlockTime) external;\n\n  function increaseLockAmount(uint256 _value) external;\n\n  function increaseLockLength(uint256 _unlockTime) external;\n\n  function withdraw() external;\n\n  function expireContract() external;\n\n  function setMiner(IGenericMiner _miner) external;\n\n  function setMinimumLockTime(uint256 _minimumLockTime) external;\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint256);\n\n  function balanceOf(address _owner) external view returns (uint256);\n\n  function balanceOfAt(address _owner, uint256 _blockTime) external view returns (uint256);\n\n  function stakingToken() external view returns (IERC20);\n}\n"
    },
    "contracts/liquidityMining/interfaces/IMIMO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IMIMO is IERC20 {\n  function burn(address account, uint256 amount) external;\n\n  function mint(address account, uint256 amount) external;\n}\n"
    },
    "contracts/liquidityMining/interfaces/IGenericMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '../../interfaces/IAddressProvider.sol';\nimport '../../governance/interfaces/IGovernanceAddressProvider.sol';\n\ninterface IGenericMiner {\n  struct UserInfo {\n    uint256 stake;\n    uint256 accAmountPerShare; // User's accAmountPerShare\n  }\n\n  /// @dev This emit when a users' productivity has changed\n  /// It emits with the user's address and the the value after the change.\n  event StakeIncreased(address indexed user, uint256 stake);\n\n  /// @dev This emit when a users' productivity has changed\n  /// It emits with the user's address and the the value after the change.\n  event StakeDecreased(address indexed user, uint256 stake);\n\n  function releaseMIMO(address _user) external;\n\n  function a() external view returns (IGovernanceAddressProvider);\n\n  function stake(address _user) external view returns (uint256);\n\n  function pendingMIMO(address _user) external view returns (uint256);\n\n  function totalStake() external view returns (uint256);\n\n  function userInfo(address _user) external view returns (UserInfo memory);\n}\n"
    },
    "contracts/v1/VaultsDataProviderV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IVaultsDataProviderV1.sol\";\nimport \"./interfaces/IAddressProviderV1.sol\";\n\ncontract VaultsDataProviderV1 is IVaultsDataProviderV1 {\n  using SafeMath for uint256;\n\n  IAddressProviderV1 public override a;\n\n  uint256 public override vaultCount = 0;\n\n  mapping(address => uint256) public override baseDebt;\n\n  mapping(uint256 => Vault) private _vaults;\n  mapping(address => mapping(address => uint256)) private _vaultOwners;\n\n  modifier onlyVaultsCore() {\n    require(msg.sender == address(a.core()), \"Caller is not VaultsCore\");\n    _;\n  }\n\n  constructor(IAddressProviderV1 _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Opens a new vault.\n    @dev only the vaultsCore module can call this function\n    @param _collateralType address to the collateral asset e.g. WETH\n    @param _owner the owner of the new vault.\n  */\n  function createVault(address _collateralType, address _owner) public override onlyVaultsCore returns (uint256) {\n    require(_collateralType != address(0));\n    require(_owner != address(0));\n    uint256 newId = ++vaultCount;\n    require(_collateralType != address(0), \"collateralType unknown\");\n    Vault memory v = Vault({\n      collateralType: _collateralType,\n      owner: _owner,\n      collateralBalance: 0,\n      baseDebt: 0,\n      createdAt: block.timestamp\n    });\n    _vaults[newId] = v;\n    _vaultOwners[_owner][_collateralType] = newId;\n    return newId;\n  }\n\n  /**\n    Set the collateral balance of a vault.\n    @dev only the vaultsCore module can call this function\n    @param _id Vault ID of which the collateral balance will be updated\n    @param _balance the new balance of the vault.\n  */\n  function setCollateralBalance(uint256 _id, uint256 _balance) public override onlyVaultsCore {\n    require(vaultExists(_id), \"Vault not found.\");\n    Vault storage v = _vaults[_id];\n    v.collateralBalance = _balance;\n  }\n\n  /**\n    Set the base debt of a vault.\n    @dev only the vaultsCore module can call this function\n    @param _id Vault ID of which the base debt will be updated\n    @param _newBaseDebt the new base debt of the vault.\n  */\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) public override onlyVaultsCore {\n    Vault storage _vault = _vaults[_id];\n    if (_newBaseDebt > _vault.baseDebt) {\n      uint256 increase = _newBaseDebt.sub(_vault.baseDebt);\n      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].add(increase);\n    } else {\n      uint256 decrease = _vault.baseDebt.sub(_newBaseDebt);\n      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].sub(decrease);\n    }\n    _vault.baseDebt = _newBaseDebt;\n  }\n\n  /**\n    Get a vault by vault ID.\n    @param _id The vault's ID to be retrieved\n  */\n  function vaults(uint256 _id) public view override returns (Vault memory) {\n    Vault memory v = _vaults[_id];\n    return v;\n  }\n\n  /**\n    Get the owner of a vault.\n    @param _id the ID of the vault\n    @return owner of the vault\n  */\n  function vaultOwner(uint256 _id) public view override returns (address) {\n    return _vaults[_id].owner;\n  }\n\n  /**\n    Get the collateral type of a vault.\n    @param _id the ID of the vault\n    @return address for the collateral type of the vault\n  */\n  function vaultCollateralType(uint256 _id) public view override returns (address) {\n    return _vaults[_id].collateralType;\n  }\n\n  /**\n    Get the collateral balance of a vault.\n    @param _id the ID of the vault\n    @return collateral balance of the vault\n  */\n  function vaultCollateralBalance(uint256 _id) public view override returns (uint256) {\n    return _vaults[_id].collateralBalance;\n  }\n\n  /**\n    Get the base debt of a vault.\n    @param _id the ID of the vault\n    @return base debt of the vault\n  */\n  function vaultBaseDebt(uint256 _id) public view override returns (uint256) {\n    return _vaults[_id].baseDebt;\n  }\n\n  /**\n    Retrieve the vault id for a specified owner and collateral type.\n    @dev returns 0 for non-existing vaults\n    @param _collateralType address of the collateral type (Eg: WETH)\n    @param _owner address of the owner of the vault\n    @return vault id of the vault or 0\n  */\n  function vaultId(address _collateralType, address _owner) public view override returns (uint256) {\n    return _vaultOwners[_owner][_collateralType];\n  }\n\n  /**\n    Checks if a specified vault exists.\n    @param _id the ID of the vault\n    @return boolean if the vault exists\n  */\n  function vaultExists(uint256 _id) public view override returns (bool) {\n    Vault memory v = _vaults[_id];\n    return v.collateralType != address(0);\n  }\n\n  /**\n    Calculated the total outstanding debt for all vaults and all collateral types.\n    @dev uses the existing cumulative rate. Call `refresh()` on `VaultsCore`\n    to make sure it's up to date.\n    @return total debt of the platform\n  */\n  function debt() public view override returns (uint256) {\n    uint256 total = 0;\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      total = total.add(collateralDebt(collateralType));\n    }\n    return total;\n  }\n\n  /**\n    Calculated the total outstanding debt for all vaults of a specific collateral type.\n    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`\n    to make sure it's up to date.\n    @param _collateralType address of the collateral type (Eg: WETH)\n    @return total debt of the platform of one collateral type\n  */\n  function collateralDebt(address _collateralType) public view override returns (uint256) {\n    return a.ratesManager().calculateDebt(baseDebt[_collateralType], a.core().cumulativeRates(_collateralType));\n  }\n\n  /**\n    Calculated the total outstanding debt for a specific vault.\n    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`\n    to make sure it's up to date.\n    @param _vaultId the ID of the vault\n    @return total debt of one vault\n  */\n  function vaultDebt(uint256 _vaultId) public view override returns (uint256) {\n    IVaultsDataProviderV1.Vault memory v = vaults(_vaultId);\n    return a.ratesManager().calculateDebt(v.baseDebt, a.core().cumulativeRates(v.collateralType));\n  }\n}\n"
    },
    "contracts/v1/interfaces/IVaultsDataProviderV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\nimport './IAddressProviderV1.sol';\n\ninterface IVaultsDataProviderV1 {\n  struct Vault {\n    // borrowedType support USDX / PAR\n    address collateralType;\n    address owner;\n    uint256 collateralBalance;\n    uint256 baseDebt;\n    uint256 createdAt;\n  }\n\n  //Write\n  function createVault(address _collateralType, address _owner) external returns (uint256);\n\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\n\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\n\n  function a() external view returns (IAddressProviderV1);\n\n  // Read\n  function baseDebt(address _collateralType) external view returns (uint256);\n\n  function vaultCount() external view returns (uint256);\n\n  function vaults(uint256 _id) external view returns (Vault memory);\n\n  function vaultOwner(uint256 _id) external view returns (address);\n\n  function vaultCollateralType(uint256 _id) external view returns (address);\n\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\n\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\n\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\n\n  function vaultExists(uint256 _id) external view returns (bool);\n\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function collateralDebt(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/v1/LiquidiationManagerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"./interfaces/IAddressProviderV1.sol\";\nimport \"./interfaces/IConfigProviderV1.sol\";\nimport \"./interfaces/ILiquidationManagerV1.sol\";\n\ncontract LiquidationManagerV1 is ILiquidationManagerV1, ReentrancyGuard {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  IAddressProviderV1 public override a;\n\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18; // 1\n  uint256 public constant FULL_LIQUIDIATION_TRESHOLD = 100e18; // 100 USDX, vaults below 100 USDX can be liquidated in full\n\n  constructor(IAddressProviderV1 _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Check if the health factor is above or equal to 1.\n    @param _collateralType address of the collateral type\n    @param _collateralValue value of the collateral in stableX currency\n    @param _vaultDebt outstanding debt to which the collateral balance shall be compared\n    @return boolean if the health factor is >= 1.\n  */\n  function isHealthy(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) public view override returns (bool) {\n    uint256 healthFactor = calculateHealthFactor(_collateralType, _collateralValue, _vaultDebt);\n    return healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\n  }\n\n  /**\n    Calculate the healthfactor of a debt balance\n    @param _collateralType address of the collateral type\n    @param _collateralValue value of the collateral in stableX currency\n    @param _vaultDebt outstanding debt to which the collateral balance shall be compared\n    @return healthFactor\n  */\n  function calculateHealthFactor(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) public view override returns (uint256 healthFactor) {\n    if (_vaultDebt == 0) return WadRayMath.wad();\n\n    // CurrentCollateralizationRatio = deposited ETH in USD / debt in USD\n    uint256 collateralizationRatio = _collateralValue.wadDiv(_vaultDebt);\n\n    // Healthfactor = CurrentCollateralizationRatio / MinimumCollateralizationRatio\n\n    uint256 collateralId = a.config().collateralIds(_collateralType);\n    require(collateralId > 0, \"collateral not supported\");\n\n    uint256 minRatio = a.config().collateralConfigs(collateralId).minCollateralRatio;\n    if (minRatio > 0) {\n      return collateralizationRatio.wadDiv(minRatio);\n    }\n\n    return 1e18; // 1\n  }\n\n  /**\n    Calculate the liquidation bonus for a specified amount\n    @param _amount amount for which the liquidation bonus shall be calculated\n    @return bonus the liquidation bonus to pay out\n  */\n  function liquidationBonus(uint256 _amount) public view override returns (uint256 bonus) {\n    return _amount.wadMul(IConfigProviderV1(address(a.config())).liquidationBonus());\n  }\n\n  /**\n    Apply the liquidation bonus to a balance as a discount.\n    @param _amount the balance on which to apply to liquidation bonus as a discount.\n    @return discountedAmount\n  */\n  function applyLiquidationDiscount(uint256 _amount) public view override returns (uint256 discountedAmount) {\n    return _amount.wadDiv(IConfigProviderV1(address(a.config())).liquidationBonus().add(WadRayMath.wad()));\n  }\n}\n"
    },
    "contracts/v1/AddressProviderV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVaultsCore.sol\";\nimport \"../interfaces/IAccessController.sol\";\nimport \"../interfaces/IConfigProvider.sol\";\nimport \"../interfaces/ISTABLEX.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/IRatesManager.sol\";\nimport \"../interfaces/IVaultsDataProvider.sol\";\nimport \"./interfaces/IConfigProviderV1.sol\";\nimport \"./interfaces/ILiquidationManagerV1.sol\";\nimport \"./interfaces/IVaultsCoreV1.sol\";\n\ncontract AddressProviderV1 is IAddressProvider {\n  IAccessController public override controller;\n  IConfigProvider public override config;\n  IVaultsCore public override core;\n\n  ISTABLEX public override stablex;\n  IRatesManager public override ratesManager;\n  IPriceFeed public override priceFeed;\n  ILiquidationManager public override liquidationManager;\n  IVaultsDataProvider public override vaultsData;\n  IFeeDistributor public override feeDistributor;\n\n  constructor(IAccessController _controller) public {\n    controller = _controller;\n  }\n\n  modifier onlyManager() {\n    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  function setAccessController(IAccessController _controller) public override onlyManager {\n    require(address(_controller) != address(0));\n    controller = _controller;\n  }\n\n  function setConfigProvider(IConfigProvider _config) public override onlyManager {\n    require(address(_config) != address(0));\n    config = _config;\n  }\n\n  function setVaultsCore(IVaultsCore _core) public override onlyManager {\n    require(address(_core) != address(0));\n    core = _core;\n  }\n\n  function setStableX(ISTABLEX _stablex) public override onlyManager {\n    require(address(_stablex) != address(0));\n    stablex = _stablex;\n  }\n\n  function setRatesManager(IRatesManager _ratesManager) public override onlyManager {\n    require(address(_ratesManager) != address(0));\n    ratesManager = _ratesManager;\n  }\n\n  function setLiquidationManager(ILiquidationManager _liquidationManager) public override onlyManager {\n    require(address(_liquidationManager) != address(0));\n    liquidationManager = _liquidationManager;\n  }\n\n  function setPriceFeed(IPriceFeed _priceFeed) public override onlyManager {\n    require(address(_priceFeed) != address(0));\n    priceFeed = _priceFeed;\n  }\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) public override onlyManager {\n    require(address(_vaultsData) != address(0));\n    vaultsData = _vaultsData;\n  }\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) public override onlyManager {\n    require(address(_feeDistributor) != address(0));\n    feeDistributor = _feeDistributor;\n  }\n}\n"
    },
    "contracts/v1/ConfigProviderV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"../libraries/WadRayMath.sol\";\nimport \"./interfaces/IConfigProviderV1.sol\";\nimport \"./interfaces/IAddressProviderV1.sol\";\nimport \"./interfaces/IVaultsCoreV1.sol\";\n\ncontract ConfigProviderV1 is IConfigProviderV1 {\n  IAddressProviderV1 public override a;\n\n  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1\n  mapping(address => uint256) public override collateralIds;\n\n  uint256 public override numCollateralConfigs;\n  uint256 public override liquidationBonus = 5e16; // 5%\n\n  constructor(IAddressProviderV1 _addresses) public {\n    a = _addresses;\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  /**\n    Creates or overwrites an existing config for a collateral type\n    @param _collateralType address of the collateral type\n    @param _debtLimit the debt ceiling for the collateral type\n    @param _minCollateralRatio the minimum ratio to maintain to avoid liquidation\n    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.\n    @param _originationFee an optional origination fee for newly created debt. Can be 0.\n  */\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee\n  ) public override onlyManager {\n    require(address(_collateralType) != address(0));\n    if (collateralIds[_collateralType] == 0) {\n      //new collateral\n      IVaultsCoreV1(address(a.core())).initializeRates(_collateralType);\n      CollateralConfig memory config = CollateralConfig({\n        collateralType: _collateralType,\n        debtLimit: _debtLimit,\n        minCollateralRatio: _minCollateralRatio,\n        borrowRate: _borrowRate,\n        originationFee: _originationFee\n      });\n\n      numCollateralConfigs++;\n      _collateralConfigs[numCollateralConfigs] = config;\n      collateralIds[_collateralType] = numCollateralConfigs;\n    } else {\n      // Update collateral config\n      IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);\n      uint256 id = collateralIds[_collateralType];\n\n      _collateralConfigs[id].collateralType = _collateralType;\n      _collateralConfigs[id].debtLimit = _debtLimit;\n      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;\n      _collateralConfigs[id].borrowRate = _borrowRate;\n      _collateralConfigs[id].originationFee = _originationFee;\n    }\n    emit CollateralUpdated(_collateralType, _debtLimit, _minCollateralRatio, _borrowRate, _originationFee);\n  }\n\n  function _emitUpdateEvent(address _collateralType) internal {\n    emit CollateralUpdated(\n      _collateralType,\n      _collateralConfigs[collateralIds[_collateralType]].debtLimit,\n      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,\n      _collateralConfigs[collateralIds[_collateralType]].borrowRate,\n      _collateralConfigs[collateralIds[_collateralType]].originationFee\n    );\n  }\n\n  /**\n    Remove the config for a collateral type\n    @param _collateralType address of the collateral type\n  */\n  function removeCollateral(address _collateralType) public override onlyManager {\n    uint256 id = collateralIds[_collateralType];\n    require(id != 0, \"collateral does not exist\");\n\n    collateralIds[_collateralType] = 0;\n\n    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward\n    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry\n    delete _collateralConfigs[numCollateralConfigs];\n    numCollateralConfigs--;\n\n    emit CollateralRemoved(_collateralType);\n  }\n\n  /**\n    Sets the debt limit for a collateral type\n    @param _collateralType address of the collateral type\n    @param _debtLimit the new debt limit\n  */\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {\n    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the minimum collateralization ratio for a collateral type\n    @dev this is the liquidation treshold under which a vault is considered open for liquidation.\n    @param _collateralType address of the collateral type\n    @param _minCollateralRatio the new minimum collateralization ratio\n  */\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)\n    public\n    override\n    onlyManager\n  {\n    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the borrowing rate for a collateral type\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\n    @param _collateralType address of the collateral type\n    @param _borrowRate the new borrowing rate for a 1 sec interval\n  */\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {\n    IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);\n    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the origiation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n    @param _originationFee new origination fee in WAD\n  */\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {\n    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Get the debt limit for a collateral type\n    @dev this is a platform wide limit for new debt issuance against a specific collateral type\n    @param _collateralType address of the collateral type\n  */\n  function collateralDebtLimit(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;\n  }\n\n  /**\n    Get the minimum collateralization ratio for a collateral type\n    @dev this is the liquidation treshold under which a vault is considered open for liquidation.\n    @param _collateralType address of the collateral type\n  */\n  function collateralMinCollateralRatio(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;\n  }\n\n  /**\n    Get the borrowing rate for a collateral type\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\n    @param _collateralType address of the collateral type\n  */\n  function collateralBorrowRate(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;\n  }\n\n  /**\n    Get the origiation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n  */\n  function collateralOriginationFee(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].originationFee;\n  }\n\n  /**\n    Set the platform wide incentive for liquidations.\n    @dev the liquidation bonus is specified in WAD\n    @param _bonus the liquidation bonus to be paid to liquidators\n  */\n  function setLiquidationBonus(uint256 _bonus) public override onlyManager {\n    liquidationBonus = _bonus;\n  }\n\n  /**\n    Retreives the entire config for a specific config id.\n    @param _id the ID of the conifg to be returned\n  */\n  function collateralConfigs(uint256 _id) public view override returns (CollateralConfig memory) {\n    require(_id <= numCollateralConfigs, \"Invalid config id\");\n    return _collateralConfigs[_id];\n  }\n}\n"
    },
    "contracts/upgrade/Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../v1/interfaces/IConfigProviderV1.sol\";\nimport \"../v1/interfaces/IVaultsCoreV1.sol\";\nimport \"../v1/interfaces/IFeeDistributorV1.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVaultsCore.sol\";\nimport \"../interfaces/IVaultsCoreState.sol\";\nimport \"../interfaces/ILiquidationManager.sol\";\nimport \"../interfaces/IConfigProvider.sol\";\nimport \"../interfaces/IFeeDistributor.sol\";\nimport \"../liquidityMining/interfaces/IDebtNotifier.sol\";\n\ncontract Upgrade {\n  using SafeMath for uint256;\n\n  uint256 public constant LIQUIDATION_BONUS = 5e16; // 5%\n\n  IAddressProvider public a;\n  IVaultsCore public core;\n  IVaultsCoreState public coreState;\n  ILiquidationManager public liquidationManager;\n  IConfigProvider public config;\n  IFeeDistributor public feeDistributor;\n  IDebtNotifier public debtNotifier;\n  IPriceFeed public priceFeed;\n  address public bpool;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\n    _;\n  }\n\n  constructor(\n    IAddressProvider _addresses,\n    IVaultsCore _core,\n    IVaultsCoreState _coreState,\n    ILiquidationManager _liquidationManager,\n    IConfigProvider _config,\n    IFeeDistributor _feeDistributor,\n    IDebtNotifier _debtNotifier,\n    IPriceFeed _priceFeed,\n    address _bpool\n  ) public {\n    require(address(_addresses) != address(0));\n    require(address(_core) != address(0));\n    require(address(_coreState) != address(0));\n    require(address(_liquidationManager) != address(0));\n    require(address(_config) != address(0));\n    require(address(_feeDistributor) != address(0));\n    require(address(_debtNotifier) != address(0));\n    require(address(_priceFeed) != address(0));\n    require(_bpool != address(0));\n\n    a = _addresses;\n    core = _core;\n    coreState = _coreState;\n    liquidationManager = _liquidationManager;\n    config = _config;\n    feeDistributor = _feeDistributor;\n    debtNotifier = _debtNotifier;\n    priceFeed = _priceFeed;\n    bpool = _bpool;\n  }\n\n  function upgrade() public onlyManager {\n    IConfigProviderV1 oldConfig = IConfigProviderV1(address(a.config()));\n    IPriceFeed oldPriceFeed = IPriceFeed(address(a.priceFeed()));\n    IVaultsCoreV1 oldCore = IVaultsCoreV1(address(a.core()));\n    IFeeDistributorV1 oldFeeDistributor = IFeeDistributorV1(address(a.feeDistributor()));\n\n    bytes32 MINTER_ROLE = a.controller().MINTER_ROLE();\n    bytes32 MANAGER_ROLE = a.controller().MANAGER_ROLE();\n    bytes32 DEFAULT_ADMIN_ROLE = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    a.controller().grantRole(MANAGER_ROLE, address(this));\n    a.controller().grantRole(MINTER_ROLE, address(core));\n    a.controller().grantRole(MINTER_ROLE, address(feeDistributor));\n\n    oldCore.refresh();\n    if (oldCore.availableIncome() > 0) {\n      oldFeeDistributor.release();\n    }\n\n    a.controller().revokeRole(MINTER_ROLE, address(a.core()));\n    a.controller().revokeRole(MINTER_ROLE, address(a.feeDistributor()));\n\n    oldCore.upgrade(payable(address(core)));\n\n    a.setVaultsCore(core);\n    a.setConfigProvider(config);\n    a.setLiquidationManager(liquidationManager);\n    a.setFeeDistributor(feeDistributor);\n    a.setPriceFeed(priceFeed);\n\n    priceFeed.setEurOracle(address(oldPriceFeed.eurOracle()));\n\n    uint256 numCollateralConfigs = oldConfig.numCollateralConfigs();\n    for (uint256 i = 1; i <= numCollateralConfigs; i++) {\n      IConfigProviderV1.CollateralConfig memory collateralConfig = oldConfig.collateralConfigs(i);\n\n      config.setCollateralConfig(\n        collateralConfig.collateralType,\n        collateralConfig.debtLimit,\n        collateralConfig.minCollateralRatio,\n        collateralConfig.minCollateralRatio,\n        collateralConfig.borrowRate,\n        collateralConfig.originationFee,\n        LIQUIDATION_BONUS,\n        0\n      );\n\n      priceFeed.setAssetOracle(\n        collateralConfig.collateralType,\n        address(oldPriceFeed.assetOracles(collateralConfig.collateralType))\n      );\n    }\n\n    coreState.syncStateFromV1(oldCore);\n    core.acceptUpgrade(payable(address(oldCore)));\n    core.setDebtNotifier(debtNotifier);\n    debtNotifier.a().setDebtNotifier(debtNotifier);\n\n    address[] memory payees = new address[](2);\n    payees[0] = bpool;\n    payees[1] = address(core);\n    uint256[] memory shares = new uint256[](2);\n    shares[0] = uint256(90);\n    shares[1] = uint256(10);\n    feeDistributor.changePayees(payees, shares);\n\n    a.controller().revokeRole(MANAGER_ROLE, address(this));\n    a.controller().revokeRole(DEFAULT_ADMIN_ROLE, address(this));\n  }\n}\n"
    },
    "contracts/v1/interfaces/IFeeDistributorV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport './IAddressProviderV1.sol';\n\ninterface IFeeDistributorV1 {\n  event PayeeAdded(address indexed account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  function release() external;\n\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n\n  function a() external view returns (IAddressProviderV1);\n\n  function lastReleasedAt() external view returns (uint256);\n\n  function getPayees() external view returns (address[] memory);\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address payee) external view returns (uint256);\n}\n"
    },
    "contracts/upgrade/MIMODeployment.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../liquidityMining/interfaces/IMIMO.sol\";\nimport \"../liquidityMining/interfaces/IMIMODistributor.sol\";\nimport \"../liquidityMining/interfaces/ISupplyMiner.sol\";\nimport \"../liquidityMining/interfaces/IDemandMiner.sol\";\nimport \"../liquidityMining/interfaces/IDebtNotifier.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"../governance/interfaces/IVotingEscrow.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ncontract MIMODeployment {\n  IGovernanceAddressProvider public ga;\n  IMIMO public mimo;\n  IMIMODistributor public mimoDistributor;\n  ISupplyMiner public wethSupplyMiner;\n  ISupplyMiner public wbtcSupplyMiner;\n  ISupplyMiner public usdcSupplyMiner;\n  IDemandMiner public demandMiner;\n  IDebtNotifier public debtNotifier;\n  IVotingEscrow public votingEscrow;\n\n  address public weth;\n  address public wbtc;\n  address public usdc;\n\n  modifier onlyManager() {\n    require(ga.controller().hasRole(ga.controller().MANAGER_ROLE(), msg.sender), \"Caller is not Manager\");\n    _;\n  }\n\n  constructor(\n    IGovernanceAddressProvider _ga,\n    IMIMO _mimo,\n    IMIMODistributor _mimoDistributor,\n    ISupplyMiner _wethSupplyMiner,\n    ISupplyMiner _wbtcSupplyMiner,\n    ISupplyMiner _usdcSupplyMiner,\n    IDemandMiner _demandMiner,\n    IDebtNotifier _debtNotifier,\n    IVotingEscrow _votingEscrow,\n    address _weth,\n    address _wbtc,\n    address _usdc\n  ) public {\n    require(address(_ga) != address(0));\n    require(address(_mimo) != address(0));\n    require(address(_mimoDistributor) != address(0));\n    require(address(_wethSupplyMiner) != address(0));\n    require(address(_wbtcSupplyMiner) != address(0));\n    require(address(_usdcSupplyMiner) != address(0));\n    require(address(_demandMiner) != address(0));\n    require(address(_debtNotifier) != address(0));\n    require(address(_votingEscrow) != address(0));\n    require(_weth != address(0));\n    require(_wbtc != address(0));\n    require(_usdc != address(0));\n\n    ga = _ga;\n    mimo = _mimo;\n    mimoDistributor = _mimoDistributor;\n    wethSupplyMiner = _wethSupplyMiner;\n    wbtcSupplyMiner = _wbtcSupplyMiner;\n    usdcSupplyMiner = _usdcSupplyMiner;\n    demandMiner = _demandMiner;\n    debtNotifier = _debtNotifier;\n    votingEscrow = _votingEscrow;\n\n    weth = _weth;\n    wbtc = _wbtc;\n    usdc = _usdc;\n  }\n\n  function setup() public onlyManager {\n    //IAddressProvider parallel = a.parallel();\n\n    //bytes32 MIMO_MINTER_ROLE = keccak256(\"MIMO_MINTER_ROLE\");\n    //bytes32 DEFAULT_ADMIN_ROLE = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    ga.setMIMO(mimo);\n    ga.setVotingEscrow(votingEscrow);\n\n    debtNotifier.setCollateralSupplyMiner(weth, wethSupplyMiner);\n    debtNotifier.setCollateralSupplyMiner(wbtc, wbtcSupplyMiner);\n    debtNotifier.setCollateralSupplyMiner(usdc, usdcSupplyMiner);\n\n    address[] memory payees = new address[](4);\n    payees[0] = address(wethSupplyMiner);\n    payees[1] = address(wbtcSupplyMiner);\n    payees[2] = address(usdcSupplyMiner);\n    payees[3] = address(demandMiner);\n    uint256[] memory shares = new uint256[](4);\n    shares[0] = uint256(20);\n    shares[1] = uint256(25);\n    shares[2] = uint256(5);\n    shares[3] = uint256(50);\n    mimoDistributor.changePayees(payees, shares);\n\n    bytes32 MANAGER_ROLE = ga.controller().MANAGER_ROLE();\n    ga.controller().renounceRole(MANAGER_ROLE, address(this));\n  }\n}\n"
    },
    "contracts/liquidityMining/interfaces/IMIMODistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport '../../governance/interfaces/IGovernanceAddressProvider.sol';\nimport './IBaseDistributor.sol';\n\ninterface IMIMODistributorExtension {\n  function startTime() external view returns (uint256);\n\n  function currentIssuance() external view returns (uint256);\n\n  function weeklyIssuanceAt(uint256 timestamp) external view returns (uint256);\n\n  function totalSupplyAt(uint256 timestamp) external view returns (uint256);\n}\n\ninterface IMIMODistributor is IBaseDistributor, IMIMODistributorExtension {}\n"
    },
    "contracts/liquidityMining/interfaces/IDemandMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IDemandMiner {\n  function deposit(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n\n  function token() external view returns (IERC20);\n}\n"
    },
    "contracts/liquidityMining/interfaces/IBaseDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport '../../governance/interfaces/IGovernanceAddressProvider.sol';\n\ninterface IBaseDistributor {\n  event PayeeAdded(address account, uint256 shares);\n  event TokensReleased(uint256 newTokens, uint256 releasedAt);\n\n  /**\n    Public function to release the accumulated new MIMO tokens to the payees.\n    @dev anyone can call this.\n  */\n  function release() external;\n\n  /**\n    Updates the payee configuration to a new one.\n    @dev will release existing fees before the update.\n    @param _payees Array of payees\n    @param _shares Array of shares for each payee\n  */\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address) external view returns (uint256);\n\n  function a() external view returns (IGovernanceAddressProvider);\n\n  function mintableTokens() external view returns (uint256);\n\n  /**\n    Get current configured payees.\n    @return array of current payees.\n  */\n  function getPayees() external view returns (address[] memory);\n}\n"
    },
    "contracts/upgrade/RepayVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVaultsDataProvider.sol\";\nimport \"../interfaces/IVaultsCore.sol\";\n\ncontract RepayVault {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  uint256 public constant REPAY_PER_VAULT = 10 ether;\n\n  IAddressProvider public a;\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n\n    a = _addresses;\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not Manager\");\n    _;\n  }\n\n  function repay() public onlyManager {\n    IVaultsCore core = a.core();\n    IVaultsDataProvider vaultsData = a.vaultsData();\n    uint256 vaultCount = a.vaultsData().vaultCount();\n\n    for (uint256 vaultId = 1; vaultId <= vaultCount; vaultId++) {\n      uint256 baseDebt = vaultsData.vaultBaseDebt(vaultId);\n\n      //if (vaultId==28 || vaultId==29 || vaultId==30 || vaultId==31 || vaultId==32 || vaultId==33 || vaultId==35){\n      //  continue;\n      //}\n\n      if (baseDebt == 0) {\n        continue;\n      }\n\n      core.repay(vaultId, REPAY_PER_VAULT);\n    }\n\n    IERC20 par = IERC20(a.stablex());\n    par.safeTransfer(msg.sender, par.balanceOf(address(this)));\n  }\n}\n"
    },
    "contracts/core/VaultsCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/IVaultsCore.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/IVaultsCoreState.sol\";\nimport \"../liquidityMining/interfaces/IDebtNotifier.sol\";\n\ncontract VaultsCore is IVaultsCore, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  uint256 internal constant _MAX_INT = 2**256 - 1;\n\n  IAddressProvider public override a;\n  IWETH public override WETH;\n  IVaultsCoreState public override state;\n  IDebtNotifier public override debtNotifier;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\n    _;\n  }\n\n  modifier onlyVaultOwner(uint256 _vaultId) {\n    require(a.vaultsData().vaultOwner(_vaultId) == msg.sender);\n    _;\n  }\n\n  constructor(\n    IAddressProvider _addresses,\n    IWETH _IWETH,\n    IVaultsCoreState _vaultsCoreState\n  ) public {\n    require(address(_addresses) != address(0));\n    require(address(_IWETH) != address(0));\n    require(address(_vaultsCoreState) != address(0));\n    a = _addresses;\n    WETH = _IWETH;\n    state = _vaultsCoreState;\n  }\n\n  // For a contract to receive ETH, it needs to have a payable fallback function\n  // https://ethereum.stackexchange.com/a/47415\n  receive() external payable {\n    require(msg.sender == address(WETH));\n  }\n\n  /*\n    Allow smooth upgrading of the vaultscore.\n    @dev this function approves token transfers to the new vaultscore of\n    both stablex and all configured collateral types\n    @param _newVaultsCore address of the new vaultscore\n  */\n  function upgrade(address payable _newVaultsCore) public override onlyManager {\n    require(address(_newVaultsCore) != address(0));\n    require(a.stablex().approve(_newVaultsCore, _MAX_INT));\n\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      IERC20 asset = IERC20(collateralType);\n      asset.safeApprove(_newVaultsCore, _MAX_INT);\n    }\n  }\n\n  /*\n    Allow smooth upgrading of the VaultsCore.\n    @dev this function transfers both PAR and all configured collateral\n    types to the new vaultscore.\n  */\n  function acceptUpgrade(address payable _oldVaultsCore) public override onlyManager {\n    IERC20 stableX = IERC20(a.stablex());\n    stableX.safeTransferFrom(_oldVaultsCore, address(this), stableX.balanceOf(_oldVaultsCore));\n\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      IERC20 asset = IERC20(collateralType);\n      asset.safeTransferFrom(_oldVaultsCore, address(this), asset.balanceOf(_oldVaultsCore));\n    }\n  }\n\n  /**\n    Configure the debt notifier.\n    @param _debtNotifier the new DebtNotifier module address.\n  **/\n  function setDebtNotifier(IDebtNotifier _debtNotifier) public override onlyManager {\n    require(address(_debtNotifier) != address(0));\n    debtNotifier = _debtNotifier;\n  }\n\n  /**\n    Deposit an ERC20 token into the vault of the msg.sender as collateral\n    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.\n    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _collateralType the address of the collateral type to be deposited\n    @param _amount the amount of tokens to be deposited in WEI.\n  **/\n  function deposit(address _collateralType, uint256 _amount) public override {\n    require(a.config().collateralIds(_collateralType) != 0);\n\n    IERC20 asset = IERC20(_collateralType);\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n    _addCollateralToVault(_collateralType, _amount);\n  }\n\n  /**\n    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral\n    @dev A new vault is created if no WETH vault exists\n  **/\n  function depositETH() public payable override {\n    WETH.deposit{ value: msg.value }();\n    _addCollateralToVault(address(WETH), msg.value);\n  }\n\n  /**\n    Deposit an ERC20 token into the specified vault as collateral\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _vaultId the address of the collateral type to be deposited\n    @param _amount the amount of tokens to be deposited in WEI.\n  **/\n  function depositByVaultId(uint256 _vaultId, uint256 _amount) public override {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n    require(v.collateralType != address(0));\n\n    IERC20 asset = IERC20(v.collateralType);\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n    _addCollateralToVaultById(_vaultId, _amount);\n  }\n\n  /**\n    Wraps ETH and deposits WETH into the specified vault as collateral\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _vaultId the address of the collateral type to be deposited\n  **/\n  function depositETHByVaultId(uint256 _vaultId) public payable override {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n    require(v.collateralType == address(WETH));\n\n    WETH.deposit{ value: msg.value }();\n\n    _addCollateralToVaultById(_vaultId, msg.value);\n  }\n\n  /**\n    Deposit an ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI\n    @dev see deposit() and borrow()\n    @param _collateralType the address of the collateral type to be deposited\n    @param _depositAmount the amount of tokens to be deposited in WEI.\n    @param _borrowAmount the amount of borrowed StableX tokens in WEI.\n  **/\n  function depositAndBorrow(\n    address _collateralType,\n    uint256 _depositAmount,\n    uint256 _borrowAmount\n  ) public override {\n    deposit(_collateralType, _depositAmount);\n    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);\n    borrow(vaultId, _borrowAmount);\n  }\n\n  /**\n    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI\n    @dev see depositETH() and borrow()\n    @param _borrowAmount the amount of borrowed StableX tokens in WEI.\n  **/\n  function depositETHAndBorrow(uint256 _borrowAmount) public payable override {\n    depositETH();\n    uint256 vaultId = a.vaultsData().vaultId(address(WETH), msg.sender);\n    borrow(vaultId, _borrowAmount);\n  }\n\n  function _addCollateralToVault(address _collateralType, uint256 _amount) internal {\n    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);\n    if (vaultId == 0) {\n      vaultId = a.vaultsData().createVault(_collateralType, msg.sender);\n    }\n\n    _addCollateralToVaultById(vaultId, _amount);\n  }\n\n  function _addCollateralToVaultById(uint256 _vaultId, uint256 _amount) internal {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.add(_amount));\n\n    emit Deposited(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Withdraws ERC20 tokens from a vault.\n    @dev Only the owner of a vault can withdraw collateral from it.\n    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\n    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.\n  **/\n  function withdraw(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\n    _removeCollateralFromVault(_vaultId, _amount);\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    IERC20 asset = IERC20(v.collateralType);\n    asset.safeTransfer(msg.sender, _amount);\n  }\n\n  /**\n    Withdraws ETH from a WETH vault.\n    @dev Only the owner of a vault can withdraw collateral from it.\n    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\n    @param _amount the amount of ETH to be withdrawn in WEI.\n  **/\n  function withdrawETH(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\n    _removeCollateralFromVault(_vaultId, _amount);\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    require(v.collateralType == address(WETH));\n\n    WETH.withdraw(_amount);\n    msg.sender.transfer(_amount);\n  }\n\n  function _removeCollateralFromVault(uint256 _vaultId, uint256 _amount) internal {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n    require(_amount <= v.collateralBalance);\n    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);\n    a.vaultsData().setCollateralBalance(_vaultId, newCollateralBalance);\n    if (v.baseDebt > 0) {\n      // Save gas cost when withdrawing from 0 debt vault\n      state.refreshCollateral(v.collateralType);\n      uint256 newCollateralValue = a.priceFeed().convertFrom(v.collateralType, newCollateralBalance);\n      require(\n        a.liquidationManager().isHealthy(\n          newCollateralValue,\n          a.vaultsData().vaultDebt(_vaultId),\n          a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).minCollateralRatio\n        )\n      );\n    }\n\n    emit Withdrawn(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Borrow new PAR tokens from a vault.\n    @dev Only the owner of a vault can borrow from it.\n    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.\n     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to borrow.\n    @param _amount the amount of borrowed PAR tokens in WEI.\n  **/\n  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    // Make sure current rate is up to date\n    state.refreshCollateral(v.collateralType);\n\n    uint256 originationFeePercentage = a.config().collateralOriginationFee(v.collateralType);\n    uint256 newDebt = _amount;\n    if (originationFeePercentage > 0) {\n      newDebt = newDebt.add(_amount.wadMul(originationFeePercentage));\n    }\n\n    // Increment vault borrow balance\n    uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(newDebt, cumulativeRates(v.collateralType));\n\n    a.vaultsData().setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));\n\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\n    uint256 newVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n\n    require(a.vaultsData().collateralDebt(v.collateralType) <= a.config().collateralDebtLimit(v.collateralType));\n\n    bool isHealthy = a.liquidationManager().isHealthy(\n      collateralValue,\n      newVaultDebt,\n      a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).minCollateralRatio\n    );\n    require(isHealthy);\n\n    a.stablex().mint(msg.sender, _amount);\n    debtNotifier.debtChanged(_vaultId);\n    emit Borrowed(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Convenience function to repay all debt of a vault\n    @dev `repayAll()` will update the outstanding vault debt to the current time.\n    @param _vaultId the ID of the vault for which to repay the debt.\n  **/\n  function repayAll(uint256 _vaultId) public override {\n    repay(_vaultId, _MAX_INT);\n  }\n\n  /**\n    Repay an outstanding PAR balance to a vault.\n    @dev `repay()` will update the outstanding vault debt to the current time.\n    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.\n    @param _amount the amount of PAR tokens in WEI to be repaid.\n  **/\n  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\n\n    // Make sure current rate is up to date\n    state.refreshCollateral(collateralType);\n\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n    // Decrement vault borrow balance\n    if (_amount >= currentVaultDebt) {\n      //full repayment\n      _amount = currentVaultDebt; //only pay back what's outstanding\n    }\n    _reduceVaultDebt(_vaultId, _amount);\n    a.stablex().burn(msg.sender, _amount);\n    debtNotifier.debtChanged(_vaultId);\n    emit Repaid(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Internal helper function to reduce the debt of a vault.\n    @dev assumes cumulative rates for the vault's collateral type are up to date.\n    please call `refreshCollateral()` before calling this function.\n    @param _vaultId the ID of the vault for which to reduce the debt.\n    @param _amount the amount of debt to be reduced.\n  **/\n  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\n\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n    uint256 remainder = currentVaultDebt.sub(_amount);\n    uint256 cumulativeRate = cumulativeRates(collateralType);\n\n    if (remainder == 0) {\n      a.vaultsData().setBaseDebt(_vaultId, 0);\n    } else {\n      uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(remainder, cumulativeRate);\n      a.vaultsData().setBaseDebt(_vaultId, newBaseDebt);\n    }\n  }\n\n  /**\n    Liquidate a vault that is below the liquidation treshold by repaying its outstanding debt.\n    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\n    to the liquidator. `liquidate()` can be called by anyone.\n    @param _vaultId the ID of the vault to be liquidated.\n  **/\n  function liquidate(uint256 _vaultId) public override {\n    liquidatePartial(_vaultId, _MAX_INT);\n  }\n\n  /**\n    Liquidate a vault partially that is below the liquidation treshold by repaying part of its outstanding debt.\n    @dev `liquidatePartial()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\n    to the liquidator. A LiquidationFee will be applied to the borrower during the liquidation.\n    This means that the change in outstanding debt can be smaller than the repaid amount.\n    `liquidatePartial()` can be called by anyone.\n    @param _vaultId the ID of the vault to be liquidated.\n    @param _amount the amount of debt+liquidationFee to repay.\n  **/\n  function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    state.refreshCollateral(v.collateralType);\n\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n\n    require(\n      !a.liquidationManager().isHealthy(\n        collateralValue,\n        currentVaultDebt,\n        a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).liquidationRatio\n      )\n    );\n\n    uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(\n      a.config().collateralLiquidationFee(v.collateralType)\n    );\n    uint256 maxLiquiditionCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);\n\n    uint256 repayAmount;\n\n    if (_amount > maxLiquiditionCost) {\n      _amount = maxLiquiditionCost;\n      repayAmount = currentVaultDebt;\n    } else {\n      repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);\n    }\n\n    // collateral value to be received by the liquidator is based on the total amount repaid (including the liquidationFee).\n    uint256 collateralValueToReceive = _amount.add(a.liquidationManager().liquidationBonus(v.collateralType, _amount));\n    uint256 insuranceAmount = 0;\n    if (collateralValueToReceive >= collateralValue) {\n      // Not enough collateral for debt & liquidation fee\n      collateralValueToReceive = collateralValue;\n      uint256 discountedCollateralValue = a.liquidationManager().applyLiquidationDiscount(\n        v.collateralType,\n        collateralValue\n      );\n\n      if (currentVaultDebt > discountedCollateralValue) {\n        // Not enough collateral for debt alone\n        insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);\n        require(a.stablex().balanceOf(address(this)) >= insuranceAmount);\n        a.stablex().burn(address(this), insuranceAmount); // Insurance uses local reserves to pay down debt\n        emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);\n      }\n\n      repayAmount = currentVaultDebt.sub(insuranceAmount);\n      _amount = discountedCollateralValue;\n    }\n\n    // reduce the vault debt by repayAmount\n    _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));\n    a.stablex().burn(msg.sender, _amount);\n\n    // send the claimed collateral to the liquidator\n    uint256 collateralToReceive = a.priceFeed().convertTo(v.collateralType, collateralValueToReceive);\n    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));\n    IERC20 asset = IERC20(v.collateralType);\n    asset.safeTransfer(msg.sender, collateralToReceive);\n\n    debtNotifier.debtChanged(_vaultId);\n\n    emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);\n  }\n\n  /**\n    Returns the cumulativeRate of a collateral type. This function exists for\n    backwards compatibility with the VaultsDataProvider.\n    @param _collateralType the address of the collateral type.\n  **/\n  function cumulativeRates(address _collateralType) public view override returns (uint256) {\n    return state.cumulativeRates(_collateralType);\n  }\n}\n"
    },
    "contracts/core/VaultsCoreState.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVaultsCoreState.sol\";\nimport \"../v1/interfaces/IVaultsCoreV1.sol\";\n\ncontract VaultsCoreState is IVaultsCoreState {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  uint256 internal constant _MAX_INT = 2**256 - 1;\n\n  bool public override synced = false;\n  IAddressProvider public override a;\n\n  mapping(address => uint256) public override cumulativeRates;\n  mapping(address => uint256) public override lastRefresh;\n\n  modifier onlyConfig() {\n    require(msg.sender == address(a.config()));\n    _;\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\n    _;\n  }\n\n  modifier notSynced() {\n    require(!synced);\n    _;\n  }\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Calculate the available income\n    @return available income that has not been minted yet.\n  **/\n  function availableIncome() public view override returns (uint256) {\n    return a.vaultsData().debt().sub(a.stablex().totalSupply());\n  }\n\n  /**\n    Refresh the cumulative rates and debts of all vaults and all collateral types.\n    @dev anyone can call this.\n  **/\n  function refresh() public override {\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      refreshCollateral(collateralType);\n    }\n  }\n\n  /**\n    Sync state with another instance. This is used during version upgrade to keep V2 in sync with V2.\n    @dev This call will read the state via\n      `cumulativeRates(address collateralType)` and `lastRefresh(address collateralType)`.\n    @param _stateAddress address from which the state is to be copied.\n  **/\n  function syncState(IVaultsCoreState _stateAddress) public override onlyManager notSynced {\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      cumulativeRates[collateralType] = _stateAddress.cumulativeRates(collateralType);\n      lastRefresh[collateralType] = _stateAddress.lastRefresh(collateralType);\n    }\n    synced = true;\n  }\n\n  /**\n    Sync state with v1 core. This is used during version upgrade to keep V2 in sync with V1.\n    @dev This call will read the state via\n      `cumulativeRates(address collateralType)` and `lastRefresh(address collateralType)`.\n    @param _core address of core v1 from which the state is to be copied.\n  **/\n  function syncStateFromV1(IVaultsCoreV1 _core) public override onlyManager notSynced {\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      cumulativeRates[collateralType] = _core.cumulativeRates(collateralType);\n      lastRefresh[collateralType] = _core.lastRefresh(collateralType);\n    }\n    synced = true;\n  }\n\n  /**\n    Initialize the cumulative rates to 1 for a new collateral type.\n    @param _collateralType the address of the new collateral type to be initialized\n  **/\n  function initializeRates(address _collateralType) public override onlyConfig {\n    require(_collateralType != address(0));\n    lastRefresh[_collateralType] = block.timestamp;\n    cumulativeRates[_collateralType] = WadRayMath.ray();\n  }\n\n  /**\n    Refresh the cumulative rate of a collateraltype.\n    @dev this updates the debt for all vaults with the specified collateral type.\n    @param _collateralType the address of the collateral type to be refreshed.\n  **/\n  function refreshCollateral(address _collateralType) public override {\n    require(_collateralType != address(0));\n    require(a.config().collateralIds(_collateralType) != 0);\n    uint256 timestamp = block.timestamp;\n    uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);\n    _refreshCumulativeRate(_collateralType, timeElapsed);\n    lastRefresh[_collateralType] = timestamp;\n  }\n\n  /**\n    Internal function to increase the cumulative rate over a specified time period\n    @dev this updates the debt for all vaults with the specified collateral type.\n    @param _collateralType the address of the collateral type to be updated\n    @param _timeElapsed the amount of time in seconds to add to the cumulative rate\n  **/\n  function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {\n    uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);\n    uint256 oldCumulativeRate = cumulativeRates[_collateralType];\n    cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(\n      borrowRate,\n      oldCumulativeRate,\n      _timeElapsed\n    );\n    emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);\n  }\n}\n"
    },
    "contracts/v1/FeeDistributorV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/ISTABLEX.sol\";\nimport \"./interfaces/IFeeDistributorV1.sol\";\nimport \"./interfaces/IAddressProviderV1.sol\";\n\ncontract FeeDistributorV1 is IFeeDistributorV1, ReentrancyGuard {\n  using SafeMath for uint256;\n\n  event PayeeAdded(address account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  uint256 public override lastReleasedAt;\n  IAddressProviderV1 public override a;\n\n  uint256 public override totalShares;\n  mapping(address => uint256) public override shares;\n  address[] public payees;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not Manager\");\n    _;\n  }\n\n  constructor(IAddressProviderV1 _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Public function to release the accumulated fee income to the payees.\n    @dev anyone can call this.\n  */\n  function release() public override nonReentrant {\n    uint256 income = a.core().availableIncome();\n    require(income > 0, \"income is 0\");\n    require(payees.length > 0, \"Payees not configured yet\");\n    lastReleasedAt = now;\n\n    // Mint USDX to all receivers\n    for (uint256 i = 0; i < payees.length; i++) {\n      address payee = payees[i];\n      _release(income, payee);\n    }\n    emit FeeReleased(income, lastReleasedAt);\n  }\n\n  /**\n    Get current configured payees.\n    @return array of current payees.\n  */\n  function getPayees() public view override returns (address[] memory) {\n    return payees;\n  }\n\n  /**\n    Internal function to release a percentage of income to a specific payee\n    @dev uses totalShares to calculate correct share\n    @param _totalIncomeReceived Total income for all payees, will be split according to shares\n    @param _payee The address of the payee to whom to distribute the fees.\n  */\n  function _release(uint256 _totalIncomeReceived, address _payee) internal {\n    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);\n    a.stablex().mint(_payee, payment);\n  }\n\n  /**\n    Internal function to add a new payee.\n    @dev will update totalShares and therefore reduce the relative share of all other payees.\n    @param _payee The address of the payee to add.\n    @param _shares The number of shares owned by the payee.\n  */\n  function _addPayee(address _payee, uint256 _shares) internal {\n    require(_payee != address(0), \"payee is the zero address\");\n    require(_shares > 0, \"shares are 0\");\n    require(shares[_payee] == 0, \"payee already has shares\");\n\n    payees.push(_payee);\n    shares[_payee] = _shares;\n    totalShares = totalShares.add(_shares);\n    emit PayeeAdded(_payee, _shares);\n  }\n\n  /**\n    Updates the payee configuration to a new one.\n    @dev will release existing fees before the update.\n    @param _payees Array of payees\n    @param _shares Array of shares for each payee\n  */\n  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    uint256 income = a.core().availableIncome();\n    if (income > 0 && payees.length > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }\n}\n"
    },
    "contracts/token/USDX.sol": {
      "content": "// solium-disable security/no-block-members\n// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/ISTABLEX.sol\";\n\n/**\n * @title   USDX\n * @notice  Stablecoin which can be minted against collateral in a vault\n */\ncontract USDX is ISTABLEX, ERC20(\"USD Stablecoin\", \"USDX\") {\n  IAddressProvider public override a;\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  function mint(address account, uint256 amount) public override onlyMinter {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) public override onlyMinter {\n    _burn(account, amount);\n  }\n\n  modifier onlyMinter() {\n    require(a.controller().hasRole(a.controller().MINTER_ROLE(), msg.sender), \"Caller is not a minter\");\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/token/PAR.sol": {
      "content": "// solium-disable security/no-block-members\n// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/ISTABLEX.sol\";\n\n/**\n * @title  PAR\n * @notice  Stablecoin which can be minted against collateral in a vault\n */\ncontract PAR is ISTABLEX, ERC20(\"PAR Stablecoin\", \"PAR\") {\n  IAddressProvider public override a;\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  function mint(address account, uint256 amount) public override onlyMinter {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) public override onlyMinter {\n    _burn(account, amount);\n  }\n\n  modifier onlyMinter() {\n    require(a.controller().hasRole(a.controller().MINTER_ROLE(), msg.sender), \"Caller is not a minter\");\n    _;\n  }\n}\n"
    },
    "contracts/token/MIMO.sol": {
      "content": "// solium-disable security/no-block-members\n// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\n\n/**\n * @title  MIMO\n * @notice  MIMO Governance token\n */\ncontract MIMO is ERC20(\"MIMO Parallel Governance Token\", \"MIMO\") {\n  IGovernanceAddressProvider public a;\n\n  bytes32 public constant MIMO_MINTER_ROLE = keccak256(\"MIMO_MINTER_ROLE\");\n\n  constructor(IGovernanceAddressProvider _a) public {\n    require(address(_a) != address(0));\n\n    a = _a;\n  }\n\n  modifier onlyMIMOMinter() {\n    require(a.controller().hasRole(MIMO_MINTER_ROLE, msg.sender), \"Caller is not MIMO Minter\");\n    _;\n  }\n\n  function mint(address account, uint256 amount) public onlyMIMOMinter {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) public onlyMIMOMinter {\n    _burn(account, amount);\n  }\n}\n"
    },
    "contracts/upgrade/PreUseAirdrop.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../token/MIMO.sol\";\n\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"../liquidityMining/interfaces/IMIMODistributor.sol\";\n\ncontract PreUseAirdrop {\n  using SafeERC20 for IERC20;\n\n  struct Payout {\n    address recipient;\n    uint256 amount;\n  }\n\n  Payout[] public payouts;\n\n  IGovernanceAddressProvider public ga;\n  IMIMODistributor public mimoDistributor;\n\n  modifier onlyManager() {\n    require(ga.controller().hasRole(ga.controller().MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  constructor(IGovernanceAddressProvider _ga, IMIMODistributor _mimoDistributor) public {\n    require(address(_ga) != address(0));\n    require(address(_mimoDistributor) != address(0));\n\n    ga = _ga;\n    mimoDistributor = _mimoDistributor;\n\n    payouts.push(Payout(0xBBd92c75C6f8B0FFe9e5BCb2e56a5e2600871a10, 271147720731494841509243076));\n    payouts.push(Payout(0xcc8793d5eB95fAa707ea4155e09b2D3F44F33D1E, 210989402066696530434956148));\n    payouts.push(Payout(0x185f19B43d818E10a31BE68f445ef8EDCB8AFB83, 22182938994846641176273320));\n    payouts.push(Payout(0xDeD9F901D40A96C3Ee558E6885bcc7eFC51ad078, 13678603288816593264718593));\n    payouts.push(Payout(0x0B3890bbF2553Bd098B45006aDD734d6Fbd6089E, 8416873402881706143143730));\n    payouts.push(Payout(0x3F41a1CFd3C8B8d9c162dE0f42307a0095A6e5DF, 7159719590701445955473554));\n    payouts.push(Payout(0x9115BaDce4873d58fa73b08279529A796550999a, 5632453715407980754075398));\n    payouts.push(Payout(0x7BC8C0B66d7f0E2193ED11eeCAAfE7c1837b926f, 5414893264683531027764823));\n    payouts.push(Payout(0xE7809aaaaa78E5a24E059889E561f598F3a4664c, 4712320945661497844704387));\n    payouts.push(Payout(0xf4D3566729f257edD0D4bF365d8f0Db7bF56e1C6, 2997276841876706895655431));\n    payouts.push(Payout(0x6Cf9AA65EBaD7028536E353393630e2340ca6049, 2734992792750385321760387));\n    payouts.push(Payout(0x74386381Cb384CC0FBa0Ac669d22f515FfC147D2, 1366427847282177615773594));\n    payouts.push(Payout(0x9144b150f28437E06Ab5FF5190365294eb1E87ec, 1363226310703652991601514));\n    payouts.push(Payout(0x5691d53685e8e219329bD8ADf62b1A0A17df9D11, 702790464733701088417744));\n    payouts.push(Payout(0x2B91B4f5223a0a1f5c7e1D139dDdD6B5B57C7A51, 678663683269882192090830));\n    payouts.push(Payout(0x8ddBad507F3b20239516810C308Ba4f3BaeAf3a1, 635520835923336863138335));\n    payouts.push(Payout(0xc3874A2C59b9779A75874Be6B5f0b578120A8701, 488385391000796390198744));\n    payouts.push(Payout(0x0A22C160f7E57F2e7d88b2fa1B1B03571bdE6128, 297735186117080365383063));\n    payouts.push(Payout(0x0a1aa2b65832fC0c71f2Ba488c84BeE0b9DB9692, 132688033756581498940995));\n    payouts.push(Payout(0xAf7b7AbC272a3aE6dD6dA41b9832C758477a85f2, 130254714680714068405131));\n    payouts.push(Payout(0xCDb17d9bCbA8E3bab6F68D59065efe784700Bee1, 71018627162763037055295));\n    payouts.push(Payout(0x4Dec19003F9Bb01A4c0D089605618b2d76deE30d, 69655357581389001902516));\n    payouts.push(Payout(0x31AacA1940C82130c2D4407E609e626E87A7BC18, 21678478730854029506989));\n    payouts.push(Payout(0xBc77AB8dd8BAa6ddf0D0c241d31b2e30bcEC127d, 21573657481017931484432));\n    payouts.push(Payout(0x1c25cDD83Cd7106C3dcB361230eC9E6930Aadd30, 14188368728356337446426));\n    payouts.push(Payout(0xf1B78ed53fa2f9B8cFfa677Ad8023aCa92109d08, 13831474058511281838532));\n    payouts.push(Payout(0xd27962455de27561e62345a516931F2392997263, 6968208393315527988941));\n    payouts.push(Payout(0xD8A4411C623aD361E98bC9D98cA33eE1cF308Bca, 4476771187861728227997));\n    payouts.push(Payout(0x1f06fA59809ee23Ee06e533D67D29C6564fC1964, 3358338614042115121460));\n    payouts.push(Payout(0xeDccc1501e3BCC8b3973B9BE33f6Bd7072d28388, 2328788070517256560738));\n    payouts.push(Payout(0xD738A884B2aFE625d372260E57e86E3eB4d5e1D7, 466769668474372743140));\n    payouts.push(Payout(0x6942b1b6526Fa05035d47c09B419039c00Ef7545, 442736084997163005698));\n  }\n\n  function airdrop() public onlyManager {\n    MIMO mimo = MIMO(address(ga.mimo()));\n    for (uint256 i = 0; i < payouts.length; i++) {\n      Payout memory payout = payouts[i];\n      mimo.mint(payout.recipient, payout.amount);\n    }\n    require(mimoDistributor.mintableTokens() > 0);\n\n    bytes32 MIMO_MINTER_ROLE = mimo.MIMO_MINTER_ROLE();\n    ga.controller().renounceRole(MIMO_MINTER_ROLE, address(this));\n  }\n}\n"
    },
    "contracts/liquidityMining/MIMODistributorV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/IMIMODistributor.sol\";\nimport \"./BaseDistributor.sol\";\n\ncontract MIMODistributorV2 is BaseDistributor, IMIMODistributorExtension {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  uint256 private constant _SECONDS_PER_YEAR = 365 days;\n  uint256 private constant _SECONDS_PER_WEEK = 7 days;\n  uint256 private constant _WEEKLY_R = 986125e21; // -1.3875% per week (-5.55% / 4)\n  uint256 private _FIRST_WEEK_TOKENS;\n\n  uint256 public override startTime;\n  uint256 public alreadyMinted;\n\n  constructor(\n    IGovernanceAddressProvider _a,\n    uint256 _startTime,\n    IMIMODistributor _mimoDistributor\n  ) public {\n    require(address(_a) != address(0));\n    require(address(_mimoDistributor) != address(0));\n\n    a = _a;\n    startTime = _startTime;\n    alreadyMinted = _mimoDistributor.totalSupplyAt(startTime);\n\n    uint256 weeklyIssuanceV1 = _mimoDistributor.weeklyIssuanceAt(startTime);\n    _FIRST_WEEK_TOKENS = weeklyIssuanceV1 / 4; // reduce weeky issuance by 4\n  }\n\n  /**\n    Get current monthly issuance of new MIMO tokens.\n    @return number of monthly issued tokens currently`.\n  */\n  function currentIssuance() public view override returns (uint256) {\n    return weeklyIssuanceAt(now);\n  }\n\n  /**\n    Get monthly issuance of new MIMO tokens at `timestamp`.\n    @dev invalid for timestamps before deployment\n    @param timestamp for which to calculate the monthly issuance\n    @return number of monthly issued tokens at `timestamp`.\n  */\n  function weeklyIssuanceAt(uint256 timestamp) public view override returns (uint256) {\n    uint256 elapsedSeconds = timestamp.sub(startTime);\n    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);\n    return _WEEKLY_R.rayPow(elapsedWeeks).rayMul(_FIRST_WEEK_TOKENS);\n  }\n\n  /**\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\n    @return number of mintable tokens available right now.\n  */\n  function mintableTokens() public view override returns (uint256) {\n    return totalSupplyAt(now).sub(a.mimo().totalSupply());\n  }\n\n  /**\n    Calculates the totalSupply for any point after `startTime`\n    @param timestamp for which to calculate the totalSupply\n    @return totalSupply at timestamp.\n  */\n  function totalSupplyAt(uint256 timestamp) public view override returns (uint256) {\n    uint256 elapsedSeconds = timestamp.sub(startTime);\n    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);\n    uint256 lastWeekSeconds = elapsedSeconds % _SECONDS_PER_WEEK;\n    uint256 one = WadRayMath.ray();\n    uint256 fullWeeks = one.sub(_WEEKLY_R.rayPow(elapsedWeeks)).rayMul(_FIRST_WEEK_TOKENS).rayDiv(one.sub(_WEEKLY_R));\n    uint256 currentWeekIssuance = weeklyIssuanceAt(timestamp);\n    uint256 partialWeek = currentWeekIssuance.mul(lastWeekSeconds).div(_SECONDS_PER_WEEK);\n    return alreadyMinted.add(fullWeeks.add(partialWeek));\n  }\n\n  /**\n    Internal function to release a percentage of newTokens to a specific payee\n    @dev uses totalShares to calculate correct share\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\n    @param _payee The address of the payee to whom to distribute the fees.\n  */\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {\n    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);\n    a.mimo().mint(_payee, payment);\n  }\n}\n"
    },
    "contracts/liquidityMining/BaseDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/IBaseDistributor.sol\";\n\n/*\n  \tDistribution Formula:\n  \t55.5m MIMO in first week\n  \t-5.55% redution per week\n\n  \ttotal(timestamp) = _SECONDS_PER_WEEK * ( (1-weeklyR^(timestamp/_SECONDS_PER_WEEK)) / (1-weeklyR) )\n  \t\t+ timestamp % _SECONDS_PER_WEEK * (1-weeklyR^(timestamp/_SECONDS_PER_WEEK)\n  */\n\nabstract contract BaseDistributor is IBaseDistributor {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  uint256 public override totalShares;\n  mapping(address => uint256) public override shares;\n  address[] public payees;\n\n  IGovernanceAddressProvider public override a;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not Manager\");\n    _;\n  }\n\n  /**\n    Public function to release the accumulated new MIMO tokens to the payees.\n    @dev anyone can call this.\n  */\n  function release() public override {\n    uint256 newTokens = mintableTokens();\n    require(newTokens > 0, \"newTokens is 0\");\n    require(payees.length > 0, \"Payees not configured yet\");\n    // Mint MIMO to all receivers\n    for (uint256 i = 0; i < payees.length; i++) {\n      address payee = payees[i];\n      _release(newTokens, payee);\n    }\n    emit TokensReleased(newTokens, now);\n  }\n\n  /**\n    Updates the payee configuration to a new one.\n    @dev will release existing fees before the update.\n    @param _payees Array of payees\n    @param _shares Array of shares for each payee\n  */\n  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    if (payees.length > 0 && mintableTokens() > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }\n\n  /**\n    Get current configured payees.\n    @return array of current payees.\n  */\n  function getPayees() public view override returns (address[] memory) {\n    return payees;\n  }\n\n  /**\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\n    @return number of mintable tokens available right now.\n  */\n  function mintableTokens() public view virtual override returns (uint256);\n\n  /**\n    Internal function to release a percentage of newTokens to a specific payee\n    @dev uses totalShares to calculate correct share\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\n    @param _payee The address of the payee to whom to distribute the fees.\n  */\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal virtual;\n\n  /**\n    Internal function to add a new payee.\n    @dev will update totalShares and therefore reduce the relative share of all other payees.\n    @param _payee The address of the payee to add.\n    @param _shares The number of shares owned by the payee.\n  */\n  function _addPayee(address _payee, uint256 _shares) internal {\n    require(_payee != address(0), \"payee is the zero address\");\n    require(_shares > 0, \"shares are 0\");\n    require(shares[_payee] == 0, \"payee already has shares\");\n\n    payees.push(_payee);\n    shares[_payee] = _shares;\n    totalShares = totalShares.add(_shares);\n    emit PayeeAdded(_payee, _shares);\n  }\n}\n"
    },
    "contracts/liquidityMining/PolygonDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/interfaces/IRootChainManager.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"./BaseDistributor.sol\";\n\ncontract PolygonDistributor is BaseDistributor {\n  using SafeMath for uint256;\n\n  IRootChainManager public rootChainManager;\n  address public erc20Predicate;\n\n  constructor(\n    IGovernanceAddressProvider _a,\n    IRootChainManager _rootChainManager,\n    address _erc20Predicate\n  ) public {\n    require(address(_a) != address(0));\n    require(address(_rootChainManager) != address(0));\n    require(_erc20Predicate != address(0));\n\n    a = _a;\n    rootChainManager = _rootChainManager;\n    erc20Predicate = _erc20Predicate;\n  }\n\n  /**\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\n    @return number of mintable tokens available right now.\n  */\n  function mintableTokens() public view override returns (uint256) {\n    return a.mimo().balanceOf(address(this));\n  }\n\n  /**\n    Internal function to release a percentage of newTokens to a specific payee\n    @dev uses totalShares to calculate correct share\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\n    @param _payee The address of the payee to whom to distribute the fees.\n  */\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {\n    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);\n    a.mimo().approve(erc20Predicate, payment);\n    rootChainManager.depositFor(_payee, address(a.mimo()), abi.encode(payment));\n  }\n}\n"
    },
    "contracts/libraries/interfaces/IRootChainManager.sol": {
      "content": "pragma solidity 0.6.12;\n\ninterface IRootChainManager {\n  event TokenMapped(address indexed rootToken, address indexed childToken, bytes32 indexed tokenType);\n\n  event PredicateRegistered(bytes32 indexed tokenType, address indexed predicateAddress);\n\n  function registerPredicate(bytes32 tokenType, address predicateAddress) external;\n\n  function mapToken(\n    address rootToken,\n    address childToken,\n    bytes32 tokenType\n  ) external;\n\n  function depositEtherFor(address user) external payable;\n\n  function depositFor(\n    address user,\n    address rootToken,\n    bytes calldata depositData\n  ) external;\n\n  function exit(bytes calldata inputData) external;\n}\n"
    },
    "contracts/mocks/MockGenericMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"../liquidityMining/GenericMiner.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\n\ncontract MockGenericMiner is GenericMiner {\n  constructor(IGovernanceAddressProvider _addresses) public GenericMiner(_addresses) {}\n\n  function increaseStake(address user, uint256 value) public {\n    _increaseStake(user, value);\n  }\n\n  function decreaseStake(address user, uint256 value) public {\n    _decreaseStake(user, value);\n  }\n}\n"
    },
    "contracts/liquidityMining/GenericMiner.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"./interfaces/IGenericMiner.sol\";\n\n/*\n    GenericMiner is based on ERC2917. https://github.com/gnufoo/ERC2917-Proposal\n\n    The Objective of GenericMiner is to implement a decentralized staking mechanism, which calculates _users' share\n    by accumulating stake * time. And calculates _users revenue from anytime t0 to t1 by the formula below:\n\n        user_accumulated_stake(time1) - user_accumulated_stake(time0)\n       _____________________________________________________________________________  * (gross_stake(t1) - gross_stake(t0))\n       total_accumulated_stake(time1) - total_accumulated_stake(time0)\n\n*/\ncontract GenericMiner is IGenericMiner {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  mapping(address => UserInfo) internal _users;\n\n  uint256 public override totalStake;\n  IGovernanceAddressProvider public override a;\n\n  uint256 internal _balanceTracker;\n  uint256 internal _accAmountPerShare;\n\n  constructor(IGovernanceAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Releases the outstanding MIMO balance to the user.\n    @param _user the address of the user for which the MIMO tokens will be released.\n  */\n  function releaseMIMO(address _user) public virtual override {\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\n    _balanceTracker = _balanceTracker.sub(pending);\n    userInfo.accAmountPerShare = _accAmountPerShare;\n    require(a.mimo().transfer(_user, pending));\n  }\n\n  /**\n    Returns the number of tokens a user has staked.\n    @param _user the address of the user.\n    @return number of staked tokens\n  */\n  function stake(address _user) public view override returns (uint256) {\n    return _users[_user].stake;\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`.\n    @param _user the address of the user.\n    @return number of MIMO tokens that the user can claim\n  */\n  function pendingMIMO(address _user) public view override returns (uint256) {\n    uint256 currentBalance = a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_balanceTracker);\n    uint256 accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));\n\n    return _users[_user].stake.rayMul(accAmountPerShare.sub(_users[_user].accAmountPerShare));\n  }\n\n  /**\n    Returns the userInfo stored of a user.\n    @param _user the address of the user.\n    @return `struct UserInfo {\n      uint256 stake;\n      uint256 rewardDebt;\n    }`\n  **/\n  function userInfo(address _user) public view override returns (UserInfo memory) {\n    return _users[_user];\n  }\n\n  /**\n    Refreshes the global state and subsequently decreases the stake a user has.\n    This is an internal call and meant to be called within derivative contracts.\n    @param user the address of the user\n    @param value the amount by which the stake will be reduced\n  */\n  function _decreaseStake(address user, uint256 value) internal {\n    require(value > 0, \"STAKE_MUST_BE_GREATER_THAN_ZERO\"); //TODO cleanup error message\n\n    UserInfo storage userInfo = _users[user];\n    require(userInfo.stake >= value, \"INSUFFICIENT_STAKE_FOR_USER\"); //TODO cleanup error message\n    _refresh();\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\n    _balanceTracker = _balanceTracker.sub(pending);\n    userInfo.stake = userInfo.stake.sub(value);\n    userInfo.accAmountPerShare = _accAmountPerShare;\n    totalStake = totalStake.sub(value);\n\n    require(a.mimo().transfer(user, pending));\n    emit StakeDecreased(user, value);\n  }\n\n  /**\n    Refreshes the global state and subsequently increases a user's stake.\n    This is an internal call and meant to be called within derivative contracts.\n    @param user the address of the user\n    @param value the amount by which the stake will be increased\n  */\n  function _increaseStake(address user, uint256 value) internal {\n    require(value > 0, \"STAKE_MUST_BE_GREATER_THAN_ZERO\"); //TODO cleanup error message\n\n    UserInfo storage userInfo = _users[user];\n    _refresh();\n\n    uint256 pending;\n    if (userInfo.stake > 0) {\n      pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\n      _balanceTracker = _balanceTracker.sub(pending);\n    }\n\n    totalStake = totalStake.add(value);\n    userInfo.stake = userInfo.stake.add(value);\n    userInfo.accAmountPerShare = _accAmountPerShare;\n\n    if (pending > 0) {\n      require(a.mimo().transfer(user, pending));\n    }\n\n    emit StakeIncreased(user, value);\n  }\n\n  /**\n    Refreshes the global state and subsequently updates a user's stake.\n    This is an internal call and meant to be called within derivative contracts.\n    @param user the address of the user\n    @param stake the new amount of stake for the user\n  */\n  function _updateStake(address user, uint256 stake) internal returns (bool) {\n    uint256 oldStake = _users[user].stake;\n    if (stake > oldStake) {\n      _increaseStake(user, stake.sub(oldStake));\n    }\n    if (stake < oldStake) {\n      _decreaseStake(user, oldStake.sub(stake));\n    }\n  }\n\n  /**\n    Internal read function to calculate the number of MIMO tokens that\n    have accumulated since the last token release.\n    @dev This is an internal call and meant to be called within derivative contracts.\n    @return newly accumulated token balance\n  */\n  function _newTokensReceived() internal view returns (uint256) {\n    return a.mimo().balanceOf(address(this)).sub(_balanceTracker);\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received MIMO tokens.\n  */\n  function _refresh() internal {\n    if (totalStake == 0) {\n      return;\n    }\n    uint256 currentBalance = a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_balanceTracker);\n    _balanceTracker = currentBalance;\n\n    _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));\n  }\n}\n"
    },
    "contracts/liquidityMining/VotingMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"./GenericMiner.sol\";\nimport \"./interfaces/IVotingMiner.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"../governance/interfaces/IVotingEscrow.sol\";\n\ncontract VotingMiner is IVotingMiner, GenericMiner {\n  constructor(IGovernanceAddressProvider _addresses) public GenericMiner(_addresses) {}\n\n  /**\n    Releases the outstanding MIMO balance to the user.\n    @param _user the address of the user for which the MIMO tokens will be released.\n  */\n  function releaseMIMO(address _user) public override {\n    IVotingEscrow votingEscrow = a.votingEscrow();\n    require((msg.sender == _user) || (msg.sender == address(votingEscrow)));\n\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\n    _balanceTracker = _balanceTracker.sub(pending);\n    userInfo.accAmountPerShare = _accAmountPerShare;\n\n    uint256 votingPower = votingEscrow.balanceOf(_user);\n    totalStake = totalStake.add(votingPower).sub(userInfo.stake);\n    userInfo.stake = votingPower;\n\n    if (pending > 0) {\n      require(a.mimo().transfer(_user, pending));\n    }\n  }\n}\n"
    },
    "contracts/liquidityMining/interfaces/IVotingMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\ninterface IVotingMiner {}\n"
    },
    "contracts/governance/VotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n/* solium-disable security/no-block-members */\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IGovernanceAddressProvider.sol\";\nimport \"../liquidityMining/interfaces/IGenericMiner.sol\";\n\n/**\n * @title  VotingEscrow\n * @notice Lockup GOV, receive vGOV (voting weight that decays over time)\n * @dev    Supports:\n *            1) Tracking MIMO Locked up\n *            2) Decaying voting weight lookup\n *            3) Closure of contract\n */\ncontract VotingEscrow is IVotingEscrow, ReentrancyGuard {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  uint256 public constant MAXTIME = 1460 days; // 365 * 4 years\n  uint256 public minimumLockTime = 1 days;\n  bool public expired = false;\n  IERC20 public override stakingToken;\n\n  mapping(address => LockedBalance) public locked;\n\n  string public override name;\n  string public override symbol;\n  // solhint-disable-next-line\n  uint256 public constant override decimals = 18;\n\n  // AddressProvider\n  IGovernanceAddressProvider public a;\n  IGenericMiner public miner;\n\n  constructor(\n    IERC20 _stakingToken,\n    IGovernanceAddressProvider _a,\n    IGenericMiner _miner,\n    string memory _name,\n    string memory _symbol\n  ) public {\n    require(address(_stakingToken) != address(0));\n    require(address(_a) != address(0));\n    require(address(_miner) != address(0));\n\n    stakingToken = _stakingToken;\n    a = _a;\n    miner = _miner;\n\n    name = _name;\n    symbol = _symbol;\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  /** @dev Modifier to ensure contract has not yet expired */\n  modifier contractNotExpired() {\n    require(!expired, \"Contract is expired\");\n    _;\n  }\n\n  /**\n   * @dev Creates a new lock\n   * @param _value Total units of StakingToken to lockup\n   * @param _unlockTime Time at which the stake should unlock\n   */\n  function createLock(uint256 _value, uint256 _unlockTime) external override nonReentrant contractNotExpired {\n    LockedBalance memory locked_ = LockedBalance({ amount: locked[msg.sender].amount, end: locked[msg.sender].end });\n\n    require(_value > 0, \"Must stake non zero amount\");\n    require(locked_.amount == 0, \"Withdraw old tokens first\");\n    require(_unlockTime > block.timestamp, \"Can only lock until time in the future\");\n    require(_unlockTime.sub(block.timestamp) > minimumLockTime, \"Lock duration should be larger than minimum locktime\");\n\n    _depositFor(msg.sender, _value, _unlockTime, locked_, LockAction.CREATE_LOCK);\n  }\n\n  /**\n   * @dev Increases amount of stake thats locked up & resets decay\n   * @param _value Additional units of StakingToken to add to exiting stake\n   */\n  function increaseLockAmount(uint256 _value) external override nonReentrant contractNotExpired {\n    LockedBalance memory locked_ = LockedBalance({ amount: locked[msg.sender].amount, end: locked[msg.sender].end });\n\n    require(_value > 0, \"Must stake non zero amount\");\n    require(locked_.amount > 0, \"No existing lock found\");\n    require(locked_.end > block.timestamp, \"Cannot add to expired lock. Withdraw\");\n\n    _depositFor(msg.sender, _value, 0, locked_, LockAction.INCREASE_LOCK_AMOUNT);\n  }\n\n  /**\n   * @dev Increases length of lockup & resets decay\n   * @param _unlockTime New unlocktime for lockup\n   */\n  function increaseLockLength(uint256 _unlockTime) external override nonReentrant contractNotExpired {\n    LockedBalance memory locked_ = LockedBalance({ amount: locked[msg.sender].amount, end: locked[msg.sender].end });\n\n    require(locked_.amount > 0, \"Nothing is locked\");\n    require(locked_.end > block.timestamp, \"Lock expired\");\n    require(_unlockTime > locked_.end, \"Can only increase lock time\");\n    require(_unlockTime.sub(locked_.end) > minimumLockTime, \"Lock duration should be larger than minimum locktime\");\n\n    _depositFor(msg.sender, 0, _unlockTime, locked_, LockAction.INCREASE_LOCK_TIME);\n  }\n\n  /**\n   * @dev Withdraws all the senders stake, providing lockup is over\n   */\n  function withdraw() external override {\n    _withdraw(msg.sender);\n  }\n\n  /**\n   * @dev Ends the contract, unlocking all stakes.\n   * No more staking can happen. Only withdraw.\n   */\n  function expireContract() external override onlyManager contractNotExpired {\n    expired = true;\n    emit Expired();\n  }\n\n  /**\n   * @dev Set miner address.\n   * @param _miner new miner contract address\n   */\n  function setMiner(IGenericMiner _miner) external override onlyManager contractNotExpired {\n    miner = _miner;\n  }\n\n  /**\n   * @dev Set minimumLockTime.\n   * @param _minimumLockTime minimum lockTime\n   */\n  function setMinimumLockTime(uint256 _minimumLockTime) external override onlyManager contractNotExpired {\n    minimumLockTime = _minimumLockTime;\n  }\n\n  /***************************************\n                    GETTERS\n    ****************************************/\n\n  /**\n   * @dev Gets the user's votingWeight at the current time.\n   * @param _owner User for which to return the votingWeight\n   * @return uint256 Balance of user\n   */\n  function balanceOf(address _owner) public view override returns (uint256) {\n    return balanceOfAt(_owner, block.timestamp);\n  }\n\n  /**\n   * @dev Gets a users votingWeight at a given block timestamp\n   * @param _owner User for which to return the balance\n   * @param _blockTime Timestamp for which to calculate balance. Can not be in the past\n   * @return uint256 Balance of user\n   */\n  function balanceOfAt(address _owner, uint256 _blockTime) public view override returns (uint256) {\n    require(_blockTime >= block.timestamp, \"Must pass block timestamp in the future\");\n\n    LockedBalance memory currentLock = locked[_owner];\n\n    if (currentLock.end <= _blockTime) return 0;\n    uint256 remainingLocktime = currentLock.end.sub(_blockTime);\n    if (remainingLocktime > MAXTIME) {\n      remainingLocktime = MAXTIME;\n    }\n\n    return currentLock.amount.mul(remainingLocktime).div(MAXTIME);\n  }\n\n  /**\n   * @dev Deposits or creates a stake for a given address\n   * @param _addr User address to assign the stake\n   * @param _value Total units of StakingToken to lockup\n   * @param _unlockTime Time at which the stake should unlock\n   * @param _oldLocked Previous amount staked by this user\n   * @param _action See LockAction enum\n   */\n  function _depositFor(\n    address _addr,\n    uint256 _value,\n    uint256 _unlockTime,\n    LockedBalance memory _oldLocked,\n    LockAction _action\n  ) internal {\n    LockedBalance memory newLocked = LockedBalance({ amount: _oldLocked.amount, end: _oldLocked.end });\n\n    // Adding to existing lock, or if a lock is expired - creating a new one\n    newLocked.amount = newLocked.amount.add(_value);\n    if (_unlockTime != 0) {\n      newLocked.end = _unlockTime;\n    }\n    locked[_addr] = newLocked;\n\n    if (_value != 0) {\n      stakingToken.safeTransferFrom(_addr, address(this), _value);\n    }\n\n    miner.releaseMIMO(_addr);\n\n    emit Deposit(_addr, _value, newLocked.end, _action, block.timestamp);\n  }\n\n  /**\n   * @dev Withdraws a given users stake, providing the lockup has finished\n   * @param _addr User for which to withdraw\n   */\n  function _withdraw(address _addr) internal nonReentrant {\n    LockedBalance memory oldLock = LockedBalance({ end: locked[_addr].end, amount: locked[_addr].amount });\n    require(block.timestamp >= oldLock.end || expired, \"The lock didn't expire\");\n    require(oldLock.amount > 0, \"Must have something to withdraw\");\n\n    uint256 value = uint256(oldLock.amount);\n\n    LockedBalance memory currentLock = LockedBalance({ end: 0, amount: 0 });\n    locked[_addr] = currentLock;\n\n    stakingToken.safeTransfer(_addr, value);\n    miner.releaseMIMO(_addr);\n\n    emit Withdraw(_addr, value, block.timestamp);\n  }\n}\n"
    },
    "contracts/liquidityMining/PARMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./interfaces/IMIMO.sol\";\nimport \"./interfaces/IGenericMiner.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract PARMiner {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using SafeERC20 for IERC20;\n\n  struct UserInfo {\n    uint256 stake;\n    uint256 accAmountPerShare;\n    uint256 accParAmountPerShare;\n  }\n\n  event StakeIncreased(address indexed user, uint256 stake);\n  event StakeDecreased(address indexed user, uint256 stake);\n\n  IERC20 public par;\n\n  mapping(address => UserInfo) internal _users;\n\n  uint256 public totalStake;\n  IGovernanceAddressProvider public a;\n\n  uint256 internal _balanceTracker;\n  uint256 internal _accAmountPerShare;\n\n  uint256 internal _parBalanceTracker;\n  uint256 internal _accParAmountPerShare;\n\n  constructor(IGovernanceAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n\n    par = IERC20(_addresses.parallel().stablex());\n  }\n\n  /**\n    Deposit an ERC20 pool token for staking\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param amount the amount of tokens to be deposited. Unit is in WEI.\n  **/\n  function deposit(uint256 amount) public {\n    par.safeTransferFrom(msg.sender, address(this), amount);\n    _increaseStake(msg.sender, amount);\n  }\n\n  /**\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked.\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI.\n  **/\n  function withdraw(uint256 amount) public {\n    par.safeTransfer(msg.sender, amount);\n    _decreaseStake(msg.sender, amount);\n  }\n\n  /**\n    Releases the outstanding MIMO balance to the user.\n    @param _user the address of the user for which the MIMO tokens will be released.\n  */\n  function releaseMIMO(address _user) public virtual {\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    _refreshPAR(totalStake);\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\n    _balanceTracker = _balanceTracker.sub(pending);\n    userInfo.accAmountPerShare = _accAmountPerShare;\n    require(a.mimo().transfer(_user, pending));\n  }\n\n  /**\n    Releases the outstanding PAR reward balance to the user.\n    @param _user the address of the user for which the PAR tokens will be released.\n  */\n  function releasePAR(address _user) public virtual {\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    _refreshPAR(totalStake);\n    uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\n    _parBalanceTracker = _parBalanceTracker.sub(pending);\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\n    require(par.transfer(_user, pending));\n  }\n\n  /**\n    Restakes the outstanding PAR reward balance to the user. Instead of sending the PAR to the user, it will be added to their stake\n    @param _user the address of the user for which the PAR tokens will be restaked.\n  */\n  function restakePAR(address _user) public virtual {\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    _refreshPAR(totalStake);\n    uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\n    _parBalanceTracker = _parBalanceTracker.sub(pending);\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    _increaseStake(_user, pending);\n  }\n\n  /**\n    Returns the number of tokens a user has staked.\n    @param _user the address of the user.\n    @return number of staked tokens\n  */\n  function stake(address _user) public view returns (uint256) {\n    return _users[_user].stake;\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`.\n    @param _user the address of the user.\n    @return number of MIMO tokens that the user can claim\n  */\n  function pendingMIMO(address _user) public view returns (uint256) {\n    uint256 currentBalance = a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_balanceTracker);\n    uint256 accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));\n\n    return _users[_user].stake.rayMul(accAmountPerShare.sub(_users[_user].accAmountPerShare));\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @param _user the address of the user.\n    @return nnumber of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function pendingPAR(address _user) public view returns (uint256) {\n    uint256 currentBalance = par.balanceOf(address(this)).sub(totalStake);\n    uint256 reward = currentBalance.sub(_parBalanceTracker);\n    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(totalStake));\n\n    return _users[_user].stake.rayMul(accParAmountPerShare.sub(_users[_user].accParAmountPerShare));\n  }\n\n  /**\n    Returns the userInfo stored of a user.\n    @param _user the address of the user.\n    @return `struct UserInfo {\n      uint256 stake;\n      uint256 rewardDebt;\n    }`\n  **/\n  function userInfo(address _user) public view returns (UserInfo memory) {\n    return _users[_user];\n  }\n\n  /**\n    Refreshes the global state and subsequently decreases the stake a user has.\n    This is an internal call and meant to be called within derivative contracts.\n    @param user the address of the user\n    @param value the amount by which the stake will be reduced\n  */\n  function _decreaseStake(address user, uint256 value) internal {\n    require(value > 0, \"STAKE_MUST_BE_GREATER_THAN_ZERO\"); //TODO cleanup error message\n\n    UserInfo storage userInfo = _users[user];\n    require(userInfo.stake >= value, \"INSUFFICIENT_STAKE_FOR_USER\"); //TODO cleanup error message\n    _refresh();\n    uint256 newTotalStake = totalStake.sub(value);\n    _refreshPAR(newTotalStake);\n\n    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\n    _balanceTracker = _balanceTracker.sub(pending);\n    userInfo.accAmountPerShare = _accAmountPerShare;\n\n    uint256 pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\n\n    _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    userInfo.stake = userInfo.stake.sub(value);\n    totalStake = newTotalStake;\n\n    if (pending > 0) {\n      require(a.mimo().transfer(user, pending));\n    }\n    if (pendingPAR > 0) {\n      require(par.transfer(user, pendingPAR));\n    }\n\n    emit StakeDecreased(user, value);\n  }\n\n  /**\n    Refreshes the global state and subsequently increases a user's stake.\n    This is an internal call and meant to be called within derivative contracts.\n    @param user the address of the user\n    @param value the amount by which the stake will be increased\n  */\n  function _increaseStake(address user, uint256 value) internal {\n    require(value > 0, \"STAKE_MUST_BE_GREATER_THAN_ZERO\"); //TODO cleanup error message\n\n    UserInfo storage userInfo = _users[user];\n\n    _refresh();\n\n    uint256 newTotalStake = totalStake.add(value);\n    _refreshPAR(newTotalStake);\n\n    uint256 pending;\n    uint256 pendingPAR;\n    if (userInfo.stake > 0) {\n      pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));\n      _balanceTracker = _balanceTracker.sub(pending);\n\n      // maybe we should add the accumulated PAR to the stake of the user instead?\n      pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\n      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    }\n\n    totalStake = newTotalStake;\n    userInfo.stake = userInfo.stake.add(value);\n\n    userInfo.accAmountPerShare = _accAmountPerShare;\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    if (pendingPAR > 0) {\n      // add pendingPAR balance to stake and totalStake instead of sending it back\n      userInfo.stake = userInfo.stake.add(pendingPAR);\n      totalStake = totalStake.add(pendingPAR);\n    }\n    if (pending > 0) {\n      require(a.mimo().transfer(user, pending));\n    }\n\n    emit StakeIncreased(user, value.add(pendingPAR));\n  }\n\n  /**\n    Refreshes the global state and subsequently updates a user's stake.\n    This is an internal call and meant to be called within derivative contracts.\n    @param user the address of the user\n    @param stake the new amount of stake for the user\n  */\n  function _updateStake(address user, uint256 stake) internal returns (bool) {\n    uint256 oldStake = _users[user].stake;\n    if (stake > oldStake) {\n      _increaseStake(user, stake.sub(oldStake));\n    }\n    if (stake < oldStake) {\n      _decreaseStake(user, oldStake.sub(stake));\n    }\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received MIMO tokens.\n  */\n  function _refresh() internal {\n    if (totalStake == 0) {\n      return;\n    }\n    uint256 currentBalance = a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_balanceTracker);\n    _balanceTracker = currentBalance;\n    _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received PAR tokens.\n  */\n  function _refreshPAR(uint256 newTotalStake) internal {\n    if (totalStake == 0) {\n      return;\n    }\n    uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);\n    uint256 parReward = currentParBalance.sub(_parBalanceTracker);\n\n    _parBalanceTracker = currentParBalance;\n    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/liquidityMining/DemandMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./GenericMiner.sol\";\nimport \"./interfaces/IMIMO.sol\";\nimport \"./interfaces/IDemandMiner.sol\";\n\ncontract DemandMiner is IDemandMiner, GenericMiner {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  IERC20 public override token;\n\n  constructor(IGovernanceAddressProvider _addresses, IERC20 _token) public GenericMiner(_addresses) {\n    require(address(_token) != address(0));\n    require(address(_token) != address(_addresses.mimo()));\n    token = _token;\n  }\n\n  /**\n    Deposit an ERC20 pool token for staking\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param amount the amount of tokens to be deposited. Unit is in WEI.\n  **/\n  function deposit(uint256 amount) public override {\n    token.safeTransferFrom(msg.sender, address(this), amount);\n    _increaseStake(msg.sender, amount);\n  }\n\n  /**\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked.\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI.\n  **/\n  function withdraw(uint256 amount) public override {\n    token.safeTransfer(msg.sender, amount);\n    _decreaseStake(msg.sender, amount);\n  }\n}\n"
    },
    "contracts/liquidityMining/EthereumDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"./BaseDistributor.sol\";\n\ncontract EthereumDistributor is BaseDistributor {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  constructor(IGovernanceAddressProvider _a) public {\n    require(address(_a) != address(0));\n\n    a = _a;\n  }\n\n  /**\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\n    @return number of mintable tokens available right now.\n  */\n  function mintableTokens() public view override returns (uint256) {\n    return a.mimo().balanceOf(address(this));\n  }\n\n  /**\n    Internal function to release a percentage of newTokens to a specific payee\n    @dev uses totalShares to calculate correct share\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\n    @param _payee The address of the payee to whom to distribute the fees.\n  */\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {\n    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);\n    IERC20(a.mimo()).safeTransfer(_payee, payment);\n  }\n}\n"
    },
    "contracts/governance/GovernanceAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"./interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/IGovernorAlpha.sol\";\nimport \"./interfaces/ITimelock.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"../interfaces/IAccessController.sol\";\nimport \"../liquidityMining/interfaces/IDebtNotifier.sol\";\nimport \"../liquidityMining/interfaces/IMIMO.sol\";\n\ncontract GovernanceAddressProvider is IGovernanceAddressProvider {\n  IAddressProvider public override parallel;\n  IMIMO public override mimo;\n  IDebtNotifier public override debtNotifier;\n  IGovernorAlpha public override governorAlpha;\n  ITimelock public override timelock;\n  IVotingEscrow public override votingEscrow;\n\n  constructor(IAddressProvider _parallel) public {\n    require(address(_parallel) != address(0));\n    parallel = _parallel;\n  }\n\n  modifier onlyManager() {\n    require(controller().hasRole(controller().MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  /**\n    Update the `AddressProvider` address that points to main AddressProvider\n    used in the Parallel Protocol\n    @dev only manager can call this.\n    @param _parallel the address of the new `AddressProvider` address.\n  */\n  function setParallelAddressProvider(IAddressProvider _parallel) public override onlyManager {\n    require(address(_parallel) != address(0));\n    parallel = _parallel;\n  }\n\n  /**\n    Update the `MIMO` ERC20 token address\n    @dev only manager can call this.\n    @param _mimo the address of the new `MIMO` token address.\n  */\n  function setMIMO(IMIMO _mimo) public override onlyManager {\n    require(address(_mimo) != address(0));\n    mimo = _mimo;\n  }\n\n  /**\n    Update the `DebtNotifier` address\n    @dev only manager can call this.\n    @param _debtNotifier the address of the new `DebtNotifier`.\n  */\n  function setDebtNotifier(IDebtNotifier _debtNotifier) public override onlyManager {\n    require(address(_debtNotifier) != address(0));\n    debtNotifier = _debtNotifier;\n  }\n\n  /**\n    Update the `GovernorAlpha` address\n    @dev only manager can call this.\n    @param _governorAlpha the address of the new `GovernorAlpha`.\n  */\n  function setGovernorAlpha(IGovernorAlpha _governorAlpha) public override onlyManager {\n    require(address(_governorAlpha) != address(0));\n    governorAlpha = _governorAlpha;\n  }\n\n  /**\n    Update the `Timelock` address\n    @dev only manager can call this.\n    @param _timelock the address of the new `Timelock`.\n  */\n  function setTimelock(ITimelock _timelock) public override onlyManager {\n    require(address(_timelock) != address(0));\n    timelock = _timelock;\n  }\n\n  /**\n    Update the `VotingEscrow` address\n    @dev only manager can call this.\n    @param _votingEscrow the address of the new `VotingEscrow`.\n  */\n  function setVotingEscrow(IVotingEscrow _votingEscrow) public override onlyManager {\n    require(address(_votingEscrow) != address(0));\n    votingEscrow = _votingEscrow;\n  }\n\n  function controller() public view override returns (IAccessController) {\n    return parallel.controller();\n  }\n}\n"
    },
    "contracts/core/AddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVaultsCore.sol\";\nimport \"../interfaces/IAccessController.sol\";\nimport \"../interfaces/IConfigProvider.sol\";\nimport \"../interfaces/ISTABLEX.sol\";\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/IRatesManager.sol\";\nimport \"../interfaces/ILiquidationManager.sol\";\nimport \"../interfaces/IVaultsCore.sol\";\nimport \"../interfaces/IVaultsDataProvider.sol\";\n\ncontract AddressProvider is IAddressProvider {\n  IAccessController public override controller;\n  IConfigProvider public override config;\n  IVaultsCore public override core;\n\n  ISTABLEX public override stablex;\n  IRatesManager public override ratesManager;\n  IPriceFeed public override priceFeed;\n  ILiquidationManager public override liquidationManager;\n  IVaultsDataProvider public override vaultsData;\n  IFeeDistributor public override feeDistributor;\n\n  constructor(IAccessController _controller) public {\n    controller = _controller;\n  }\n\n  modifier onlyManager() {\n    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  function setAccessController(IAccessController _controller) public override onlyManager {\n    require(address(_controller) != address(0));\n    controller = _controller;\n  }\n\n  function setConfigProvider(IConfigProvider _config) public override onlyManager {\n    require(address(_config) != address(0));\n    config = _config;\n  }\n\n  function setVaultsCore(IVaultsCore _core) public override onlyManager {\n    require(address(_core) != address(0));\n    core = _core;\n  }\n\n  function setStableX(ISTABLEX _stablex) public override onlyManager {\n    require(address(_stablex) != address(0));\n    stablex = _stablex;\n  }\n\n  function setRatesManager(IRatesManager _ratesManager) public override onlyManager {\n    require(address(_ratesManager) != address(0));\n    ratesManager = _ratesManager;\n  }\n\n  function setLiquidationManager(ILiquidationManager _liquidationManager) public override onlyManager {\n    require(address(_liquidationManager) != address(0));\n    liquidationManager = _liquidationManager;\n  }\n\n  function setPriceFeed(IPriceFeed _priceFeed) public override onlyManager {\n    require(address(_priceFeed) != address(0));\n    priceFeed = _priceFeed;\n  }\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) public override onlyManager {\n    require(address(_vaultsData) != address(0));\n    vaultsData = _vaultsData;\n  }\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) public override onlyManager {\n    require(address(_feeDistributor) != address(0));\n    feeDistributor = _feeDistributor;\n  }\n}\n"
    },
    "contracts/liquidityMining/DebtNotifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/ISupplyMiner.sol\";\nimport \"../interfaces/IVaultsDataProvider.sol\";\n\ncontract DebtNotifier is IDebtNotifier {\n  IGovernanceAddressProvider public override a;\n  mapping(address => ISupplyMiner) public override collateralSupplyMinerMapping;\n\n  constructor(IGovernanceAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  modifier onlyVaultsCore() {\n    require(msg.sender == address(a.parallel().core()), \"Caller is not VaultsCore\");\n    _;\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\n    _;\n  }\n\n  /**\n    Notifies the correct supplyMiner of a change in debt.\n    @dev Only the vaultsCore can call this.\n    `debtChanged` will silently return if collateralType is not known to prevent any problems in vaultscore.\n    @param _vaultId the ID of the vault of which the debt has changed.\n  **/\n  function debtChanged(uint256 _vaultId) public override onlyVaultsCore {\n    IVaultsDataProvider.Vault memory v = a.parallel().vaultsData().vaults(_vaultId);\n\n    ISupplyMiner supplyMiner = collateralSupplyMinerMapping[v.collateralType];\n    if (address(supplyMiner) == address(0)) {\n      // not throwing error so VaultsCore keeps working\n      return;\n    }\n    supplyMiner.baseDebtChanged(v.owner, v.baseDebt);\n  }\n\n  /**\n    Updates the collateral to supplyMiner mapping.\n    @dev Manager role in the AccessController is required to call this.\n    @param collateral the address of the collateralType.\n    @param supplyMiner the address of the supplyMiner which will be notified on debt changes for this collateralType.\n  **/\n  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) public override onlyManager {\n    collateralSupplyMinerMapping[collateral] = supplyMiner;\n  }\n}\n"
    },
    "contracts/liquidityMining/SupplyMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./GenericMiner.sol\";\nimport \"./interfaces/ISupplyMiner.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\n\ncontract SupplyMiner is ISupplyMiner, GenericMiner {\n  using SafeMath for uint256;\n\n  constructor(IGovernanceAddressProvider _addresses) public GenericMiner(_addresses) {}\n\n  modifier onlyNotifier() {\n    require(msg.sender == address(a.debtNotifier()), \"Caller is not DebtNotifier\");\n    _;\n  }\n\n  /**\n    Gets called by the `DebtNotifier` and will update the stake of the user\n    to match his current outstanding debt by using his baseDebt.\n    @param user address of the user.\n    @param newBaseDebt the new baseDebt and therefore stake for the user.\n  */\n  function baseDebtChanged(address user, uint256 newBaseDebt) public override onlyNotifier {\n    _updateStake(user, newBaseDebt);\n  }\n}\n"
    },
    "contracts/core/VaultsDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IVaultsDataProvider.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ncontract VaultsDataProvider is IVaultsDataProvider {\n  using SafeMath for uint256;\n\n  IAddressProvider public override a;\n\n  uint256 public override vaultCount = 0;\n\n  mapping(address => uint256) public override baseDebt;\n\n  mapping(uint256 => Vault) private _vaults;\n  mapping(address => mapping(address => uint256)) private _vaultOwners;\n\n  modifier onlyVaultsCore() {\n    require(msg.sender == address(a.core()), \"Caller is not VaultsCore\");\n    _;\n  }\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Opens a new vault.\n    @dev only the vaultsCore module can call this function\n    @param _collateralType address to the collateral asset e.g. WETH\n    @param _owner the owner of the new vault.\n  */\n  function createVault(address _collateralType, address _owner) public override onlyVaultsCore returns (uint256) {\n    require(_collateralType != address(0));\n    require(_owner != address(0));\n    uint256 newId = ++vaultCount;\n    require(_collateralType != address(0), \"collateralType unknown\");\n    Vault memory v = Vault({\n      collateralType: _collateralType,\n      owner: _owner,\n      collateralBalance: 0,\n      baseDebt: 0,\n      createdAt: block.timestamp\n    });\n    _vaults[newId] = v;\n    _vaultOwners[_owner][_collateralType] = newId;\n    return newId;\n  }\n\n  /**\n    Set the collateral balance of a vault.\n    @dev only the vaultsCore module can call this function\n    @param _id Vault ID of which the collateral balance will be updated\n    @param _balance the new balance of the vault.\n  */\n  function setCollateralBalance(uint256 _id, uint256 _balance) public override onlyVaultsCore {\n    require(vaultExists(_id), \"Vault not found.\");\n    Vault storage v = _vaults[_id];\n    v.collateralBalance = _balance;\n  }\n\n  /**\n    Set the base debt of a vault.\n    @dev only the vaultsCore module can call this function\n    @param _id Vault ID of which the base debt will be updated\n    @param _newBaseDebt the new base debt of the vault.\n  */\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) public override onlyVaultsCore {\n    Vault storage _vault = _vaults[_id];\n    if (_newBaseDebt > _vault.baseDebt) {\n      uint256 increase = _newBaseDebt.sub(_vault.baseDebt);\n      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].add(increase);\n    } else {\n      uint256 decrease = _vault.baseDebt.sub(_newBaseDebt);\n      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].sub(decrease);\n    }\n    _vault.baseDebt = _newBaseDebt;\n  }\n\n  /**\n    Get a vault by vault ID.\n    @param _id The vault's ID to be retrieved\n    @return struct Vault {\n      address collateralType;\n      address owner;\n      uint256 collateralBalance;\n      uint256 baseDebt;\n      uint256 createdAt;\n    }\n  */\n  function vaults(uint256 _id) public view override returns (Vault memory) {\n    Vault memory v = _vaults[_id];\n    return v;\n  }\n\n  /**\n    Get the owner of a vault.\n    @param _id the ID of the vault\n    @return owner of the vault\n  */\n  function vaultOwner(uint256 _id) public view override returns (address) {\n    return _vaults[_id].owner;\n  }\n\n  /**\n    Get the collateral type of a vault.\n    @param _id the ID of the vault\n    @return address for the collateral type of the vault\n  */\n  function vaultCollateralType(uint256 _id) public view override returns (address) {\n    return _vaults[_id].collateralType;\n  }\n\n  /**\n    Get the collateral balance of a vault.\n    @param _id the ID of the vault\n    @return collateral balance of the vault\n  */\n  function vaultCollateralBalance(uint256 _id) public view override returns (uint256) {\n    return _vaults[_id].collateralBalance;\n  }\n\n  /**\n    Get the base debt of a vault.\n    @param _id the ID of the vault\n    @return base debt of the vault\n  */\n  function vaultBaseDebt(uint256 _id) public view override returns (uint256) {\n    return _vaults[_id].baseDebt;\n  }\n\n  /**\n    Retrieve the vault id for a specified owner and collateral type.\n    @dev returns 0 for non-existing vaults\n    @param _collateralType address of the collateral type (Eg: WETH)\n    @param _owner address of the owner of the vault\n    @return vault id of the vault or 0\n  */\n  function vaultId(address _collateralType, address _owner) public view override returns (uint256) {\n    return _vaultOwners[_owner][_collateralType];\n  }\n\n  /**\n    Checks if a specified vault exists.\n    @param _id the ID of the vault\n    @return boolean if the vault exists\n  */\n  function vaultExists(uint256 _id) public view override returns (bool) {\n    Vault memory v = _vaults[_id];\n    return v.collateralType != address(0);\n  }\n\n  /**\n    Calculated the total outstanding debt for all vaults and all collateral types.\n    @dev uses the existing cumulative rate. Call `refresh()` on `VaultsCore`\n    to make sure it's up to date.\n    @return total debt of the platform\n  */\n  function debt() public view override returns (uint256) {\n    uint256 total = 0;\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      total = total.add(collateralDebt(collateralType));\n    }\n    return total;\n  }\n\n  /**\n    Calculated the total outstanding debt for all vaults of a specific collateral type.\n    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`\n    to make sure it's up to date.\n    @param _collateralType address of the collateral type (Eg: WETH)\n    @return total debt of the platform of one collateral type\n  */\n  function collateralDebt(address _collateralType) public view override returns (uint256) {\n    return a.ratesManager().calculateDebt(baseDebt[_collateralType], a.core().cumulativeRates(_collateralType));\n  }\n\n  /**\n    Calculated the total outstanding debt for a specific vault.\n    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`\n    to make sure it's up to date.\n    @param _vaultId the ID of the vault\n    @return total debt of one vault\n  */\n  function vaultDebt(uint256 _vaultId) public view override returns (uint256) {\n    IVaultsDataProvider.Vault memory v = _vaults[_vaultId];\n    return a.ratesManager().calculateDebt(v.baseDebt, a.core().cumulativeRates(v.collateralType));\n  }\n}\n"
    },
    "contracts/core/LiquidiationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/ILiquidationManager.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ncontract LiquidationManager is ILiquidationManager, ReentrancyGuard {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  IAddressProvider public override a;\n\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18; // 1\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Check if the health factor is above or equal to 1.\n    @param _collateralValue value of the collateral in PAR\n    @param _vaultDebt outstanding debt to which the collateral balance shall be compared\n    @param _minRatio min ratio to calculate health factor\n    @return boolean if the health factor is >= 1.\n  */\n  function isHealthy(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) public view override returns (bool) {\n    uint256 healthFactor = calculateHealthFactor(_collateralValue, _vaultDebt, _minRatio);\n    return healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\n  }\n\n  /**\n    Calculate the healthfactor of a debt balance\n    @param _collateralValue value of the collateral in PAR currency\n    @param _vaultDebt outstanding debt to which the collateral balance shall be compared\n    @param _minRatio min ratio to calculate health factor\n    @return healthFactor\n  */\n  function calculateHealthFactor(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) public view override returns (uint256 healthFactor) {\n    if (_vaultDebt == 0) return WadRayMath.wad();\n\n    // CurrentCollateralizationRatio = value(deposited ETH) / debt\n    uint256 collateralizationRatio = _collateralValue.wadDiv(_vaultDebt);\n\n    // Healthfactor = CurrentCollateralizationRatio / MinimumCollateralizationRatio\n    if (_minRatio > 0) {\n      return collateralizationRatio.wadDiv(_minRatio);\n    }\n\n    return 1e18; // 1\n  }\n\n  /**\n    Calculate the liquidation bonus for a specified amount\n    @param _collateralType address of the collateral type\n    @param _amount amount for which the liquidation bonus shall be calculated\n    @return bonus the liquidation bonus to pay out\n  */\n  function liquidationBonus(address _collateralType, uint256 _amount) public view override returns (uint256 bonus) {\n    return _amount.wadMul(a.config().collateralLiquidationBonus(_collateralType));\n  }\n\n  /**\n    Apply the liquidation bonus to a balance as a discount.\n    @param _collateralType address of the collateral type\n    @param _amount the balance on which to apply to liquidation bonus as a discount.\n    @return discountedAmount\n  */\n  function applyLiquidationDiscount(address _collateralType, uint256 _amount)\n    public\n    view\n    override\n    returns (uint256 discountedAmount)\n  {\n    return _amount.wadDiv(a.config().collateralLiquidationBonus(_collateralType).add(WadRayMath.wad()));\n  }\n}\n"
    },
    "contracts/fees/FeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/ISTABLEX.sol\";\nimport \"../interfaces/IFeeDistributor.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ncontract FeeDistributor is IFeeDistributor, ReentrancyGuard {\n  using SafeMath for uint256;\n\n  event PayeeAdded(address account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  uint256 public override lastReleasedAt;\n  IAddressProvider public override a;\n\n  uint256 public override totalShares;\n  mapping(address => uint256) public override shares;\n  address[] public payees;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not Manager\");\n    _;\n  }\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Public function to release the accumulated fee income to the payees.\n    @dev anyone can call this.\n  */\n  function release() public override nonReentrant {\n    uint256 income = a.core().state().availableIncome();\n    require(income > 0, \"income is 0\");\n    require(payees.length > 0, \"Payees not configured yet\");\n    lastReleasedAt = now;\n\n    // Mint USDX to all receivers\n    for (uint256 i = 0; i < payees.length; i++) {\n      address payee = payees[i];\n      _release(income, payee);\n    }\n    emit FeeReleased(income, lastReleasedAt);\n  }\n\n  /**\n    Updates the payee configuration to a new one.\n    @dev will release existing fees before the update.\n    @param _payees Array of payees\n    @param _shares Array of shares for each payee\n  */\n  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    uint256 income = a.core().state().availableIncome();\n    if (income > 0 && payees.length > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }\n\n  /**\n    Get current configured payees.\n    @return array of current payees.\n  */\n  function getPayees() public view override returns (address[] memory) {\n    return payees;\n  }\n\n  /**\n    Internal function to release a percentage of income to a specific payee\n    @dev uses totalShares to calculate correct share\n    @param _totalIncomeReceived Total income for all payees, will be split according to shares\n    @param _payee The address of the payee to whom to distribute the fees.\n  */\n  function _release(uint256 _totalIncomeReceived, address _payee) internal {\n    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);\n    a.stablex().mint(_payee, payment);\n  }\n\n  /**\n    Internal function to add a new payee.\n    @dev will update totalShares and therefore reduce the relative share of all other payees.\n    @param _payee The address of the payee to add.\n    @param _shares The number of shares owned by the payee.\n  */\n  function _addPayee(address _payee, uint256 _shares) internal {\n    require(_payee != address(0), \"payee is the zero address\");\n    require(_shares > 0, \"shares are 0\");\n    require(shares[_payee] == 0, \"payee already has shares\");\n\n    payees.push(_payee);\n    shares[_payee] = _shares;\n    totalShares = totalShares.add(_shares);\n    emit PayeeAdded(_payee, _shares);\n  }\n}\n"
    },
    "contracts/core/RatesManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/IRatesManager.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ncontract RatesManager is IRatesManager {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  uint256 private constant _SECONDS_PER_YEAR = 365 days;\n\n  IAddressProvider public override a;\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Calculate the annualized borrow rate from the specified borrowing rate.\n    @param _borrowRate rate for a 1 second interval specified in RAY accuracy.\n    @return annualized rate\n  */\n  function annualizedBorrowRate(uint256 _borrowRate) public pure override returns (uint256) {\n    return _borrowRate.rayPow(_SECONDS_PER_YEAR);\n  }\n\n  /**\n    Calculate the total debt from a specified base debt and cumulative rate.\n    @param _baseDebt the base debt to be used. Can be a vault base debt or an aggregate base debt\n    @param _cumulativeRate the cumulative rate in RAY accuracy.\n    @return debt after applying the cumulative rate\n  */\n  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) public pure override returns (uint256 debt) {\n    return _baseDebt.rayMul(_cumulativeRate);\n  }\n\n  /**\n    Calculate the base debt from a specified total debt and cumulative rate.\n    @param _debt the total debt to be used.\n    @param _cumulativeRate the cumulative rate in RAY accuracy.\n    @return baseDebt the new base debt\n  */\n  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) public pure override returns (uint256 baseDebt) {\n    return _debt.rayDiv(_cumulativeRate);\n  }\n\n  /**\n    Bring an existing cumulative rate forward in time\n    @param _borrowRate rate for a 1 second interval specified in RAY accuracy to be applied\n    @param _timeElapsed the time over whicht the borrow rate shall be applied\n    @param _cumulativeRate the initial cumulative rate from which to apply the borrow rate\n    @return new cumulative rate\n  */\n  function calculateCumulativeRate(\n    uint256 _borrowRate,\n    uint256 _cumulativeRate,\n    uint256 _timeElapsed\n  ) public view override returns (uint256) {\n    if (_timeElapsed == 0) return _cumulativeRate;\n    uint256 cumulativeElapsed = _borrowRate.rayPow(_timeElapsed);\n    return _cumulativeRate.rayMul(cumulativeElapsed);\n  }\n}\n"
    },
    "contracts/core/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../interfaces/IPriceFeed.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../chainlink/AggregatorV3Interface.sol\";\nimport \"../libraries/MathPow.sol\";\nimport \"../libraries/WadRayMath.sol\";\n\ncontract PriceFeed is IPriceFeed {\n  using SafeMath for uint256;\n  using SafeMath for uint8;\n  using WadRayMath for uint256;\n\n  uint256 public constant PRICE_ORACLE_STALE_THRESHOLD = 1 days;\n\n  IAddressProvider public override a;\n\n  mapping(address => AggregatorV3Interface) public override assetOracles;\n\n  AggregatorV3Interface public override eurOracle;\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  /**\n   * @notice Sets the oracle for the given asset,\n   * @param _asset address to the collateral asset e.g. WETH\n   * @param _oracle address to the oracel, this oracle should implement the AggregatorV3Interface\n   */\n  function setAssetOracle(address _asset, address _oracle) public override onlyManager {\n    require(_asset != address(0));\n    require(_oracle != address(0));\n    assetOracles[_asset] = AggregatorV3Interface(_oracle);\n    emit OracleUpdated(_asset, _oracle, msg.sender);\n  }\n\n  /**\n   * @notice Sets the oracle for EUR, this oracle should provide EUR-USD prices\n   * @param _oracle address to the oracle, this oracle should implement the AggregatorV3Interface\n   */\n  function setEurOracle(address _oracle) public override onlyManager {\n    require(_oracle != address(0));\n    eurOracle = AggregatorV3Interface(_oracle);\n    emit EurOracleUpdated(_oracle, msg.sender);\n  }\n\n  /**\n   * Gets the asset price in EUR (PAR)\n   * @dev returned value has matching decimals to the asset oracle (not the EUR oracle)\n   * @param _asset address to the collateral asset e.g. WETH\n   */\n  function getAssetPrice(address _asset) public view override returns (uint256 price) {\n    (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = eurOracle.latestRoundData();\n    require(eurAnswer > 0, \"EUR price data not valid\");\n    require(block.timestamp - eurUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, \"EUR price data is stale\");\n\n    (, int256 answer, , uint256 assetUpdatedAt, ) = assetOracles[_asset].latestRoundData();\n    require(answer > 0, \"Price data not valid\");\n    require(block.timestamp - assetUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, \"Price data is stale\");\n\n    uint8 eurDecimals = eurOracle.decimals();\n    uint256 eurAccuracy = MathPow.pow(10, eurDecimals);\n    return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));\n  }\n\n  /**\n   * @notice Converts asset balance into stablecoin balance at current price\n   * @param _asset address to the collateral asset e.g. WETH\n   * @param _amount amount of collateral\n   */\n  function convertFrom(address _asset, uint256 _amount) public view override returns (uint256) {\n    uint256 price = getAssetPrice(_asset);\n    uint8 collateralDecimals = ERC20(_asset).decimals();\n    uint8 parDecimals = ERC20(address(a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()\n    uint8 oracleDecimals = assetOracles[_asset].decimals();\n    uint256 parAccuracy = MathPow.pow(10, parDecimals);\n    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));\n    return _amount.mul(price).mul(parAccuracy).div(collateralAccuracy);\n  }\n\n  /**\n   * @notice Converts stablecoin balance into collateral balance at current price\n   * @param _asset address to the collateral asset e.g. WETH\n   * @param _amount amount of stablecoin\n   */\n  function convertTo(address _asset, uint256 _amount) public view override returns (uint256) {\n    uint256 price = getAssetPrice(_asset);\n    uint8 collateralDecimals = ERC20(_asset).decimals();\n    uint8 parDecimals = ERC20(address(a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()\n    uint8 oracleDecimals = assetOracles[_asset].decimals();\n    uint256 parAccuracy = MathPow.pow(10, parDecimals);\n    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));\n    return _amount.mul(collateralAccuracy).div(price).div(parAccuracy);\n  }\n}\n"
    },
    "contracts/libraries/MathPow.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary MathPow {\n  function pow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n    z = n % 2 != 0 ? x : 1;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x = SafeMath.mul(x, x);\n\n      if (n % 2 != 0) {\n        z = SafeMath.mul(z, x);\n      }\n    }\n  }\n}\n"
    },
    "contracts/mocks/MockChainlinkFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../chainlink/AggregatorV3Interface.sol\";\n\ncontract MockChainlinkFeed is AggregatorV3Interface, Ownable {\n  uint256 private _latestPrice;\n  string public override description;\n  uint256 public override version = 3;\n\n  uint8 public override decimals;\n\n  constructor(\n    uint8 _decimals,\n    uint256 _price,\n    string memory _description\n  ) public {\n    decimals = _decimals;\n    _latestPrice = _price;\n    description = _description;\n  }\n\n  function setLatestPrice(uint256 price) public onlyOwner {\n    require(price > 110033500); // > 1.1 USD\n    require(price < 130033500); // > 1.3 USD\n    _latestPrice = price;\n  }\n\n  /**\n   * @notice get data about a round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @param _roundId the requested round ID as presented through the proxy, this\n   * is made up of the aggregator's round ID with the phase ID encoded in the\n   * two highest order bytes\n   * @return roundId is the round ID from the aggregator for which the data was\n   * retrieved combined with an phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function getRoundData(uint80 _roundId)\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    roundId = uint80(_roundId);\n    answer = int256(_latestPrice);\n    startedAt = uint256(1597422127);\n    updatedAt = uint256(1597695228);\n    answeredInRound = uint80(_roundId);\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @return roundId is the round ID from the aggregator for which the data was\n   * retrieved combined with an phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function latestRoundData()\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    uint256 latestRound = 101;\n    roundId = uint80(latestRound);\n    answer = int256(_latestPrice);\n    startedAt = uint256(1597422127);\n    updatedAt = now;\n    answeredInRound = uint80(latestRound);\n  }\n}\n"
    },
    "contracts/mocks/MockChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../chainlink/AggregatorV3Interface.sol\";\n\ncontract MockChainlinkAggregator is AggregatorV3Interface {\n  uint256 private _latestPrice;\n  uint256 private _updatedAt;\n  string public override description;\n  uint256 public override version = 3;\n\n  uint8 public override decimals;\n\n  constructor(\n    uint8 _decimals,\n    uint256 _price,\n    string memory _description\n  ) public {\n    decimals = _decimals;\n    _latestPrice = _price;\n    description = _description;\n  }\n\n  function setLatestPrice(uint256 price) public {\n    _latestPrice = price;\n  }\n\n  function setUpdatedAt(uint256 updatedAt) public {\n    _updatedAt = updatedAt;\n  }\n\n  /**\n   * @notice get data about a round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @param _roundId the requested round ID as presented through the proxy, this\n   * is made up of the aggregator's round ID with the phase ID encoded in the\n   * two highest order bytes\n   * @return roundId is the round ID from the aggregator for which the data was\n   * retrieved combined with an phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function getRoundData(uint80 _roundId)\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    roundId = uint80(_roundId);\n    answer = int256(_latestPrice);\n    startedAt = uint256(1597422127);\n    updatedAt = uint256(1597695228);\n    answeredInRound = uint80(_roundId);\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @return roundId is the round ID from the aggregator for which the data was\n   * retrieved combined with an phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function latestRoundData()\n    public\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    uint256 latestRound = 101;\n    roundId = uint80(latestRound);\n    answer = int256(_latestPrice);\n    startedAt = uint256(1597422127);\n    updatedAt = _updatedAt;\n    answeredInRound = uint80(latestRound);\n  }\n}\n"
    },
    "contracts/core/ConfigProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/IConfigProvider.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ncontract ConfigProvider is IConfigProvider {\n  IAddressProvider public override a;\n\n  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1\n  mapping(address => uint256) public override collateralIds;\n\n  uint256 public override numCollateralConfigs;\n  /// @notice The minimum duration of voting on a proposal, in seconds\n  uint256 public override minVotingPeriod = 3 days;\n  /// @notice The max duration of voting on a proposal, in seconds\n  uint256 public override maxVotingPeriod = 2 weeks;\n  /// @notice The percentage of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed\n  uint256 public override votingQuorum = 1e16; // 1%\n  /// @notice The percentage of votes required in order for a voter to become a proposer\n  uint256 public override proposalThreshold = 2e14; // 0.02%\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n\n    a = _addresses;\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  /**\n    Creates or overwrites an existing config for a collateral type\n    @param _collateralType address of the collateral type\n    @param _debtLimit the debt ceiling for the collateral type\n    @param _liquidationRatio the minimum ratio to maintain to avoid liquidation\n    @param _minCollateralRatio the minimum ratio to maintain to borrow new money or withdraw collateral\n    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.\n    @param _originationFee an optional origination fee for newly created debt. Can be 0.\n    @param _liquidationBonus the liquidation bonus to be paid to liquidators.\n    @param _liquidationFee an optional fee for liquidation debt. Can be 0.\n  */\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _liquidationRatio,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee,\n    uint256 _liquidationBonus,\n    uint256 _liquidationFee\n  ) public override onlyManager {\n    require(address(_collateralType) != address(0));\n    require(_minCollateralRatio >= _liquidationRatio);\n    if (collateralIds[_collateralType] == 0) {\n      // Initialize new collateral\n      a.core().state().initializeRates(_collateralType);\n      CollateralConfig memory config = CollateralConfig({\n        collateralType: _collateralType,\n        debtLimit: _debtLimit,\n        liquidationRatio: _liquidationRatio,\n        minCollateralRatio: _minCollateralRatio,\n        borrowRate: _borrowRate,\n        originationFee: _originationFee,\n        liquidationBonus: _liquidationBonus,\n        liquidationFee: _liquidationFee\n      });\n\n      numCollateralConfigs++;\n      _collateralConfigs[numCollateralConfigs] = config;\n      collateralIds[_collateralType] = numCollateralConfigs;\n    } else {\n      // Update collateral config\n      a.core().state().refreshCollateral(_collateralType);\n      uint256 id = collateralIds[_collateralType];\n\n      _collateralConfigs[id].collateralType = _collateralType;\n      _collateralConfigs[id].debtLimit = _debtLimit;\n      _collateralConfigs[id].liquidationRatio = _liquidationRatio;\n      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;\n      _collateralConfigs[id].borrowRate = _borrowRate;\n      _collateralConfigs[id].originationFee = _originationFee;\n      _collateralConfigs[id].liquidationBonus = _liquidationBonus;\n      _collateralConfigs[id].liquidationFee = _liquidationFee;\n    }\n    emit CollateralUpdated(\n      _collateralType,\n      _debtLimit,\n      _liquidationRatio,\n      _minCollateralRatio,\n      _borrowRate,\n      _originationFee,\n      _liquidationBonus,\n      _liquidationFee\n    );\n  }\n\n  function _emitUpdateEvent(address _collateralType) internal {\n    emit CollateralUpdated(\n      _collateralType,\n      _collateralConfigs[collateralIds[_collateralType]].debtLimit,\n      _collateralConfigs[collateralIds[_collateralType]].liquidationRatio,\n      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,\n      _collateralConfigs[collateralIds[_collateralType]].borrowRate,\n      _collateralConfigs[collateralIds[_collateralType]].originationFee,\n      _collateralConfigs[collateralIds[_collateralType]].liquidationBonus,\n      _collateralConfigs[collateralIds[_collateralType]].liquidationFee\n    );\n  }\n\n  /**\n    Remove the config for a collateral type\n    @param _collateralType address of the collateral type\n  */\n  function removeCollateral(address _collateralType) public override onlyManager {\n    uint256 id = collateralIds[_collateralType];\n    require(id != 0, \"collateral does not exist\");\n\n    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward\n    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry\n    delete _collateralConfigs[numCollateralConfigs]; // delete last entry\n    delete collateralIds[_collateralType];\n\n    numCollateralConfigs--;\n\n    emit CollateralRemoved(_collateralType);\n  }\n\n  /**\n    Sets the debt limit for a collateral type\n    @param _collateralType address of the collateral type\n    @param _debtLimit the new debt limit\n  */\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {\n    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the minimum liquidation ratio for a collateral type\n    @dev this is the liquidation treshold under which a vault is considered open for liquidation.\n    @param _collateralType address of the collateral type\n    @param _liquidationRatio the new minimum collateralization ratio\n  */\n  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio)\n    public\n    override\n    onlyManager\n  {\n    require(_liquidationRatio <= _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio);\n    _collateralConfigs[collateralIds[_collateralType]].liquidationRatio = _liquidationRatio;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the minimum ratio for a collateral type for new borrowing or collateral withdrawal\n    @param _collateralType address of the collateral type\n    @param _minCollateralRatio the new minimum open ratio\n  */\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)\n    public\n    override\n    onlyManager\n  {\n    require(_minCollateralRatio >= _collateralConfigs[collateralIds[_collateralType]].liquidationRatio);\n    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the borrowing rate for a collateral type\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\n    @param _collateralType address of the collateral type\n    @param _borrowRate the new borrowing rate for a 1 sec interval\n  */\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {\n    a.core().state().refreshCollateral(_collateralType);\n    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the origiation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n    @param _originationFee new origination fee in WAD\n  */\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {\n    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the liquidation bonus for a collateral type\n    @dev the liquidation bonus is specified in WAD\n    @param _collateralType address of the collateral type\n    @param _liquidationBonus the liquidation bonus to be paid to liquidators.\n  */\n  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus)\n    public\n    override\n    onlyManager\n  {\n    _collateralConfigs[collateralIds[_collateralType]].liquidationBonus = _liquidationBonus;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Sets the liquidation fee for a collateral type\n    @dev this rate is applied as a fee for liquidation and is specified in WAD\n    @param _collateralType address of the collateral type\n    @param _liquidationFee new liquidation fee in WAD\n  */\n  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) public override onlyManager {\n    require(_liquidationFee < 1e18); // fee < 100%\n    _collateralConfigs[collateralIds[_collateralType]].liquidationFee = _liquidationFee;\n    _emitUpdateEvent(_collateralType);\n  }\n\n  /**\n    Set the min voting period for a gov proposal.\n    @param _minVotingPeriod the min voting period for a gov proposal\n  */\n  function setMinVotingPeriod(uint256 _minVotingPeriod) public override onlyManager {\n    minVotingPeriod = _minVotingPeriod;\n  }\n\n  /**\n    Set the max voting period for a gov proposal.\n    @param _maxVotingPeriod the max voting period for a gov proposal\n  */\n  function setMaxVotingPeriod(uint256 _maxVotingPeriod) public override onlyManager {\n    maxVotingPeriod = _maxVotingPeriod;\n  }\n\n  /**\n    Set the voting quora for a gov proposal.\n    @param _votingQuorum the voting quora for a gov proposal\n  */\n  function setVotingQuorum(uint256 _votingQuorum) public override onlyManager {\n    require(_votingQuorum < 1e18);\n    votingQuorum = _votingQuorum;\n  }\n\n  /**\n    Set the proposal threshold for a gov proposal.\n    @param _proposalThreshold the proposal threshold for a gov proposal\n  */\n  function setProposalThreshold(uint256 _proposalThreshold) public override onlyManager {\n    require(_proposalThreshold < 1e18);\n    proposalThreshold = _proposalThreshold;\n  }\n\n  /**\n    Get the debt limit for a collateral type\n    @dev this is a platform wide limit for new debt issuance against a specific collateral type\n    @param _collateralType address of the collateral type\n  */\n  function collateralDebtLimit(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;\n  }\n\n  /**\n    Get the liquidation ratio that needs to be maintained for a collateral type to avoid liquidation.\n    @param _collateralType address of the collateral type\n  */\n  function collateralLiquidationRatio(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].liquidationRatio;\n  }\n\n  /**\n    Get the minimum collateralization ratio for a collateral type for new borrowing or collateral withdrawal.\n    @param _collateralType address of the collateral type\n  */\n  function collateralMinCollateralRatio(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;\n  }\n\n  /**\n    Get the borrowing rate for a collateral type\n    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.\n    @param _collateralType address of the collateral type\n  */\n  function collateralBorrowRate(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;\n  }\n\n  /**\n    Get the origiation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n  */\n  function collateralOriginationFee(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].originationFee;\n  }\n\n  /**\n    Get the liquidation bonus for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n  */\n  function collateralLiquidationBonus(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].liquidationBonus;\n  }\n\n  /**\n    Get the liquidation fee for a collateral type\n    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD\n    @param _collateralType address of the collateral type\n  */\n  function collateralLiquidationFee(address _collateralType) public view override returns (uint256) {\n    return _collateralConfigs[collateralIds[_collateralType]].liquidationFee;\n  }\n\n  /**\n    Retreives the entire config for a specific config id.\n    @param _id the ID of the conifg to be returned\n  */\n  function collateralConfigs(uint256 _id) public view override returns (CollateralConfig memory) {\n    require(_id <= numCollateralConfigs, \"Invalid config id\");\n    return _collateralConfigs[_id];\n  }\n}\n"
    },
    "contracts/governance/Timelock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ITimelock.sol\";\n\ncontract Timelock is ITimelock {\n  using SafeMath for uint256;\n\n  uint256 public constant MINIMUM_DELAY = 2 days;\n  uint256 public constant MAXIMUM_DELAY = 30 days;\n  uint256 public constant override GRACE_PERIOD = 14 days;\n\n  address public admin;\n  address public pendingAdmin;\n  uint256 public override delay;\n\n  mapping(bytes32 => bool) public override queuedTransactions;\n\n  constructor(address _admin, uint256 _delay) public {\n    require(address(_admin) != address(0));\n    require(_delay >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n    require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n    admin = _admin;\n    delay = _delay;\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {}\n\n  function setDelay(uint256 _delay) public {\n    require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n    require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n    require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n    delay = _delay;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public override {\n    require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address _pendingAdmin) public {\n    require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n    pendingAdmin = _pendingAdmin;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override returns (bytes32) {\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(\n      eta >= block.timestamp.add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override {\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable override returns (bytes memory) {\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(block.timestamp >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(block.timestamp <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n}\n"
    },
    "contracts/governance/test/TestTimelock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\nimport '../Timelock.sol';\n\n// Test timelock contract with admin helpers\ncontract TestTimelock is Timelock {\n  constructor(address admin_, uint256 delay_) public Timelock(admin_, 2 days) {\n    delay = delay_;\n  }\n\n  function harnessSetPendingAdmin(address pendingAdmin_) public {\n    pendingAdmin = pendingAdmin_;\n  }\n\n  function harnessSetAdmin(address admin_) public {\n    admin = admin_;\n  }\n}\n"
    },
    "contracts/governance/GovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IGovernorAlpha.sol\";\nimport \"./interfaces/IGovernanceAddressProvider.sol\";\nimport \"../libraries/WadRayMath.sol\";\n\ncontract GovernorAlpha is IGovernorAlpha {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  function proposalMaxOperations() public pure returns (uint256) {\n    return 10;\n  } // 10 actions\n\n  IGovernanceAddressProvider public a;\n\n  /// @notice The address of the Governor Guardian\n  address public guardian;\n\n  /// @notice The total number of proposals\n  uint256 public proposalCount;\n\n  /// @notice The official record of all proposals ever proposed\n  mapping(uint256 => Proposal) public proposals;\n\n  /// @notice The latest proposal for each proposer\n  mapping(address => uint256) public latestProposalIds;\n\n  constructor(IGovernanceAddressProvider _addresses, address _guardian) public {\n    require(address(_addresses) != address(0));\n    require(address(_guardian) != address(0));\n\n    a = _addresses;\n    guardian = _guardian;\n  }\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description,\n    uint256 endTime\n  ) public override returns (uint256) {\n    uint256 votingDuration = endTime.sub(block.timestamp);\n    require(votingDuration >= a.parallel().config().minVotingPeriod(), \"Proposal end-time too early\");\n    require(votingDuration <= a.parallel().config().maxVotingPeriod(), \"Proposal end-time too late\");\n\n    require(\n      a.votingEscrow().balanceOfAt(msg.sender, endTime) > proposalThreshold(),\n      \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n    );\n    require(\n      targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n      \"GovernorAlpha::propose: proposal function information arity mismatch\"\n    );\n    require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n    require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n    uint256 latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(\n        proposersLatestProposalState != ProposalState.Active,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n      );\n    }\n\n    proposalCount++;\n    Proposal memory newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: targets,\n      values: values,\n      signatures: signatures,\n      calldatas: calldatas,\n      startTime: block.timestamp,\n      endTime: endTime,\n      forVotes: 0,\n      againstVotes: 0,\n      canceled: false,\n      executed: false\n    });\n\n    proposals[newProposal.id] = newProposal;\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(\n      newProposal.id,\n      msg.sender,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      block.timestamp,\n      endTime,\n      description\n    );\n    return newProposal.id;\n  }\n\n  function queue(uint256 proposalId) public override {\n    require(\n      state(proposalId) == ProposalState.Succeeded,\n      \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    uint256 eta = block.timestamp.add(a.timelock().delay());\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n    }\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n  }\n\n  function execute(uint256 proposalId) public payable override {\n    require(\n      state(proposalId) == ProposalState.Queued,\n      \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      a.timelock().executeTransaction{ value: proposal.values[i] }(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n    emit ProposalExecuted(proposalId);\n  }\n\n  function cancel(uint256 proposalId) public override {\n    ProposalState state = state(proposalId);\n    require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n    Proposal storage proposal = proposals[proposalId];\n    require(msg.sender == guardian, \"Only Guardian can cancel\");\n\n    proposal.canceled = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      a.timelock().cancelTransaction(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  function castVote(uint256 proposalId, bool support) public override {\n    require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[msg.sender];\n    require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n    uint256 votes = a.votingEscrow().balanceOfAt(msg.sender, proposal.endTime);\n\n    if (support) {\n      proposal.forVotes = proposal.forVotes.add(votes);\n    } else {\n      proposal.againstVotes = proposal.againstVotes.add(votes);\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(msg.sender, proposalId, support, votes);\n  }\n\n  // solhint-disable-next-line private-vars-leading-underscore\n  function __acceptAdmin() public {\n    require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n    a.timelock().acceptAdmin();\n  }\n\n  // solhint-disable-next-line private-vars-leading-underscore\n  function __abdicate() public {\n    require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n    guardian = address(0);\n  }\n\n  // solhint-disable-next-line private-vars-leading-underscore\n  function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n    require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n    a.timelock().queueTransaction(\n      address(a.timelock()),\n      0,\n      \"setPendingAdmin(address)\",\n      abi.encode(newPendingAdmin),\n      eta\n    );\n  }\n\n  // solhint-disable-next-line private-vars-leading-underscore\n  function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n    require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n    a.timelock().executeTransaction(\n      address(a.timelock()),\n      0,\n      \"setPendingAdmin(address)\",\n      abi.encode(newPendingAdmin),\n      eta\n    );\n  }\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  function quorumVotes() public view override returns (uint256) {\n    return a.votingEscrow().stakingToken().totalSupply().wadMul(a.parallel().config().votingQuorum());\n  }\n\n  /// @notice The number of votes required in order for a voter to become a proposer\n  function proposalThreshold() public view override returns (uint256) {\n    return a.votingEscrow().stakingToken().totalSupply().wadMul(a.parallel().config().proposalThreshold());\n  }\n\n  function getActions(uint256 proposalId)\n    public\n    view\n    override\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    )\n  {\n    Proposal storage p = proposals[proposalId];\n    return (p.targets, p.values, p.signatures, p.calldatas);\n  }\n\n  function getReceipt(uint256 proposalId, address voter) public view override returns (Receipt memory) {\n    return proposals[proposalId].receipts[voter];\n  }\n\n  function state(uint256 proposalId) public view override returns (ProposalState) {\n    require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n    Proposal storage proposal = proposals[proposalId];\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.timestamp <= proposal.endTime) {\n      return ProposalState.Active;\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n      return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (block.timestamp >= a.timelock().GRACE_PERIOD().add(proposal.endTime)) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function _queueOrRevert(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) internal {\n    require(\n      !a.timelock().queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n      \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n    );\n    a.timelock().queueTransaction(target, value, signature, data, eta);\n  }\n}\n"
    },
    "contracts/liquidityMining/MIMODistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/IMIMODistributor.sol\";\nimport \"./BaseDistributor.sol\";\n\n/*\n  \tDistribution Formula:\n  \t55.5m MIMO in first week\n  \t-5.55% redution per week\n\n  \ttotal(timestamp) = _SECONDS_PER_WEEK * ( (1-_WEEKLY_R^(timestamp/_SECONDS_PER_WEEK)) / (1-_WEEKLY_R) )\n  \t\t+ timestamp % _SECONDS_PER_WEEK * (1-_WEEKLY_R^(timestamp/_SECONDS_PER_WEEK)\n  */\n\ncontract MIMODistributor is BaseDistributor, IMIMODistributorExtension {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  uint256 private constant _SECONDS_PER_YEAR = 365 days;\n  uint256 private constant _SECONDS_PER_WEEK = 7 days;\n  uint256 private constant _WEEKLY_R = 9445e23; //-5.55%\n  uint256 private constant _FIRST_WEEK_TOKENS = 55500000 ether; //55.5m\n\n  uint256 public override startTime;\n\n  constructor(IGovernanceAddressProvider _a, uint256 _startTime) public {\n    require(address(_a) != address(0));\n\n    a = _a;\n    startTime = _startTime;\n  }\n\n  /**\n    Get current monthly issuance of new MIMO tokens.\n    @return number of monthly issued tokens currently`.\n  */\n  function currentIssuance() public view override returns (uint256) {\n    return weeklyIssuanceAt(now);\n  }\n\n  /**\n    Get monthly issuance of new MIMO tokens at `timestamp`.\n    @dev invalid for timestamps before deployment\n    @param timestamp for which to calculate the monthly issuance\n    @return number of monthly issued tokens at `timestamp`.\n  */\n  function weeklyIssuanceAt(uint256 timestamp) public view override returns (uint256) {\n    uint256 elapsedSeconds = timestamp.sub(startTime);\n    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);\n    return _WEEKLY_R.rayPow(elapsedWeeks).rayMul(_FIRST_WEEK_TOKENS);\n  }\n\n  /**\n    Calculates how many MIMO tokens can be minted since the last time tokens were minted\n    @return number of mintable tokens available right now.\n  */\n  function mintableTokens() public view override returns (uint256) {\n    return totalSupplyAt(now).sub(a.mimo().totalSupply());\n  }\n\n  /**\n    Calculates the totalSupply for any point after `startTime`\n    @param timestamp for which to calculate the totalSupply\n    @return totalSupply at timestamp.\n  */\n  function totalSupplyAt(uint256 timestamp) public view override returns (uint256) {\n    uint256 elapsedSeconds = timestamp.sub(startTime);\n    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);\n    uint256 lastWeekSeconds = elapsedSeconds % _SECONDS_PER_WEEK;\n    uint256 one = WadRayMath.ray();\n    uint256 fullWeeks = one.sub(_WEEKLY_R.rayPow(elapsedWeeks)).rayMul(_FIRST_WEEK_TOKENS).rayDiv(one.sub(_WEEKLY_R));\n    uint256 currentWeekIssuance = weeklyIssuanceAt(timestamp);\n    uint256 partialWeek = currentWeekIssuance.mul(lastWeekSeconds).div(_SECONDS_PER_WEEK);\n    return fullWeeks.add(partialWeek);\n  }\n\n  /**\n    Internal function to release a percentage of newTokens to a specific payee\n    @dev uses totalShares to calculate correct share\n    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares\n    @param _payee The address of the payee to whom to distribute the fees.\n  */\n  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {\n    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);\n    a.mimo().mint(_payee, payment);\n  }\n}\n"
    },
    "contracts/liquidityMining/DistributorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/IBaseDistributor.sol\";\n\ncontract DistributorManager {\n  using SafeMath for uint256;\n\n  IGovernanceAddressProvider public a;\n  IBaseDistributor public mimmoDistributor;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not Manager\");\n    _;\n  }\n\n  constructor(IGovernanceAddressProvider _a, IBaseDistributor _mimmoDistributor) public {\n    require(address(_a) != address(0));\n    require(address(_mimmoDistributor) != address(0));\n\n    a = _a;\n    mimmoDistributor = _mimmoDistributor;\n  }\n\n  /**\n    Public function to release the accumulated new MIMO tokens to the payees.\n    @dev anyone can call this.\n  */\n  function releaseAll() public {\n    mimmoDistributor.release();\n    address[] memory distributors = mimmoDistributor.getPayees();\n    for (uint256 i = 0; i < distributors.length; i++) {\n      IBaseDistributor(distributors[i]).release();\n    }\n  }\n}\n"
    },
    "contracts/mocks/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockWETH is ERC20(\"Wrapped Ether\", \"WETH\") {\n  function mint(address account, uint256 amount) public {\n    _mint(account, amount);\n  }\n\n  function deposit() public payable {\n    _mint(msg.sender, msg.value);\n  }\n\n  function withdraw(uint256 wad) public {\n    _burn(msg.sender, wad);\n    msg.sender.transfer(wad);\n  }\n}\n"
    },
    "contracts/mocks/MockWBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockWBTC is ERC20(\"Wrapped Bitcoin\", \"WBTC\") {\n  function mint(address account, uint256 amount) public {\n    _mint(account, amount);\n  }\n}\n"
    },
    "contracts/mocks/MockMIMO.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockMIMO is ERC20(\"MIMO Token\", \"MIMO\") {\n  function mint(address account, uint256 amount) public {\n    _mint(account, amount);\n  }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n  ) public ERC20(_name, _symbol) {\n    super._setupDecimals(_decimals);\n  }\n\n  function mint(address account, uint256 amount) public {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) public {\n    _burn(account, amount);\n  }\n}\n"
    },
    "contracts/mocks/MockBPT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockBPT is ERC20(\"Balancer Pool Token\", \"BPT\") {\n  function mint(address account, uint256 amount) public {\n    _mint(account, amount);\n  }\n}\n"
    },
    "contracts/liquidityMining/MIMOBuyBack.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../libraries/interfaces/IVault.sol\";\n\ncontract MIMOBuyback {\n  bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n  IAddressProvider public a;\n  IERC20 public PAR;\n  IERC20 public MIMO;\n  uint256 public lockExpiry;\n  bytes32 public poolID;\n  IVault public balancer = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n  bool public whitelistEnabled = false;\n\n  constructor(\n    uint256 _lockExpiry,\n    bytes32 _poolID,\n    address _a,\n    address _mimo\n  ) public {\n    lockExpiry = _lockExpiry;\n    poolID = _poolID;\n    a = IAddressProvider(_a);\n    MIMO = IERC20(_mimo);\n    PAR = a.stablex();\n\n    PAR.approve(address(balancer), 2**256 - 1);\n  }\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  modifier onlyKeeper() {\n    require(\n      !whitelistEnabled || (whitelistEnabled && a.controller().hasRole(KEEPER_ROLE, msg.sender)),\n      \"Caller is not a Keeper\"\n    );\n    _;\n  }\n\n  function withdrawMIMO(address destination) public onlyManager {\n    require(block.timestamp > lockExpiry, \"lock not expired yet\");\n    require(MIMO.transfer(destination, MIMO.balanceOf(address(this))));\n  }\n\n  function buyMIMO() public onlyKeeper {\n    a.core().state().refresh();\n    a.feeDistributor().release();\n\n    bytes memory userData = abi.encode();\n    IVault.SingleSwap memory singleSwap = IVault.SingleSwap(\n      poolID,\n      IVault.SwapKind.GIVEN_IN,\n      IAsset(address(PAR)), // swap in\n      IAsset(address(MIMO)), // swap out\n      PAR.balanceOf(address(this)), // all PAR of this contract\n      userData\n    );\n\n    IVault.FundManagement memory fundManagement = IVault.FundManagement(\n      address(this), // sender\n      false, // useInternalBalance\n      payable(address(this)), // recipient\n      false // // useInternalBalance\n    );\n\n    balancer.swap(\n      singleSwap,\n      fundManagement,\n      0, // limit, could be frontrun?\n      2**256 - 1 // deadline\n    );\n  }\n\n  function setWhitelistEnabled(bool _status) public onlyManager {\n    whitelistEnabled = _status;\n  }\n}\n"
    },
    "contracts/libraries/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IAsset {\n  // solhint-disable-previous-line no-empty-blocks\n}\n\ninterface IVault {\n  enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n  /**\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n   * the `kind` value.\n   *\n   * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n   * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n   *\n   * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n   * used to extend swap behavior.\n   */\n  struct SingleSwap {\n    bytes32 poolId;\n    SwapKind kind;\n    IAsset assetIn;\n    IAsset assetOut;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n   * `recipient` account.\n   *\n   * If the caller is not `sender`, it must be an authorized relayer for them.\n   *\n   * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n   * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n   * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n   * `joinPool`.\n   *\n   * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n   * transferred. This matches the behavior of `exitPool`.\n   *\n   * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n   * revert.\n   */\n  struct FundManagement {\n    address sender;\n    bool fromInternalBalance;\n    address payable recipient;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Performs a swap with a single Pool.\n   *\n   * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n   * taken from the Pool, which must be greater than or equal to `limit`.\n   *\n   * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n   * sent to the Pool, which must be less than or equal to `limit`.\n   *\n   * Internal Balance usage and the recipient are determined by the `funds` struct.\n   *\n   * Emits a `Swap` event.\n   */\n  function swap(\n    SingleSwap memory singleSwap,\n    FundManagement memory funds,\n    uint256 limit,\n    uint256 deadline\n  ) external payable returns (uint256);\n}\n"
    },
    "contracts/mocks/MockBuggyERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\n/**\n    Buggy ERC20 implementation without the return bool on `transfer`, `transferFrom` and `approve` for testing purposes\n*/\n\ncontract MockBuggyERC20 is Context {\n  using SafeMath for uint256;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  constructor(string memory name_, string memory symbol_) public {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = 18;\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount) public virtual {\n    _transfer(_msgSender(), recipient, amount);\n  }\n\n  function allowance(address owner, address spender) public view virtual returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount) public virtual {\n    _approve(_msgSender(), spender, amount);\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n    );\n  }\n\n  function mint(address account, uint256 amount) public {\n    _mint(account, amount);\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n"
    },
    "contracts/libraries/interfaces/BPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface BPool is IERC20 {\n  function gulp(address token) external;\n\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    uint256 minPoolAmountOut\n  ) external returns (uint256 poolAmountOut);\n\n  function joinswapPoolAmountOut(\n    address tokenIn,\n    uint256 poolAmountOut,\n    uint256 maxAmountIn\n  ) external returns (uint256 tokenAmountIn);\n\n  function exitswapPoolAmountIn(\n    address tokenOut,\n    uint256 poolAmountIn,\n    uint256 minAmountOut\n  ) external returns (uint256 tokenAmountOut);\n\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPoolAmountIn\n  ) external returns (uint256 poolAmountIn);\n\n  function calcPoolOutGivenSingleIn(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 poolSupply,\n    uint256 totalWeight,\n    uint256 tokenAmountIn,\n    uint256 swapFee\n  ) external pure returns (uint256 poolAmountOut);\n\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n  function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n  function getSwapFee() external view returns (uint256);\n\n  function getBalance(address token) external view returns (uint256);\n\n  function getDenormalizedWeight(address token) external view returns (uint256);\n\n  function getTotalDenormalizedWeight() external view returns (uint256);\n\n  function getNormalizedWeight(address token) external view returns (uint256);\n\n  function isPublicSwap() external view returns (bool);\n\n  function isFinalized() external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}