{{
  "language": "Solidity",
  "sources": {
    "/contracts/TinyDaemons.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: TinyDaemons.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: TinyDaemons an LZ ERC 721\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"./access/MaxAccess.sol\";\nimport \"./modules/TimeCop.sol\";\nimport \"./modules/NonblockingReceiver.sol\";\nimport \"./modules/ContractURI.sol\";\nimport \"./modules/PaymentSplitterV2.sol\";\nimport \"./modules/lzLlamas.sol\";\nimport \"./eip/2981/ERC2981Collection.sol\";\n\ncontract TinyDaemons is MaxAccess\n                      , TimeCop\n                      , ContractURI\n                      , PaymentSplitterV2\n                      , ERC2981Collection\n                      , lzLlamas\n                      , ERC721\n                      , ERC721Burnable\n                      , NonblockingReceiver {\n\n  using Strings for uint256;\n\n  uint private gasForDestinationLzReceive = 350000;\n  string base;\n\n  event UpdatedBaseURI(string _old, string _new);\n  event ThankYou(address user, uint amount);\n\n  constructor() ERC721(\"TinyDaemons\", \"TINYDMN\") {}\n\n  modifier presaleChecks() {\n    if (balanceOf(msg.sender) >= 4) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"Token: Ok \",\n                    Strings.toHexString(uint160(msg.sender), 20),\n                    \" you have \",\n                    Strings.toString(balanceOf(msg.sender)),\n                    \" maximum at this time is 4.\"\n                  )\n                )\n      });\n    }\n    _;\n  }\n\n  modifier saleChecks() {\n    if (balanceOf(msg.sender) >= 10) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"Token: Ok \",\n                    Strings.toHexString(uint160(msg.sender), 20),\n                    \" you have \",\n                    Strings.toString(balanceOf(msg.sender)),\n                    \" maximum at this time is 10.\"\n                  )\n                )\n      });\n    }\n    _;\n  }\n\n  function presaleMint(\n    uint quant\n  ) external\n    onlyPresale()\n    presaleChecks() {\n    if (quant > 2) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"Token: Ok \",\n                    Strings.toHexString(uint160(msg.sender), 20),\n                    \" you wanted to mint \",\n                    Strings.toString(quant),\n                    \" 2 or less please.\"\n                  )\n                )\n      });\n    }\n    for (uint x = 0; x < quant;) {\n      // this is a little sneaky to ensure you can't mint 1-2-2\n      if (balanceOf(msg.sender) >= 4) {\n        revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"Token: Ok \",\n                    Strings.toHexString(uint160(msg.sender), 20),\n                    \" you wanted to mint \",\n                    Strings.toString(quant),\n                    \" that puts you at \",\n                    Strings.toString(quant + balanceOf(msg.sender)),\n                    \" maximum at this time is 4.\"\n                  )\n                )\n        });\n      }\n      // mint it\n      _safeMint(msg.sender, _nextUp());\n      _oneRegularMint();\n      unchecked { ++x; }\n    }\n  }\n\n  function publicMint()\n    external \n    onlySale()\n    saleChecks() {\n    _safeMint(msg.sender, _nextUp());\n    _oneRegularMint();\n  }\n\n  function teamMint()\n    external\n    onlyDev() {\n    uint quant = this.minterTeamMintsRemaining();\n    for (uint x = 0; x < quant;) {\n      // mint it\n      _safeMint(this.owner(), _nextUp());\n      _oneTeamMint();\n      unchecked { ++x; }\n    }\n  }\n    \n  function donate()\n    external\n    payable {\n    // thank you\n    emit ThankYou(msg.sender, msg.value);\n  }\n\n  // @notice: Function to receive ether, msg.data must be empty\n  receive() \n    external\n    payable {\n    // From PaymentSplitter.sol\n    emit PaymentReceived(msg.sender, msg.value);\n  }\n\n  // @notice: Function to receive ether, msg.data is not empty\n  fallback()\n    external\n    payable {\n    // From PaymentSplitter.sol\n    emit PaymentReceived(msg.sender, msg.value);\n  }\n\n  // @notice this is a public getter for ETH blance on contract\n  function getBalance()\n    external\n    view\n    returns (uint) {\n    return address(this).balance;\n  }\n\n  // @notice: This sets the data for LZ minting\n  // @param startNumber: What tokenID number to start with\n  // @param authMint: How many to mint on this chain\n  // @param teamMints: How many for team mint on this chain\n  // @param string memory img: Provenance Hash of images in sequence\n  // @param string memory json: Provenance Hash of metadata in sequence\n  // @param newAddress: The address for the LZ Endpoint (see LZ docs)\n  function setMinter (\n    uint startNumber\n  , uint authMint\n  , uint teamMints\n  , string memory img\n  , string memory json\n  , address newAddress\n  ) external\n    onlyDev {\n    _setLZLlamasEngine( startNumber\n                      , authMint\n                      , teamMints);\n    _setProvenance( img\n                  , json);\n    endpoint = ILayerZeroEndpoint(newAddress);\n  }\n\n  /*\n   *     #@+                                             .                                     \n   *    -@@#                                             =#*+=---+**-                          \n   *    %@@.                                               .==*@@@@+-                          \n   *   =@@*                                                  -@@@*                             \n   *  .@@@                                                 .#@@#:                              \n   *  *@@+        :                          ::   -:    +**@%@*=*-            .:   --    .:    \n   *  @@%      =%@@@#@@. -@@*   +*:  .*##+.  @@- *@@=   =%@@**++*+    .+##*.  @@= *@@= .%@@%   \n   * +@@=     #@@#--@@@. #@@*  =@@+ =@@@%@+ +@@:#--*#- -#%%.         -@@@#@* =@@:#-:*%*%@#-%= .\n   * @@@    :#@@+.=@@@: .@@@ :*@@% =@@@%%= .@@#@-     .#@*          :@@@#%+ .%@#%=    %@##*@#*@\n   * @@#  .*@@@%#%-@@* +@@@#*@#@@#%@@+: .-#*@@@*      *%%     ....  +@*: .-#*@@@*    =@% :%%-: \n   * =@@.=@@=-%#-  +@%@#:-*#+.@@@*:.%++%%=.%@@+       @@%#%**#@%@@@@*@*+%%+.%@@*     .%##@#    \n   *   -==:         .-:     =%@@.    ::.   =%:        =%##+-.      .::::.   -#-        :-.     \n   *                      +@@@@=                                                               \n   *                    .%@-*@#                                                                \n   *                    %@.=@@.                                                                \n   *                    =@%@%:                                                                 \n   *\n   * @dev: This is the LayerZero functions for NonblockingReceiver.sol and more\n   */\n\n  // @notice: This function transfers the nft from your address on the \n  //          source chain to the same address on the destination chain\n  // @param _chainId: the uint16 of desination chain (see LZ docs)\n  // @param tokenId: tokenID to be sent\n  function traverseChains(\n    uint16 _chainId\n  , uint tokenId\n  ) public\n    payable {\n    if (msg.sender != ownerOf(tokenId)) {\n      revert Unauthorized();\n    }\n    if (trustedRemoteLookup[_chainId].length == 0) {\n      revert MaxSplaining({\n        reason: \"Token: Ok the Dev didn't set this paramater, contact MaxFlowO2.eth.\"\n      });\n    }\n\n    // burn NFT, eliminating it from circulation on src chain\n    _burn(tokenId);\n    // fixes totalSupply()\n    _subOne();\n\n    // abi.encode() the payload with the values to send\n    bytes memory payload = abi.encode(\n                             msg.sender\n                           , tokenId);\n\n    // encode adapterParams to specify more gas for the destination\n    uint16 version = 1;\n    bytes memory adapterParams = abi.encodePacked(\n                                   version\n                                 , gasForDestinationLzReceive);\n\n    // get the fees we need to pay to LayerZero + Relayer to cover message delivery\n    // you will be refunded for extra gas paid\n    (uint messageFee, ) = endpoint.estimateFees(\n                            _chainId\n                          , address(this)\n                          , payload\n                          , false\n                          , adapterParams);\n\n    // revert this transaction if the fees are not met\n    if (messageFee > msg.value) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"Token: \",\n                    Strings.toHexString(uint160(msg.sender), 20),\n                    \" sent \",\n                    Strings.toString(msg.value),\n                    \" instead of \",\n                    Strings.toString(messageFee)\n                  )\n                )\n      });\n    }\n\n    // send the transaction to the endpoint\n    endpoint.send{value: msg.value}(\n      _chainId,                           // destination chainId\n      trustedRemoteLookup[_chainId],      // destination address of nft contract\n      payload,                            // abi.encoded()'ed bytes\n      payable(msg.sender),                // refund address\n      address(0x0),                       // 'zroPaymentAddress' unused for this\n      adapterParams                       // txParameters \n    );\n  }\n\n  // @notice: just in case this fixed variable limits us from future integrations\n  // @param newVal: new value for gas amount\n  function setGasForDestinationLzReceive(\n    uint newVal\n  ) external onlyOwner {\n    gasForDestinationLzReceive = newVal;\n  }\n\n  // @notice internal function to mint NFT from migration\n  // @param _srcChainId - the source endpoint identifier\n  // @param _srcAddress - the source sending contract address from the source chain\n  // @param _nonce - the ordered message nonce\n  // @param _payload - the signed payload is the UA bytes has encoded to be sent\n  function _LzReceive(\n    uint16 _srcChainId\n  , bytes memory _srcAddress\n  , uint64 _nonce\n  , bytes memory _payload\n  ) override\n    internal {\n    // decode\n    (address toAddr, uint tokenId) = abi.decode(_payload, (address, uint));\n\n    // mint the tokens back into existence on destination chain\n    _safeMint(toAddr, tokenId);\n    // fixes totalSupply()\n    _addOne();\n  }\n\n  // @notice: will return gas value for LZ\n  // @return: uint for gas value\n  function currentLZGas()\n    external\n    view\n    returns (uint256) {\n    return gasForDestinationLzReceive;\n  }  \n\n  /*\n   *       .=*#%@@@@%+                                     .:.                                 \n   * .-+*%@@@@@@@-:::-*+                         =-=+**#%%@@@@%:     -*%@@@@%*-            #@@%\n   * :*@%*=:-@@@*                                +%@@%##*+@@@@#    =@@@@#=.   =@:        +@@@@@\n   *       .@@@#                                        =@@@%-   -#@@@#:       @@:     +@@@@@@=\n   *      .@@@#                                        *@@@*   .#@@@%:        =@@-   =@@@@@@@% \n   *     :@@@*                                   -*##%@@@@@#:  :*##+         :@@#      --@%@@= \n   *    .@@@@===-     .    ..                     *@@@@@+++.                -@@%        #%%@#  \n   * -#%@@@@@%##*=   @@@  =@@@   -+*+-             =@@@-                   =@@*.       :@#@@.  \n   *  +%@@@:        =@@# #++@@:-*@@@@@=           -@@@:                  .=%*          =#@@#   \n   *   %@@=      =+ #@@:#=: .++*@@*.%@: .:       :@@%.                  -*#-           %#@@-   \n   *  .@@@     -#%=.@@%%#.    :@@*    :---       @@@.                  :#+            .%@@@    \n   *  =@@+  .+%@%- *@@%%-     *@@   =%%++       :@@*                .-*+....:-*.      -#@@#:   \n   *   #@*.+@@@=  :@@@@-      +@%=#@@%-         .%@-               #%@@@@@@@@@@*.   .++@@@@@*  \n   *    -*#*+:    -@@+.        =###*:             =-               -**++++=-::::    :+**+=-.   \n   *\n   * @dev: These are the ERC721 functions/overrides plus ERC165 at the end\n   */\n\n  // @notice will update _baseURI() by onlyDeveloper() role\n  // @param _base: Base for NFT's\n  function setBaseURI(\n    string memory _base\n    )\n    public\n    onlyDev() {\n    string memory old = base;\n    base = _base;\n    emit UpdatedBaseURI(old, base);\n  }\n\n  // @notice: This override sets _base as the string for tokenURI(tokenId)\n  function _baseURI()\n    internal\n    view\n    override\n    returns (string memory) {\n    return base;\n  }\n\n  // @notice: This override is for making string/number now string/number.json\n  // @param tokenId: tokenId to pull URI for\n  function tokenURI(\n    uint256 tokenId\n  ) public\n    view\n    virtual\n    override (ERC721)\n    returns (string memory) {\n    if (!_exists(tokenId)) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"ERC721Metadata: URI query for \",\n                    Strings.toString(tokenId),\n                    \" returns nonexistent token\"\n                  )\n                )\n      });\n    }\n    string memory baseURI = _baseURI();\n    string memory json = \".json\";\n    return bytes(baseURI).length > 0 ? string(\n                                         abi.encodePacked(\n                                           baseURI\n                                         , tokenId.toString()\n                                         , json)\n                                       ) : \"\";\n  }\n\n  // @notice: This override is to correct totalSupply()\n  // @param tokenId: tokenId to burn\n  function burn(\n    uint256 tokenId\n  ) public\n    virtual\n    override(ERC721Burnable) {\n    //solhint-disable-next-line max-line-length\n    if (!_isApprovedOrOwner(_msgSender(), tokenId)) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"ERC721Burnable: \",\n                    Strings.toHexString(uint160(msg.sender), 20),\n                    \" is not owner nor approved\"\n                  )\n                )\n      });\n    }\n    _burn(tokenId);\n    // fixes totalSupply()\n    _subOne();\n  }\n\n  // @notice: Standard override for ERC165\n  // @param interfaceId: interfaceId to check for compliance\n  // @return: bool if interfaceId is supported\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public\n    view\n    virtual\n    override (\n      ERC721\n    , IERC165\n    ) returns (bool) {\n    return (\n      interfaceId == type(IRole).interfaceId  ||\n      interfaceId == type(IDeveloper).interfaceId  ||\n      interfaceId == type(IDeveloperV2).interfaceId  ||\n      interfaceId == type(IOwner).interfaceId  ||\n      interfaceId == type(IOwnerV2).interfaceId  ||\n      interfaceId == type(IERC2981).interfaceId  ||\n      interfaceId == type(IMAX2981).interfaceId  ||\n      interfaceId == type(IMAXPaymentSplitter).interfaceId  ||\n      interfaceId == type(IPaymentSplitter).interfaceId  ||\n      interfaceId == type(IMAX721).interfaceId  ||\n      interfaceId == type(ILlamas).interfaceId  ||\n      interfaceId == type(lzILlamas).interfaceId  ||\n      interfaceId == type(ITimeCop).interfaceId  ||\n      interfaceId == type(IContractURI).interfaceId  ||\n      interfaceId == type(IMAXContractURI).interfaceId  ||\n      interfaceId == type(ILayerZeroReceiver).interfaceId  ||\n      super.supportsInterface(interfaceId)\n    );\n  }\n}\n"
    },
    "/contracts/modules/lzLlamas.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: lzLlamas.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Solidity for Llama/BAYC Mint engine, does Provenance for Metadata/Images, for lzModules\n * Source: https://etherscan.io/address/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./lzILlamas.sol\";\nimport \"../lib/PsuedoRand.sol\";\nimport \"../lib/CountersV2.sol\";\n\nabstract contract lzLlamas is lzILlamas {\n\n  using PsuedoRand for PsuedoRand.Engine;\n  using CountersV2 for CountersV2.Counter;\n\n  PsuedoRand.Engine private llamas;\n  CountersV2.Counter private tokensOnChain;\n  uint private tokenStartNumber;\n\n  event SetStartNumbers(uint numberToMint, uint startingID, uint endingID);\n\n  // @dev this is for any team mint that happens, must be included in mint...\n  function _oneTeamMint()\n    internal {\n    llamas.battersUp();\n    llamas.battersUpTeam();\n    tokensOnChain.increment();\n  }\n\n  // @dev this is for any mint outside of a team mint, must be included in mint...\n  function _oneRegularMint()\n    internal {\n    llamas.battersUp();\n    tokensOnChain.increment();\n  }\n\n  // @dev this is to add one to on chain minted\n  function _addOne()\n    internal {\n    tokensOnChain.increment();\n  }\n\n  // @dev this is to substract one to on chain minted\n  function _subOne()\n    internal {\n    tokensOnChain.decrement();\n  }\n\n  // @dev this will set the boolean for minter status\n  // @param toggle: bool for enabled or not\n  function _setStatus(\n    bool toggle\n  ) internal {\n    llamas.setStatus(toggle);\n  }\n\n  // @dev this will set the minter fees\n  // @param number: uint for fees in wei.\n  function _setMintFees(\n    uint number\n  ) internal {\n    llamas.setFees(number);\n  }\n\n  // @dev this will set the mint engine\n  // @param _startID: uint for startingID number (say 2000)\n  // @param _mintingCap: uint for publicMint() capacity of this chain\n  // @param _teamMints: uint for maximum teamMints() capacity on this chain\n  function _setLZLlamasEngine(\n    uint _startID\n  , uint _mintingCap\n  , uint _teamMints\n  ) internal {\n    tokenStartNumber = _startID;\n    llamas.setMaxCap(_mintingCap);\n    llamas.setMaxTeam(_teamMints);\n\n    emit SetStartNumbers( _mintingCap\n                        , _startID\n                        , _mintingCap + _startID);\n  }\n\n  // @dev this will set the Provenance Hashes\n  // @param string memory img - Provenance Hash of images in sequence\n  // @param string memory json - Provenance Hash of metadata in sequence\n  // @notice: This will set the start number as well, make sure to set MaxCap\n  //  also can be a hyperlink... sha3... ipfs.. whatever.\n  function _setProvenance(\n    string memory img\n  , string memory json\n  ) internal {\n    llamas.setProvJSON(json);\n    llamas.setProvIMG(img);\n    llamas.setStartNumber();\n  }\n\n  function _nextUp()\n    internal\n    view\n    returns (uint) {\n    return tokenStartNumber + llamas.mintID();\n  }\n\n  // @dev will return status of Minter\n  // @return - bool of active or not\n  function minterStatus()\n    external\n    view\n    virtual\n    override\n    returns (bool) {\n    return llamas.status;\n  }\n\n  // @dev will return minting fees\n  // @return - uint of mint costs in wei\n  function minterFees()\n    external\n    view\n    virtual\n    override\n    returns (uint) {\n    return llamas.mintFee;\n  }\n\n  // @dev will return maximum mint capacity\n  // @return - uint of maximum mints allowed\n  function minterMaximumCapacity()\n    external\n    view\n    virtual\n    override\n    returns (uint) {\n    return llamas.maxCapacity;\n  }\n\n  // @dev will return maximum mint capacity\n  // @return - uint of maximum mints allowed\n  function minterMintsRemaining()\n    external\n    view\n    virtual\n    returns (uint) {\n    return llamas.maxCapacity - llamas.showMinted();\n  }\n\n  // @dev will return maximum mint capacity\n  // @return - uint of maximum mints allowed\n  function minterCurrentMints()\n    external\n    view\n    virtual\n    returns (uint) {\n    return llamas.showMinted();\n  }\n\n  // @dev will return maximum \"team minting\" capacity\n  // @return - uint of maximum airdrops or team mints allowed\n  function minterMaximumTeamMints()\n    external\n    view\n    virtual\n    override\n    returns (uint) {\n    return llamas.maxTeamMints;\n  }\n\n  // @dev will return \"team mints\" left\n  // @return - uint of remaing airdrops or team mints\n  function minterTeamMintsRemaining()\n    external\n    view\n    virtual\n    override\n    returns (uint) {\n    return llamas.maxTeamMints - llamas.showTeam();\n  }\n\n  // @dev will return \"team mints\" count\n  // @return - uint of airdrops or team mints done\n  function minterTeamMintsCount()\n    external\n    view\n    virtual\n    override\n    returns (uint) {\n    return llamas.showTeam();\n  }\n\n  // @dev: will return total supply for mint\n  // @return: uint for this mint\n  function totalSupply()\n    external\n    view\n    virtual\n    override\n    returns (uint256) {\n    return tokensOnChain.current();\n  }\n\n  // @dev: will return Provenance hash of images\n  // @return: string memory of the Images Hash (sha256)\n  function RevealProvenanceImages() \n    external \n    view \n    virtual\n    override \n    returns (string memory) {\n    return llamas.ProvenanceIMG;\n  }\n\n  // @dev: will return Provenance hash of metadata\n  // @return: string memory of the Metadata Hash (sha256)\n  function RevealProvenanceJSON()\n    external\n    view\n    virtual\n    override\n    returns (string memory) {\n    return llamas.ProvenanceJSON;\n  }\n\n  // @dev: will return starting number for mint\n  // @return: uint of the start number\n  function RevealStartNumber()\n    external\n    view\n    virtual\n    override\n    returns (uint256) {\n    return llamas.startNumber;\n  }\n\n  // @dev: this is will show the start number for this chain's start number\n  // @return: uint of start number\n  function lzStartNumber()\n    external\n    view\n    virtual\n    override\n    returns (uint256) {\n    return tokenStartNumber;\n  }\n}\n"
    },
    "/contracts/modules/lzILlamas.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: lzILlamas.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for Llama/BAYC Mint engine, does Provenance for Metadata/Images\n * Source: https://etherscan.io/address/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./ILlamas.sol\";\n\n///\n/// @dev Interface for the ILlamas Standard v2.0 for LayerZero\n///  this includes metadata with images\n///\n\ninterface lzILlamas is ILlamas {\n\n  // @dev: this is will show the start number for this chain's start number\n  // @return: uint of start number\n  function lzStartNumber()\n    external\n    view\n    returns (uint256);\n\n}\n"
    },
    "/contracts/modules/TimeCop.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: TimeCop.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Time based mechanism for Solidity\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./ITimeCop.sol\";\nimport \"../access/MaxAccess.sol\";\n\nabstract contract TimeCop is MaxAccess\n                           , ITimeCop {\n\n   uint private startPresale;\n   uint private presaleDuration;\n\n   event PresaleSet(uint start, uint length);\n\n  function setPresale(\n    uint time\n  , uint duration\n  ) external\n    onlyDev() {\n    startPresale = time;\n    presaleDuration = duration;\n    emit PresaleSet(time, duration);\n  }\n\n  function showPresaleStart()\n    external\n    view\n    virtual\n    override (ITimeCop)\n    returns (uint) {\n    return startPresale;\n  }\n\n  function showStart()\n    external\n    view\n    virtual\n    override (ITimeCop)\n    returns (uint) {\n    return startPresale + presaleDuration;\n  }\n\n  function showPresaleTimes()\n    external\n    view\n    virtual\n    override (ITimeCop)\n    returns (uint, uint) {\n    return (\n      startPresale\n    , startPresale + presaleDuration\n    );\n  }\n\n    modifier onlyPresale() {\n    if (block.timestamp < startPresale) {\n      revert TooSoonJunior({\n        yourTime: block.timestamp\n      , hitTime: startPresale\n      });\n    }\n    if (block.timestamp >= startPresale + presaleDuration) {\n      revert TooLateBoomer({\n        yourTime: block.timestamp\n      , hitTime: startPresale + presaleDuration\n      });\n    }\n    _;\n  }\n\n    modifier onlySale() {\n    if (block.timestamp < startPresale + presaleDuration) {\n      revert TooSoonJunior({\n        yourTime: block.timestamp\n      , hitTime: startPresale + presaleDuration\n      });\n    }\n    if (startPresale == 0) {\n      revert MaxSplaining({\n        reason: \"TimeCop: You've been Time Copped. NGL onlyDev() hasn't set the time\"\n      });\n    }\n    _;\n  }\n}\n"
    },
    "/contracts/modules/PaymentSplitterV2.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: PaymentSplitterV2.sol\n * @author: OG was OZ, rewritten by Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Updated to add/subtract payees\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IMAXPaymentSplitter.sol\";\nimport \"../access/MaxAccess.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n// Removal of SafeMath due to ^0.8.0 standards, not needed\n\n/**\n * @title PaymentSplitter\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\n * that the Ether will be split in this way, since it is handled transparently by the contract.\n *\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\n * an amount proportional to the percentage of total shares they were assigned.\n *\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\n * function.\n */\n\nabstract contract PaymentSplitterV2 is MaxAccess\n                                     , IMAXPaymentSplitter {\n\n  event PayeeAdded(address account, uint256 shares);\n  event PaymentReleased(address to, uint256 amount);\n  event PaymentReceived(address from, uint256 amount);\n  event PayeeRemoved(address account, uint256 shares);\n  event PayeesReset();\n\n  uint256 private _totalShares;\n  uint256 private _totalReleased;\n  mapping(address => uint256) private _shares;\n  mapping(address => uint256) private _released;\n  address[] private _payees;\n\n  /**\n   * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\n   * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\n   * reliability of the events, and not the actual splitting of Ether.\n   *\n   * To learn more about this see the Solidity documentation for\n   * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\n   * functions].\n   *\n   *  receive() external payable virtual {\n   *    emit PaymentReceived(msg.sender, msg.value);\n   *  }\n   *\n   *  // Fallback function is called when msg.data is not empty\n   *  // Added to PaymentSplitter.sol\n   *  fallback() external payable {\n   *    emit PaymentReceived(msg.sender, msg.value);\n   *  }\n   *\n   * receive() and fallback() to be handled at final contract\n   */\n\n  /**\n   * @dev Getter for the total shares held by payees.\n   */\n  function totalShares() \n    external\n    view\n    virtual\n    override\n    returns (uint256) {\n    return _totalShares;\n  }\n\n  /**\n   * @dev Getter for the total amount of Ether already released.\n   */\n  function totalReleased()\n    external\n    view\n    virtual\n    override\n    returns (uint256) {\n    return _totalReleased;\n  }\n\n  /**\n   * @dev Getter for the amount of shares held by an account.\n   */\n  function shares(\n    address account\n  ) external\n    view\n    virtual\n    override\n    returns (uint256) {\n    return _shares[account];\n  }\n\n  /**\n   * @dev Getter for the amount of Ether already released to a payee.\n   */\n  function released(\n    address account\n  ) external\n    view\n    virtual\n    override\n    returns (uint256) {\n    return _released[account];\n  }\n\n  /**\n   * @dev Getter for the address of the payee number `index`.\n   */\n  function payee(\n    uint256 index\n  ) external\n    view\n    virtual\n    override\n    returns (address) {\n    return _payees[index];\n  }\n\n  /**\n   * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\n   * total shares and their previous withdrawals.\n   */\n  // This function was updated from \"account\" to msg.sender\n  function claim()\n    external\n    virtual\n    override {\n    address check = msg.sender;\n\n    if (_shares[check] == 0) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"PaymentSplitter: \",\n                    Strings.toHexString(uint160(msg.sender), 20),\n                    \" has no shares.\"\n                  )\n                )\n      });\n    }\n\n    uint256 totalReceived = address(this).balance + _totalReleased;\n    uint256 payment = (totalReceived * _shares[check]) / _totalShares - _released[check];\n\n    if (payment == 0) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"PaymentSplitter: \",\n                    Strings.toHexString(uint160(msg.sender), 20),\n                    \" is not due payment.\"\n                  )\n                )\n      });\n    }\n\n    _released[check] = _released[check] + payment;\n    _totalReleased = _totalReleased + payment;\n\n    Address.sendValue(payable(check), payment);\n    emit PaymentReleased(check, payment);\n  }\n\n  // now the internal logic of this contract\n\n  /**\n   * @dev Add a new payee to the contract.\n   * @param account The address of the payee to add.\n   * @param shares_ The number of shares owned by the payee.\n   */\n  // This function was updated to internal\n  function _addPayee(\n    address account\n  , uint256 shares_\n  ) internal {\n    if (account == address(0)) {\n      revert MaxSplaining({\n        reason: \"PaymentSplitter: account is the zero address\"\n      });\n    } else if (shares_ == 0) {\n      revert MaxSplaining({\n        reason: \"PaymentSplitter: shares are 0\"\n      });\n    } else if (_shares[account] > 0) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"PaymentSplitter: \",\n                    Strings.toHexString(uint160(account), 20),\n                    \" already has \",\n                    Strings.toString(_shares[account]),\n                    \" shares.\"\n                  )\n                )\n      });\n    }\n\n    _payees.push(account);\n    _shares[account] = shares_;\n    _totalShares = _totalShares + shares_;\n\n    emit PayeeAdded(account, shares_);\n  }\n\n  /**\n   * @dev finds index in array\n   * @param account The address of the payee\n   */\n  function _findIndex(\n    address account\n  ) internal\n    view\n    returns (uint index) {\n    uint max = _payees.length;\n    for (uint i = 0; i < max;) {\n      if (_payees[i] == account) {\n        index = i;\n      }\n      unchecked { ++i; }\n    }\n  }\n\n  /**\n   * @dev Remove a payee to the contract.\n   * @param account The address of the payee to remove.\n   * leaves all payment data in the contract incase something was claimed\n   */\n  function _removePayee(\n    address account\n  ) internal {\n    if (account == address(0)) {\n      revert MaxSplaining({\n        reason: \"PaymentSplitter: account is the zero address\"\n      });\n    } \n\n    // This finds the payee in the array _payees and removes it\n    uint remove = _findIndex(account);\n    address last = _payees[_payees.length - 1];\n    _payees[remove] = last;\n    _payees.pop();\n\n    uint removeTwo = _shares[account];\n    _shares[account] = 0;\n    _totalShares = _totalShares - removeTwo;\n\n    emit PayeeRemoved(account, removeTwo);\n  }\n\n  /**\n   * @dev clears all data in PaymentSplitterV2\n   * leaves all payment data in the contract incase something was claimed\n   */\n  function _clearAll()\n    internal {\n    uint max = _payees.length;\n    for (uint i = 0; i < max;) {\n      address account = _payees[i];\n      _shares[account] = 0;\n      unchecked { ++i; }\n    }\n    delete _totalShares;\n    delete _payees;\n    emit PayeesReset();\n  }\n\n  // @notice: This adds a payment split to PaymentSplitterV2.sol\n  // @param newSplit: Address of payee\n  // @param newShares: Shares to send user\n  function addSplit (\n    address newSplit\n  , uint256 newShares\n  ) external\n    virtual\n    override\n    onlyDev() {\n    _addPayee(newSplit, newShares);\n  }\n\n  // @notice: This removes a payment split on PaymentSplitterV2.sol\n  // @param remSplit: Address of payee to remove\n  function removeSplit (\n    address remSplit\n  ) external\n    virtual\n    override\n    onlyDev() {\n    _removePayee(remSplit);\n  }\n\n  // @notice: This removes all payment splits on PaymentSplitterV2.sol\n  function clearSplits()\n    external\n    virtual\n    override\n    onlyDev() {\n    _clearAll();\n  }\n}\n"
    },
    "/contracts/modules/NonblockingReceiver.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: NonblockingReceiver.sol\n * @author: OG?? Rewrite: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: LZ non blocking reciever\n * OG Source: https://etherscan.io/address/0xa74ae2c6fca0cedbaef30a8ceef834b247186bcf#code\n * Remember to set all the trustedRemoteLookups with trustedRemoteLookup[chainID] = contract address\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./ILayerZeroReceiver.sol\";\nimport \"./ILayerZeroEndpoint.sol\";\nimport \"../access/MaxAccess.sol\";\n\nabstract contract NonblockingReceiver is MaxAccess, ILayerZeroReceiver {\n\n  ILayerZeroEndpoint internal endpoint;\n\n  struct FailedMessages {\n    uint payloadLength;\n    bytes32 payloadHash;\n  }\n\n  mapping(uint16 => mapping(bytes => mapping(uint => FailedMessages))) public failedMessages;\n  mapping(uint16 => bytes) public trustedRemoteLookup;\n\n  event TrustedRemoteSet(\n    uint16 _chainId\n  , bytes _trustedRemote);\n\n  event MessageFailed(\n    uint16 _srcChainId\n  , bytes _srcAddress\n  , uint64 _nonce\n  , bytes _payload);\n\n  // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n  // @param _srcChainId - the source endpoint identifier\n  // @param _srcAddress - the source sending contract address from the source chain\n  // @param _nonce - the ordered message nonce\n  // @param _payload - the signed payload is the UA bytes has encoded to be sent\n  function lzReceive(\n    uint16 _srcChainId\n  , bytes memory _srcAddress\n  , uint64 _nonce\n  , bytes memory _payload\n  ) external\n    override {\n    if (msg.sender != address(endpoint)) {\n      revert MaxSplaining({\n        reason: \"NonblockingReceiver: This message did not come from the endpoint, you failed, I won!\"\n      });\n    }\n\n    if (\n      _srcAddress.length != trustedRemoteLookup[_srcChainId].length ||\n      keccak256(_srcAddress) != keccak256(trustedRemoteLookup[_srcChainId])\n    ) {\n      revert MaxSplaining({\n        reason: \"NonblockingReceiver: This message did not come from a trusted contract, you failed, I won!\"\n      });\n    }\n\n    // try-catch all errors/exceptions\n    // having failed messages does not block messages passing\n    try this.onLzReceive(_srcChainId, _srcAddress, _nonce, _payload) {\n      // do nothing\n    } catch {\n      // error or exception\n      failedMessages[_srcChainId][_srcAddress][_nonce] = FailedMessages(_payload.length, keccak256(_payload));\n      emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n  }\n\n  // @notice this is the catch all above (should be an internal?)\n  // @param _srcChainId - the source endpoint identifier\n  // @param _srcAddress - the source sending contract address from the source chain\n  // @param _nonce - the ordered message nonce\n  // @param _payload - the signed payload is the UA bytes has encoded to be sent\n  function onLzReceive(\n    uint16 _srcChainId\n  , bytes memory _srcAddress\n  , uint64 _nonce\n  , bytes memory _payload\n  ) public {\n\n    // only internal transaction\n    if (msg.sender != address(this)) {\n      revert MaxSplaining({\n        reason: \"NonblockingReceiver: This message did not come internally, you failed, I won!\"\n      });\n    }\n\n    // handle incoming message\n    _LzReceive( _srcChainId, _srcAddress, _nonce, _payload);\n  }\n\n  // @notice internal function to do something in the main contract\n  // @param _srcChainId - the source endpoint identifier\n  // @param _srcAddress - the source sending contract address from the source chain\n  // @param _nonce - the ordered message nonce\n  // @param _payload - the signed payload is the UA bytes has encoded to be sent\n  function _LzReceive(\n    uint16 _srcChainId\n  , bytes memory _srcAddress\n  , uint64 _nonce\n  , bytes memory _payload\n  ) virtual\n    internal;\n\n  // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n  // @param _dstChainId - the destination chain identifier\n  // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n  // @param _payload - a custom bytes payload to send to the destination contract\n  // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n  // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n  // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n  function _lzSend(\n    uint16 _dstChainId\n  , bytes memory _payload\n  , address payable _refundAddress\n  , address _zroPaymentAddress\n  , bytes memory _txParam\n  ) internal {\n    endpoint.send{value: msg.value}(\n      _dstChainId\n    , trustedRemoteLookup[_dstChainId]\n    , _payload, _refundAddress\n    , _zroPaymentAddress\n    , _txParam);\n  }\n\n  // @notice this is to retry a failed message on LayerZero\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  // @param _nonce - the ordered message nonce\n  // @param _payload - the payload to be retried\n  function retryMessage(\n    uint16 _srcChainId\n  , bytes memory _srcAddress\n  , uint64 _nonce\n  , bytes calldata _payload\n  ) external\n    payable {\n    // assert there is message to retry\n    FailedMessages storage failedMsg = failedMessages[_srcChainId][_srcAddress][_nonce];\n    if (failedMsg.payloadHash == bytes32(0)) {\n      revert MaxSplaining({\n        reason: \"NonblockingReceiver: This message was already executed, you failed, I won!\"\n      });\n    }\n    if (\n      _payload.length != failedMsg.payloadLength ||\n      keccak256(_payload) != failedMsg.payloadHash\n    ) {\n      revert MaxSplaining({\n        reason: \"NonblockingReceiver: This message was not stored, you failed, I won!\"\n      });\n    }\n\n    // clear the stored message\n    failedMsg.payloadLength = 0;\n    failedMsg.payloadHash = bytes32(0);\n\n    // execute the message. revert if it fails again\n    this.onLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n  }\n\n\n  // @notice this is to set all valid incoming messages\n  // @param _srcChainId - the source chain identifier\n  // @param _trustedRemote - the source chain contract address\n  function setTrustedRemote(\n    uint16 _chainId\n  , bytes calldata _trustedRemote\n  ) external\n    onlyDev() {\n    trustedRemoteLookup[_chainId] = _trustedRemote;\n    emit TrustedRemoteSet(_chainId, _trustedRemote);\n  }\n}\n"
    },
    "/contracts/modules/ITimeCop.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: ITimeCop.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Time based interface for Solidity\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface ITimeCop is IERC165 {\n\n  function setPresale(\n    uint time\n  , uint duration\n  ) external;\n\n  function showPresaleStart()\n    external\n    view\n    returns (uint);\n\n  function showStart()\n    external\n    view\n    returns (uint);\n\n  function showPresaleTimes()\n    external\n    view\n    returns (uint, uint);\n\n}\n"
    },
    "/contracts/modules/IPaymentSplitter.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: IPaymentSplitter.sol\n * @author: OG was OZ, rewritten by Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for PaymentSplitter.sol\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n///\n/// @dev Interface for PaymentSplitter\n///\n\ninterface IPaymentSplitter is IERC165 {\n\n  /**\n   * @dev Getter for the total shares held by payees.\n   */\n  function totalShares()\n    external\n    returns (uint256);\n\n  /**\n   * @dev Getter for the total amount of Ether already released.\n   */\n  function totalReleased()\n    external\n    returns (uint256);\n\n  /**\n   * @dev Getter for the amount of shares held by an account.\n   */\n  function shares(\n    address account\n  ) external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Getter for the amount of Ether already released to a payee.\n   */\n  function released(\n    address account\n  ) external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Getter for the address of the payee number `index`.\n   */\n  function payee(\n    uint256 index\n  ) external\n    view\n    returns (address);\n\n  /**\n   * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\n   * total shares and their previous withdrawals.\n   */\n  // This function was updated from \"account\" to msg.sender\n  function claim()\n    external;\n}\n"
    },
    "/contracts/modules/IMAXPaymentSplitter.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: IMAXPaymentSplitter.sol\n * @author: OG was OZ, rewritten by Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface extension for PaymentSplitter.sol\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IPaymentSplitter.sol\";\n\n///\n/// @dev Interface extension for PaymentSplitter\n///\n\ninterface IMAXPaymentSplitter is IPaymentSplitter {\n\n  // @notice: This adds a payment split to PaymentSplitterV2.sol\n  // @param newSplit: Address of payee\n  // @param newShares: Shares to send user\n  function addSplit (\n    address newSplit\n  , uint256 newShares\n  ) external;\n\n  // @notice: This removes a payment split on PaymentSplitterV2.sol\n  // @param remSplit: Address of payee to remove\n  function removeSplit (\n    address remSplit\n  ) external;\n\n  // @notice: This removes all payment splits on PaymentSplitterV2.sol\n  function clearSplits()\n    external;\n\n}\n"
    },
    "/contracts/modules/IMAXContractURI.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: IMAXContractURI.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Extension for IContractURI\n */\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IContractURI.sol\";\n\ninterface IMAXContractURI is IContractURI {\n\n  // @notice this sets the contractURI, set to internal\n  // @param URI - string to URI of Contract Metadata\n  // @notice: let the metadata be in this format\n  // {\n  //   \"name\": Project's name,\n  //   \"description\": Project's Description,\n  //   \"image\": pfp for project,\n  //   \"external_link\": web url,\n  //   \"seller_fee_basis_points\": 100 -> Indicates a 1% seller fee.\n  //   \"fee_recipient\": checksum address\n  // }\n  function setContractURI(\n    string memory URI\n  ) external;\n}\n"
    },
    "/contracts/modules/IMAX721.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: IMAX721.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for UX/UI\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n///\n/// @dev Interface for @MaxFlowO2's Contracts\n///\n\ninterface IMAX721 is IERC165 {\n\n  // @dev will return status of Minter\n  // @return - bool of active or not\n  function minterStatus() \n    external\n    view\n    returns (bool);\n\n  // @dev will return minting fees\n  // @return - uint of mint costs in wei\n  function minterFees()\n    external\n    view\n    returns (uint);\n\n  // @dev will return maximum mint capacity\n  // @return - uint of maximum mints allowed\n  function minterMaximumCapacity()\n    external\n    view\n    returns (uint);\n\n  // @dev will return maximum \"team minting\" capacity\n  // @return - uint of maximum airdrops or team mints allowed\n  function minterMaximumTeamMints()\n    external\n    view\n    returns (uint);\n\n  // @dev will return \"team mints\" left\n  // @return - uint of remaing airdrops or team mints\n  function minterTeamMintsRemaining()\n    external\n    view\n    returns (uint);\n\n  // @dev will return \"team mints\" count\n  // @return - uint of airdrops or team mints done\n  function minterTeamMintsCount()\n    external\n    view\n    returns (uint);\n\n  // @dev: will return total supply for mint\n  // @return: uint for this mint\n  function totalSupply()\n    external\n    view\n    returns (uint256);\n}\n"
    },
    "/contracts/modules/ILlamas.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: ILlamas.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for Llama/BAYC Mint engine, does Provenance for Metadata/Images\n * Source: https://etherscan.io/address/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IMAX721.sol\";\n\n///\n/// @dev Interface for the ILlamas Standard v2.0\n///  this includes metadata with images\n///\n\ninterface ILlamas is IMAX721{\n\n  // @dev: will return Provenance hash of images\n  // @return: string memory of the Images Hash (sha256)\n  function RevealProvenanceImages()\n    external\n    view\n    returns (string memory);\n\n  // @dev: will return Provenance hash of metadata\n  // @return: string memory of the Metadata Hash (sha256)\n  function RevealProvenanceJSON()\n    external\n    view\n    returns (string memory);\n\n  // @dev: will return starting number for mint\n  // @return: uint of the start number\n  function RevealStartNumber()\n    external\n    view\n    returns (uint256);\n\n}\n"
    },
    "/contracts/modules/ILayerZeroUserApplicationConfig.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: ILayerZeroUserApplicationConfig.sol\n * @author: OG?? Rewrite: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for LayerZeroUserApplicationConfig\n * OG Source: https://etherscan.io/address/0xa74ae2c6fca0cedbaef30a8ceef834b247186bcf#code\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n  // @notice set the configuration of the LayerZero messaging library of the specified version\n  // @param _version - messaging library version\n  // @param _chainId - the chainId for the pending config change\n  // @param _configType - type of configuration. every messaging library has its own convention.\n  // @param _config - configuration in the bytes. can encode arbitrary content.\n  function setConfig(\n    uint16 _version\n  , uint16 _chainId\n  , uint _configType\n  , bytes calldata _config\n  ) external;\n\n  // @notice set the send() LayerZero messaging library version to _version\n  // @param _version - new messaging library version\n  function setSendVersion(\n    uint16 _version\n  ) external;\n\n  // @notice set the lzReceive() LayerZero messaging library version to _version\n  // @param _version - new messaging library version\n  function setReceiveVersion(\n    uint16 _version\n  ) external;\n\n  // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n  // @param _srcChainId - the chainId of the source chain\n  // @param _srcAddress - the contract address of the source contract at the source chain\n  function forceResumeReceive(\n    uint16 _srcChainId\n  , bytes calldata _srcAddress\n  ) external;\n}\n"
    },
    "/contracts/modules/ILayerZeroReceiver.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: ILayerZeroReceiver.sol\n * @author: OG?? Rewrite: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for LayerZeroReceiver\n * OG Source: https://etherscan.io/address/0xa74ae2c6fca0cedbaef30a8ceef834b247186bcf#code\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n\n  // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n  // @param _srcChainId - the source endpoint identifier\n  // @param _srcAddress - the source sending contract address from the source chain\n  // @param _nonce - the ordered message nonce\n  // @param _payload - the signed payload is the UA bytes has encoded to be sent\n  function lzReceive(\n    uint16 _srcChainId\n  , bytes calldata _srcAddress\n  , uint64 _nonce\n  , bytes calldata _payload\n  ) external;\n\n}\n"
    },
    "/contracts/modules/ILayerZeroEndpoint.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: ILayerZeroEndpoint.sol\n * @author: OG?? Rewrite: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for LayerZeroEndpoint\n * OG Source: https://etherscan.io/address/0xa74ae2c6fca0cedbaef30a8ceef834b247186bcf#code\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n  // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n  // @param _dstChainId - the destination chain identifier\n  // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n  // @param _payload - a custom bytes payload to send to the destination contract\n  // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n  // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n  // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n  function send(\n    uint16 _dstChainId\n  , bytes calldata _destination\n  , bytes calldata _payload\n  , address payable _refundAddress\n  , address _zroPaymentAddress\n  , bytes calldata _adapterParams\n  ) external\n    payable;\n\n  // @notice used by the messaging library to publish verified payload\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source contract (as bytes) at the source chain\n  // @param _dstAddress - the address on destination chain\n  // @param _nonce - the unbound message ordering nonce\n  // @param _gasLimit - the gas limit for external contract execution\n  // @param _payload - verified payload to send to the destination contract\n  function receivePayload(\n    uint16 _srcChainId\n  , bytes calldata _srcAddress\n  , address _dstAddress\n  , uint64 _nonce\n  , uint _gasLimit\n  , bytes calldata _payload\n  ) external;\n\n  // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  function getInboundNonce(\n    uint16 _srcChainId\n  , bytes calldata _srcAddress\n  ) external\n    view\n    returns (uint64);\n\n  // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n  // @param _srcAddress - the source chain contract address\n  function getOutboundNonce(\n    uint16 _dstChainId\n  , address _srcAddress\n  ) external\n    view\n    returns (uint64);\n\n  // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n  // @param _dstChainId - the destination chain identifier\n  // @param _userApplication - the user app address on this EVM chain\n  // @param _payload - the custom message to send over LayerZero\n  // @param _payInZRO - if false, user app pays the protocol fee in native token\n  // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n  function estimateFees(\n    uint16 _dstChainId\n  , address _userApplication\n  , bytes calldata _payload\n  , bool _payInZRO\n  , bytes calldata _adapterParam\n  ) external\n    view\n    returns (\n    uint nativeFee\n  , uint zroFee);\n\n  // @notice get this Endpoint's immutable source identifier\n  function getChainId()\n    external\n    view\n    returns (uint16);\n\n  // @notice the interface to retry failed message on this Endpoint destination\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  // @param _payload - the payload to be retried\n  function retryPayload(\n    uint16 _srcChainId\n  , bytes calldata _srcAddress\n  , bytes calldata _payload\n  ) external;\n\n  // @notice query if any STORED payload (message blocking) at the endpoint.\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  function hasStoredPayload(\n    uint16 _srcChainId\n  , bytes calldata _srcAddress\n  ) external\n    view\n    returns (bool);\n\n  // @notice query if the _libraryAddress is valid for sending msgs.\n  // @param _userApplication - the user app address on this EVM chain\n  function getSendLibraryAddress(\n    address _userApplication\n  ) external\n    view\n    returns (address);\n\n  // @notice query if the _libraryAddress is valid for receiving msgs.\n  // @param _userApplication - the user app address on this EVM chain\n  function getReceiveLibraryAddress(\n    address _userApplication\n  ) external\n    view\n    returns (address);\n\n  // @notice query if the non-reentrancy guard for send() is on\n  // @return true if the guard is on. false otherwise\n  function isSendingPayload()\n    external\n    view\n    returns (bool);\n\n  // @notice query if the non-reentrancy guard for receive() is on\n  // @return true if the guard is on. false otherwise\n  function isReceivingPayload()\n    external\n    view\n    returns (bool);\n\n  // @notice get the configuration of the LayerZero messaging library of the specified version\n  // @param _version - messaging library version\n  // @param _chainId - the chainId for the pending config change\n  // @param _userApplication - the contract address of the user application\n  // @param _configType - type of configuration. every messaging library has its own convention.\n  function getConfig(\n    uint16 _version\n  , uint16 _chainId\n  , address _userApplication\n  , uint _configType\n  ) external\n    view\n    returns (bytes memory);\n\n  // @notice get the send() LayerZero messaging library version\n  // @param _userApplication - the contract address of the user application\n  function getSendVersion(\n    address _userApplication\n  ) external\n    view\n    returns (uint16);\n\n  // @notice get the lzReceive() LayerZero messaging library version\n  // @param _userApplication - the contract address of the user application\n  function getReceiveVersion(\n    address _userApplication\n  ) external\n    view\n    returns (uint16);\n}\n"
    },
    "/contracts/modules/IContractURI.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: IContractURI.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Purely for OpenSea compliance\n */\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n///\n/// @dev Interface for the OpenSea Standard\n///\n\ninterface IContractURI is IERC165{\n\n  // @notice contractURI() called for retreval of \n  //  OpenSea style collections pages\n  // @return - the string URI of the contract, usually IPFS\n  function contractURI()\n    external\n    view\n    returns (string memory);\n}\n\n"
    },
    "/contracts/modules/ContractURI.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: ContractURI.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Purely for OpenSea compliance\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IMAXContractURI.sol\";\nimport \"../access/MaxAccess.sol\";\n\n///\n/// @dev Implementation of IMAXContractURI.sol\n///\n\nabstract contract ContractURI is MaxAccess\n                               , IMAXContractURI {\n\n  event ContractURIChange(\n          string _old\n        , string _new);\n\n  string private thisContractURI;\n\n  // @notice this sets the contractURI, set to internal\n  // @param newURI - string to URI of Contract Metadata\n  // @notice: let the metadata be in this format\n  //{\n  //  \"name\": Project's name,\n  //  \"description\": Project's Description,\n  //  \"image\": pfp for project,\n  //  \"external_link\": web url,\n  //  \"seller_fee_basis_points\": 100 -> Indicates a 1% seller fee.\n  //  \"fee_recipient\": checksum address\n  //}\n  function _setContractURI(\n    string memory newURI\n  ) internal {\n    string memory old = thisContractURI;\n    thisContractURI = newURI;\n    emit ContractURIChange(old, thisContractURI);\n  }\n\n  // @notice this clears the contractURI, set to internal\n  function _clearContractURI() internal {\n    string memory old = thisContractURI;\n    delete thisContractURI;\n    emit ContractURIChange(old, thisContractURI);\n  }\n\n  // @notice this sets the contractURI, set to internal\n  // @param URI - string to URI of Contract Metadata\n  // @notice: let the metadata be in this format\n  // {\n  //   \"name\": Project's name,\n  //   \"description\": Project's Description,\n  //   \"image\": pfp for project,\n  //   \"external_link\": web url,\n  //   \"seller_fee_basis_points\": 100 -> Indicates a 1% seller fee.\n  //   \"fee_recipient\": checksum address\n  // }\n  function setContractURI(\n    string memory URI\n  ) external\n    virtual\n    override\n    onlyDev() {\n    _setContractURI(URI);\n  }\n\n  // @notice contractURI() called for retreval of\n  //  OpenSea style collections pages\n  // @return - string thisContractURI\n  function contractURI() \n    external\n    view\n    virtual\n    override(IContractURI)\n    returns (string memory) {\n    return thisContractURI;\n  }\n}\n"
    },
    "/contracts/lib/Roles.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: Roles.sol\n * @author: OpenZeppelin, rewrite by Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Library for MaxAcess.sol\n * @dev: Rewritten for gas optimization, and from abstract -> library, added\n * multiple types instead of a solo role.\n * Original source:\n * https://github.com/hiddentao/openzeppelin-solidity/blob/master/contracts/access/Roles.sol\n *\n * Include with 'using Roles for Roles.Role;'\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nlibrary Roles {\n\n  // @dev: this is Unauthorized(), basically a catch all, zero description\n  // @notice: 0x82b42900 bytes4 of this\n  error Unauthorized();\n\n  // @dev: this is MaxSplaining(), giving you a reason, aka require(param, \"reason\")\n  // @param reason: Use the \"Contract name: error\"\n  // @notice: 0x0661b792 bytes4 of this\n  error MaxSplaining(\n    string reason\n  );\n\n  event RoleChanged(bytes4 _type, address _user, bool _status); // 0x0baaa7ab\n\n  struct Role {\n    mapping(address => mapping(bytes4 => bool)) bearer;\n  }\n\n  /**\n   * @dev give an account access to this role\n   */\n  function add(Role storage role, bytes4 _type, address account) internal {\n    if (account == address(0)) {\n      revert Unauthorized();\n    } else if (has(role, _type, account)) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"Lib Roles: \",\n                    Strings.toHexString(uint160(account), 20),\n                    \" already has role \",\n                    Strings.toHexString(uint32(_type), 4)\n                  )\n                )\n      });\n    }\n    role.bearer[account][_type] = true;\n    emit RoleChanged(_type, account, true);\n  }\n\n  /**\n   * @dev remove an account's access to this role\n   */\n  function remove(Role storage role, bytes4 _type, address account) internal {\n    if (account == address(0)) {\n      revert Unauthorized();\n    } else if (!has(role, _type, account)) {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"Lib Roles: \",\n                    Strings.toHexString(uint160(account), 20),\n                    \" does not have role \",\n                    Strings.toHexString(uint32(_type), 4)\n                  )\n                )\n      });\n    }\n    role.bearer[account][_type] = false;\n    emit RoleChanged(_type, account, false);\n  }\n\n  /**\n   * @dev check if an account has this role\n   * @return bool\n   */\n  function has(Role storage role, bytes4 _type, address account)\n    internal\n    view\n    returns (bool)\n  {\n    if (account == address(0)) {\n      revert Unauthorized();\n    }\n    return role.bearer[account][_type];\n  }\n}\n"
    },
    "/contracts/lib/PsuedoRand.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: PsuedoRand.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Library for Llama/BAYC Mint engine...\n *  basically a random start point and a bookends mint to start\n *  i.e. 0-2999 start at 500 -> 2999, then 0 -> 499.\n *\n *  Covers IMAX721.sol and Illamas.sol\n *\n * Include with 'using PsuedoRand for PsuedoRand.Engine;'\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./CountersV2.sol\";\n\nlibrary PsuedoRand {\n  using CountersV2 for CountersV2.Counter;\n\n  event SetProvenanceIMG(string _new, string _old);\n  event SetProvenanceJSON(string _new, string _old);\n  event SetStartNumber(uint _new);\n  event SetMaxCapacity(uint _new, uint _old);\n  event SetMaxTeamMint(uint _new, uint _old);\n  event SetMintFees(uint _new, uint _old);\n  event SetStatus(bool _new);\n\n  // @dev: this is MaxSplaining(), giving you a reason, aka require(param, \"reason\")\n  // @param reason: Use the \"Contract name: error\"\n  // @notice: 0x0661b792 bytes4 of this\n  error MaxSplaining(\n    string reason\n  );\n\n  struct Engine {\n    uint256 mintFee;\n    uint256 startNumber;\n    uint256 maxCapacity;\n    uint256 maxTeamMints;\n    string ProvenanceIMG;\n    string ProvenanceJSON;\n    CountersV2.Counter currentMinted;\n    CountersV2.Counter currentTeam;\n    bool status;\n  }\n\n  function setProvJSON(\n    Engine storage engine\n  , string memory provJSON\n  ) internal {\n    string memory old = engine.ProvenanceJSON;\n    engine.ProvenanceJSON = provJSON;\n    emit SetProvenanceJSON(provJSON, old);\n  }\n \n  function setProvIMG(\n    Engine storage engine\n  , string memory provIMG\n  ) internal {\n    string memory old = engine.ProvenanceIMG;\n    engine.ProvenanceIMG = provIMG;\n    emit SetProvenanceIMG(provIMG, old);\n  }\n\n  function setStartNumber(\n    Engine storage engine\n  ) internal {\n    if (engine.maxCapacity == 0) {\n      revert MaxSplaining({\n        reason : \"PsuedoRandom Lib: Maximum Capacity not set!\"\n      });\n    }\n    engine.startNumber = uint(\n                           keccak256(\n                             abi.encodePacked(\n                               block.timestamp\n                             , msg.sender\n                             , engine.ProvenanceIMG\n                             , engine.ProvenanceJSON\n                             , block.difficulty))) \n                         % engine.maxCapacity;\n    emit SetStartNumber(engine.startNumber);\n  }\n\n  function setMaxCap(\n    Engine storage engine\n  , uint256 max\n  ) internal {\n    uint old = engine.maxCapacity;\n    engine.maxCapacity = max;\n    emit SetMaxCapacity(max, old);\n  }\n\n  function setMaxTeam(\n    Engine storage engine\n  , uint256 max\n  ) internal {\n    uint old = engine.maxTeamMints;\n    engine.maxTeamMints = max;\n    emit SetMaxTeamMint(max, old);\n  }\n\n  function setFees(\n    Engine storage engine\n  , uint256 max\n  ) internal {\n    uint old = engine.mintFee;\n    engine.mintFee = max;\n    emit SetMintFees(max, old);\n  }\n\n  function setStatus(\n    Engine storage engine\n  , bool change\n  ) internal {\n    engine.status = change;\n    emit SetStatus(change);\n  }\n\n  function mintID(\n    Engine storage engine\n  ) internal\n    view\n    returns (uint256) {\n    return (engine.startNumber + engine.currentMinted.current()) % engine.maxCapacity;\n  }\n\n  function showTeam(\n    Engine storage engine\n  ) internal \n    view\n    returns (uint256) {\n    return engine.currentTeam.current();\n  }\n\n  function showMinted(\n    Engine storage engine\n  ) internal\n    view\n    returns (uint256) {\n    return engine.currentMinted.current();\n  }\n\n  function battersUpTeam(\n    Engine storage engine\n  ) internal {\n    engine.currentTeam.increment();\n  }\n\n  function battersUp(\n    Engine storage engine\n  ) internal {\n    engine.currentMinted.increment();\n  }\n}\n"
    },
    "/contracts/lib/CountersV2.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: CountersV2.sol\n * @author Matt Condon (@shrugs), Edits by Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @dev Provides counters that can only be incremented, decremented, reset or set. \n * This can be used e.g. to track the number of elements in a mapping, issuing ERC721 ids\n * or counting request ids.\n *\n * Edited by @MaxFlowO2 for more NFT functionality on 13 Jan 2022\n * added .set(uint) so if projects need to start at say 1 or some random number they can\n * and an event log for numbers being reset or set.\n *\n * Include with `using CountersV2 for CountersV2.Counter;`\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary CountersV2 {\n\n  // @dev: this is MaxSplaining(), giving you a reason, aka require(param, \"reason\")\n  // @param reason: Use the \"Contract name: error\"\n  // @notice: 0x0661b792 bytes4 of this\n  error MaxSplaining(\n    string reason\n  );\n\n  event CounterNumberChangedTo(uint _number);\n\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(\n    Counter storage counter\n  ) internal\n    view\n    returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(\n    Counter storage counter\n  ) internal {\n    unchecked {\n      ++counter._value;\n    }\n  }\n\n  function decrement(\n    Counter storage counter\n  ) internal {\n    uint256 value = counter._value;\n    if (value == 0) {\n      revert MaxSplaining({\n        reason : \"CountersV2: No negatives in uints\"\n      });\n    }\n    unchecked {\n      --counter._value;\n    }\n  }\n\n  function reset(\n    Counter storage counter\n  ) internal {\n    counter._value = 0;\n    emit CounterNumberChangedTo(counter._value);\n  }\n\n  function set(\n    Counter storage counter\n  , uint number\n  ) internal {\n    counter._value = number;\n    emit CounterNumberChangedTo(counter._value);\n  }  \n}\n"
    },
    "/contracts/errors/MaxErrors.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: MaxErrors.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Custom errors for all contracts, minus libraries\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nabstract contract MaxErrors {\n\n  // @dev: this is Unauthorized(), basically a catch all, zero description\n  // @notice: 0x82b42900 bytes4 of this\n  error Unauthorized();\n\n  // @dev: this is MaxSplaining(), giving you a reason, aka require(param, \"reason\")\n  // @param reason: Use the \"Contract name: error\"\n  // @notice: 0x0661b792 bytes4 of this\n  error MaxSplaining(\n    string reason\n  );\n\n  // @dev: this is TooSoonJunior(), using times\n  // @param yourTime: should almost always be block.timestamp\n  // @param hitTime: the time you should have started\n  // @notice: 0xf3f82ac5 bytes4 of this\n  error TooSoonJunior(\n    uint yourTime\n  , uint hitTime\n  );\n\n  // @dev: this is TooLateBoomer(), using times\n  // @param yourTime: should almost always be block.timestamp\n  // @param hitTime: the time you should have ended\n  // @notice: 0x43c540ef bytes4 of this\n  error TooLateBoomer(\n    uint yourTime\n  , uint hitTime\n  );\n\n}\n"
    },
    "/contracts/eip/2981/IMAX2981.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: IMAX2981.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: IERC2981 Extension\n */\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IERC2981.sol\";\n\ninterface IMAX2981 is IERC2981 {\n\n  // @notice: This sets the contract as royalty reciever (useful with abstract PaymentSplitter)\n  // @param permille: Percentage you want so 3.5% -> 35\n  function setRoyaltiesThis (\n    uint permille\n  ) external;\n\n  // @notice: This sets royalties per EIP-2981\n  // @param newAddress: Sets the address for royalties\n  // @param permille: Percentage you want so 3.5% -> 35\n  function setRoyalties (\n    address newAddress\n  , uint256 permille\n  ) external;\n\n  // @notice: This clears all EIP-2981 royalties (address(0) and 0%)\n  function clearRoyalties()\n    external;\n\n}\n"
    },
    "/contracts/eip/2981/IERC2981.sol": {
      "content": "/***\n *                 \n *          \n *       \n *          \n *                 \n *                                                                            \n * Zach Burks, James Morgan, Blaine Malone, James Seibel,\n * \"EIP-2981: NFT Royalty Standard,\"\n * Ethereum Improvement Proposals, no. 2981, September 2020. [Online serial].\n * Available: https://eips.ethereum.org/EIPS/eip-2981.\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n///\n/// @dev Interface for the NFT Royalty Standard\n///\n\ninterface IERC2981 is IERC165 {\n\n  // @notice Called with the sale price to determine how much royalty\n  //  is owed and to whom.\n  // @param _tokenId - the NFT asset queried for royalty information\n  // @param _salePrice - the sale price of the NFT asset specified by _tokenId\n  // @return receiver - address of who should be sent the royalty payment\n  // @return royaltyAmount - the royalty payment amount for _salePrice\n  function royaltyInfo(\n    uint256 _tokenId\n  , uint256 _salePrice\n  ) external\n    view\n    returns (\n    address receiver\n  , uint256 royaltyAmount\n  );\n}\n"
    },
    "/contracts/eip/2981/ERC2981Collection.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: ERC2981Collection.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Use case for EIP 2981, steered more towards NFT Collections as a whole\n */\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IMAX2981.sol\";\nimport \"../../access/MaxAccess.sol\";\n\nabstract contract ERC2981Collection is MaxAccess, IMAX2981 {\n\n  address private royaltyAddress;\n  uint256 private royaltyPermille;\n\n  event royalatiesSet(\n          uint value\n        , address recipient\n        );\n\n  // the internals to do logic flows later\n\n  // @dev to set roaylties on contract via EIP 2891\n  // @param _receiver, address of recipient\n  // @param _permille, permille xx.x -> xxx value\n  function _setRoyalties(\n    address _receiver\n  , uint256 _permille\n  ) internal {\n  if (_permille >= 1000 || _permille == 0) {\n    revert MaxSplaining({\n      reason: string(\n                abi.encodePacked(\n                  \"ERC2981Collection: \",\n                  Strings.toHexString(uint160(msg.sender), 20),\n                  \" submitted \",\n                  Strings.toString(_permille),\n                  \" and that is out of bounds!\"\n                )\n              )\n    });\n  }\n    royaltyAddress = _receiver;\n    royaltyPermille = _permille;\n    emit royalatiesSet(royaltyPermille, royaltyAddress);\n  }\n\n  // @dev to remove royalties from contract\n  function _removeRoyalties()\n    internal {\n    delete royaltyAddress;\n    delete royaltyPermille;\n    emit royalatiesSet(royaltyPermille, royaltyAddress);\n  }\n\n  // Logic for this contract (abstract)\n\n  // @notice: This sets the contract as royalty reciever (useful with abstract PaymentSplitter)\n  // @param permille: Percentage you want so 3.5% -> 35\n  function setRoyaltiesThis (\n    uint permille\n  ) external\n    virtual\n    override\n    onlyOwner() {\n    _setRoyalties(address(this), permille);\n  }\n\n  // @notice: This sets royalties per EIP-2981\n  // @param newAddress: Sets the address for royalties\n  // @param permille: Percentage you want so 3.5% -> 35\n  function setRoyalties (\n    address newAddress\n  , uint256 permille\n  ) external\n    virtual\n    override\n    onlyOwner() {\n    _setRoyalties(newAddress, permille);\n  }\n\n  // @notice: This clears all EIP-2981 royalties (address(0) and 0%)\n  function clearRoyalties()\n    external\n    virtual\n    override\n    onlyOwner() {\n    _removeRoyalties();\n  }\n\n  // @dev Override for royaltyInfo(uint256, uint256)\n  // @param _tokenId, uint of token ID to be checked\n  // @param _salePrice, uint of amount of sale\n  // @return receiver, address of recipient\n  // @return royaltyAmount, amount royalties recieved\n  function royaltyInfo(\n    uint256 _tokenId\n  , uint256 _salePrice\n  ) external\n    view\n    virtual\n    override\n    returns (\n    address receiver\n  , uint256 royaltyAmount\n  ) {\n    receiver = royaltyAddress;\n    royaltyAmount = _salePrice * royaltyPermille / 1000;\n  }\n}\n"
    },
    "/contracts/access/MaxAccess.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: MaxAccess.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Access control based off EIP 173/roles from OZ\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IOwnerV2.sol\";\nimport \"./IDeveloperV2.sol\";\nimport \"./IRole.sol\";\nimport \"../lib/Roles.sol\";\nimport \"../errors/MaxErrors.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nabstract contract MaxAccess is MaxErrors\n                             , IRole\n                             , IOwnerV2\n                             , IDeveloperV2 {\n  using Roles for Roles.Role;\n\n  Roles.Role private contractRoles;\n\n  // bytes4 caluclated as follows\n  // bytes4(keccak256(bytes(signature)))\n  // developer() => 0xca4b208b\n  // owner() => 0x8da5cb5b\n  // admin() => 0xf851a440\n  // was using trailing () for caluclations\n\n  bytes4 constant private DEVS = 0xca4b208b;\n  bytes4 constant private PENDING_DEVS = 0xca4b208a; // DEVS - 1\n  bytes4 constant private OWNERS = 0x8da5cb5b;\n  bytes4 constant private PENDING_OWNERS = 0x8da5cb5a; // OWNERS - 1\n  bytes4 constant private ADMIN = 0xf851a440;\n\n  // @dev you can sub your own address here... this is MaxFlowO2.eth\n  // these are for displays anyways, and init().\n  address private TheDev = address(0x4CE69fd760AD0c07490178f9a47863Dc0358cCCD);\n  address private TheOwner = address(0x44f750eB065596c150B3479B1DF6957da300a332);\n\n  constructor() {\n    // supercedes all the logic below\n    contractRoles.add(ADMIN, address(this));\n    _grantRole(ADMIN, TheDev);\n    _grantRole(OWNERS, TheOwner);\n    _grantRole(DEVS, TheDev);\n  }\n\n  // modifiers\n  modifier onlyRole(bytes4 role) {\n    if (_checkRole(role, msg.sender) || _checkRole(ADMIN, msg.sender)) {\n      _;\n    } else {\n      revert MaxSplaining({\n        reason: string(\n                  abi.encodePacked(\n                    \"MaxAccess: You are a not an \",\n                    Strings.toHexString(uint32(role), 4),\n                    \" or \",\n                    Strings.toHexString(uint32(ADMIN), 4),\n                    \" \",\n                    Strings.toHexString(uint160(msg.sender), 20)\n                  )\n                )\n      });\n    }\n  }\n\n  modifier onlyDev() {\n    if (!_checkRole(DEVS, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  modifier onlyOwner() {\n    if (!_checkRole(OWNERS, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  // internal logic first \n  // (sets the tone later, and for later contracts)\n\n  // @dev: this is the bool for checking if the account has a role via lib roles.sol\n  // @param role: bytes4 of the role to check for\n  // @param account: address of account to check\n  // @return: bool true/false\n  function _checkRole(\n    bytes4 role\n  , address account\n  ) internal\n    view\n    virtual\n    returns (bool) {\n    return contractRoles.has(role, account);\n  }\n\n  // @dev: this is the internal to grant roles\n  // @param role: bytes4 of the role\n  // @param account: address of account to add\n  function _grantRole(\n    bytes4 role\n  , address account\n  ) internal\n    virtual {\n    contractRoles.add(role, account);\n  }\n\n  // @dev: this is the internal to revoke roles\n  // @param role: bytes4 of the role\n  // @param account: address of account to remove\n  function _revokeRole(\n    bytes4 role\n  , address account\n  ) internal\n    virtual {\n    contractRoles.remove(role, account);\n  }\n\n  // @dev: Returns `true` if `account` has been granted `role`.\n  // @param role: Bytes4 of a role\n  // @param account: Address to check\n  // @return: bool true/false if account has role\n  function hasRole(\n    bytes4 role\n  , address account\n  ) external\n    view\n    virtual\n    override\n    returns (bool) {\n    return _checkRole(role, account);\n  }\n\n  // @dev: Returns the admin role that controls a role\n  // @param role: Role to check\n  // @return: admin role\n  function getRoleAdmin(\n    bytes4 role\n  ) external\n    view\n    virtual\n    override\n    returns (bytes4) {\n    return ADMIN;\n  }\n\n  // @dev: Grants `role` to `account`\n  // @param role: Bytes4 of a role\n  // @param account: account to give role to\n  function grantRole(\n    bytes4 role\n  , address account\n  ) external\n    virtual\n    override \n    onlyRole(role) {\n\n    if (role == PENDING_DEVS) {\n      // locks out pending devs from mass swapping roles\n      if (_checkRole(PENDING_DEVS, msg.sender)) {\n        revert MaxSplaining({\n          reason: string(\n                    abi.encodePacked(\n                      \"MaxAccess: You are a pending developer() \",\n                      Strings.toHexString(uint160(msg.sender), 20),\n                      \" you can not grant role \",\n                      Strings.toHexString(uint32(role), 4),\n                      \" to \",\n                      Strings.toHexString(uint160(account), 20)\n                    )\n                  )\n        });\n      }\n    }\n\n    if (role == PENDING_OWNERS) {\n      // locks out pending owners from mass swapping roles\n      if (_checkRole(PENDING_OWNERS, msg.sender)) {\n        revert MaxSplaining({\n          reason: string(\n                    abi.encodePacked(\n                      \"MaxAccess: You are a pending owner() \",\n                      Strings.toHexString(uint160(msg.sender), 20),\n                      \" you can not grant role \",\n                      Strings.toHexString(uint32(role), 4),\n                      \" to \",\n                      Strings.toHexString(uint160(account), 20)\n                    )\n                  )\n        });\n      }\n    }\n\n    _grantRole(role, account);\n  }\n\n  // @dev: Revokes `role` from `account`\n  // @param role: Bytes4 of a role\n  // @param account: account to revoke role from\n  function revokeRole(\n    bytes4 role\n  , address account\n  ) external\n    virtual\n    override\n    onlyRole(role) {\n\n    if (role == PENDING_DEVS) {\n      // locks out pending devs from mass swapping roles\n      if (account != msg.sender) {\n        revert MaxSplaining({\n          reason: string(\n                    abi.encodePacked(\n                      \"MaxAccess: You are a pending developer() \",\n                      Strings.toHexString(uint160(msg.sender), 20),\n                      \" you can not revoke role \",\n                      Strings.toHexString(uint32(role), 4),\n                      \" to \",\n                      Strings.toHexString(uint160(account), 20)\n                    )\n                  )\n        });\n      }\n    }\n\n    if (role == PENDING_OWNERS) {\n      // locks out pending owners from mass swapping roles\n      if (account != msg.sender) {\n        revert MaxSplaining({\n          reason: string(\n                    abi.encodePacked(\n                      \"MaxAccess: You are a pending owner() \",\n                      Strings.toHexString(uint160(msg.sender), 20),\n                      \" you can not revoke role \",\n                      Strings.toHexString(uint32(role), 4),\n                      \" to \",\n                      Strings.toHexString(uint160(account), 20)\n                    )\n                  )\n        });\n      }\n    }\n    _revokeRole(role, account);\n  }\n\n  // @dev: Renounces `role` from `account`\n  // @param role: Bytes4 of a role\n  // @param account: account to renounce role from\n  function renounceRole(\n    bytes4 role\n  ) external\n    virtual\n    override \n    onlyRole(role) {\n    address user = msg.sender;\n    _revokeRole(role, user);\n  }\n\n  // Now the classic onlyDev() + \"V2\" suggested by auditors\n\n  // @dev: Classic \"EIP-173\" but for onlyDev()\n  // @return: Developer of contract\n  function developer()\n    external\n    view\n    virtual\n    override\n    returns (address) {\n    return TheDev;\n  }\n\n  // @dev: This renounces your role as onlyDev()\n  function renounceDeveloper()\n    external\n    virtual\n    override \n    onlyRole(DEVS) {\n    address user = msg.sender;\n    _revokeRole(DEVS, user);\n  }\n\n  // @dev: Classic \"EIP-173\" but for onlyDev()\n  // @param newDeveloper: addres of new pending Developer role\n  function transferDeveloper(\n    address newDeveloper\n  ) external\n    virtual\n    override \n    onlyRole(DEVS) {\n    address user = msg.sender;\n    _grantRole(DEVS, newDeveloper);\n    _revokeRole(DEVS, user);\n  }\n\n  // @dev: This accepts the push-pull method of onlyDev()\n  function acceptDeveloper()\n    external\n    virtual\n    override \n    onlyRole(PENDING_DEVS) {\n    address user = msg.sender;\n    _revokeRole(PENDING_DEVS, user);\n    _grantRole(DEVS, user);\n  }\n\n  // @dev: This declines the push-pull method of onlyDev()\n  function declineDeveloper()\n    external\n    virtual\n    override \n    onlyRole(PENDING_DEVS) {\n    address user = msg.sender;\n    _revokeRole(PENDING_DEVS, user);\n  }\n\n  // @dev: This starts the push-pull method of onlyDev()\n  // @param newDeveloper: addres of new pending developer role\n  function pushDeveloper(\n    address newDeveloper\n  ) external\n    virtual\n    override\n    onlyRole(DEVS) {\n    _grantRole(PENDING_DEVS, newDeveloper);\n  }\n\n  // @dev: This changes the display of developer()\n  // @param newDisplay: new display addrss for developer()\n  function setDeveloper(\n    address newDisplay\n  ) external\n    onlyDev() {\n    if (!_checkRole(DEVS, newDisplay)) {\n        revert MaxSplaining({\n          reason: string(\n                    abi.encodePacked(\n                      \"MaxAccess: The address \",\n                      Strings.toHexString(uint160(newDisplay), 20),\n                      \" is not a developer and does not have the role \",\n                      Strings.toHexString(uint32(DEVS), 4),\n                      \" there \",\n                      Strings.toHexString(uint160(msg.sender), 20)\n                    )\n                  )\n        });\n    }\n    TheDev = newDisplay;\n  }\n\n  // Now the classic onlyOwner() + \"V2\" suggested by auditors\n\n  // @dev: Classic \"EIP-173\" getter for owner()\n  // @return: owner of contract\n  function owner()\n    external\n    view\n    virtual\n    override\n    returns (address) {\n    return TheOwner;\n  }\n\n   // @dev: This renounces your role as onlyOwner()\n  function renounceOwnership()\n    external\n    virtual\n    override\n    onlyRole(OWNERS) {\n    address user = msg.sender;\n    _revokeRole(OWNERS, user);\n  }\n\n  // @dev: Classic \"EIP-173\" but for onlyOwner()\n  // @param newOwner: addres of new pending Developer role\n  function transferOwnership(\n    address newOwner\n  ) external\n    virtual\n    override\n    onlyRole(OWNERS) {\n    address user = msg.sender;\n    _grantRole(OWNERS, newOwner);\n    _revokeRole(OWNERS, user);\n  }\n\n  // @dev: This accepts the push-pull method of onlyOwner()\n  function acceptOwnership()\n    external\n    virtual\n    override\n    onlyRole(PENDING_OWNERS) {\n    address user = msg.sender;\n    _revokeRole(PENDING_OWNERS, user);\n    _grantRole(OWNERS, user);\n  }\n\n  // @dev: This declines the push-pull method of onlyOwner()\n  function declineOwnership()\n    external\n    virtual\n    override\n    onlyRole(PENDING_OWNERS) {\n    address user = msg.sender;\n    _revokeRole(PENDING_OWNERS, user);\n  }\n\n  // @dev: This starts the push-pull method of onlyOwner()\n  // @param newOwner: addres of new pending developer role\n  function pushOwnership(\n    address newOwner\n  ) external\n    virtual\n    override\n    onlyRole(OWNERS) {\n    _grantRole(PENDING_OWNERS, newOwner);\n  }\n\n  // @dev: This changes the display of Ownership()\n  // @param newDisplay: new display addrss for Ownership()\n  function setOwner(\n    address newDisplay\n  ) external\n    onlyOwner() {\n    if (!_checkRole(OWNERS, newDisplay)) {\n        revert MaxSplaining({\n          reason: string(\n                    abi.encodePacked(\n                      \"MaxAccess: The address \",\n                      Strings.toHexString(uint160(newDisplay), 20),\n                      \" is not an owner and does not have the role \",\n                      Strings.toHexString(uint32(OWNERS), 4),\n                      \" there \",\n                      Strings.toHexString(uint160(msg.sender), 20)\n                    )\n                  )\n        });\n    }\n    TheOwner = newDisplay;\n  }\n}\n"
    },
    "/contracts/access/IRole.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: IRole.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for MaxAccess version of roles\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IRole is IERC165 {\n\n  // @dev: Returns `true` if `account` has been granted `role`.\n  // @param role: Bytes4 of a role\n  // @param account: Address to check\n  // @return: bool true/false if account has role\n  function hasRole(\n    bytes4 role\n  , address account\n  ) external\n    view\n    returns (bool);\n\n  // @dev: Returns the admin role that controls a role\n  // @param role: Role to check\n  // @return: admin role\n  function getRoleAdmin(\n    bytes4 role\n  ) external\n    view \n    returns (bytes4);\n\n  // @dev: Grants `role` to `account`\n  // @param role: Bytes4 of a role\n  // @param account: account to give role to\n  function grantRole(\n    bytes4 role\n  , address account\n  ) external;\n\n  // @dev: Revokes `role` from `account`\n  // @param role: Bytes4 of a role\n  // @param account: account to revoke role from\n  function revokeRole(\n    bytes4 role\n  , address account\n  ) external;\n\n  // @dev: Renounces `role` from `account`\n  // @param role: Bytes4 of a role\n  // @param account: account to renounce role from\n  function renounceRole(\n    bytes4 role\n  ) external;\n}\n"
    },
    "/contracts/access/IOwnerV2.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: IOwnerV2.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface V2 for onlyOwner() role, suggested by Auditors...\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IOwner.sol\";\n\ninterface IOwnerV2 is IOwner {\n\n  // @dev: This accepts the push-pull method of onlyOwner()\n  function acceptOwnership()\n    external;\n\n  // @dev: This declines the push-pull method of onlyOwner()\n  function declineOwnership()\n    external;\n\n  // @dev: This starts the push-pull method of onlyOwner()\n  // @param newOwner: addres of new pending owner role\n  function pushOwnership(\n    address newOwner\n  ) external;\n}\n"
    },
    "/contracts/access/IOwner.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#* \n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=: \n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%* \n *\n * @title: IOwner.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for onlyOwner() role\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IOwner is IERC165 {\n\n  // @dev: Classic \"EIP-173\" getter for owner()\n  // @return: owner of contract\n  function owner()\n    external\n    view\n    returns (address);\n\n  // @dev: This is the classic \"EIP-173\" method of setting onlyOwner()  \n  function renounceOwnership()\n    external;\n\n\n  // @dev: This is the classic \"EIP-173\" method of setting onlyOwner()\n  // @param newOwner: addres of new pending owner role\n  function transferOwnership(\n    address newOwner\n  ) external;\n}\n"
    },
    "/contracts/access/IDeveloperV2.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#*\n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=:\n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%*\n *\n * @title: IDeveloperV2.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface V2 for onlyDev() role, suggested by Auditors...\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./IDeveloper.sol\";\n\ninterface IDeveloperV2 is IDeveloper {\n\n  // @dev: This accepts the push-pull method of onlyDev()\n  function acceptDeveloper()\n    external;\n\n  // @dev: This declines the push-pull method of onlyDev()\n  function declineDeveloper()\n    external;\n\n  // @dev: This starts the push-pull method of onlyDev()\n  // @param newDeveloper: addres of new pending developer role\n  function pushDeveloper(\n    address newDeveloper\n  ) external;\n}\n"
    },
    "/contracts/access/IDeveloper.sol": {
      "content": "/*     +%%#-                           ##.        =+.    .+#%#+:       *%%#:    .**+-      =+\n *   .%@@*#*:                          @@: *%-   #%*=  .*@@=.  =%.   .%@@*%*   +@@=+=%   .%##\n *  .%@@- -=+                         *@% :@@-  #@=#  -@@*     +@-  :@@@: ==* -%%. ***   #@=*\n *  %@@:  -.*  :.                    +@@-.#@#  =@%#.   :.     -@*  :@@@.  -:# .%. *@#   *@#* \n * *%@-   +++ +@#.-- .*%*. .#@@*@#  %@@%*#@@: .@@=-.         -%-   #%@:   +*-   =*@*   -@%=: \n * @@%   =##  +@@#-..%%:%.-@@=-@@+  ..   +@%  #@#*+@:      .*=     @@%   =#*   -*. +#. %@#+*@\n * @@#  +@*   #@#  +@@. -+@@+#*@% =#:    #@= :@@-.%#      -=.  :   @@# .*@*  =@=  :*@:=@@-:@+\n * -#%+@#-  :@#@@+%++@*@*:=%+..%%#=      *@  *@++##.    =%@%@%%#-  =#%+@#-   :*+**+=: %%++%* \n *\n * @title: IDeveloper.sol\n * @author: Max Flow O2 -> @MaxFlowO2 on bird app/GitHub\n * @notice: Interface for onlyDev() role\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IDeveloper is IERC165 {\n\n\n  // @dev: Classic \"EIP-173\" but for onlyDev()\n  // @return: Developer of contract\n  function developer()\n    external\n    view\n    returns (address);\n\n  // @dev: This renounces your role as onlyDev()\n  function renounceDeveloper()\n    external;\n\n  // @dev: Classic \"EIP-173\" but for onlyDev()\n  // @param newDeveloper: addres of new pending Developer role\n  function transferDeveloper(\n    address newDeveloper\n  ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}