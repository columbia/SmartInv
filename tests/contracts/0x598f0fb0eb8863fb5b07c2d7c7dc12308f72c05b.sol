{{
  "language": "Solidity",
  "sources": {
    "contracts/token/SyntheticSyndicateERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"../utils/ERC20.sol\";\nimport \"../utils/AccessControl.sol\";\n\ncontract SyntheticSyndicateERC20 is ERC20(\"Synthetic Syndicate Token\", \"sSYNR\"), AccessControl {\n  /**\n   * @dev Smart contract unique identifier, a random number\n   * @dev Should be regenerated each time smart contact source code is changed\n   *      and changes smart contract itself is to be redeployed\n   * @dev Generated using https://www.random.org/bytes/\n   */\n  uint256 public constant TOKEN_UID = 0xac3051b8d4f50966afb632468a4f61483ae6a953b74e387a01ef94316d6b7d62;\n\n  uint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n  uint32 public constant ROLE_WHITE_LISTED_RECEIVER = 0x0004_0000;\n\n  constructor(address _superAdmin) AccessControl(_superAdmin) {}\n\n  /**\n   * @notice Must be called by ROLE_TOKEN_CREATOR addresses.\n   *\n   * @param recipient address to receive the tokens.\n   * @param amount number of tokens to be minted.\n   */\n  function mint(address recipient, uint256 amount) external {\n    require(isSenderInRole(ROLE_TOKEN_CREATOR), \"sSYNR: insufficient privileges (ROLE_TOKEN_CREATOR required)\");\n    _mint(recipient, amount);\n  }\n\n  /**\n   * @param amount number of tokens to be burned.\n   */\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /**\n   * @notice Must be called by ROLE_TOKEN_DESTROYER addresses (SynrSwapper)\n   *         Can burn only tokens owned by ROLE_WHITE_LISTED_RECEIVER address\n   * @param recipient address to burn the tokens.\n   * @param amount number of tokens to be burned\n   */\n  function burn(address recipient, uint256 amount) external {\n    require(isSenderInRole(ROLE_TOKEN_DESTROYER), \"sSYNR: insufficient privileges (ROLE_TOKEN_DESTROYER required)\");\n    require(isOperatorInRole(recipient, ROLE_WHITE_LISTED_RECEIVER), \"sSYNR: Non Allowed Receiver\");\n    _burn(recipient, amount);\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual override {\n    require(isOperatorInRole(recipient, ROLE_WHITE_LISTED_RECEIVER), \"sSYNR: Non Allowed Receiver\");\n    super._transfer(sender, recipient, amount);\n  }\n}\n"
    },
    "contracts/utils/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"../interfaces/IERC20.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\n\n// Copied from Open Zeppelin\n\ncontract ERC20 is IERC20 {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n   * @notice Token creator is responsible for creating (minting)\n   *      tokens to an arbitrary address\n   * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n   *      (calling `mint` function)\n   */\n  uint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n   * a default value of 18.\n   *\n   * To select a different value for {decimals}, use {_setupDecimals}.\n   *\n   * All three of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = 18;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n   * called.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * Requirements:\n   *\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender] - amount;\n    _balances[recipient] = _balances[recipient] + amount;\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply + amount;\n    _balances[account] = _balances[account] + amount;\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account] - amount;\n    _totalSupply = _totalSupply - amount;\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal virtual {\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "contracts/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\n// import \"hardhat/console.sol\";\n\n/**\n * @title Access Control List\n *\n * @notice Access control smart contract provides an API to check\n *      if specific operation is permitted globally and/or\n *      if particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable specific\n *      functions (public functions) of the smart contract for everyone.\n * @notice User roles are designed to restrict access to specific\n *      functions (restricted functions) of the smart contract to some users.\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @author Basil Gorin\n */\ncontract AccessControl {\n  /**\n   * @notice Access manager is responsible for assigning the roles to users,\n   *      enabling/disabling global features of the smart contract\n   * @notice Access manager can add, remove and update user roles,\n   *      remove and update global features\n   *\n   * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n   * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n   */\n  uint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n  /**\n   * @dev Bitmask representing all the possible permissions (super admin role)\n   * @dev Has all the bits are enabled (2^256 - 1 value)\n   */\n  // solhint-disable-next-line\n  uint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n  /**\n   * @notice Privileged addresses with defined roles/permissions\n   * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n   *      allow minting or burning tokens, transferring on behalf and so on\n   *\n   * @dev Maps user address to the permissions bitmask (role), where each bit\n   *      represents a permission\n   * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n   *      represents all possible permissions\n   * @dev Zero address mapping represents global features of the smart contract\n   */\n  mapping(address => uint256) public userRoles;\n\n  /**\n   * @dev Fired in updateRole() and updateFeatures()\n   *\n   * @param _by operator which called the function\n   * @param _to address which was granted/revoked permissions\n   * @param _requested permissions requested\n   * @param _actual permissions effectively set\n   */\n  event RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n  /**\n   * @notice Creates an access control instance,\n   *      setting contract creator to have full privileges\n   */\n  constructor(address _superAdmin) {\n    userRoles[_superAdmin] = FULL_PRIVILEGES_MASK;\n    userRoles[msg.sender] = FULL_PRIVILEGES_MASK;\n  }\n\n  /**\n   * @notice Retrieves globally set of features enabled\n   *\n   * @dev Auxiliary getter function to maintain compatibility with previous\n   *      versions of the Access Control List smart contract, where\n   *      features was a separate uint256 public field\n   *\n   * @return 256-bit bitmask of the features enabled\n   */\n  function features() public view returns (uint256) {\n    // according to new design features are stored in zero address\n    // mapping of `userRoles` structure\n    return userRoles[address(0)];\n  }\n\n  /**\n   * @notice Updates set of the globally enabled features (`features`),\n   *      taking into account sender's permissions\n   *\n   * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n   * @dev Function is left for backward compatibility with older versions\n   *\n   * @param _mask bitmask representing a set of features to enable/disable\n   */\n  function updateFeatures(uint256 _mask) public {\n    // delegate call to `updateRole`\n    updateRole(address(0), _mask);\n  }\n\n  /**\n   * @notice Updates set of permissions (role) for a given user,\n   *      taking into account sender's permissions.\n   *\n   * @dev Setting role to zero is equivalent to removing an all permissions\n   * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n   *      copying senders' permissions (role) to the user\n   * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n   *\n   * @param operator address of a user to alter permissions for or zero\n   *      to alter global features of the smart contract\n   * @param role bitmask representing a set of permissions to\n   *      enable/disable for a user specified\n   */\n  function updateRole(address operator, uint256 role) public {\n    // caller must have a permission to update user roles\n    require(isSenderInRole(ROLE_ACCESS_MANAGER), \"insufficient privileges (ROLE_ACCESS_MANAGER required)\");\n\n    // evaluate the role and reassign it\n    userRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n    // fire an event\n    emit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n  }\n\n  /**\n   * @notice Determines the permission bitmask an operator can set on the\n   *      target permission set\n   * @notice Used to calculate the permission bitmask to be set when requested\n   *     in `updateRole` and `updateFeatures` functions\n   *\n   * @dev Calculated based on:\n   *      1) operator's own permission set read from userRoles[operator]\n   *      2) target permission set - what is already set on the target\n   *      3) desired permission set - what do we want set target to\n   *\n   * @dev Corner cases:\n   *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n   *        `desired` bitset is returned regardless of the `target` permission set value\n   *        (what operator sets is what they get)\n   *      2) Operator with no permissions (zero bitset):\n   *        `target` bitset is returned regardless of the `desired` value\n   *        (operator has no authority and cannot modify anything)\n   *\n   * @dev Example:\n   *      Consider an operator with the permissions bitmask     00001111\n   *      is about to modify the target permission set          01010101\n   *      Operator wants to set that permission set to          00110011\n   *      Based on their role, an operator has the permissions\n   *      to update only lowest 4 bits on the target, meaning that\n   *      high 4 bits of the target set in this example is left\n   *      unchanged and low 4 bits get changed as desired:      01010011\n   *\n   * @param operator address of the contract operator which is about to set the permissions\n   * @param target input set of permissions to operator is going to modify\n   * @param desired desired set of permissions operator would like to set\n   * @return resulting set of permissions given operator will set\n   */\n  function evaluateBy(\n    address operator,\n    uint256 target,\n    uint256 desired\n  ) public view returns (uint256) {\n    // read operator's permissions\n    uint256 p = userRoles[operator];\n\n    // taking into account operator's permissions,\n    // 1) enable the permissions desired on the `target`\n    target |= p & desired;\n    // 2) disable the permissions desired on the `target`\n    target &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n    // return calculated result\n    return target;\n  }\n\n  /**\n   * @notice Checks if requested set of features is enabled globally on the contract\n   *\n   * @param required set of features to check against\n   * @return true if all the features requested are enabled, false otherwise\n   */\n  function isFeatureEnabled(uint256 required) public view returns (bool) {\n    // delegate call to `__hasRole`, passing `features` property\n    return __hasRole(features(), required);\n  }\n\n  /**\n   * @notice Checks if transaction sender `msg.sender` has all the permissions required\n   *\n   * @param required set of permissions (role) to check against\n   * @return true if all the permissions requested are enabled, false otherwise\n   */\n  function isSenderInRole(uint256 required) public view returns (bool) {\n    // delegate call to `isOperatorInRole`, passing transaction sender\n    return isOperatorInRole(msg.sender, required);\n  }\n\n  /**\n   * @notice Checks if operator has all the permissions (role) required\n   *\n   * @param operator address of the user to check role for\n   * @param required set of permissions (role) to check\n   * @return true if all the permissions requested are enabled, false otherwise\n   */\n  function isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n    // delegate call to `__hasRole`, passing operator's permissions (role)\n    return __hasRole(userRoles[operator], required);\n  }\n\n  /**\n   * @dev Checks if role `actual` contains all the permissions required `required`\n   *\n   * @param actual existent role\n   * @param required required role\n   * @return true if actual has required role (all permissions), false otherwise\n   */\n  function __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\n    // check the bitmask for the role required and return the result\n    return actual & required == required;\n  }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}