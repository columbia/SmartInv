{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n"},"CyberGorillas.sol":{"content":"// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./ERC721.sol\";\nimport \"./Strings.sol\";\nimport \"./Ownable.sol\";\n\nerror SoldOut();\nerror SaleClosed();\nerror InvalidMintParameters();\nerror MintingTooMany();\nerror NotWhitelisted();\nerror NotAuthorized();\n\n/*\n   ______      __              ______           _ ____          \n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\n / /   / / / / __ \\/ _ \\/ ___/ / __/ __ \\/ ___/ / / / __ `/ ___/\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \n\\____/\\__, /_.___/\\___/_/   \\____/\\____/_/  /_/_/_/\\__,_/____/  \n     /____/                                                     \n\n*/\n\n/// @author distractedm1nd\ncontract CyberGorillas is ERC721, Ownable {\n    using Strings for uint256;\n    address private passwordSigner;\n    address private gorillaBurner;\n\n    bool publicSaleActive;\n\n    uint256 constant PRESALE_MAX_TX = 2;\n    uint256 constant PUBLIC_MAX_TX = 5;\n    uint256 constant public MAX_SUPPLY = 3333;\n    uint256 constant PRICE = 0.08 ether;\n\n    string public baseURI;\n\n    mapping (address =\u003e uint256) private presaleWalletLimits;\n    mapping (address =\u003e uint256) private mainsaleWalletLimits;\n\n    constructor(string memory initialBaseURI, address initialPasswordSigner) ERC721(\"Cyber Gorillas\", \"CyberGorillas\"){\n        baseURI = initialBaseURI;\n        passwordSigner = initialPasswordSigner;\n    }\n\n    function airdrop(address[] calldata airdropAddresses) public onlyOwner {\n        for(uint256 i = 0; i \u003c airdropAddresses.length; i++) {\n            _mint(airdropAddresses[i], totalSupply);\n        }\n    }\n\n    function setGorilliaBurner(address newGorillaBurner) public onlyOwner {\n        gorillaBurner = newGorillaBurner;\n    }\n\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseURI = newBaseURI;\n    }\n\n    function setPasswordSigner(address signer) public onlyOwner {\n        passwordSigner = signer;\n    }\n\n    function setPublicSale(bool publicSale) public onlyOwner {\n        publicSaleActive = publicSale;\n    }\n\n    function purchase(uint256 amount) public payable {\n        if(!publicSaleActive) revert SaleClosed();\n        if(totalSupply + amount \u003e MAX_SUPPLY) revert SoldOut();\n        if(mainsaleWalletLimits[msg.sender] + amount \u003e PUBLIC_MAX_TX || msg.value \u003c PRICE * amount) revert InvalidMintParameters(); \n\n        mainsaleWalletLimits[msg.sender] += amount;\n        for(uint256 i = 0; i \u003c amount; i++) {\n            _mint(msg.sender, totalSupply);\n        }\n    }\n\n    function presale(uint256 amount, bytes memory signature) public payable {\n        if(publicSaleActive) revert SaleClosed();\n        if(totalSupply + amount \u003e MAX_SUPPLY) revert SoldOut();\n        if(!isWhitelisted(msg.sender, signature)) revert NotWhitelisted();\n        if(presaleWalletLimits[msg.sender] + amount \u003e PRESALE_MAX_TX || msg.value \u003c PRICE * amount) revert InvalidMintParameters(); \n\n        presaleWalletLimits[msg.sender] += amount;\n        for(uint256 i = 0; i \u003c amount; i++) {\n            _mint(msg.sender, totalSupply);\n        }\n    }\n\n    function withdraw(address payable recipient) external onlyOwner {\n        recipient.transfer(address(this).balance);\n    }\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        return bytes(baseURI).length \u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), \".json\")) : \"\";\n    }\n\n    function isWhitelisted(address user, bytes memory signature) public view returns (bool) {\n        bytes32 messageHash = keccak256(abi.encode(user));\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n        return recoverSigner(ethSignedMessageHash, signature) == passwordSigner;\n    }\n\n    function getEthSignedMessageHash(bytes32 _messageHash) private pure returns (bytes32) {\n        /*\n        Signature is produced by signing a keccak256 hash with the following format:\n        \"\\x19Ethereum Signed Message\\n\" + len(msg) + msg\n        */\n        return\n        keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash)\n        );\n    }\n\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) private pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function recoverSignerTest(bytes32 _ethSignedMessageHash, bytes memory _signature) private pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig) private pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"sig invalid\");\n\n        assembly {\n        /*\n        First 32 bytes stores the length of the signature\n\n        add(sig, 32) = pointer of sig + 32\n        effectively, skips first 32 bytes of signature\n\n        mload(p) loads next 32 bytes starting at the memory address p into memory\n        */\n\n        // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n        // second 32 bytes\n            s := mload(add(sig, 64))\n        // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n\n    function burn(uint tokenId) public {\n        if(msg.sender != gorillaBurner) revert NotAuthorized();\n        _burn(tokenId);\n    }\n}\n\n"},"ERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\n/// including the MetaData, and partially, Enumerable extensions.\n/// @author from an unmerged solmate PR from z0r0z \u0026 distractedm1nd\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n    \n    string public name;\n\n    string public symbol;\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC-721 STORAGE\n    //////////////////////////////////////////////////////////////*/\n    \n    uint256 public totalSupply;\n    \n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(uint256 =\u003e address) public ownerOf;\n\n    mapping(uint256 =\u003e address) public getApproved;\n\n    mapping(address =\u003e mapping(address =\u003e bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                            EIP-2612-LIKE STORAGE\n    //////////////////////////////////////////////////////////////*/\n    \n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n\n    bytes32 public constant PERMIT_ALL_TYPEHASH = \n        keccak256(\"Permit(address owner,address spender,uint256 nonce,uint256 deadline)\");\n    \n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(uint256 =\u003e uint256) public nonces;\n\n    mapping(address =\u003e uint256) public noncesForAll;\n    \n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n    \n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n        \n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC-20-LIKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transfer(address to, uint256 tokenId) public virtual returns (bool success) {\n        require(msg.sender == ownerOf[tokenId], \"NOT_OWNER\");\n        \n        // Cannot overflow because because ownership is checked\n        // against decrement, and sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[msg.sender]--; \n        \n            balanceOf[to]++;\n        }\n        \n        delete getApproved[tokenId];\n        \n        ownerOf[tokenId] = to;\n        \n        emit Transfer(msg.sender, to, tokenId); \n        \n        success = true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC-721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool supported) {\n        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f || interfaceId == 0x01ffc9a7;\n    }\n    \n    function approve(address spender, uint256 tokenId) public virtual {\n        address owner = ownerOf[tokenId];\n        \n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_APPROVED\");\n        \n        getApproved[tokenId] = spender;\n        \n        emit Approval(owner, spender, tokenId); \n    }\n    \n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        \n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    \n    function transferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) public virtual {\n        require(from == ownerOf[tokenId], \u0027NOT_OWNER\u0027);\n        \n        require(\n            msg.sender == from \n            || msg.sender == getApproved[tokenId]\n            || isApprovedForAll[from][msg.sender], \n            \u0027NOT_APPROVED\u0027\n        );\n        \n        // this is safe because ownership is checked\n        // against decrement, and sum of all user\n        // balances can\u0027t exceed \u0027type(uint256).max\u0027\n        unchecked { \n            balanceOf[from]--; \n        \n            balanceOf[to]++;\n        }\n        \n        delete getApproved[tokenId];\n        \n        ownerOf[tokenId] = to;\n        \n        emit Transfer(from, to, tokenId); \n    }\n    \n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) public virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n    \n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId, \n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, tokenId); \n        \n        if (to.code.length \u003e 0) {\n            // selector = \"onERC721Received(address,address,uint256,bytes)\".\n            (, bytes memory returned) = to.staticcall(abi.encodeWithSelector(0x150b7a02,\n                msg.sender, from, tokenId, data));\n                \n            bytes4 selector = abi.decode(returned, (bytes4));\n            \n            require(selector == 0x150b7a02, \u0027NOT_ERC721_RECEIVER\u0027);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            EIP-2612-LIKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n    \n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp \u003c= deadline, \"PERMIT_DEADLINE_EXPIRED\");\n        \n        address owner = ownerOf[tokenId];\n        \n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonces[tokenId]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0), \"INVALID_PERMIT_SIGNATURE\");\n\n            require(recoveredAddress == owner || isApprovedForAll[owner][recoveredAddress], \"INVALID_SIGNER\");\n        }\n        \n        getApproved[tokenId] = spender;\n\n        emit Approval(owner, spender, tokenId);\n    }\n    \n    function permitAll(\n        address owner,\n        address operator,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp \u003c= deadline, \"PERMIT_DEADLINE_EXPIRED\");\n        \n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_ALL_TYPEHASH, owner, operator, noncesForAll[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            \n            require(\n                (recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress],\n                \u0027INVALID_PERMIT_SIGNATURE\u0027\n            );\n        }\n        \n        isApprovedForAll[owner][operator] = true;\n\n        emit ApprovalForAll(owner, operator, true);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 domainSeparator) {\n        domainSeparator = block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32 domainSeparator) {\n        domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n    \n    function _mint(\n        address to, \n        uint256 tokenId\n    ) internal virtual { \n        require(ownerOf[tokenId] == address(0), \"ALREADY_MINTED\");\n  \n        // Cannot realistically overflow from incrementing total supply beyond\n        // the max uint256 value, and because the sum of all user balances \n        // can\u0027t exceed the max uint256 value.\n        unchecked {\n            totalSupply++;\n            \n            balanceOf[to]++;\n        }\n        \n        ownerOf[tokenId] = to;\n        \n        emit Transfer(address(0), to, tokenId); \n    }\n    \n    function _burn(uint256 tokenId) internal virtual { \n        address owner = ownerOf[tokenId];\n        \n        require(ownerOf[tokenId] != address(0), \"NOT_MINTED\");\n        \n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply--;\n        \n            balanceOf[owner]--;\n        }\n        \n        delete ownerOf[tokenId];\n        \n        emit Transfer(owner, address(0), tokenId); \n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n"},"Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\u0027s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp \u003e\u003e= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value \u0026 0xf];\n            value \u003e\u003e= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n"}}