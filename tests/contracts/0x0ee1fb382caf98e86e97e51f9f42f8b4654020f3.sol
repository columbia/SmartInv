{{
  "language": "Solidity",
  "sources": {
    "/contracts/Claim_Codes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IVesting.sol\";\n\n// Structs are used here as they do not incur any overhead, and\n// make the function specifications below less tedious\n\nstruct Claim {\n  uint256 amount;\n  uint8 tranche;\n  uint32 expiry;\n  // This is simply here for reference. Solidity does not have optional params\n  // and after the London fork, zero bytes are charged more in calldata, so we\n  // simply leave it out of the struct and add it as an argument where it's\n  // needed\n  /* address optionalTarget; */\n}\n\n// ECDSA signature as struct\nstruct Signature {\n  uint8 v; // Must be 27 or 28\n  bytes32 r;\n  bytes32 s; // Must be small order\n}\n\nfunction hash_claim (\n  uint chainid,\n  Claim calldata c,\n  address target\n) pure returns (bytes32) {\n  bytes memory _msg = abi.encodePacked(chainid, c.amount, c.tranche, c.expiry);\n  if (target != address(0)) {\n    _msg = abi.encodePacked(_msg, target);\n  }\n\n  return keccak256(_msg);\n}\n\ncontract Claim_Codes {\n  // Only address able to perform management operations\n  address public controller;\n\n  // Vega vesting contract, which must have this contract registered as an\n  // issuer for `issue_into_tranche` to work. Marked immutable to assist the\n  // solidity compiler in inlining\n  IVesting immutable trusted_vesting_contract;\n\n  // Track committed and spent signatures (codes). The next constants are used\n  // as special placeholders. Note that uninitialised slots in a map always will\n  // have the default value (eg address 0x0 in this case)\n  mapping (bytes32 => address) public commitments;\n  address constant UNCLAIMED_CODE = address(0);\n  address constant SPENT_CODE = address(1);\n\n  // Map issuers to their max allowed spending. We may consider here whether we\n  // actually care about limiting each issuer (signer) spending or not\n  mapping (address => uint256) public issuers;\n\n  // Allow list of countries that can use claim codes. Mapping uppercase ascii\n  // ISO 2-letter country codes.\n  mapping (bytes2 => bool) public allowed_countries;\n\n  constructor (address vesting_address) {\n    trusted_vesting_contract = IVesting(vesting_address);\n    controller = msg.sender;\n  }\n\n  // To prevent front running on untargeted codes, the user can precommit to the\n  // S part of the signature (ie. the one-time key)\n  function commit_untargeted (bytes32 s) external {\n    require(commitments[s] == UNCLAIMED_CODE);\n    commitments[s] = msg.sender;\n  }\n\n  // Since solidity/web3 do not support optional arguments, we must have a\n  // separate function with and without the target argument\n  function claim_targeted (\n    Signature calldata sig,\n    Claim calldata clm,\n    bytes2 country,\n    address target\n  ) external {\n    _claim(sig, clm, target, country);\n  }\n\n  function claim_untargeted (\n    Signature calldata sig,\n    Claim calldata clm,\n    bytes2 country\n  ) external {\n    _claim(sig, clm, address(0), country);\n  }\n\n  function _claim (\n    Signature calldata sig,\n    Claim calldata clm,\n    address target,\n    bytes2 country\n  ) internal {\n    require(clm.expiry > block.timestamp, \"Claim code has expired\");\n    require(allowed_countries[country], \"Claim code is not available in your country\");\n\n    // Verify the claim was signed by an issuer\n    bytes32 hash = hash_claim(block.chainid, clm, target);\n    address issuer = verify(hash, sig);\n    require(issuer != address(0), \"Invalid claim code\");\n\n    // Burn the claim\n    target = burn_claim(sig, target);\n\n    require(issuer != target, \"Cannot claim to yourself\");\n    uint256 issuer_amount = issuers[issuer];\n    require(clm.amount <= issuer_amount, \"Out of funds\");\n    issuers[issuer] = issuer_amount - clm.amount;\n\n    trusted_vesting_contract.issue_into_tranche(target, clm.tranche, clm.amount);\n  }\n\n  function allow_countries (\n    bytes2[] calldata countries\n  ) only_controller external {\n    for (uint i = 0; i < countries.length; i++) {\n      allowed_countries[countries[i]] = true;\n    }\n  }\n\n  function block_countries (\n    bytes2[] calldata countries\n  ) only_controller external {\n    for (uint i = 0; i < countries.length; i++) {\n      allowed_countries[countries[i]] = false;\n    }\n  }\n\n  function permit_issuer (address issuer, uint256 amount) only_controller external {\n    issuers[issuer] = amount;\n  }\n\n  function revoke_issuer (address issuer) only_controller external {\n    delete(issuers[issuer]);\n  }\n\n  function swap_controller(address _controller) only_controller external {\n    require(_controller != address(0));\n    controller = _controller;\n  }\n\n  function destroy () only_controller external {\n    selfdestruct(payable(msg.sender));\n  }\n\n  // Strict ECDSA recovery;\n  // - Only allow small-order s\n  // - Only allow correct v encoding (27 or 28)\n  function verify (\n    bytes32 hash,\n    Signature calldata _sig\n  ) internal pure returns (address) {\n    if (_sig.s > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) return address(0);\n    return ecrecover(hash, _sig.v, bytes32(_sig.r), bytes32(_sig.s));\n  }\n\n  function burn_claim (\n    Signature calldata sig,\n    address target\n  ) internal returns (address) {\n    address _tmp = commitments[sig.s];\n\n    // If targeted code, just check that it's unspent\n    if (target != address(0)) {\n      require(_tmp != SPENT_CODE, \"Claim code already spent\");\n    }\n    // If untargeted, check that it was committed or unspent\n    else {\n      require(_tmp == msg.sender || _tmp == UNCLAIMED_CODE, \"Claim code already spent\");\n      target = msg.sender;\n    }\n\n    commitments[sig.s] = SPENT_CODE;\n    return target;\n  }\n\n  modifier only_controller () {\n    require(msg.sender == controller);\n    _;\n  }\n}\n"
    },
    "/contracts/IVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IVesting {\n  function issue_into_tranche (\n    address user,\n    uint8 tranche,\n    uint256 amount\n  ) external;\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}