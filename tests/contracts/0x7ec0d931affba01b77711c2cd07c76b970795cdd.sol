{{
  "language": "Solidity",
  "sources": {
    "contracts/Stabilizer.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./SafeMath.sol\";\nimport \"./ERC20.sol\";\n\ninterface IStrat {\n    function invest() external; // underlying amount must be sent from vault to strat address before\n    function divest(uint amount) external; // should send requested amount to vault directly, not less or more\n    function calcTotalValue() external returns (uint);\n    function underlying() external view returns (address);\n}\n\n// WARNING: This contract assumes synth and reserve are equally valuable and share the same decimals (e.g. Dola and Dai)\n// DO NOT USE WITH USDC OR USDT\n// DO NOT USE WITH NON-STANDARD ERC20 TOKENS\ncontract Stabilizer {\n    using SafeMath for uint;\n\n    uint public constant MAX_FEE = 1000; // 10%\n    uint public constant FEE_DENOMINATOR = 10000;\n    uint public buyFee;\n    uint public sellFee;\n    uint public supplyCap;\n    uint public supply;\n    ERC20 public synth;\n    ERC20 public reserve;\n    address public operator;\n    IStrat public strat;\n    address public governance;\n\n    constructor(ERC20 synth_, ERC20 reserve_, address gov_, uint buyFee_, uint sellFee_, uint supplyCap_) public {\n        require(buyFee_ <= MAX_FEE, \"buyFee_ too high\");\n        require(sellFee_ <= MAX_FEE, \"sellFee_ too high\");\n        synth = synth_;\n        reserve = reserve_;\n        governance = gov_;\n        buyFee = buyFee_;\n        sellFee = sellFee_;\n        operator = msg.sender;\n        supplyCap = supplyCap_;\n    }\n\n    modifier onlyOperator {\n        require(msg.sender == operator || msg.sender == governance, \"ONLY OPERATOR OR GOV\");\n        _;\n    }\n\n    modifier onlyGovernance {\n        require(msg.sender == governance, \"ONLY GOV\");\n        _;\n    }\n\n    function setOperator(address operator_) public {\n        require(msg.sender == governance || msg.sender == operator, \"ONLY GOV OR OPERATOR\");\n        require(operator_ != address(0), \"NO ADDRESS ZERO\");\n        operator = operator_;\n    }\n\n    function setBuyFee(uint amount) public onlyGovernance {\n        require(amount <= MAX_FEE, \"amount too high\");\n        buyFee = amount;\n    }\n\n    function setSellFee(uint amount) public onlyGovernance {\n        require(amount <= MAX_FEE, \"amount too high\");\n        sellFee = amount;\n    }\n    \n    function setCap(uint amount) public onlyOperator {\n        supplyCap = amount;\n    }\n\n    function setGovernance(address gov_) public onlyGovernance {\n        require(gov_ != address(0), \"NO ADDRESS ZERO\");\n        governance = gov_;\n    }\n\n    function setStrat(IStrat newStrat) public onlyGovernance {\n        require(newStrat.underlying() == address(reserve), \"Invalid strat\");\n        if(address(strat) != address(0)) {\n            uint prevTotalValue = strat.calcTotalValue();\n            strat.divest(prevTotalValue);\n        }\n        reserve.transfer(address(newStrat), reserve.balanceOf(address(this)));\n        newStrat.invest();\n        strat = newStrat;\n    }\n\n    function removeStrat() public onlyGovernance {\n        uint prevTotalValue = strat.calcTotalValue();\n        strat.divest(prevTotalValue);\n\n        strat = IStrat(address(0));\n    }\n\n    function takeProfit() public {\n        uint totalReserves = getTotalReserves();\n        if(totalReserves > supply) {\n            uint profit = totalReserves - supply; // underflow prevented by if condition\n            if(address(strat) != address(0)) {\n                uint bal = reserve.balanceOf(address(this));\n                if(bal < profit) {\n                    strat.divest(profit - bal); // underflow prevented by if condition\n                }\n            }\n            reserve.transfer(governance, profit);\n        }\n    }\n\n    function buy(uint amount) public {\n        require(supply.add(amount) <= supplyCap, \"supply exceeded cap\");\n        if(address(strat) != address(0)) {\n            reserve.transferFrom(msg.sender, address(strat), amount);\n            strat.invest();\n        } else {\n            reserve.transferFrom(msg.sender, address(this), amount);\n        }\n\n        if(buyFee > 0) {\n            uint fee = amount.mul(buyFee).div(FEE_DENOMINATOR);\n            reserve.transferFrom(msg.sender, governance, fee);\n            emit Buy(msg.sender, amount, amount.add(fee));\n        } else {\n            emit Buy(msg.sender, amount, amount);\n        }\n\n        synth.mint(msg.sender, amount);\n        supply = supply.add(amount);\n    }\n\n    function sell(uint amount) public {\n        synth.transferFrom(msg.sender, address(this), amount);\n        synth.burn(amount);\n\n        uint reserveBal = reserve.balanceOf(address(this));\n        if(address(strat) != address(0) && reserveBal < amount) {\n            strat.divest(amount - reserveBal); // underflow prevented by if condition\n        }\n\n        uint afterFee;\n        if(sellFee > 0) {\n            uint fee = amount.mul(sellFee).div(FEE_DENOMINATOR);\n            afterFee = amount.sub(fee);\n            reserve.transfer(governance, fee);\n        } else {\n            afterFee = amount;\n        }\n        \n        reserve.transfer(msg.sender, afterFee);\n        supply = supply.sub(amount);\n        emit Sell(msg.sender, amount, afterFee);\n    }\n\n    function rescue(ERC20 token) public onlyGovernance {\n        require(token != reserve, \"RESERVE CANNOT BE RESCUED\");\n        token.transfer(governance, token.balanceOf(address(this)));\n    }\n\n    function getTotalReserves() internal returns (uint256 bal) { // new view function because strat.calcTotalValue() is not view function\n        bal = reserve.balanceOf(address(this));\n        if(address(strat) != address(0)) {\n            bal = bal.add(strat.calcTotalValue());\n        }\n    }\n\n    event Buy(address indexed user, uint purchased, uint spent);\n    event Sell(address indexed user, uint sold, uint received);\n}"
    },
    "contracts/SafeMath.sol": {
      "content": "pragma solidity ^0.5.16;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/ERC20.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"./SafeMath.sol\";\n\ncontract ERC20 {\n    using SafeMath for uint;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint  public totalSupply;\n    address public operator;\n    address public pendingOperator;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    mapping (address => bool) public minters;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event AddMinter(address indexed minter);\n    event RemoveMinter(address indexed minter);\n    event ChangeOperator(address indexed newOperator);\n\n    modifier onlyOperator {\n        require(msg.sender == operator, \"ONLY OPERATOR\");\n        _;\n    }\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) public {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n        operator = msg.sender;\n        uint chainId;\n        assembly {\n            chainId := chainid\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function setPendingOperator(address newOperator_) public onlyOperator {\n        pendingOperator = newOperator_;\n    }\n\n    function claimOperator() public {\n        require(msg.sender == pendingOperator, \"ONLY PENDING OPERATOR\");\n        operator = pendingOperator;\n        pendingOperator = address(0);\n        emit ChangeOperator(operator);\n    }\n\n    function addMinter(address minter_) public onlyOperator {\n        minters[minter_] = true;\n        emit AddMinter(minter_);\n    }\n\n    function removeMinter(address minter_) public onlyOperator {\n        minters[minter_] = false;\n        emit RemoveMinter(minter_);\n    }\n\n    function mint(address to, uint amount) public {\n        require(minters[msg.sender] == true || msg.sender == operator, \"ONLY MINTERS OR OPERATOR\");\n        _mint(to, amount);\n    }\n\n    function burn(uint amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}