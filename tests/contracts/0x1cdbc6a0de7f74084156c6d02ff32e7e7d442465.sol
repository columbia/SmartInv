{{
  "language": "Solidity",
  "sources": {
    "src/Gachapon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM`MMM NMM MMM MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMhMMMMMMM  MMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MM-MMMMM   MMMM    MMMM   lMMMDMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMM jMMMMl   MM    MMM  M  MMM   M   MMMM MMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMM  , `     M   Y   MM  MMM  BMMMMMM MMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMM MMMMMMMMMMMM  IM  MM  l  MMM  X   MM.  MMMMMMMMMM MMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.nlMMMMMMMMMMMMMMMMM]._  MMMMMMMMMMMMMMMNMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMM TMMMMMMMMMMMMMMMMMM          +MMMMMMMMMMMM:  rMMMMMMMMN MMMMMMMMMMMMMM\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMM                  MMMMMM           MMMMMMMM qMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMM^                   MMMb              .MMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMM MMMMMMMMMMMMMMM                     MM                  MMMMMMM MMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                     M                   gMMMMMMMMMMMMMMMMM\n// MMMMMMMMu MMMMMMMMMMMMMMM                                           MMMMMMM .MMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           :MMMMMMMMMMMMMMMM\n// MMMMMMM^ MMMMMMMMMMMMMMMl                                            MMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\n// MMMMMMM MMMMMMMMMMMMMMMM                                             MMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\n// MMMMMMr MMMMMMMMMMMMMMMM                                             MMMMMMMM .MMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           MMMMMMMMMMMMMMMMM\n// MMMMMMM MMMMMMMMMMMMMMMMM                                         DMMMMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                              MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMM|`MMMMMMMMMMMMMMMM         q                      MMMMMMMMMMMMMMMMMMM  MMMMMMM\n// MMMMMMMMMTMMMMMMMMMMMMMMM                               qMMMMMMMMMMMMMMMMMMgMMMMMMMMM\n// MMMMMMMMq MMMMMMMMMMMMMMMh                             jMMMMMMMMMMMMMMMMMMM nMMMMMMMM\n// MMMMMMMMMM MMMMMMMMMMMMMMMQ      nc    -MMMMMn        MMMMMMMMMMMMMMMMMMMM MMMMMMMMMM\n// MMMMMMMMMM.MMMMMMMMMMMMMMMMMMl            M1       `MMMMMMMMMMMMMMMMMMMMMMrMMMMMMMMMM\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMM               :MMMMMMMMMM MMMMMMMMMMMM qMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMX       MMMMMMMMMMMMMMM  uMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMM DMMMMMMMMM   IMMMMMMMMMMMMMMMMMMMMMMM   M   Y  MMMMMMMN MMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMM MMMMMM    ``    M      MM  MMM   , MMMM    Mv  MMM MMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMM MMh  Ml  .   M  MMMM  I  MMMT  M     :M   ,MMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMt  MM  MMMMB m  ]MMM  MMMM   MMMMMM MMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMM MMMMM  MMM   TM   MM  9U  .MM  _MMMMM MMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM YMMMMMMMn     MMMM    +MMMMMMM1`MMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.`MMM MMM MMMMM`.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM author: phaze MMM\n\nimport {Strings} from \"../lib/openzeppelin-contracts/contracts/utils/Strings.sol\";\nimport {IERC20} from \"../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport {IERC721} from \"../lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol\";\nimport {IERC721Metadata} from \"../lib/openzeppelin-contracts/contracts/interfaces/IERC721Metadata.sol\";\n\nimport {IGouda, IMadMouse} from \"./lib/interfaces.sol\";\nimport {Ownable} from \"./lib/Ownable.sol\";\nimport {Choice} from \"./lib/Choice.sol\";\n\nimport {SoulboundTickets as Tickets} from \"./SoulboundTickets.sol\";\n\nerror RaffleNotActive();\nerror RaffleOngoing();\nerror RaffleRandomSeedSet();\nerror RaffleAlreadyCancelled();\nerror TicketsMaxSupplyReached();\n\nerror RaffleUnrevealed();\nerror PrizeAlreadyClaimed();\n\nerror BetterLuckNextTime();\nerror MachineBeDoinWork();\nerror NeedsMoarTickets();\nerror TicketsImplementationUnset();\nerror InvalidTimestamps();\nerror InvalidTicketPrice();\nerror RequirementNotFulfilled();\n\nerror ContractCallNotAllowed();\n\ncontract Gachapon is Ownable {\n    using Strings for uint256;\n\n    event Chachingg();\n    event GrappleGrapple();\n    event BZZzzt();\n\n    struct Raffle {\n        address prizeNFT;\n        uint40 start;\n        uint40 end;\n        uint16 ticketPrice; // in multiples of 1e18\n        // first slot\n        uint16 ticketSupply;\n        uint16 maxTicketSupply;\n        uint8 refundRate; // set in range [0, 2^8 - 1] (0, 100%)\n        uint8 requirement;\n        bool cancelled;\n        uint40 randomSeed;\n        address tickets;\n        // second slot\n        uint32[] prizeTokenIds;\n    }\n\n    string ticketURI = \"ipfs://QmSwrzsySKnkQmRQoZYmZ2XuJx3NMn2awdHwf1fezAJbq3/silver-ticket.json\";\n    string losingTicketURI = \"ipfs://QmSwrzsySKnkQmRQoZYmZ2XuJx3NMn2awdHwf1fezAJbq3/red-ticket.json\";\n    string winningTicketURI = \"ipfs://QmSwrzsySKnkQmRQoZYmZ2XuJx3NMn2awdHwf1fezAJbq3/gold-ticket.json\";\n\n    address ticketsImplementation;\n\n    uint256 public numRaffles;\n    mapping(uint256 => Raffle) private raffles;\n    mapping(address => uint256) public ticketsToRaffleId;\n    mapping(uint256 => uint256) requestIdToLot;\n\n    mapping(uint256 => mapping(uint256 => bool)) public claimedPrize;\n\n    uint256 constant ONE_MONTH = 3600 * 24 * 28;\n\n    IGouda constant gouda = IGouda(0x3aD30C5E3496BE07968579169a96f00D56De4C1A);\n    IMadMouse constant genesis = IMadMouse(0x3aD30c5e2985e960E89F4a28eFc91BA73e104b77);\n    IMadMouse constant troupe = IMadMouse(0x74d9d90a7fc261FBe92eD47B606b6E0E00d75E70);\n\n    /* ------------- External ------------- */\n\n    function buyTicket(uint256 raffleId, uint256 requirementData) external noContract {\n        unchecked {\n            Raffle storage raffle = raffles[raffleId];\n            uint256 ticketSupply = raffle.ticketSupply;\n\n            if (ticketSupply == raffle.maxTicketSupply) revert TicketsMaxSupplyReached();\n            if (block.timestamp < raffle.start || raffle.end < block.timestamp || raffle.cancelled)\n                revert RaffleNotActive();\n\n            uint256 requirement = raffle.requirement;\n            if (requirement != 0 && !fulfillsRequirement(msg.sender, requirement, requirementData))\n                revert RequirementNotFulfilled();\n\n            // verifies ownership\n            gouda.burnFrom(msg.sender, uint256(raffle.ticketPrice) * 1e18);\n\n            uint256 ticketId = ++ticketSupply;\n            raffle.ticketSupply = uint16(ticketSupply);\n\n            Tickets(raffle.tickets).mint(msg.sender, ticketId);\n        }\n    }\n\n    function claimPrize(uint256 raffleId, uint256 ticketId) external noContract {\n        Raffle storage raffle = raffles[raffleId];\n        Tickets tickets = Tickets(raffle.tickets);\n\n        uint256 randomSeed = raffle.randomSeed;\n\n        if (raffle.cancelled) revert RaffleNotActive();\n        if (randomSeed == 0) revert RaffleUnrevealed();\n\n        uint256 numPrizes = raffle.prizeTokenIds.length;\n        uint256 numEntries = raffle.ticketSupply;\n        bool win;\n        uint256 prizeId;\n\n        // ticketId starts at 1; ownerOf is checked, so underflow is no issue\n        unchecked {\n            (win, prizeId) = Choice.indexOfSelectNOfM(ticketId - 1, numPrizes, numEntries, randomSeed);\n        }\n\n        if (tickets.ownerOf(ticketId) != msg.sender || !win) revert BetterLuckNextTime();\n\n        uint256 prizeTokenId = raffle.prizeTokenIds[prizeId];\n\n        // encode whether the user has claimed in with the tokenId by setting the first bit; saves a cold sload/sstore\n        if (prizeTokenId > 0x7fffffff) revert PrizeAlreadyClaimed();\n        raffle.prizeTokenIds[prizeId] = uint32(prizeTokenId) | 0x80000000;\n\n        IERC721 prizeNFT = IERC721(raffle.prizeNFT);\n        prizeNFT.transferFrom(owner(), msg.sender, prizeTokenId & 0x0fffffff);\n    }\n\n    function burnTickets(uint256[] calldata burnRaffleIds, uint256[] calldata burnTicketIds) external noContract {\n        Raffle storage raffle;\n\n        uint256 refund;\n        uint256 refundRate;\n\n        uint256 numBurnTickets = burnTicketIds.length;\n        if (numBurnTickets == 0) revert NeedsMoarTickets();\n\n        unchecked {\n            for (uint256 i; i < numBurnTickets; ++i) {\n                raffle = raffles[burnRaffleIds[i]];\n                Tickets tickets = Tickets(raffle.tickets);\n\n                tickets.burnFrom(msg.sender, burnTicketIds[i]);\n\n                refundRate = raffle.refundRate;\n                // type(uint40).max * 1e18 * type(uint8).max < type(uint256).max\n                if (refundRate > 0) refund += (uint256(raffle.ticketPrice) * 1e18 * (refundRate + 1)) >> 8; // slight imprecission is ok\n            }\n        }\n\n        gouda.mint(msg.sender, refund);\n    }\n\n    /* ------------- View ------------- */\n\n    function isWinningTicket(uint256 raffleId, uint256 ticketId) public view returns (bool win) {\n        Raffle storage raffle = raffles[raffleId];\n        uint256 randomSeed = raffle.randomSeed;\n\n        if (raffle.cancelled || randomSeed == 0) return false;\n\n        uint256 numPrizes = raffle.prizeTokenIds.length;\n        uint256 numEntrants = raffle.ticketSupply;\n\n        unchecked {\n            (win, ) = Choice.indexOfSelectNOfM(ticketId - 1, numPrizes, numEntrants, randomSeed);\n        }\n        return win;\n    }\n\n    function getWinningTickets(uint256 raffleId) public view returns (uint256[] memory ticketIds) {\n        Raffle storage raffle = raffles[raffleId];\n\n        uint256 randomSeed = raffle.randomSeed;\n\n        if (raffle.cancelled || randomSeed == 0) return ticketIds;\n\n        uint256 numPrizes = raffle.prizeTokenIds.length;\n        uint256 numEntrants = raffle.ticketSupply;\n\n        return Choice.selectNOfM(numPrizes, numEntrants, randomSeed, 1);\n    }\n\n    function getWinners(uint256 raffleId) public view returns (address[] memory winners) {\n        Tickets tickets = Tickets(raffles[raffleId].tickets);\n\n        uint256[] memory prizeTokenIds = getWinningTickets(raffleId);\n        uint256 numIds = prizeTokenIds.length;\n\n        winners = new address[](numIds);\n        for (uint256 i; i < numIds; ++i) winners[i] = tickets.ownerOf(prizeTokenIds[i]);\n    }\n\n    function getRaffle(uint256 raffleId) external view returns (Raffle memory) {\n        return raffles[raffleId];\n    }\n\n    function fulfillsRequirement(\n        address user,\n        uint256 requirement,\n        uint256 data\n    ) public view returns (bool) {\n        unchecked {\n            if (requirement == 1 && genesis.numOwned(user) > 0) return true;\n            else if (requirement == 2 && troupe.numOwned(user) > 0) return true;\n            else if (\n                requirement == 3 &&\n                // specify data == 1 to direct that user is holding troupe and potentially save an sload;\n                // or leave unspecified and worst-case check both\n                ((data != 2 && troupe.numOwned(user) > 0) || (data != 1 && genesis.numOwned(user) > 0))\n            ) return true;\n            else if (\n                requirement == 4 &&\n                (\n                    data > 5000 // specify owner-held id: data > 5000 refers to genesis collection\n                        ? genesis.getLevel(data - 5000) > 1 && genesis.ownerOf(data - 5000) == user\n                        : troupe.getLevel(data) > 1 && troupe.ownerOf(data) == user\n                )\n            ) return true;\n            else if (\n                requirement == 5 &&\n                (\n                    data > 5000\n                        ? genesis.getLevel(data - 5000) > 2 && genesis.ownerOf(data - 5000) == user\n                        : troupe.getLevel(data) > 2 && troupe.ownerOf(data) == user\n                )\n            ) return true;\n            return false;\n        }\n    }\n\n    /* ------------- Tickets Callbacks ------------- */\n\n    function ticketsSupply() external view returns (uint256) {\n        uint256 raffleId = ticketsToRaffleId[msg.sender];\n        return raffles[raffleId].ticketSupply;\n    }\n\n    function ticketsName() external view returns (string memory) {\n        uint256 raffleId = ticketsToRaffleId[msg.sender];\n        string memory prizeNFTName = IERC721Metadata(raffles[raffleId].prizeNFT).name();\n        return string.concat(\"Gouda Slot Machine Raffle #\", raffleId.toString(), \": \", prizeNFTName);\n    }\n\n    function ticketsSymbol() external view returns (string memory) {\n        uint256 raffleId = ticketsToRaffleId[msg.sender];\n        return string.concat(\"GRAFF\", raffleId.toString());\n    }\n\n    function ticketsTokenURI(uint256 id) external view returns (string memory) {\n        uint256 raffleId = ticketsToRaffleId[msg.sender];\n        return\n            raffles[raffleId].randomSeed != 0\n                ? isWinningTicket(raffleId, id) ? winningTicketURI : losingTicketURI\n                : ticketURI;\n    }\n\n    /* ------------- Owner ------------- */\n\n    function feedToys(\n        address prizeNFT,\n        uint32[] calldata prizeTokenIds,\n        uint40 start,\n        uint40 end,\n        uint16 ticketPrice,\n        uint8 refundRate,\n        uint16 maxTicketSupply,\n        uint8 requirement\n    ) external onlyOwner {\n        unchecked {\n            // don't transfer to contract to save gas\n            // need to make sure that contract has allowance to transfer NFTs of owner\n            // for (uint256 i; i < prizeTokenIds.length; ++i)\n            //     IERC721(prizeNFT).transferFrom(msg.sender, address(this), prizeTokenIds[i]);\n\n            uint256 raffleId = ++numRaffles;\n            Raffle storage raffle = raffles[raffleId];\n\n            if (ticketPrice >= 1e18) revert InvalidTicketPrice(); // sanity check, since ticketPrice is kept in multiples of 1e18\n            if (ticketsImplementation == address(0)) revert TicketsImplementationUnset();\n            if (ONE_MONTH < start - block.timestamp || ONE_MONTH < end - start) revert InvalidTimestamps(); // underflow desired\n\n            address tickets = createTicketsClone(ticketsImplementation);\n            ticketsToRaffleId[tickets] = raffleId;\n\n            raffle.tickets = tickets;\n            raffle.prizeNFT = prizeNFT;\n            raffle.prizeTokenIds = prizeTokenIds;\n            raffle.start = start;\n            raffle.end = end;\n            raffle.ticketPrice = ticketPrice;\n            raffle.refundRate = refundRate;\n            raffle.maxTicketSupply = maxTicketSupply;\n            raffle.requirement = requirement;\n\n            emit Chachingg();\n        }\n    }\n\n    // should normally be ignored\n    function incrementRaffleId(uint256 num) external onlyOwner {\n        numRaffles += num;\n    }\n\n    function editRaffle(\n        uint256 raffleId,\n        address prizeNFT,\n        uint32[] calldata prizeTokenIds,\n        uint40 start,\n        uint40 end,\n        uint16 ticketPrice,\n        uint8 refundRate,\n        uint16 maxTicketSupply,\n        uint8 requirement,\n        bool cancelled\n    ) external onlyOwner {\n        unchecked {\n            if (ticketPrice >= 1e18) revert InvalidTicketPrice();\n            if (block.timestamp + ONE_MONTH < start || ONE_MONTH < end - start) revert InvalidTimestamps();\n\n            Raffle storage raffle = raffles[raffleId];\n\n            raffle.prizeNFT = prizeNFT;\n            raffle.prizeTokenIds = prizeTokenIds;\n            raffle.start = start;\n            raffle.end = end;\n            raffle.ticketPrice = ticketPrice;\n            raffle.refundRate = refundRate;\n            raffle.maxTicketSupply = maxTicketSupply;\n            raffle.requirement = requirement;\n            raffle.cancelled = cancelled;\n        }\n    }\n\n    function rescueToys(IERC721 toy, uint256[] calldata toyIds) external onlyOwner {\n        unchecked {\n            for (uint256 i; i < toyIds.length; ++i) toy.transferFrom(address(this), msg.sender, toyIds[i]);\n        }\n    }\n\n    function rescueERC20(IERC20 token) external onlyOwner {\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    function triggerClaw(uint256 raffleId) external onlyOwner {\n        Raffle storage raffle = raffles[raffleId];\n\n        if (raffle.cancelled) revert RaffleNotActive();\n        if (block.timestamp < raffle.end) revert RaffleOngoing();\n        if (raffle.randomSeed != 0) revert MachineBeDoinWork();\n\n        emit GrappleGrapple();\n        emit BZZzzt();\n\n        raffle.randomSeed = uint40(uint256(blockhash(block.number - 1)));\n    }\n\n    function setTicketsImplementation(address ticketsImplementation_) external onlyOwner {\n        ticketsImplementation = ticketsImplementation_;\n    }\n\n    function setTicketURIs(\n        string calldata ticketURI_,\n        string calldata losingTicketURI_,\n        string calldata winningTicketURI_\n    ) external onlyOwner {\n        ticketURI = ticketURI_;\n        losingTicketURI = losingTicketURI_;\n        winningTicketURI = winningTicketURI_;\n    }\n\n    /* ------------- Private ------------- */\n\n    // https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\n    function createTicketsClone(address target) private returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            result := create(0, clone, 0x37)\n        }\n    }\n\n    /* ------------- Modifier ------------- */\n\n    modifier noContract() {\n        if (msg.sender != tx.origin) revert ContractCallNotAllowed();\n        _;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "src/lib/interfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ninterface IGouda {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function transfer(address to, uint256 amount) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function mint(address user, uint256 amount) external;\n\n    function burnFrom(address account, uint256 amount) external;\n}\n\ninterface IMadMouse {\n    function numStaked(address user) external view returns (uint256);\n\n    function numOwned(address user) external view returns (uint256);\n\n    function balanceOf(address user) external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function getLevel(uint256 tokenId) external view returns (uint256);\n\n    function getDNA(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "src/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nerror CallerNotOwner();\n\nabstract contract Ownable {\n    address _owner = msg.sender;\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        _owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner) revert CallerNotOwner();\n        _;\n    }\n}\n"
    },
    "src/lib/Choice.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// author: phaze\n\n// assumption: n << m\n// caveats: splits random number into 16 parts for efficiency\n// this means that 65536 is the highest random number\n// (can skew uniform distributions when m is hight)\nlibrary Choice {\n    function selectNOfM(\n        uint256 n,\n        uint256 m,\n        uint256 r\n    ) internal pure returns (uint256[] memory) {\n        unchecked {\n            if (n > m) n = m;\n\n            uint256[] memory choice = new uint256[](n);\n\n            uint256 s;\n            uint256 slot;\n\n            uint256 j;\n            uint256 c;\n\n            bool invalidChoice;\n\n            for (uint256 i; i < n; ++i) {\n                do {\n                    slot = (s & 0xF) << 4;\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\n                    c = ((r >> slot) & 0xFFFF) % m;\n                    invalidChoice = false;\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = choice[j] == c;\n                    ++s;\n                } while (invalidChoice);\n\n                choice[i] = c;\n            }\n            return choice;\n        }\n    }\n\n    function selectNOfM(\n        uint256 n,\n        uint256 m,\n        uint256 r,\n        uint256 offset\n    ) internal pure returns (uint256[] memory) {\n        unchecked {\n            if (n > m) n = m;\n\n            uint256[] memory choice = new uint256[](n);\n\n            uint256 s;\n            uint256 slot;\n\n            uint256 j;\n            uint256 c;\n\n            bool invalidChoice;\n\n            for (uint256 i; i < n; ++i) {\n                do {\n                    slot = (s & 0xF) << 4;\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\n                    c = (((r >> slot) & 0xFFFF) % m) + offset;\n                    invalidChoice = false;\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = choice[j] == c;\n                    ++s;\n                } while (invalidChoice);\n\n                choice[i] = c;\n            }\n            return choice;\n        }\n    }\n\n    function indexOfSelectNOfM(\n        uint256 x,\n        uint256 n,\n        uint256 m,\n        uint256 r\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            if (n > m) n = m;\n\n            uint256[] memory choice = new uint256[](n);\n\n            uint256 s;\n            uint256 slot;\n\n            uint256 j;\n            uint256 c;\n\n            bool invalidChoice;\n\n            for (uint256 i; i < n; ++i) {\n                do {\n                    slot = (s & 0xF) << 4;\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\n                    c = ((r >> slot) & 0xFFFF) % m;\n                    invalidChoice = false;\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = choice[j] == c;\n                    ++s;\n                } while (invalidChoice);\n\n                if (x == c) return (true, i);\n\n                choice[i] = c;\n            }\n            return (false, 0);\n        }\n    }\n}\n"
    },
    "src/SoulboundTickets.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM`MMM NMM MMM MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMhMMMMMMM  MMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MM-MMMMM   MMMM    MMMM   lMMMDMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMM jMMMMl   MM    MMM  M  MMM   M   MMMM MMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMM  , `     M   Y   MM  MMM  BMMMMMM MMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMM MMMMMMMMMMMM  IM  MM  l  MMM  X   MM.  MMMMMMMMMM MMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.nlMMMMMMMMMMMMMMMMM]._  MMMMMMMMMMMMMMMNMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMM TMMMMMMMMMMMMMMMMMM          +MMMMMMMMMMMM:  rMMMMMMMMN MMMMMMMMMMMMMM\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMM                  MMMMMM           MMMMMMMM qMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMM^                   MMMb              .MMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMM MMMMMMMMMMMMMMM                     MM                  MMMMMMM MMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                     M                   gMMMMMMMMMMMMMMMMM\n// MMMMMMMMu MMMMMMMMMMMMMMM                                           MMMMMMM .MMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           :MMMMMMMMMMMMMMMM\n// MMMMMMM^ MMMMMMMMMMMMMMMl                                            MMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\n// MMMMMMM MMMMMMMMMMMMMMMM                                             MMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\n// MMMMMMr MMMMMMMMMMMMMMMM                                             MMMMMMMM .MMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           MMMMMMMMMMMMMMMMM\n// MMMMMMM MMMMMMMMMMMMMMMMM                                         DMMMMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                              MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMM|`MMMMMMMMMMMMMMMM         q                      MMMMMMMMMMMMMMMMMMM  MMMMMMM\n// MMMMMMMMMTMMMMMMMMMMMMMMM                               qMMMMMMMMMMMMMMMMMMgMMMMMMMMM\n// MMMMMMMMq MMMMMMMMMMMMMMMh                             jMMMMMMMMMMMMMMMMMMM nMMMMMMMM\n// MMMMMMMMMM MMMMMMMMMMMMMMMQ      nc    -MMMMMn        MMMMMMMMMMMMMMMMMMMM MMMMMMMMMM\n// MMMMMMMMMM.MMMMMMMMMMMMMMMMMMl            M1       `MMMMMMMMMMMMMMMMMMMMMMrMMMMMMMMMM\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMM               :MMMMMMMMMM MMMMMMMMMMMM qMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMX       MMMMMMMMMMMMMMM  uMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMM DMMMMMMMMM   IMMMMMMMMMMMMMMMMMMMMMMM   M   Y  MMMMMMMN MMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMM MMMMMM    ``    M      MM  MMM   , MMMM    Mv  MMM MMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMM MMh  Ml  .   M  MMMM  I  MMMT  M     :M   ,MMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMt  MM  MMMMB m  ]MMM  MMMM   MMMMMM MMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMM MMMMM  MMM   TM   MM  9U  .MM  _MMMMM MMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM YMMMMMMMn     MMMM    +MMMMMMM1`MMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.`MMM MMM MMMMM`.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM author: phaze MMM\n\nimport {Gachapon} from \"./Gachapon.sol\";\n\nerror CallerNotOwner();\nerror CallerNotApproved();\nerror CallerNotOwnerNorApproved();\n\nerror MintExceedsLimit();\n\nerror TransferFromIncorrectOwner();\nerror TransferToNonERC721Receiver();\nerror TransferToZeroAddress();\n\nerror BurnFromIncorrectOwner();\n\ncontract SoulboundTickets {\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    mapping(uint256 => address) public ownerOf;\n    mapping(address => uint256) public balanceOf;\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    Gachapon immutable gachapon;\n\n    constructor(Gachapon gachapon_) {\n        gachapon = gachapon_;\n    }\n\n    /* ------------- View ------------- */\n\n    function tokenURI(uint256 id) external view returns (string memory) {\n        return gachapon.ticketsTokenURI(id);\n    }\n\n    function name() external view returns (string memory) {\n        return gachapon.ticketsName();\n    }\n\n    function symbol() external view returns (string memory) {\n        return gachapon.ticketsSymbol();\n    }\n\n    function supportsInterface(bytes4 interfaceId) external view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /* ------------- Restricted ------------- */\n\n    // @note assumes correct handling by master contract in order to save gas\n    function mint(address to, uint256 id) external onlyGachapon {\n        if (balanceOf[to] == 1) revert MintExceedsLimit();\n\n        ownerOf[id] = to;\n\n        unchecked {\n            ++balanceOf[to];\n        }\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function burnFrom(address from, uint256 id) external onlyGachapon {\n        if (ownerOf[id] != from) revert BurnFromIncorrectOwner();\n\n        unchecked {\n            --balanceOf[from];\n        }\n\n        emit Transfer(from, address(0), id);\n\n        delete ownerOf[id];\n    }\n\n    modifier onlyGachapon() {\n        if (msg.sender != address(gachapon)) revert CallerNotApproved();\n        _;\n    }\n\n    /* ------------- O(N) Read Only ------------- */\n\n    function ticketIdOf(address user) external view returns (uint256) {\n        unchecked {\n            uint256 supply = gachapon.ticketsSupply() + 1;\n            for (uint256 id; id < supply; ++id) if (ownerOf[id] == user) return id;\n            return 0;\n        }\n    }\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}