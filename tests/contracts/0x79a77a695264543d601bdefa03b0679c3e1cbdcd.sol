{"ApproveAndCallFallback.sol":{"content":"pragma solidity 0.4.26;\n\n\ninterface ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) external;\n}\n"},"IERC20.sol":{"content":"interface ERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address who) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function approveAndCall(address spender, uint tokens, bytes data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  function burn(uint256 amount) external;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"SafeMath.sol":{"content":"library SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a / b;\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003c= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a);\n    return c;\n  }\n\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n    uint256 c = add(a,m);\n    uint256 d = sub(c,1);\n    return mul(div(d,m),m);\n  }\n}\n"},"SignedSafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.4.26;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n        /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 \u0026\u0026 b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 \u0026\u0026 a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b \u003e= 0 \u0026\u0026 c \u003c= a) || (b \u003c 0 \u0026\u0026 c \u003e a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b \u003e= 0 \u0026\u0026 c \u003e= a) || (b \u003c 0 \u0026\u0026 c \u003c a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"},"staking.sol":{"content":"pragma solidity 0.4.26;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SignedSafeMath.sol\";\nimport \"./ApproveAndCallFallback.sol\";\n\ncontract MeridianInterface is ERC20{\n  function owner() external returns(address);\n}\n\ncontract MeridianStaking is ApproveAndCallFallBack{\n  using SafeMath for uint;\n  using SignedSafeMath for int;\n  MeridianInterface public meridianToken;\n  mapping(address =\u003e uint256) public amountStaked;\n  mapping(address =\u003e int256) public payoutsTo;//only represents the portion of payouts from collective dividends\n  mapping(address =\u003e uint256) public payoutsToTime;//over time related payouts\n  mapping(address =\u003e uint256) public unclaimedDividends;//dividends over time before the last user checkpoint\n  mapping(address =\u003e uint256) public dividendCheckpoints;//the time from which to calculate new dividends\n  mapping(address =\u003e uint256) public dividendRateUsed;\n  uint256 public stakedTotalSum;\n  uint256 public divsPerShare;\n  uint256 constant internal magnitude = 2 ** 64;\n  uint256 constant internal STAKING_MINIMUM = 100 * (10 ** 18); //token is 18 decimals\n  uint256 public STAKING_PERIOD = 1 days; //time period to which the dividend rate refers to\n  uint256 public BURN_RATE = 100; //10% transaction burns, unstaking burns, div withdraw burns\n  uint public STAKE_DIV_FEE = 50; //5% stake div fee\n  uint256 public DIVIDEND_RATE = 10;//1.0%\n  bool public activated = false;\n  uint256 public contractEndTime=0;\n\n  uint256 public nowTest=now;\n\n  event Stake(address indexed user, uint256 amount);\n\tevent UnStake(address indexed user, uint256 amount);\n  event WithdrawDivs(address indexed user, uint256 amount);\n  event ReStakeDivs(address indexed user, uint256 amount);\n\n  modifier isAdmin() {\n      require(msg.sender==meridianToken.owner(),\"user is not admin\");\n      _;\n  }\n  modifier isActive() {\n      require(activated,\"staking is not yet active\");\n      _;\n  }\n\n  constructor(address token) public{\n    meridianToken=MeridianInterface(token);\n  }\n  function setRates(uint burn,uint div,uint unstake) public isAdmin{\n    BURN_RATE=burn;\n    DIVIDEND_RATE=div;\n    STAKE_DIV_FEE=unstake;\n  }\n  function activateContract() public isAdmin{\n    activated=true;\n  }\n  function burnAfterContractEnd() public isAdmin{\n    meridianToken.burn(meridianToken.balanceOf(address(this)));\n  }\n  function disableDividendAccumulation() public isAdmin{\n    contractEndTime=now;\n  }\n\n  /*\n    Used for staking, must send an approveAndCall to the token which will then call this function\n  */\n  function receiveApproval(address fromAddr, uint256 tokens, address token, bytes data) external{\n    require(msg.sender==address(meridianToken));\n    require(meridianToken.transferFrom(fromAddr,address(this),tokens),\"transfer failed\");\n    _stake(tokens,fromAddr);\n  }\n  function _stake(uint256 amount,address fromAddr) private isActive{\n    require(amountStaked[fromAddr].add(amount) \u003e= STAKING_MINIMUM,\"amount below staking minimum\");\n    updateCheckpoint(fromAddr,true);\n    stakedTotalSum = stakedTotalSum.add(amount);\n    amountStaked[fromAddr] = amountStaked[fromAddr].add(amount);\n    payoutsTo[fromAddr] = payoutsTo[fromAddr].add(int256(amount.mul(divsPerShare)));\n    emit Stake(fromAddr, amount);\n  }\n  function unstake(uint256 amount) public isActive{\n    require(amountStaked[msg.sender] \u003e= amount);\n    updateCheckpoint(msg.sender,true);\n\n    uint256 divPortion=amount.mul(STAKE_DIV_FEE).div(1000);// dividends to be redistributed to users\n    uint256 burnPortion=amount.mul(BURN_RATE).div(1000);// tokens to be burned\n    uint256 unstakeFee = divPortion.add(burnPortion);\n    divsPerShare = divsPerShare.add(divPortion.mul(magnitude).div(stakedTotalSum)); //portion of fee redistributed as divs, the rest to be burned\n    stakedTotalSum = stakedTotalSum.sub(amount);\n    uint256 taxedAmount = amount.sub(unstakeFee);\n    amountStaked[msg.sender] = amountStaked[msg.sender].sub(amount);\n    payoutsTo[msg.sender] = payoutsTo[msg.sender].sub(int256(amount.mul(divsPerShare)));\n    meridianToken.burn(burnPortion);//burn a portion of the fee\n    meridianToken.transfer(msg.sender,taxedAmount);\n    emit UnStake(msg.sender, amount);\n  }\n  function withdrawDivs() public isActive{\n    updateCheckpoint(msg.sender,false);\n    uint256 burnedDivs = getBurnedDivs(msg.sender);\n    payoutsTo[msg.sender] = payoutsTo[msg.sender].add(int256(burnedDivs.mul(magnitude)));\n    uint256 timeDivs=getTotalDivsOverTime(msg.sender);\n    payoutsToTime[msg.sender] = payoutsToTime[msg.sender].add(timeDivs);\n    uint256 baseDivs=burnedDivs.add(timeDivs);\n\n    uint256 burnFee=baseDivs.mul(BURN_RATE).div(1000);\n    uint256 divs=baseDivs.sub(burnFee);\n\n    meridianToken.burn(burnFee);\n    meridianToken.transfer(msg.sender,divs);\n    emit WithdrawDivs(msg.sender, divs);\n  }\n  function reinvestDivs() public isActive{\n    updateCheckpoint(msg.sender,false);\n    uint256 burnedDivs = getBurnedDivs(msg.sender);\n    payoutsTo[msg.sender] = payoutsTo[msg.sender].add(int256(burnedDivs.mul(magnitude)));\n    uint256 timeDivs=getTotalDivsOverTime(msg.sender);\n    payoutsToTime[msg.sender] = payoutsToTime[msg.sender].add(timeDivs);\n    uint256 divs=burnedDivs.add(timeDivs);\n    _stake(divs,msg.sender);\n    emit ReStakeDivs(msg.sender, divs);\n  }\n\n  function getDividends(address user) public view returns(uint256){\n    return getBurnedDivs(user).add(getTotalDivsOverTime(user));\n  }\n  function getBurnedDivs(address user) public view returns(uint256){\n    if(int256(divsPerShare.mul(amountStaked[user])) \u003c payoutsTo[user]){\n      return 0;\n    }\n    else{\n      return uint256(int256(divsPerShare.mul(amountStaked[user])).sub(payoutsTo[user])).div(magnitude);\n    }\n  }\n  function updateCheckpoint(address user,bool updateRate) private{\n    unclaimedDividends[user]=unclaimedDividends[user].add(getNewDivsOverTime(user));\n    dividendCheckpoints[user]=getNow();\n    if(updateRate){\n      dividendRateUsed[user]=DIVIDEND_RATE;//locks in latest div rate. Done after unclaimedDividends updated, so divs from before this operation will be at the old rate.\n    }\n  }\n  function getTotalDivsSubWithdrawFee(address user) external view returns(uint256){\n    uint256 baseDivs=getDividends(user);\n    uint256 fee=baseDivs.mul(BURN_RATE).div(1000).add(baseDivs.mul(STAKE_DIV_FEE).div(1000));\n    return baseDivs.sub(fee);\n  }\n  //recent divs over time plus previously recorded divs over time\n  function getTotalDivsOverTime(address user) public view returns(uint256){\n    return unclaimedDividends[user].add(getNewDivsOverTime(user)).sub(payoutsToTime[user]);\n  }\n  //Formula for dividends over time is (time_passed/staking_period)*staked_tokens*dividend_rate\n  //All divided by 1000 to convert dividend rate to the appropriate units\n  function getNewDivsOverTime(address user) public view returns(uint256){\n    return getNow().sub(dividendCheckpoints[user]).mul(amountStaked[user]).mul(dividendRateUsed[user]).div(STAKING_PERIOD.mul(1000));\n  }\n  function getNow() public view returns(uint256){\n      //have \u0027now\u0027 be assumed to be the contract end time, if the current time is later than that. This is to prevent accumulation of dividends after this point.\n      if(contractEndTime\u003e0 \u0026\u0026 now\u003econtractEndTime){\n        return contractEndTime;\n      }\n      else{\n        return now;\n      }\n\n  }\n}\n"}}