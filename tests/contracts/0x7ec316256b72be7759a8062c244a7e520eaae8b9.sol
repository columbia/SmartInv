{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract\u0027s constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 \u0026\u0026 codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call{value:amount}(new bytes(0));\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}"},"IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n\ninterface IERC1155 {\n  // Events\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n\n  /**\n   * @dev MUST emit when an approval is updated\n   */\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  /**\n   * @dev MUST emit when the URI is updated for a token ID\n   *   URIs are defined in RFC 3986\n   *   The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\"\n   */\n  event URI(string _amount, uint256 indexed _id);\n\n  /**\n   * @notice Transfers amount of an _id from the _from address to the _to address specified\n   * @dev MUST emit TransferSingle event on success\n   * Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n   * MUST throw if `_to` is the zero address\n   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n   * MUST throw on any other error\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n   * @param _from    Source address\n   * @param _to      Target address\n   * @param _id      ID of the token type\n   * @param _amount  Transfered amount\n   * @param _data    Additional data with no specified format, sent in call to `_to`\n   */\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n\n  /**\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n   * @dev MUST emit TransferBatch event on success\n   * Caller must be approved to manage the _from account\u0027s tokens (see isApprovedForAll)\n   * MUST throw if `_to` is the zero address\n   * MUST throw if length of `_ids` is not the same as length of `_amounts`\n   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n   * MUST throw on any other error\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n   * @param _from     Source addresses\n   * @param _to       Target addresses\n   * @param _ids      IDs of each token type\n   * @param _amounts  Transfer amounts per token type\n   * @param _data     Additional data with no specified format, sent in call to `_to`\n  */\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n  \n  /**\n   * @notice Get the balance of an account\u0027s Tokens\n   * @param _owner  The address of the token holder\n   * @param _id     ID of the Token\n   * @return        The _owner\u0027s balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n  /**\n   * @notice Get the balance of multiple account/token pairs\n   * @param _owners The addresses of the token holders\n   * @param _ids    ID of the Tokens\n   * @return        The _owner\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n   */\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller\u0027s tokens\n   * @dev MUST emit the ApprovalForAll event on success\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   */\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n\n}\n"},"IERC1155TokenReceiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/**\n * @dev ERC-1155 interface for accepting safe transfers.\n */\ninterface IERC1155TokenReceiver {\n\n  /**\n   * @notice Handle the receipt of a single ERC1155 token type\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value MUST result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _id        The id of the token being transferred\n   * @param _amount    The amount of tokens being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Handle the receipt of multiple ERC1155 token types\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value WILL result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _ids       An array containing ids of each token being transferred\n   * @param _amounts   An array containing amounts of each token being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n   */\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\n   *      This function MUST NOT consume more than 5,000 gas.\n   * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\n   */\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n}"},"MiningCore.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\nimport \"./SafeMath.sol\";\nimport \"./IERC1155.sol\";\nimport \"./IERC1155TokenReceiver.sol\";\nimport \"./Ownable.sol\";\nimport \"./Address.sol\";\n\n// sns: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]\n// ids:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\n// fertilities:[1,2,5,10,30,100,1,2,5,10,30,100,10,20,50,100,300,1000]\n// carries:[0,0,0,0,0,0,10,20,50,100,300,1000,1,2,5,10,30,100]\n\ninterface MiningPool{\n    \n    function users(address userAddress) external view returns(uint256 id,uint256 investment,uint256 freezeTime);\n    \n    function balanceOf(address userAddress) external view returns (address[2] memory,uint256[2] memory balances);\n    \n    function totalSupply() external view returns (uint256);\n    \n    function stakeAmount() external view returns (uint256);\n    \n    function duration() external view returns (uint256);\n    \n    function token() external view returns (address);\n    \n    function deposit(uint256[2] calldata amounts) external returns(bool);\n    \n    function allot(address userAddress,uint256[2] calldata amounts) external returns(bool);\n    \n    function lock(address holder, address locker, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\n    \n    function lockStatus(address userAddress) external view returns(bool);\n}\n\ninterface IUniswapPair {\n    \n    function setFeeOwner(address _feeOwner) external;\n}\n\ninterface IUniswapFactory {\n    \n    function getPair(address token0,address token1) external returns(address);\n}\n\nabstract contract ERC1155TokenReceiver is IERC1155TokenReceiver{\n    \n    bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n    bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n    \n    //-------------------------------------ERC1155---------------------------------------------------------------------\n    \n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external override returns(bytes4) {\n        uint256[] memory _values = new uint256[](1);\n        uint256[] memory _ids = new uint256[](1);\n        _ids[0] = _id;\n        _values[0] = _value;\n        \n        operateToken1155(msg.sender,_operator,_from,_ids,_values,_data);\n        return ERC1155_RECEIVED_VALUE;\n    }\n\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external override returns(bytes4) {\n        operateToken1155(msg.sender,_operator,_from,_ids,_values,_data);\n        return ERC1155_BATCH_RECEIVED_VALUE;\n    }\n\n    // ERC165 interface support\n    function supportsInterface(bytes4 interfaceID) external override pure returns (bool) {\n        return  interfaceID == 0x01ffc9a7 ||    // ERC165\n                interfaceID == 0x4e2312e0;      // ERC1155_ACCEPTED ^ ERC1155_BATCH_ACCEPTED;\n    }\n    \n    function operateToken1155(address msgSender, address _operator, address _from, uint256[] memory _ids, uint256[] memory _values, bytes calldata _data) internal virtual;\n}\n\ncontract Config{\n    \n    uint256 public constant ONE_DAY = 1 days;\n    \n    uint256[10] public  RANKING_AWARD_PERCENT = [10,5,3,1,1,1,1,1,1,1];\n    \n    uint256 public constant LAST_STRAW_PERCNET = 5;\n    \n    uint256[2] public  OUT_RATE = [1,1];\n\n}\n\n\ncontract MiningCore is Config, Ownable, ERC1155TokenReceiver {\n    \n    using SafeMath for uint256;\n    \n    constructor(MiningPool _pool,IERC1155 _token1155,address payable _developer) {\n        pool = _pool;\n        token1155 = _token1155;\n        developer = _developer;\n    }\n    \n    MiningPool public pool;\n    \n    IERC1155 public token1155;\n    \n    \n    uint256 public ORE_AMOUNT = 250000000;\n    \n    struct Record{\n        //提现状态\n        bool drawStatus;\n        //挖矿总量\n        uint256 digGross;\n        //最后一击\n        bool lastStraw;\n       \n        mapping(uint256=\u003euint256) disCars;\n    }\n    \n    struct Pair {\n        uint256[2] amounts;\n        //挖矿总量\n        uint256 complete;\n        //实际挖矿量\n        uint256 actual;\n        \n        uint256 oracleAmount;\n        \n        address lastStraw;\n    }\n    \n    struct Car{\n        uint256 sn;\n        uint256 fertility;\n        uint256 carry;\n    }\n    \n    //address[] callHelper;\n    \n    address payable developer;\n    \n    uint256 public version;\n    \n    //User acquisition record\n    //mapping(uint256=\u003emapping(address=\u003ebool)) public obtainLogs;\n    \n    mapping(uint256=\u003emapping(address=\u003eRecord)) public records;\n    \n    //Record of each mining period\n    mapping(uint256=\u003ePair) public history;\n    \n    //Daily output\n    mapping(uint256=\u003euint256) public dailyOutput;\n    \n    //The number corresponds to the carIndex\n    uint256[] public carIndex;\n    \n    //Each ID corresponds to a car attribute\n    mapping(uint256=\u003eCar) public cars;\n    \n    mapping(uint256=\u003e address[10]) public rank;\n    \n    event ObtainCar(address indexed userAddress,uint256 indexed _version,uint256 amount );\n    \n    event Mining(address indexed userAddress,uint256 indexed _version,uint256[] ,uint256[],uint256 amount);\n    \n    event WithdrawAward(address indexed userAddress,uint256 indexed _version,uint256[2] amounts);\n    \n    event UpdateRank(address indexed operator);\n    \n    event DeveloperFee(uint256 fee1,uint256 fee2);\n    \n    event SetCarIndex(uint256 sn,uint256 id,uint256 fertility,uint256 carry);\n    \n    event LastStraw(address indexed userAddress,uint256 _version,uint256,uint256,uint256);\n    \n    function init() public onlyOwner {\n        uint256[18] memory _ids = [uint256(1),2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18];\n        uint256[18] memory _fertilities = [uint256(1),2,5,10,30,100,1,2,5,10,30,100,10,20,50,100,300,1000];\n        uint256[18] memory _carries = [uint256(1),2,5,10,30,100,10,20,50,100,300,1000,1,2,5,10,30,100];\n        setCarIndexs(_ids,_fertilities,_carries);\n    }\n\n     //Set vehicle properties\n    function setCarIndex(uint256 sn,uint256 id,uint256 fertility,uint256 carry) public onlyOwner{\n        if(sn+1\u003ecarIndex.length){\n            carIndex.push(id);\n            //callHelper.push(address(this));\n        }else{\n            carIndex[sn] = id;\n        }\n        \n        cars[id] = Car(sn,fertility,carry);\n        emit SetCarIndex( sn, id, fertility, carry);\n    }\n    \n    //Batch set vehicle properties\n    function setCarIndexs(uint256[18] memory ids,uint256[18] memory fertilities,uint256[18] memory carries) private {\n        for(uint256 i=0;i\u003cids.length;i++){\n            setCarIndex(i,ids[i],fertilities[i],carries[i]);\n        }\n    }\n    \n    function setFeeOwner(address _feeOwner,address factory) external  onlyOwner {\n        (address[2] memory tokens,) = pool.balanceOf(address(0));\n        address pair = IUniswapFactory(factory).getPair(tokens[0],tokens[1]);\n        IUniswapPair(pair).setFeeOwner(_feeOwner);\n    }\n    \n    \n    function setOracle(uint256 _ORE_AMOUNT) public onlyOwner {\n        ORE_AMOUNT = _ORE_AMOUNT;\n    }\n    \n    \n    function operateToken1155(address msgSender,address _operator, address _from, uint256[] memory _ids, uint256[] memory _values, bytes calldata) internal override virtual{\n        \n        require(address(token1155)==msgSender,\"not allowed\");\n        require(!Address.isContract(_operator),\"Contract invocation is not allowed\");\n       \n        if(_from!=address(0x0)){\n            mining(_from,_ids,_values);\n        }\n    }\n    \n\n    function obtainCar(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) public {\n        require(!pool.lockStatus(msg.sender),\"Have been received\");\n\t\t\n\t\t     (,uint256[] memory counts,uint256 len,uint256 token1155Amount,uint256 quantity) = cat(msg.sender);\n            \n             if(dailyOutput[pool.duration()]==0){\n                 dailyOutput[pool.duration()] = token1155Amount;\n             }\n        \n        pool.lock(msg.sender,address(this),nonce,expiry,allowed,v,r,s);\n        //token1155.safeBatchTransferFrom(address(this),msg.sender,carIndex,carUsable,\"success\");\n \n    }\n    \n    function withdrawAward(uint256 _version) public {\n        \n       require(!records[_version][msg.sender].drawStatus,\"have withdrawal\");\n\t   require(_version\u003cversion,\"Event not over\");\n        \n       (uint256[2] memory amounts) =  getVersionAward(_version,msg.sender);\n\n       records[_version][msg.sender].drawStatus = true;\n       \n       pool.allot(msg.sender,amounts);\n       \n       emit WithdrawAward(msg.sender,_version,amounts);\n       \n    }\n    \n    \n    function getVersionAward(uint256 _version,address userAddress) public view returns(uint256[2] memory amounts){\n        Pair memory pair = history[_version];\n        return getPredictAward(_version,userAddress,pair);\n    }\n    \n    function getPredictAward(uint256 _version,address userAddress,Pair memory pair) internal view returns(uint256[2] memory amounts){\n        Record storage record = records[_version][userAddress];\n        \n        uint256 ranking = getRanking(userAddress,_version);\n\n        for(uint8 i = 0;i\u003c2;i++){\n            uint256 baseAmount = pair.amounts[i].mul(70).div(100);\n            uint256 awardAmount = pair.amounts[i].mul(30).div(100);\n            \n            amounts[i] = amounts[i].add(baseAmount.mul(record.digGross).div(pair.oracleAmount==0?ORE_AMOUNT:pair.oracleAmount));\n            \n            if(ranking\u003c10){\n                amounts[i] = amounts[i].add(awardAmount.mul(RANKING_AWARD_PERCENT[ranking]).div(30));\n            }\n            \n            if(record.lastStraw){\n                amounts[i] = amounts[i].add(awardAmount.mul(LAST_STRAW_PERCNET).div(30));\n            }\n        }\n    }\n\n    function getGlobalStats(uint256 _version) external view returns (uint256[5] memory stats,address lastStrawUser) {\n        \n        Pair memory pair = history[_version];\n        if(_version==version){\n            (,uint256[2] memory balances) = pool.balanceOf(address(this));\n            pair.amounts = balances;\n        }\n        \n        stats[0] = pair.amounts[0];\n        stats[1] = pair.amounts[1];\n        stats[2] = pair.complete;\n        stats[3] = pair.actual;\n        stats[4] = (pool.duration()+1)*ONE_DAY;\n        lastStrawUser = pair.lastStraw;\n  \n    }\n    \n    \n    function crown(uint256 _version) external view returns (address[10] memory ranking,uint256[10] memory digGross){\n        ranking = sortRank(_version);\n        for(uint8 i =0;i\u003cranking.length;i++){\n            digGross[i] = getDigGross(ranking[i],_version);\n        }\n    }\n    \n    \n    function getPersonalStats(uint256 _version,address userAddress) external view returns (uint256[8] memory stats,bool[3] memory stats2,uint256[] memory departs){\n        Record storage record = records[_version][userAddress];\n         \n        (uint256 id,uint256 investment,uint256 freezeTime) = pool.users(userAddress);\n        stats[0] = investment;\n        stats[1] = record.digGross;\n         \n        Pair memory pair = history[_version];\n         \n        if(_version==version){\n            (,uint256[2] memory balances) = pool.balanceOf(address(this));\n            pair.amounts = balances;\n        }\n         \n        uint256[2] memory amounts = getPredictAward(_version,userAddress,pair);\n         \n        stats[2] = amounts[1];\n        stats[3] = amounts[0];\n        stats[4] = id;\n        stats[5] = freezeTime;\n        stats[6] = getRanking(userAddress,_version)+1;\n         \n        stats2[0] = record.drawStatus;\n        stats2[1] = record.lastStraw;\n        stats2[2] = pool.lockStatus(userAddress);\n         \n        departs = new uint256[](kinds());\n        uint256 total;\n        for(uint256 i =0;i\u003ckinds();i++){\n            uint256 depart = getDepartCars(_version,userAddress,carIndex[i]);\n            departs[i] = depart;\n            total = total.add(depart);\n        }\n        stats[7] = total;\n        \n     }\n     \n\n    function getDepartCars(uint256 _version,address userAddress,uint256 _carId) public view returns(uint256){\n        return records[_version][userAddress].disCars[_carId];\n    }\n    \n    \n    \n    function mining(address userAddress,uint256[] memory ids,uint256[] memory amounts) internal returns(uint256){\n        Pair storage pair = history[version];\n        require(ids.length\u003e0\u0026\u0026ids.length == amounts.length,\"error\");\n        \n        uint256 carFertility;\n        uint256 carCarry;\n        Record storage record = records[version][userAddress];\n        uint256 output;\n        for(uint256 i = 0;i\u003cids.length;i++){\n            Car memory car = cars[ids[i]];\n            carFertility = carFertility.add(car.fertility.mul(amounts[i]));\n            carCarry = carCarry.add(car.carry.mul(amounts[i]));\n            record.disCars[ids[i]] = record.disCars[ids[i]].add(amounts[i]);\n        }\n        \n        if(carFertility\u003ecarCarry){\n            output = carCarry;\n        }else{\n            output = carFertility;\n        }\n        \n        uint256 miningQuantity = pair.complete.add(carFertility);\n        \n        if(pair.complete.add(output)\u003eORE_AMOUNT){\n            output = ORE_AMOUNT\u003epair.complete?ORE_AMOUNT-pair.complete:0;\n        }\n        \n        record.digGross = record.digGross.add(output);\n        pair.complete = pair.complete.add(carFertility);\n        pair.actual = pair.actual.add(output);\n        updateRank(userAddress);\n        \n        if(miningQuantity\u003e=ORE_AMOUNT){ \n            emit LastStraw(userAddress,version,carFertility,carCarry,output);\n            lastStraw(userAddress,pair);\n        }\n        \n        token1155.safeBatchTransferFrom(address(this),owner(),ids,amounts,\"success\");\n        \n        emit Mining(userAddress,version,ids,amounts,output);\n        return output;\n    }\n    \n    function getRanking(address userAddress,uint256 _version) public view returns(uint256){\n        address[10] memory rankingList = sortRank(_version);\n        uint256 ranking = 10;\n        for(uint8 i =0;i\u003crankingList.length;i++){\n            if(userAddress == rankingList[i]){\n                ranking = i;\n                break;\n            }\n        }\n        return ranking;\n    }\n    \n    function pickUp(address[10] memory rankingList,address userAddress) internal view returns (uint256 sn,uint256 minDig){\n        \n        minDig = getDigGross(rankingList[0]);\n        for(uint8 i =0;i\u003crankingList.length;i++){\n            if(rankingList[i]==userAddress){\n                return (rankingList.length,0);\n            }\n            if(getDigGross(rankingList[i])\u003cminDig){\n                minDig = getDigGross(rankingList[i]);\n                sn = i;\n            }\n        }\n        \n        return (sn,minDig);\n    }\n    \n    function updateRank(address userAddress) internal {\n        address[10] memory rankingList = rank[version];\n        \n        (uint256 sn,uint256 minDig) = pickUp(rankingList,userAddress);\n        if(sn!=rankingList.length){\n            if(minDig\u003c getDigGross(userAddress)){\n                rankingList[sn] = userAddress;\n            }\n            rank[version] = rankingList;\n            emit UpdateRank(userAddress);\n        }\n    }\n    \n    function sortRank(uint256 _version) public view returns(address[10] memory ranking){\n        ranking = rank[_version];\n        \n        address tmp;\n        for(uint8 i = 1;i\u003c5;i++){\n            for(uint8 j = 0;j\u003c5-i;j++){\n                if(getDigGross(ranking[j],_version)\u003cgetDigGross(ranking[j+1],_version)){\n                    tmp = ranking[j];\n                    ranking[j] = ranking[j+1];\n                    ranking[j+1] = tmp;\n                }\n            }\n        }\n        return ranking;\n    }\n    \n    function getDigGross(address userAddress) internal view returns(uint256){\n        return getDigGross(userAddress,version);\n    }\n    \n    function getDigGross(address userAddress,uint256 _version) internal view returns(uint256){\n        return records[_version][userAddress].digGross;\n    }\n    \n    function lastStraw(address userAddress,Pair storage pair) internal{\n        \n        (address[2] memory tokens,uint256[2] memory amounts) = pool.balanceOf(address(this));\n        \n        for(uint8 i;i\u003camounts.length;i++){\n            TransferHelper.safeApprove(tokens[i],address(pool),amounts[i]);\n        }\n        pool.deposit(amounts);\n        pair.amounts = amounts;\n\n        pair.lastStraw = userAddress;\n        pair.oracleAmount = ORE_AMOUNT;\n        records[version][userAddress].lastStraw = true;    \n        \n        developerFee(pair);\n        version++;  \n        \n    }\n    \n     //项目方收款\n    function developerFee(Pair storage pair) internal{\n     \n        uint256[2] memory amounts;\n        address[10] memory rankingList = rank[version];\n        uint count;\n        for(uint i = 0;i\u003crankingList.length;i++) {\n            if(rankingList[i]==address(0)) {\n                count++;\n            }\n        }\n        \n        uint used;\n        for(uint j = 0;j\u003ccount;j++){\n            used+=RANKING_AWARD_PERCENT[j];\n        }\n        \n        for(uint256 i = 0;i\u003camounts.length;i++){\n            uint waste = pair.amounts[i].mul(70).mul(pair.oracleAmount.sub(pair.actual)).div(ORE_AMOUNT).div(100);\n            uint rest = pair.amounts[i].mul(30).mul(uint256(25).sub(used)).div(30).div(100);\n            amounts[i] = waste+rest;\n        }\n        \n        pool.allot(developer,amounts);\n        \n        emit DeveloperFee(amounts[0],amounts[1]);\n    }\n    \n    \n    \n    function cat(address userAddress) public view returns(uint256[] memory,uint256[] memory counts,uint256 len,uint256 token1155Amount,uint256 quantity){\n        \n        ( ,uint256 investment, ) = pool.users(userAddress);\n        \n        (counts,token1155Amount) = determinate(); \n\n        uint256 dailyTokenAmount = dailyOutput[pool.duration()];\n        if(dailyTokenAmount==0){\n            dailyTokenAmount = token1155Amount;\n        }\n        uint256 totalSupply = pool.totalSupply();\n        quantity = investment.mul(dailyTokenAmount).div(totalSupply);\n        \n        return (carIndex,counts,kinds(),token1155Amount,quantity);\n\n    }\n    \n    function determinate() public view returns(uint256[] memory counts,uint256 token1155Amount){\n        address _owner = owner();\n        counts = new uint256[](kinds());\n        for(uint8 i = 0;i\u003ckinds();i++){\n            uint256 count = token1155.balanceOf(_owner,carIndex[i]);\n            counts[i] = count;\n            token1155Amount+=count;\n        }\n\t\t\n        for(uint8 i = 0;i\u003ckinds();i++){\n            token1155Amount+=counts[i];\n        }\n        \n    }\n    \n    function kinds() internal view returns (uint256) {\n        return carIndex.length;\n    }\n}\n\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\u0027approve(address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: APPROVE_FAILED\u0027);\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: TRANSFER_FAILED\u0027);\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes(\u0027transferFrom(address,address,uint256)\u0027)));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: TRANSFER_FROM_FAILED\u0027);\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, \u0027TransferHelper: ETH_TRANSFER_FAILED\u0027);\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n\nimport \"./SafeMath.sol\";\n\ncontract Context {\n    \n    \n    constructor () { }\n    \n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    \n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}