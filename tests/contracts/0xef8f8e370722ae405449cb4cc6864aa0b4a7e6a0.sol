{{
  "language": "Solidity",
  "sources": {
    "contracts/global/WaitlistBatch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {Ownable} from \"../lib/Ownable.sol\";\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {SafeERC20} from \"../lib/SafeERC20.sol\";\n\nimport {IERC20} from \"../token/IERC20.sol\";\n\ncontract WaitlistBatch is Ownable {\n\n    /* ========== Libraries ========== */\n\n    using SafeMath for uint256;\n\n    /* ========== Types ========== */\n\n    struct Batch {\n        uint256 totalSpots;\n        uint256 filledSpots;\n        uint256 batchStartTimestamp;\n        uint256 depositAmount;\n        uint256 approvedAt;\n    }\n\n    struct UserBatchInfo {\n        bool hasParticipated;\n        uint256 batchNumber;\n        uint256 depositAmount;\n        uint256 depositRetrievalTimestamp;\n    }\n\n    /* ========== Variables ========== */\n\n    address public moderator;\n\n    IERC20 public depositCurrency;\n\n    uint256 public nextBatchNumber;\n\n    uint256 public depositLockupDuration;\n\n    mapping (uint256 => mapping (address => uint256)) public userDepositMapping;\n\n    mapping (uint256 => Batch) public batchMapping;\n\n    mapping (address => uint256) public userBatchMapping;\n\n    mapping (address => bool) public blacklist;\n\n    /* ========== Events ========== */\n\n    event AppliedToBatch(\n        address indexed user,\n        uint256 batchNumber,\n        uint256 amount\n    );\n\n    event NewBatchAdded(\n        uint256 totalSpots,\n        uint256 batchStartTimestamp,\n        uint256 depositAmount,\n        uint256 batchNumber\n    );\n\n    event BatchApproved(uint256 _batchNumber);\n\n    event BatchTimestampChanged(\n        uint256 batchNumber,\n        uint256 batchStartTimstamp\n    );\n\n    event BatchTotalSpotsUpdated(\n        uint256 batchNumber,\n        uint256 newTotalSpots\n    );\n\n    event TokensReclaimed(\n        address user,\n        uint256 amount\n    );\n\n    event TokensReclaimedBlacklist(\n        address user,\n        uint256 amount\n    );\n\n    event TokensTransferred(\n        address tokenAddress,\n        uint256 amount,\n        address destination\n    );\n\n    event RemovedFromBlacklist(\n        address user\n    );\n\n    event AddedToBlacklist(\n        address user\n    );\n\n    event ModeratorSet(\n        address user\n    );\n\n    event DepositLockupDurationSet(uint256 _depositLockupDuration);\n\n    /* ========== Modifiers ========== */\n\n    modifier onlyModerator() {\n        require(\n            msg.sender == moderator,\n            \"WaitlistBatch: caller is not moderator\"\n        );\n        _;\n    }\n\n    /* ========== Constructor ========== */\n\n    constructor(\n        address _depositCurrency,\n        uint256 _depositLockupDuration\n    ) public {\n        depositCurrency = IERC20(_depositCurrency);\n        depositLockupDuration = _depositLockupDuration;\n\n        // Set the next batch number to 1 to avoid some complications\n        // caused by batch number 0\n        nextBatchNumber = 1;\n    }\n\n    /* ========== Public Getters ========== */\n\n    function getBatchInfoForUser(\n        address _user\n    )\n        public\n        view\n        returns (UserBatchInfo memory)\n    {\n        uint256 participatingBatch = userBatchMapping[_user];\n\n        return UserBatchInfo({\n            hasParticipated: participatingBatch > 0,\n            batchNumber: participatingBatch,\n            depositAmount: userDepositMapping[participatingBatch][_user],\n            depositRetrievalTimestamp: getDepositRetrievalTimestamp(_user)\n        });\n    }\n\n    function getTotalNumberOfBatches()\n        public\n        view\n        returns (uint256)\n    {\n        return nextBatchNumber - 1;\n    }\n\n    /**\n     * @notice Returns the epoch when the user can withdraw their deposit\n     */\n    function getDepositRetrievalTimestamp(\n        address _account\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 participatingBatch = userBatchMapping[_account];\n\n        Batch memory batch = batchMapping[participatingBatch];\n\n        return batch.approvedAt == 0\n            ? 0\n            : batch.approvedAt.add(depositLockupDuration);\n    }\n\n    /* ========== Public Functions ========== */\n\n    function applyToBatch(\n        uint256 _batchNumber\n    )\n        public\n    {\n        require(\n            _batchNumber > 0 && _batchNumber < nextBatchNumber,\n            \"WaitlistBatch: batch does not exist\"\n        );\n\n        // Check if user already applied to a batch\n        UserBatchInfo memory batchInfo = getBatchInfoForUser(msg.sender);\n        require(\n            !batchInfo.hasParticipated,\n            \"WaitlistBatch: cannot apply to more than one batch\"\n        );\n\n        Batch storage batch = batchMapping[_batchNumber];\n\n        require(\n            batch.filledSpots < batch.totalSpots,\n            \"WaitlistBatch: batch is filled\"\n        );\n\n        require(\n            currentTimestamp() >= batch.batchStartTimestamp,\n            \"WaitlistBatch: cannot apply before the start time\"\n        );\n\n        batch.filledSpots++;\n\n        userDepositMapping[_batchNumber][msg.sender] = batch.depositAmount;\n        userBatchMapping[msg.sender] = _batchNumber;\n\n        SafeERC20.safeTransferFrom(\n            depositCurrency,\n            msg.sender,\n            address(this),\n            batch.depositAmount\n        );\n\n        emit AppliedToBatch(\n            msg.sender,\n            _batchNumber,\n            batch.depositAmount\n        );\n    }\n\n    function reclaimTokens()\n        public\n    {\n        require(\n            blacklist[msg.sender] == false,\n            \"WaitlistBatch: user is blacklisted\"\n        );\n\n        UserBatchInfo memory batchInfo = getBatchInfoForUser(msg.sender);\n\n        require(\n            batchInfo.hasParticipated,\n            \"WaitlistBatch: user did not participate in a batch\"\n        );\n\n        require(\n            batchInfo.depositAmount > 0,\n            \"WaitlistBatch: there are no tokens to reclaim\"\n        );\n\n        require(\n            batchInfo.depositRetrievalTimestamp > 0,\n            \"WaitlistBatch: the batch is not approved yet\"\n        );\n\n        require(\n            batchInfo.depositRetrievalTimestamp <= currentTimestamp(),\n            \"WaitlistBatch: the deposit lockup duration has not passed yet\"\n        );\n\n        userDepositMapping[batchInfo.batchNumber][msg.sender] -= batchInfo.depositAmount;\n\n        SafeERC20.safeTransfer(\n            depositCurrency,\n            msg.sender,\n            batchInfo.depositAmount\n        );\n\n        emit TokensReclaimed(msg.sender, batchInfo.depositAmount);\n    }\n\n    /* ========== Admin Functions ========== */\n\n    /**\n     * @dev Adds a new batch to the `batchMapping` and increases the\n     *      count of `totalNumberOfBatches`\n     */\n    function addNewBatch(\n        uint256 _totalSpots,\n        uint256 _batchStartTimestamp,\n        uint256 _depositAmount\n    )\n        public\n        onlyOwner\n    {\n        require(\n            _batchStartTimestamp >= currentTimestamp(),\n            \"WaitlistBatch: batch start time cannot be in the past\"\n        );\n\n        require(\n            _depositAmount > 0,\n            \"WaitlistBatch: deposit amount cannot be 0\"\n        );\n\n        require(\n            _totalSpots > 0,\n            \"WaitlistBatch: batch cannot have 0 spots\"\n        );\n\n        Batch memory batch = Batch(\n            _totalSpots,\n            0,\n            _batchStartTimestamp,\n            _depositAmount,\n            0\n        );\n\n        batchMapping[nextBatchNumber] = batch;\n        nextBatchNumber = nextBatchNumber + 1;\n\n        emit NewBatchAdded(\n            _totalSpots,\n            _batchStartTimestamp,\n            _depositAmount,\n            nextBatchNumber - 1\n        );\n    }\n\n    /**\n     * @dev Approves a batch. Users can then start reclaiming their deposit\n     *      after the retrieval date delay.\n     */\n    function approveBatch(\n        uint256 _batchNumber\n    )\n        external\n        onlyOwner\n    {\n        require(\n            _batchNumber > 0 && _batchNumber < nextBatchNumber,\n            \"WaitlistBatch: the batch does not exist\"\n        );\n\n        Batch storage batch = batchMapping[_batchNumber];\n\n        require(\n            batch.approvedAt == 0,\n            \"WaitlistBatch: the batch is already approved\"\n        );\n\n        batch.approvedAt = currentTimestamp();\n\n        emit BatchApproved(_batchNumber);\n    }\n\n    function changeBatchStartTimestamp(\n        uint256 _batchNumber,\n        uint256 _newStartTimestamp\n    )\n        public\n        onlyOwner\n    {\n        require(\n            _batchNumber > 0 && _batchNumber < nextBatchNumber,\n            \"WaitlistBatch: batch does not exit\"\n        );\n\n        require(\n            _newStartTimestamp >= currentTimestamp(),\n            \"WaitlistBatch: batch start time cannot be in the past\"\n        );\n\n        Batch storage batch = batchMapping[_batchNumber];\n        batch.batchStartTimestamp = _newStartTimestamp;\n\n        emit BatchTimestampChanged(\n            _batchNumber,\n            _newStartTimestamp\n        );\n    }\n\n    function changeBatchTotalSpots(\n        uint256 _batchNumber,\n        uint256 _newSpots\n    )\n        public\n        onlyOwner\n    {\n        require(\n            _batchNumber > 0 && _batchNumber < nextBatchNumber,\n            \"WaitlistBatch: the batch does not exist\"\n        );\n\n        Batch storage batch = batchMapping[_batchNumber];\n\n        require(\n            currentTimestamp() < batch.batchStartTimestamp,\n            \"WaitlistBatch: the batch start date already passed\"\n        );\n\n        require(\n            batch.totalSpots < _newSpots,\n            \"WaitlistBatch: cannot change total spots to a smaller or equal number\"\n        );\n\n        batch.totalSpots = _newSpots;\n\n        emit BatchTotalSpotsUpdated(\n            _batchNumber,\n            _newSpots\n        );\n    }\n\n    function transferTokens(\n        address _tokenAddress,\n        uint256 _amount,\n        address _destination\n    )\n        public\n        onlyOwner\n    {\n        SafeERC20.safeTransfer(\n            IERC20(_tokenAddress),\n            _destination,\n            _amount\n        );\n\n        emit TokensTransferred(\n            _tokenAddress,\n            _amount,\n            _destination\n        );\n    }\n\n    function setModerator(\n        address _user\n    )\n        public\n        onlyOwner\n    {\n        moderator = _user;\n\n        emit ModeratorSet(_user);\n    }\n\n    function setDepositLockupDuration(\n        uint256 _duration\n    )\n        external\n        onlyOwner\n    {\n        depositLockupDuration = _duration;\n\n        emit DepositLockupDurationSet(depositLockupDuration);\n    }\n\n    /* ========== Moderator Functions ========== */\n\n    function addToBlacklist(\n        address _user\n    )\n        public\n        onlyModerator\n    {\n        blacklist[_user] = true;\n\n        emit AddedToBlacklist(_user);\n    }\n\n    function removeFromBlacklist(\n        address _user\n    )\n        public\n        onlyModerator\n    {\n        blacklist[_user] = false;\n\n        emit RemovedFromBlacklist(_user);\n    }\n\n    /* ========== Dev Functions ========== */\n\n    function currentTimestamp()\n        public\n        view\n        returns (uint256)\n    {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "\npragma solidity ^0.5.16;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.5.16;\n\nimport {IERC20} from \"../token/IERC20.sol\";\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary SafeERC20 {\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        /* solium-disable-next-line */\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        /* solium-disable-next-line */\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        /* solium-disable-next-line */\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(\n                0x23b872dd,\n                from,\n                to,\n                value\n            )\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: TRANSFER_FROM_FAILED\"\n        );\n    }\n}\n"
    },
    "contracts/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}