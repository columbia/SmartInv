{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/WorkerAuthManager.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerAuthManager\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\ninterface WorkerAuthManager {\n    /// @notice Gives worker permission to act on a DApp\n    /// @param _workerAddress address of the worker node to given permission\n    /// @param _dappAddress address of the dapp that permission will be given to\n    function authorize(address _workerAddress, address _dappAddress) external;\n\n    /// @notice Removes worker's permission to act on a DApp\n    /// @param _workerAddress address of the proxy that will lose permission\n    /// @param _dappAddresses addresses of dapps that will lose permission\n    function deauthorize(address _workerAddress, address _dappAddresses)\n        external;\n\n    /// @notice Returns is the dapp is authorized to be called by that worker\n    /// @param _workerAddress address of the worker\n    /// @param _dappAddress address of the DApp\n    function isAuthorized(address _workerAddress, address _dappAddress)\n        external\n        view\n        returns (bool);\n\n    /// @notice Get the owner of the worker node\n    /// @param workerAddress address of the worker node\n    function getOwner(address workerAddress) external view returns (address);\n\n    /// @notice A DApp has been authorized by a user for a worker\n    event Authorization(\n        address indexed user,\n        address indexed worker,\n        address indexed dapp\n    );\n\n    /// @notice A DApp has been deauthorized by a user for a worker\n    event Deauthorization(\n        address indexed user,\n        address indexed worker,\n        address indexed dapp\n    );\n}\n"
    },
    "contracts/WorkerManager.sol": {
      "content": "// Copyright 2010 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerManager\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\ninterface WorkerManager {\n    /// @notice Returns true if worker node is available\n    /// @param workerAddress address of the worker node\n    function isAvailable(address workerAddress) external view returns (bool);\n\n    /// @notice Returns true if worker node is pending\n    /// @param workerAddress address of the worker node\n    function isPending(address workerAddress) external view returns (bool);\n\n    /// @notice Get the owner of the worker node\n    /// @param workerAddress address of the worker node\n    function getOwner(address workerAddress) external view returns (address);\n\n    /// @notice Get the user of the worker node, which may not be the owner yet, or how was the previous owner of a retired node\n    function getUser(address workerAddress) external view returns (address);\n\n    /// @notice Returns true if worker node is owned by some user\n    function isOwned(address workerAddress) external view returns (bool);\n\n    /// @notice Asks the worker to work for the sender. Sender needs to pay something.\n    /// @param workerAddress address of the worker\n    function hire(address payable workerAddress) external payable;\n\n    /// @notice Called by the worker to accept the job\n    function acceptJob() external;\n\n    /// @notice Called by the worker to reject a job offer\n    function rejectJob() external payable;\n\n    /// @notice Called by the user to cancel a job offer\n    /// @param workerAddress address of the worker node\n    function cancelHire(address workerAddress) external;\n\n    /// @notice Called by the user to retire his worker.\n    /// @param workerAddress address of the worker to be retired\n    /// @dev this also removes all authorizations in place\n    function retire(address payable workerAddress) external;\n\n    /// @notice Returns true if worker node was retired by its owner\n    function isRetired(address workerAddress) external view returns (bool);\n\n    /// @notice Events signalling every state transition\n    event JobOffer(address indexed worker, address indexed user);\n    event JobAccepted(address indexed worker, address indexed user);\n    event JobRejected(address indexed worker, address indexed user);\n    event Retired(address indexed worker, address indexed user);\n}\n"
    },
    "contracts/WorkerManagerAuthManagerImpl.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerManagerAuthManagerImpl\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\nimport \"./WorkerManager.sol\";\nimport \"./WorkerAuthManager.sol\";\n\ncontract WorkerManagerAuthManagerImpl is WorkerManager, WorkerAuthManager {\n    /// @dev user can only hire a worker if he sends more than minimum value\n    uint256 constant MINIMUM_FUNDING = 0.001 ether;\n\n    /// @dev transfers bigger than maximum value should be done directly\n    uint256 constant MAXIMUM_FUNDING = 3 ether;\n\n    /// @notice A worker can be in 4 different states, starting from Available\n    enum WorkerState {Available, Pending, Owned, Retired}\n\n    /// @dev mapping from worker to its user\n    mapping(address => address payable) private userOf;\n\n    /// @dev mapping from worker to its internal state\n    mapping(address => WorkerState) private stateOf;\n\n    /// @dev permissions keyed by hash(user, worker, dapp)\n    mapping(bytes32 => bool) private permissions;\n\n    function isAvailable(address workerAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return stateOf[workerAddress] == WorkerState.Available;\n    }\n\n    function isPending(address workerAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return stateOf[workerAddress] == WorkerState.Pending;\n    }\n\n    function getOwner(address _workerAddress)\n        public\n        override(WorkerManager, WorkerAuthManager)\n        view\n        returns (address)\n    {\n        return\n            stateOf[_workerAddress] == WorkerState.Owned\n                ? userOf[_workerAddress]\n                : address(0);\n    }\n\n    function getUser(address _workerAddress)\n        public\n        override\n        view\n        returns (address)\n    {\n        return userOf[_workerAddress];\n    }\n\n    function isOwned(address _workerAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return stateOf[_workerAddress] == WorkerState.Owned;\n    }\n\n    function hire(address payable _workerAddress) public override payable {\n        require(isAvailable(_workerAddress), \"worker is not available\");\n        require(_workerAddress != address(0), \"worker address can not be 0x0\");\n        require(msg.value >= MINIMUM_FUNDING, \"funding below minimum\");\n        require(msg.value <= MAXIMUM_FUNDING, \"funding above maximum\");\n\n        // set owner\n        userOf[_workerAddress] = msg.sender;\n\n        // change state\n        stateOf[_workerAddress] = WorkerState.Pending;\n\n        // transfer ether to worker\n        _workerAddress.transfer(msg.value);\n\n        // emit event\n        emit JobOffer(_workerAddress, msg.sender);\n    }\n\n    function acceptJob() public override {\n        require(\n            stateOf[msg.sender] == WorkerState.Pending,\n            \"worker not is not in pending state\"\n        );\n\n        // change state\n        stateOf[msg.sender] = WorkerState.Owned;\n        // from now on getOwner will return the user\n\n        // emit event\n        emit JobAccepted(msg.sender, userOf[msg.sender]);\n    }\n\n    function rejectJob() public override payable {\n        require(\n            userOf[msg.sender] != address(0),\n            \"worker does not have a job offer\"\n        );\n\n        address payable owner = userOf[msg.sender];\n\n        // reset hirer back to null\n        userOf[msg.sender] = address(0);\n\n        // change state\n        stateOf[msg.sender] = WorkerState.Available;\n\n        // return the money\n        owner.transfer(msg.value);\n\n        // emit event\n        emit JobRejected(msg.sender, userOf[msg.sender]);\n    }\n\n    function cancelHire(address _workerAddress) public override {\n        require(\n            userOf[_workerAddress] == msg.sender,\n            \"only hirer can cancel the offer\"\n        );\n\n        // change state\n        stateOf[_workerAddress] = WorkerState.Retired;\n\n        // emit event\n        emit JobRejected(_workerAddress, msg.sender);\n    }\n\n    function retire(address payable _workerAddress) public override {\n        require(\n            stateOf[_workerAddress] == WorkerState.Owned,\n            \"worker not owned\"\n        );\n        require(\n            userOf[_workerAddress] == msg.sender,\n            \"only owner can retire worker\"\n        );\n\n        // change state\n        stateOf[_workerAddress] = WorkerState.Retired;\n\n        // emit event\n        emit Retired(_workerAddress, msg.sender);\n    }\n\n    function isRetired(address _workerAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return stateOf[_workerAddress] == WorkerState.Retired;\n    }\n\n    modifier onlyByUser(address _workerAddress) {\n        require(\n            getUser(_workerAddress) == msg.sender,\n            \"worker not hired by sender\"\n        );\n        _;\n    }\n\n    function getAuthorizationKey(\n        address _user,\n        address _worker,\n        address _dapp\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_user, _worker, _dapp));\n    }\n\n    function authorize(address _workerAddress, address _dappAddress)\n        public\n        override\n        onlyByUser(_workerAddress)\n    {\n        bytes32 key = getAuthorizationKey(\n            msg.sender,\n            _workerAddress,\n            _dappAddress\n        );\n        require(permissions[key] == false, \"dapp already authorized\");\n\n        // record authorization from that user\n        permissions[key] = true;\n\n        // emit event\n        emit Authorization(msg.sender, _workerAddress, _dappAddress);\n    }\n\n    function deauthorize(address _workerAddress, address _dappAddress)\n        public\n        override\n        onlyByUser(_workerAddress)\n    {\n        bytes32 key = getAuthorizationKey(\n            msg.sender,\n            _workerAddress,\n            _dappAddress\n        );\n        require(permissions[key] == true, \"dapp not authorized\");\n\n        // record deauthorization from that user\n        permissions[key] = false;\n\n        // emit event\n        emit Deauthorization(msg.sender, _workerAddress, _dappAddress);\n    }\n\n    function isAuthorized(address _workerAddress, address _dappAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return\n            permissions[getAuthorizationKey(\n                getOwner(_workerAddress),\n                _workerAddress,\n                _dappAddress\n            )];\n    }\n\n    function hireAndAuthorize(\n        address payable _workerAddress,\n        address _dappAddress\n    ) public payable {\n        hire(_workerAddress);\n        authorize(_workerAddress, _dappAddress);\n    }\n}\n"
    }
  }
}}