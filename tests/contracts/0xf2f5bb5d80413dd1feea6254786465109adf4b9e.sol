{{
  "language": "Solidity",
  "sources": {
    "contracts/OrgFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./EndaomentAdminStorage.sol\";\nimport \"./Org.sol\";\nimport \"./ProxyFactory.sol\";\n\n//ORG FACTORY CONTRACT\n/**\n * @title OrgFactory\n * @author rheeger\n * @notice OrgFactory is a contract that allows the EndaomentAdmin to\n * instantiate new Org contracts. It also provides for fetching of\n * individual Org contract addresses as well as a list of all\n * allowedOrgs.\n */\ncontract OrgFactory is ProxyFactory, EndaomentAdminStorage {\n  // ========== EVENTS===================\n\n  event OrgCreated(address indexed newAddress);\n  event OrgStatusChanged(address indexed orgAddress, bool indexed isAllowed);\n  event OrgLogicDeployed(address logicAddress);\n\n  // ========== STATE VARIABLES==========\n\n  mapping(address => bool) public allowedOrgs;\n  address public immutable orgLogic; // logic template for all Org contracts\n\n  // ========== CONSTRUCTOR ==========\n  /**\n   * @notice Creates new Org Factory and emits a `EndaomentAdminChanged` event\n   * @param adminContractAddress Address of EndaomentAdmin contract.\n   */\n  constructor(address adminContractAddress) public {\n    // Set endaoment admin\n    require(adminContractAddress != address(0), \"OrgFactory: Admin cannot be the zero address\");\n    endaomentAdmin = adminContractAddress;\n    emit EndaomentAdminChanged(address(0), adminContractAddress);\n\n    // Deploy and initialize Org logic contract (used to deploy minimal proxies in createOrg)\n    // We set the EIN to 999999999, since it is unlikely to be a real EIN. Even if it is a real\n    // EIN, that is ok because (1) there is no check against duplicate EINs, and (2) this instance\n    // is not used as anything other than a logic template, so the EIN value doesn't matter\n    Org orgLogicContract = new Org();\n    orgLogicContract.initializeOrg(999999999, address(this));\n\n    // Save off address so we can reference for all future deployments\n    orgLogic = address(orgLogicContract);\n    emit OrgLogicDeployed(address(orgLogicContract));\n  }\n\n  // ========== Org Creation & Management ==========\n  /**\n   * @notice Creates new Org Contract and emits a `OrgCreated` event\n   * @param ein The U.S. Tax Identification Number for the Organization\n   */\n  function createOrg(uint256 ein)\n    public\n    onlyAdminOrRole(endaomentAdmin, IEndaomentAdmin.Role.ACCOUNTANT)\n  {\n    require(ein >= 10000000 && ein <= 999999999, \"Org: Must provide a valid EIN\");\n    bytes memory payload = abi.encodeWithSignature(\n      \"initializeOrg(uint256,address)\",\n      ein,\n      address(this)\n    );\n    address newOrg = deployMinimal(orgLogic, payload);\n\n    allowedOrgs[newOrg] = true;\n    emit OrgCreated(newOrg);\n  }\n\n  /**\n   * @notice Toggles whether Org is allowed and emits a `OrgStatusChanged` event\n   * @param orgAddress THe address of the Org contract.\n   */\n  function toggleOrg(address orgAddress)\n    public\n    onlyAdminOrRole(endaomentAdmin, IEndaomentAdmin.Role.REVIEWER)\n  {\n    require(Org(orgAddress).taxId() != 0, \"OrgFactory: Not a valid org.\");\n    allowedOrgs[orgAddress] = !allowedOrgs[orgAddress];\n    emit OrgStatusChanged(orgAddress, allowedOrgs[orgAddress]);\n  }\n}\n"
    },
    "contracts/EndaomentAdminStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./Administratable.sol\";\n\n// ENDAOMENT ADMIN STORAGE CONTRACT\n/**\n * @title EndaomentAdminStorage\n * @author rheeger\n * @notice Stores the contract address of the EndaomentAdmin,\n * for use in references by the Org and Fund factories and\n * subsequently deployed Org and Fund contracts.\n */\ncontract EndaomentAdminStorage is Administratable {\n  address public endaomentAdmin;\n  event EndaomentAdminChanged(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @notice Updates address of the endaomentAdmin contract and emits `EndaomentAdminChanged` event.\n   * @param newAdmin New address of the endaomentAdmin contract\n   */\n  function updateEndaomentAdmin(address newAdmin) public onlyAdmin(endaomentAdmin) {\n    // Validate that contract has a valid admin address set\n    require(newAdmin != address(0), \"EndaomentAdminStorage: New admin cannot be the zero address\");\n    EndaomentAdmin endaomentAdminContract = EndaomentAdmin(newAdmin);\n\n    address admin = endaomentAdminContract.getRoleAddress(IEndaomentAdmin.Role.ADMIN);\n    require(admin != address(0), \"EndaomentAdminStorage: Admin cannot be the zero address\");\n\n    emit EndaomentAdminChanged(endaomentAdmin, newAdmin);\n    endaomentAdmin = newAdmin;\n  }\n}\n"
    },
    "contracts/Org.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport \"./Administratable.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\n//ORG CONTRACT\n/**\n * @title Org\n * @author rheeger\n * @notice Org is a contract that serves as a smart wallet for US nonprofit\n * organizations. It holds the organization's federal Tax ID number as taxID,\n * and allows for an address to submit a Claim struct to the contract whereby\n * the organization can directly receive grant awards from Endaoment Funds.\n */\ncontract Org is Initializable, Administratable {\n  using SafeERC20 for IERC20;\n\n  // ========== STRUCTS & EVENTS ==========\n\n  struct Claim {\n    string firstName;\n    string lastName;\n    string eMail;\n    address desiredWallet;\n  }\n  event CashOutComplete(uint256 cashOutAmount);\n  event ClaimCreated(string claimId, Claim claim);\n  event ClaimApproved(string claimId, Claim claim);\n  event ClaimRejected(string claimId, Claim claim);\n\n  // ========== STATE VARIABLES ==========\n\n  IFactory public orgFactoryContract;\n  uint256 public taxId;\n  mapping(string => Claim) public pendingClaims; // claim UUID to Claim\n  Claim public activeClaim;\n\n  // ========== CONSTRUCTOR ==========\n\n  /**\n   * @notice Create new Organization Contract\n   * @dev Using initializer instead of constructor for minimal proxy support. This function\n   * can only be called once in the contract's lifetime\n   * @param ein The U.S. Tax Identification Number for the Organization\n   * @param orgFactory Address of the Factory contract.\n   */\n  function initializeOrg(uint256 ein, address orgFactory) public initializer {\n    require(orgFactory != address(0), \"Org: Factory cannot be null address.\");\n    taxId = ein;\n    orgFactoryContract = IFactory(orgFactory);\n  }\n\n  // ========== Org Management & Info ==========\n\n  /**\n   * @notice Creates Organization Claim and emits a `ClaimCreated` event\n   * @param  claimId UUID representing this claim\n   * @param  fName First name of Administrator\n   * @param  lName Last name of Administrator\n   * @param  eMail Email contact for Organization Administrator.\n   * @param  orgAdminWalletAddress Wallet address of Organization's Administrator.\n   */\n  function claimRequest(\n    string calldata claimId,\n    string calldata fName,\n    string calldata lName,\n    string calldata eMail,\n    address orgAdminWalletAddress\n  ) public {\n    require(!isEqual(claimId, \"\"), \"Org: Must provide claimId\");\n    require(!isEqual(fName, \"\"), \"Org: Must provide the first name of the administrator\");\n    require(!isEqual(lName, \"\"), \"Org: Must provide the last name of the administrator\");\n    require(!isEqual(eMail, \"\"), \"Org: Must provide the email address of the administrator\");\n    require(orgAdminWalletAddress != address(0), \"Org: Wallet address cannot be the zero address\");\n    require(\n      pendingClaims[claimId].desiredWallet == address(0),\n      \"Org: Pending Claim with Id already exists\"\n    );\n\n    Claim memory newClaim = Claim({\n      firstName: fName,\n      lastName: lName,\n      eMail: eMail,\n      desiredWallet: orgAdminWalletAddress\n    });\n\n    emit ClaimCreated(claimId, newClaim);\n    pendingClaims[claimId] = newClaim;\n  }\n\n  /**\n   * @notice Approves an Organization Claim and emits a `ClaimApproved` event\n   * @param claimId UUID of the claim being approved\n   */\n  function approveClaim(string calldata claimId)\n    public\n    onlyAdminOrRole(orgFactoryContract.endaomentAdmin(), IEndaomentAdmin.Role.REVIEWER)\n  {\n    require(!isEqual(claimId, \"\"), \"Fund: Must provide a claimId\");\n    Claim storage claim = pendingClaims[claimId];\n    require(claim.desiredWallet != address(0), \"Org: claim does not exist\");\n    emit ClaimApproved(claimId, claim);\n    activeClaim = claim;\n    delete pendingClaims[claimId];\n  }\n\n  /**\n   * @notice Rejects an Organization Claim and emits a 'ClaimRejected` event\n   * @param claimId UUID of the claim being rejected\n   */\n  function rejectClaim(string calldata claimId)\n    public\n    onlyAdminOrRole(orgFactoryContract.endaomentAdmin(), IEndaomentAdmin.Role.REVIEWER)\n  {\n    require(!isEqual(claimId, \"\"), \"Fund: Must provide a claimId\");\n    Claim storage claim = pendingClaims[claimId];\n    require(claim.desiredWallet != address(0), \"Org: claim does not exist\");\n\n    emit ClaimRejected(claimId, claim);\n\n    delete pendingClaims[claimId];\n  }\n\n  /**\n   * @notice Cashes out Organization Contract and emits a `CashOutComplete` event\n   * @param tokenAddress ERC20 address of desired token withdrawal\n   */\n  function cashOutOrg(address tokenAddress)\n    public\n    onlyAdminOrRole(orgFactoryContract.endaomentAdmin(), IEndaomentAdmin.Role.ACCOUNTANT)\n  {\n    require(tokenAddress != address(0), \"Org: Token address cannot be the zero address\");\n    address payoutAddr = orgWallet();\n    require(payoutAddr != address(0), \"Org: Cannot cashout unclaimed Org\");\n\n    IERC20 tokenContract = IERC20(tokenAddress);\n    uint256 cashOutAmount = tokenContract.balanceOf(address(this));\n\n    tokenContract.safeTransfer(orgWallet(), cashOutAmount);\n    emit CashOutComplete(cashOutAmount);\n  }\n\n  /**\n   * @notice Retrieves Token Balance of Org Contract\n   * @param tokenAddress Address of desired token to query for balance\n   * @return Balance of conract in token base unit of provided tokenAddress\n   */\n  function getTokenBalance(address tokenAddress) external view returns (uint256) {\n    IERC20 tokenContract = IERC20(tokenAddress);\n    uint256 balance = tokenContract.balanceOf(address(this));\n\n    return balance;\n  }\n\n  /**\n   * @notice Org Wallet convenience accessor\n   * @return The wallet specified in the active, approved claim\n   */\n  function orgWallet() public view returns (address) {\n    return activeClaim.desiredWallet;\n  }\n}\n"
    },
    "contracts/ProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.7;\n\ncontract ProxyFactory {\n  /**\n   * @dev This function enables deployment of EIP-1167 minimal proxies. The code below\n   * was copied from the OpenZeppelin ProxyFactory.sol contract, as there is currently\n   * no package that has a version compatible with Solidity ^0.6.0. At the time of writing\n   * copy/pasting the file in this manner is considered the best practice for ^0.6.0:\n   *   https://forum.openzeppelin.com/t/best-practice-for-using-proxyfactory-sol-in-a-solidity-0-6-project-deploying-minimal-proxies/3478\n   *\n   * EIP-1167 references:\n   *   The EIP and associated CloneFactory repo\n   *     - https://eips.ethereum.org/EIPS/eip-1167\n   *   Open Zeppelin blog post and discussion\n   *     - https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\n   *     - https://forum.openzeppelin.com/t/deep-dive-into-the-minimal-proxy-contract/1928\n   */\n  function deployMinimal(address _logic, bytes memory _data) public returns (address proxy) {\n    // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n    bytes20 targetBytes = bytes20(_logic);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      proxy := create(0, clone, 0x37)\n    }\n\n    if (_data.length > 0) {\n      (bool success, ) = proxy.call(_data);\n      require(success, \"ProxyFactory: Initialization of proxy failed\");\n    }\n  }\n}\n"
    },
    "contracts/Administratable.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./EndaomentAdmin.sol\";\n\n//ADMINISTRATABLE\n/**\n * @title Administratable\n * @author rheeger\n * @notice Provides two modifiers allowing contracts administered\n * by the EndaomentAdmin contract to properly restrict method calls\n * based on the a given role. Also provides a utility function for\n * validating string input arguments.\n */\ncontract Administratable {\n  /**\n   * @notice onlyAdmin checks that the caller is the EndaomentAdmin\n   * @param adminContractAddress is the supplied EndaomentAdmin contract address\n   */\n  modifier onlyAdmin(address adminContractAddress) {\n    require(\n      adminContractAddress != address(0),\n      \"Administratable: Admin must not be the zero address\"\n    );\n    EndaomentAdmin endaomentAdmin = EndaomentAdmin(adminContractAddress);\n\n    require(\n      msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN),\n      \"Administratable: only ADMIN can access.\"\n    );\n    _;\n  }\n\n  /**\n   * @notice onlyAdminOrRole checks that the caller is either the Admin or the provided role.\n   * @param adminContractAddress supplied EndaomentAdmin address\n   * @param role The role to require unless the caller is the owner. Permitted\n   * roles are ADMIN (6), ACCOUNTANT (2), REVIEWER (3), FUND_FACTORY (4) and ORG_FACTORY(5).\n   */\n  modifier onlyAdminOrRole(address adminContractAddress, IEndaomentAdmin.Role role) {\n    _onlyAdminOrRole(adminContractAddress, role);\n    _;\n  }\n\n  /**\n   * @notice _onlyAdminOrRole checks that the caller is either the Admin or the provided role.\n   * @param adminContractAddress supplied EndaomentAdmin address\n   * @param role The role to require unless the caller is the owner. Permitted\n   * roles are ADMIN (6), ACCOUNTANT (2), REVIEWER (3), FUND_FACTORY (4) and ORG_FACTORY(5).\n   */\n  function _onlyAdminOrRole(address adminContractAddress, IEndaomentAdmin.Role role) private view {\n    require(\n      adminContractAddress != address(0),\n      \"Administratable: Admin must not be the zero address\"\n    );\n    EndaomentAdmin endaomentAdmin = EndaomentAdmin(adminContractAddress);\n    bool isAdmin = (msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ADMIN));\n\n    if (!isAdmin) {\n      if (endaomentAdmin.isPaused(role)) {\n        revert(\"Administratable: requested role is paused\");\n      }\n\n      if (role == IEndaomentAdmin.Role.ACCOUNTANT) {\n        require(\n          msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ACCOUNTANT),\n          \"Administratable: only ACCOUNTANT can access\"\n        );\n      }\n      if (role == IEndaomentAdmin.Role.REVIEWER) {\n        require(\n          msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.REVIEWER),\n          \"Administratable: only REVIEWER can access\"\n        );\n      }\n      if (role == IEndaomentAdmin.Role.FUND_FACTORY) {\n        require(\n          msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.FUND_FACTORY),\n          \"Administratable: only FUND_FACTORY can access\"\n        );\n      }\n      if (role == IEndaomentAdmin.Role.ORG_FACTORY) {\n        require(\n          msg.sender == endaomentAdmin.getRoleAddress(IEndaomentAdmin.Role.ORG_FACTORY),\n          \"Administratable: only ORG_FACTORY can access\"\n        );\n      }\n    }\n  }\n\n  /**\n   * @notice Checks that the caller is either a provided address, admin or role.\n   * @param allowedAddress An exempt address provided that shall be allowed to proceed.\n   * @param adminContractAddress The EndaomentAdmin contract address.\n   * @param role The desired IEndaomentAdmin.Role to check against. Permitted\n   * roles are ADMIN (6), ACCOUNTANT (2), REVIEWER (3), FUND_FACTORY (4) and ORG_FACTORY(5).\n   */\n  modifier onlyAddressOrAdminOrRole(\n    address allowedAddress,\n    address adminContractAddress,\n    IEndaomentAdmin.Role role\n  ) {\n    require(\n      allowedAddress != address(0),\n      \"Administratable: Allowed address must not be the zero address\"\n    );\n\n    bool isAllowed = (msg.sender == allowedAddress);\n\n    if (!isAllowed) {\n      _onlyAdminOrRole(adminContractAddress, role);\n    }\n    _;\n  }\n\n  /**\n   * @notice Returns true if two strings are equal, false otherwise\n   * @param s1 First string to compare\n   * @param s2 Second string to compare\n   */\n  function isEqual(string memory s1, string memory s2) internal pure returns (bool) {\n    return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));\n  }\n}\n"
    },
    "contracts/EndaomentAdmin.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\nimport \"./interfaces/IEndaomentAdmin.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n *\n * In order to transfer ownership, a recipient must be specified, at which point\n * the specified recipient can call `acceptOwnership` and take ownership.\n */\ncontract TwoStepOwnable {\n  address private _owner;\n  address private _newPotentialOwner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  event TransferInitiated(address indexed newOwner);\n\n  event TransferCancelled(address indexed newPotentialOwner);\n\n  /**\n   * @dev Initialize contract by setting transaction submitter as initial owner.\n   */\n  constructor() internal {\n    _owner = tx.origin;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function getOwner() external view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Returns the address of the current potential new owner.\n   */\n  function getNewPotentialOwner() external view returns (address) {\n    return _newPotentialOwner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\n    _;\n  }\n\n  /**\n   * @dev Returns true if the caller is the current owner.\n   */\n  function isOwner() public view returns (bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Allows a new account (`newOwner`) to accept ownership.\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newPotentialOwner) public onlyOwner {\n    require(\n      newPotentialOwner != address(0),\n      \"TwoStepOwnable: new potential owner is the zero address.\"\n    );\n\n    _newPotentialOwner = newPotentialOwner;\n    emit TransferInitiated(address(newPotentialOwner));\n  }\n\n  /**\n   * @dev Cancel a transfer of ownership to a new account.\n   * Can only be called by the current owner.\n   */\n  function cancelOwnershipTransfer() public onlyOwner {\n    emit TransferCancelled(address(_newPotentialOwner));\n    delete _newPotentialOwner;\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to the caller.\n   * Can only be called by a new potential owner set by the current owner.\n   */\n  function acceptOwnership() public {\n    require(\n      msg.sender == _newPotentialOwner,\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\n    );\n\n    delete _newPotentialOwner;\n\n    emit OwnershipTransferred(_owner, msg.sender);\n\n    _owner = msg.sender;\n  }\n}\n\n/**\n * @title EndaomentAdmin\n * @author rheeger\n * @notice Provides admin controls for the Endaoment contract ecosystem using\n * a roles-based system. Available roles are PAUSER (1), ACCOUNTANT (2),\n * REVIEWER (3), FUND_FACTORY (4), ORG_FACTORY (5), and ADMIN (6).\n */\ncontract EndaomentAdmin is IEndaomentAdmin, TwoStepOwnable {\n  // Maintain a role status mapping with assigned accounts and paused states.\n  mapping(uint256 => RoleStatus) private _roles;\n\n  /**\n   * @notice Set a new account on a given role and emit a `RoleModified` event\n   * if the role holder has changed. Only the owner may call this function.\n   * @param role The role that the account will be set for.\n   * @param account The account to set as the designated role bearer.\n   */\n  function setRole(Role role, address account) public override onlyOwner {\n    require(account != address(0), \"EndaomentAdmin: Must supply an account.\");\n    _setRole(role, account);\n  }\n\n  /**\n   * @notice Remove any current role bearer for a given role and emit a\n   * `RoleModified` event if a role holder was previously set. Only the owner\n   * may call this function.\n   * @param role The role that the account will be removed from.\n   */\n  function removeRole(Role role) public override onlyOwner {\n    _setRole(role, address(0));\n  }\n\n  /**\n   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\n   * the owner or the designated pauser may call this function. Also, bear in\n   * mind that only the owner may unpause a role once paused.\n   * @param role The role to pause.\n   */\n  function pause(Role role) public override onlyAdminOr(Role.PAUSER) {\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n    require(!storedRoleStatus.paused, \"EndaomentAdmin: Role in question is already paused.\");\n    storedRoleStatus.paused = true;\n    emit RolePaused(role);\n  }\n\n  /**\n   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\n   * Only the owner may call this function.\n   * @param role The role to pause.\n   */\n  function unpause(Role role) public override onlyOwner {\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n    require(storedRoleStatus.paused, \"EndaomentAdmin: Role in question is already unpaused.\");\n    storedRoleStatus.paused = false;\n    emit RoleUnpaused(role);\n  }\n\n  /**\n   * @notice External view function to check whether or not the functionality\n   * associated with a given role is currently paused or not. The owner or the\n   * pauser may pause any given role (including the pauser itself), but only the\n   * owner may unpause functionality. Additionally, the owner may call paused\n   * functions directly.\n   * @param role The role to check the pause status on.\n   * @return A boolean to indicate if the functionality associated with\n   * the role in question is currently paused.\n   */\n  function isPaused(Role role) external override view returns (bool) {\n    return _isPaused(role);\n  }\n\n  /**\n   * @notice External view function to check whether the caller is the current\n   * role holder.\n   * @param role The role to check for.\n   * @return A boolean indicating if the caller has the specified role.\n   */\n  function isRole(Role role) external override view returns (bool) {\n    return _isRole(role);\n  }\n\n  /**\n   * @notice External view function to check the account currently holding the\n   * given role.\n   * @param role The desired role to fetch the current address of.\n   * @return The address of the requested role, or the null\n   * address if none is set.\n   */\n  function getRoleAddress(Role role) external override view returns (address) {\n    require(\n      _roles[uint256(role)].account != address(0),\n      \"EndaomentAdmin: Role bearer is null address.\"\n    );\n    return _roles[uint256(role)].account;\n  }\n\n  /**\n   * @notice Private function to set a new account on a given role and emit a\n   * `RoleModified` event if the role holder has changed.\n   * @param role The role that the account will be set for.\n   * @param account The account to set as the designated role bearer.\n   */\n  function _setRole(Role role, address account) private {\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n\n    if (account != storedRoleStatus.account) {\n      storedRoleStatus.account = account;\n      emit RoleModified(role, account);\n    }\n  }\n\n  /**\n   * @notice Private view function to check whether the caller is the current\n   * role holder.\n   * @param role The role to check for.\n   * @return A boolean indicating if the caller has the specified role.\n   */\n  function _isRole(Role role) private view returns (bool) {\n    return msg.sender == _roles[uint256(role)].account;\n  }\n\n  /**\n   * @notice Private view function to check whether the given role is paused or\n   * not.\n   * @param role The role to check for.\n   * @return A boolean indicating if the specified role is paused or not.\n   */\n  function _isPaused(Role role) private view returns (bool) {\n    return _roles[uint256(role)].paused;\n  }\n\n  /**\n   * @notice Modifier that throws if called by any account other than the owner\n   * or the supplied role, or if the caller is not the owner and the role in\n   * question is paused.\n   * @param role The role to require unless the caller is the owner.\n   */\n  modifier onlyAdminOr(Role role) {\n    if (!isOwner()) {\n      require(_isRole(role), \"EndaomentAdmin: Caller does not have a required role.\");\n      require(!_isPaused(role), \"EndaomentAdmin: Role in question is currently paused.\");\n    }\n    _;\n  }\n}\n"
    },
    "contracts/interfaces/IEndaomentAdmin.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\n/**\n * @dev Interface of the EndaomentAdmin contract\n */\ninterface IEndaomentAdmin {\n  event RoleModified(Role indexed role, address account);\n  event RolePaused(Role indexed role);\n  event RoleUnpaused(Role indexed role);\n\n  enum Role {\n    EMPTY,\n    PAUSER,\n    ACCOUNTANT,\n    REVIEWER,\n    FUND_FACTORY,\n    ORG_FACTORY,\n    ADMIN\n  }\n\n  struct RoleStatus {\n    address account;\n    bool paused;\n  }\n\n  function setRole(Role role, address account) external;\n\n  function removeRole(Role role) external;\n\n  function pause(Role role) external;\n\n  function unpause(Role role) external;\n\n  function isPaused(Role role) external view returns (bool);\n\n  function isRole(Role role) external view returns (bool);\n\n  function getRoleAddress(Role role) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD 3-Clause\n\npragma solidity ^0.6.10;\n\ninterface IFactory {\n  function endaomentAdmin() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/upgrades/contracts/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}