{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/ArchToken.sol": {
      "content": "\n\n/************************************************************************\n ~~~ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\ ~~~~\n ~~~ @@@@@@ ░█████╗░██████╗░░█████╗░██╗░░██╗███████╗██████╗░ @@@@@@ | ~~~\n ~~~ @@@@@  ██╔══██╗██╔══██╗██╔══██╗██║░░██║██╔════╝██╔══██╗  @@@@@ | ~~~\n ~~~ @@@@@  ███████║██████╔╝██║░░╚═╝███████║█████╗░░██████╔╝ @@@@@@ | ~~~\n ~~~ @@@@@  ██╔══██║██╔══██╗██║░░██╗██╔══██║██╔══╝░░██╔══██╗  @@@@@ | ~~~\n ~~~ @@@@@  ██║░░██║██║░░██║╚█████╔╝██║░░██║███████╗██║░░██║  @@@@@ | ~~~\n ~~~ @@@@@  ╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝  @@@@@ | ~~~\n ~~~ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ | ~~~\n ~~~ \\_____________________________________________________________\\| ~~~\n ************************************************************************/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\n\n/**\n * @title ArchToken\n * @dev The governance token for Archer DAO\n * ERC-20 with supply controls + add-ons to allow for offchain signing\n * See EIP-712, EIP-2612, and EIP-3009 for details\n */\ncontract ArchToken {\n    using SafeMath for uint256;\n\n    /// @notice EIP-20 token name for this token\n    string public name = \"Archer DAO Governance Token\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public symbol = \"ARCH\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    uint256 public totalSupply = 100_000_000e18; // 100 million\n\n    /// @notice Address which may mint/burn tokens\n    address public supplyManager;\n\n    /// @notice Address which may change token metadata\n    address public metadataManager;\n\n    /// @notice The timestamp after which a supply change may occur\n    uint256 public supplyChangeAllowedAfter;\n\n    /// @notice The initial minimum time between changing the token supply\n    uint32 public supplyChangeWaitingPeriod = 1 days * 365;\n\n    /// @notice Hard cap on the minimum time between changing the token supply\n    uint32 public constant supplyChangeWaitingPeriodMinimum = 1 days * 90;\n\n    /// @notice Cap on the total amount that can be minted at each mint (measured in bips: 10,000 bips = 1% of current totalSupply)\n    uint16 public mintCap = 20_000;\n\n    /// @dev Allowance amounts on behalf of others\n    mapping (address => mapping (address => uint256)) internal allowances;\n\n    /// @dev Official record of token balances for each account\n    mapping (address => uint256) internal balances;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    /// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n    \n    /// @notice The EIP-712 version hash\n    /// keccak256(\"1\");\n    bytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// @notice The EIP-712 typehash for permit (EIP-2612)\n    /// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice The EIP-712 typehash for transferWithAuthorization (EIP-3009)\n    /// keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n    /// @notice The EIP-712 typehash for receiveWithAuthorization (EIP-3009)\n    /// keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @dev authorizer address > nonce > state (true = used / false = unused)\n    mapping (address => mapping (bytes32 => bool)) public authorizationState;\n\n    /// @notice An event that's emitted when the mintCap is changed\n    event MintCapChanged(uint16 indexed oldMintCap, uint16 indexed newMintCap);\n\n    /// @notice An event that's emitted when the supplyManager address is changed\n    event SupplyManagerChanged(address indexed oldManager, address indexed newManager);\n\n    /// @notice An event that's emitted when the supplyChangeWaitingPeriod is changed\n    event SupplyChangeWaitingPeriodChanged(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod);\n\n    /// @notice An event that's emitted when the metadataManager address is changed\n    event MetadataManagerChanged(address indexed oldManager, address indexed newManager);\n\n    /// @notice An event that's emitted when the token name and symbol are changed\n    event TokenMetaUpdated(string indexed name, string indexed symbol);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice An event that's emitted whenever an authorized transfer occurs\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n    /**\n     * @notice Construct a new Arch token\n     * @param _metadataManager The account with the ability to change token metadata\n     * @param _supplyManager The address with minting ability\n     * @param _firstSupplyChangeAllowed The timestamp after which the first supply change may occur\n     */\n    constructor(address _metadataManager, address _supplyManager, uint256 _firstSupplyChangeAllowed) {\n        require(_firstSupplyChangeAllowed >= block.timestamp, \"Arch::constructor: minting can only begin after deployment\");\n\n        balances[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n\n        supplyChangeAllowedAfter = _firstSupplyChangeAllowed;\n        supplyManager = _supplyManager;\n        emit SupplyManagerChanged(address(0), _supplyManager);\n\n        metadataManager = _metadataManager;\n        emit MetadataManagerChanged(address(0), metadataManager);\n    }\n\n    /**\n     * @notice Change the supplyManager address\n     * @param newSupplyManager The address of the new supply manager\n     * @return true if successful\n     */\n    function setSupplyManager(address newSupplyManager) external returns (bool) {\n        require(msg.sender == supplyManager, \"Arch::setSupplyManager: only SM can change SM\");\n        emit SupplyManagerChanged(supplyManager, newSupplyManager);\n        supplyManager = newSupplyManager;\n        return true;\n    }\n\n    /**\n     * @notice Change the metadataManager address\n     * @param newMetadataManager The address of the new metadata manager\n     * @return true if successful\n     */\n    function setMetadataManager(address newMetadataManager) external returns (bool) {\n        require(msg.sender == metadataManager, \"Arch::setMetadataManager: only MM can change MM\");\n        emit MetadataManagerChanged(metadataManager, newMetadataManager);\n        metadataManager = newMetadataManager;\n        return true;\n    }\n\n    /**\n     * @notice Mint new tokens\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to be minted\n     * @return Boolean indicating success of mint\n     */\n    function mint(address dst, uint256 amount) external returns (bool) {\n        require(msg.sender == supplyManager, \"Arch::mint: only the supplyManager can mint\");\n        require(dst != address(0), \"Arch::mint: cannot transfer to the zero address\");\n        require(amount <= totalSupply.mul(mintCap).div(1000000), \"Arch::mint: exceeded mint cap\");\n        require(block.timestamp >= supplyChangeAllowedAfter, \"Arch::mint: minting not allowed yet\");\n\n        // update the next supply change allowed timestamp\n        supplyChangeAllowedAfter = block.timestamp.add(supplyChangeWaitingPeriod);\n\n        // mint the amount\n        _mint(dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Burn tokens\n     * @param src The account that will burn tokens\n     * @param amount The number of tokens to be burned\n     * @return Boolean indicating success of burn\n     */\n    function burn(address src, uint256 amount) external returns (bool) {\n        address spender = msg.sender;\n        require(spender == supplyManager, \"Arch::burn: only the supplyManager can burn\");\n        require(src != address(0), \"Arch::burn: cannot transfer from the zero address\");\n        require(block.timestamp >= supplyChangeAllowedAfter, \"Arch::burn: burning not allowed yet\");\n        \n        uint256 spenderAllowance = allowances[src][spender];\n        // check allowance and reduce by amount\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = spenderAllowance.sub(\n                amount,\n                \"Arch::burn: burn amount exceeds allowance\"\n            );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        // update the next supply change allowed timestamp\n        supplyChangeAllowedAfter = block.timestamp.add(supplyChangeWaitingPeriod);\n\n        // burn the amount\n        _burn(src, amount);\n        return true;\n    }\n\n    /**\n     * @notice Set the maximum amount of tokens that can be minted at once\n     * @param newCap The new mint cap in bips (10,000 bips = 1% of totalSupply)\n     * @return true if successful\n     */\n    function setMintCap(uint16 newCap) external returns (bool) {\n        require(msg.sender == supplyManager, \"Arch::setMintCap: only SM can change mint cap\");\n        emit MintCapChanged(mintCap, newCap);\n        mintCap = newCap;\n        return true;\n    }\n\n    /**\n     * @notice Set the minimum time between supply changes\n     * @param period The new supply change waiting period\n     * @return true if succssful\n     */\n    function setSupplyChangeWaitingPeriod(uint32 period) external returns (bool) {\n        require(msg.sender == supplyManager, \"Arch::setSupplyChangeWaitingPeriod: only SM can change waiting period\");\n        require(period >= supplyChangeWaitingPeriodMinimum, \"Arch::setSupplyChangeWaitingPeriod: waiting period must be > minimum\");\n        emit SupplyChangeWaitingPeriodChanged(supplyChangeWaitingPeriod, period);\n        supplyChangeWaitingPeriod = period;\n        return true;\n    }\n\n    /**\n     * @notice Update the token name and symbol\n     * @param tokenName The new name for the token\n     * @param tokenSymbol The new symbol for the token\n     * @return true if successful\n     */\n    function updateTokenMetadata(string memory tokenName, string memory tokenSymbol) external returns (bool) {\n        require(msg.sender == metadataManager, \"Arch::updateTokenMeta: only MM can update token metadata\");\n        name = tokenName;\n        symbol = tokenSymbol;\n        emit TokenMetaUpdated(name, symbol);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * It is recommended to use increaseAllowance and decreaseAllowance instead\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Increase the allowance by a given amount\n     * @param spender Spender's address\n     * @param addedValue Amount of increase in allowance\n     * @return True if successful\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        returns (bool)\n    {\n        _increaseAllowance(msg.sender, spender, addedValue);\n        return true;\n    }\n\n    /**\n     * @notice Decrease the allowance by a given amount\n     * @param spender Spender's address\n     * @param subtractedValue Amount of decrease in allowance\n     * @return True if successful\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        returns (bool)\n    {\n        _decreaseAllowance(msg.sender, spender, subtractedValue);\n        return true;\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spender\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param value The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"Arch::permit: signature expired\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowances[src][spender];\n\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = spenderAllowance.sub(\n                amount,\n                \"Arch::transferFrom: transfer amount exceeds allowance\"\n            );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens with a signed authorization\n     * @param from Payer's address (Authorizer)\n     * @param to Payee's address\n     * @param value Amount to be transferred\n     * @param validAfter The time after which this is valid (unix time)\n     * @param validBefore The time before which this is valid (unix time)\n     * @param nonce Unique nonce\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        require(block.timestamp > validAfter, \"Arch::transferWithAuth: auth not yet valid\");\n        require(block.timestamp < validBefore, \"Arch::transferWithAuth: auth expired\");\n        require(!authorizationState[from][nonce],  \"Arch::transferWithAuth: auth already used\");\n\n        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n        _validateSignedData(from, encodeData, v, r, s);\n\n        authorizationState[from][nonce] = true;\n        emit AuthorizationUsed(from, nonce);\n\n        _transferTokens(from, to, value);\n    }\n\n    /**\n     * @notice Receive a transfer with a signed authorization from the payer\n     * @dev This has an additional check to ensure that the payee's address matches\n     * the caller of this function to prevent front-running attacks.\n     * @param from Payer's address (Authorizer)\n     * @param to Payee's address\n     * @param value Amount to be transferred\n     * @param validAfter The time after which this is valid (unix time)\n     * @param validBefore The time before which this is valid (unix time)\n     * @param nonce Unique nonce\n     * @param v v of the signature\n     * @param r r of the signature\n     * @param s s of the signature\n     */\n    function receiveWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(to == msg.sender, \"Arch::receiveWithAuth: caller must be the payee\");\n        require(block.timestamp > validAfter, \"Arch::receiveWithAuth: auth not yet valid\");\n        require(block.timestamp < validBefore, \"Arch::receiveWithAuth: auth expired\");\n        require(!authorizationState[from][nonce],  \"Arch::receiveWithAuth: auth already used\");\n\n        bytes32 encodeData = keccak256(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n        _validateSignedData(from, encodeData, v, r, s);\n\n        authorizationState[from][nonce] = true;\n        emit AuthorizationUsed(from, nonce);\n\n        _transferTokens(from, to, value);\n    }\n\n    /**\n     * @notice EIP-712 Domain separator\n     * @return Separator\n     */\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                VERSION_HASH,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Recovers address from signed data and validates the signature\n     * @param signer Address that signed the data\n     * @param encodeData Data signed by the address\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"Arch::validateSig: invalid signature\");\n    }\n\n    /**\n     * @notice Approval implementation\n     * @param owner The address of the account which owns tokens\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"Arch::_approve: approve from the zero address\");\n        require(spender != address(0), \"Arch::_approve: approve to the zero address\");\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _increaseAllowance(\n        address owner,\n        address spender,\n        uint256 addedValue\n    ) internal {\n        _approve(owner, spender, allowances[owner][spender].add(addedValue));\n    }\n\n    function _decreaseAllowance(\n        address owner,\n        address spender,\n        uint256 subtractedValue\n    ) internal {\n        _approve(\n            owner,\n            spender,\n            allowances[owner][spender].sub(\n                subtractedValue,\n                \"Arch::_decreaseAllowance: decreased allowance below zero\"\n            )\n        );\n    }\n\n    /**\n     * @notice Transfer implementation\n     * @param from The address of the account which owns tokens\n     * @param to The address of the account which is receiving tokens\n     * @param value The number of tokens that are being transferred\n     */\n    function _transferTokens(address from, address to, uint256 value) internal {\n        require(to != address(0), \"Arch::_transferTokens: cannot transfer to the zero address\");\n\n        balances[from] = balances[from].sub(\n            value,\n            \"Arch::_transferTokens: transfer exceeds from balance\"\n        );\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @notice Mint implementation\n     * @param to The address of the account which is receiving tokens\n     * @param value The number of tokens that are being minted\n     */\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    /**\n     * @notice Burn implementation\n     * @param from The address of the account which owns tokens\n     * @param value The number of tokens that are being burned\n     */\n    function _burn(address from, uint256 value) internal {\n        balances[from] = balances[from].sub(\n            value,\n            \"Arch::_burn: burn amount exceeds from balance\"\n        );\n        totalSupply = totalSupply.sub(\n            value,\n            \"Arch::_burn: burn amount exceeds total supply\"\n        );\n        emit Transfer(from, address(0), value);\n    }\n\n    /**\n     * @notice Current id of the chain where this contract is deployed\n     * @return Chain id\n     */\n    function _getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    }
  }
}}