{"SafeMathLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.7.4;\n\nlibrary SafeMathLib {\n  function times(uint a, uint b) public pure returns (uint) {\n    uint c = a * b;\n    require(a == 0 || c / a == b, \u0027Overflow detected\u0027);\n    return c;\n  }\n\n  function minus(uint a, uint b) public pure returns (uint) {\n    require(b \u003c= a, \u0027Underflow detected\u0027);\n    return a - b;\n  }\n\n  function plus(uint a, uint b) public pure returns (uint) {\n    uint c = a + b;\n    require(c\u003e=a \u0026\u0026 c\u003e=b, \u0027Overflow detected\u0027);\n    return c;\n  }\n\n}\n"},"TrollboxComplete.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.7.4;\n\nimport \"./SafeMathLib.sol\";\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\u0027s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\n\ncontract Trollbox {\n    using SafeMathLib for uint;\n\n    /**\n        Votes are a mapping from choices to weights, plus a metadataHash, which references an arbitrary bit of metadata\n        stored on IPFS. The meaning of these choices is not stored on chain, only the index. For example, if  the choices\n        are [\"BTC\", \"ETH\", \"DASH\"],  and the user  wants to put 3 votes on BTC, 5 votes on ETH and 4 on DASH, then this\n        will be recorded as weights[1]  = 3; weights[2]  = 5; weights[3] = 4; The choices are indexed starting on 1 to\n        prevent confusion caused by empty votes.\n    **/\n    struct Vote {\n        mapping(uint =\u003e uint) weights;\n        bytes32 metadataHash;\n    }\n\n    /**\n        Rounds occur with some frequency and represent a complete cycle of prediction-\u003eresolution. Each round has an id,\n        which represents it\u0027s location in a linear sequence of rounds of the same type. It stores a mapping of voter\n        ids to votes and records the winning option when the round is resolved.\n    **/\n    struct Round {\n        uint roundId;\n        mapping (uint =\u003e Vote) votes;\n        mapping (uint =\u003e uint) voteTotals;\n        uint winningOption;\n    }\n\n    /**\n        A tournament is a linear sequence of rounds of the same type. Tournaments are identified by an integer that\n        increases sequentially with each tournament. Tournaments also have hash for storing off-chain metadata about the\n        tournament. A tournament has a set wavelength and phase, called roundLengthSeconds and startDate, respectively. Each\n        tournament also has it\u0027s own set of voice credits, which is a mapping from address to balance. The rounds\n        mapping takes a round id and spits out a Round struct. The tokenRoundBonus attribute describes how much IERC20 to be\n        distributed to the voters each round. The tokenListENS stores the ENS address of a token list that forms the\n        choices of the tournament.\n    **/\n    struct Tournament {\n        uint tournamentId;\n        bytes32 metadataHash;  // ipfs hash of more verbose description, possibly multimedia\n        uint startTime;\n        uint roundLengthSeconds;\n        uint tokenRoundBonus;\n        uint minimumRank;\n        uint voiceUBI;   // number of voice credits available to spend each round\n        bytes32 tokenListENS;\n        address winnerOracle;  // address that sets the winner for a tournament\n        mapping (uint =\u003e uint) voiceCredits;\n        mapping (uint =\u003e Round) rounds;\n    }\n\n    /**\n        An identity is purchased with IERC20 and stores the creation time and a mapping of tournament id to the last round\n        id that the identity voted in, which is used for deferred reward computation.\n    **/\n    struct IdMetadata {\n        mapping (uint =\u003e uint) lastRoundVoted;\n//        uint firstTimeVoted;\n//        uint timesVoted;\n        uint cumulativeBonus;\n        uint rank;\n    }\n\n    address public management; // authoritative key that can make important decisions, can be DAO address later\n    address public rankManager;\n    IERC20 public token;\n    IERC721 public identity;\n\n    uint public numTournaments = 0; // a counter to know what index to assign to new tournaments\n    bytes32 public siteHash;\n\n    mapping (uint =\u003e Tournament) public tournaments; // mapping from tournament id to tournament struct\n    mapping (uint =\u003e IdMetadata) public identities; // mapping from address to identity struct\n    mapping (uint =\u003e uint) public tokensWon; // tokensWon[voterId] = fvt-wei owed\n    mapping (uint =\u003e mapping (uint =\u003e mapping (uint =\u003e bool))) public syncMap; // syncMap[voterId][tournamentId][roundId] = true/false\n\n    // events for consumption by off chain systems\n    event VoteOccurred(uint indexed tournamentId, uint indexed roundId, uint indexed voterId, uint[] choices, uint[] weights, bytes32 metadata);\n    event RoundResolved(uint indexed tournamentId, uint roundId, uint winningChoice);\n    event TournamentCreated(uint tournamentId, bytes32 metadataHash, uint startTime, uint roundLengthSeconds, uint tokenRoundBonus, uint minimumRank, uint voiceUBI, bytes32 tokenListENS, address winnerOracle);\n    event ManagementUpdated(address oldManagement, address newManagement);\n    event SiteHashUpdated(bytes32 oldSiteHash, bytes32 newSiteHash);\n    event RankUpdated(uint voterId, uint oldRank, uint newRank);\n    event RankManagerUpdated(address oldManager, address newManager);\n    event TournamentUpdated(uint tournamentId, bytes32 metadataHash, uint tokenRoundBonus, uint minimumRank, uint voiceUBI, bytes32 tokenListENS, address winnerOracle);\n    event AccountSynced(uint tournamentId, uint voterId);\n\n    modifier managementOnly() {\n        require (msg.sender == management, \u0027Only management may call this\u0027);\n        _;\n    }\n\n    constructor(address mgmt, address rankMgmt, address id) {\n        management = mgmt;\n        rankManager = rankMgmt;\n        identity = IERC721(id);\n    }\n\n    // this function creates a new tournament type, only management can call it\n    function createTournament(\n        bytes32 hash,\n        uint startTime,\n        uint roundLengthSeconds,\n        uint tokenRoundBonus,\n        bytes32 tokenListENS,\n        address oracle,\n        uint minRank,\n        uint voiceUBI) public managementOnly {\n        numTournaments = numTournaments.plus(1);\n        Tournament storage tournament = tournaments[numTournaments];\n        tournament.metadataHash = hash;\n        tournament.startTime = startTime == 0 ? block.timestamp : startTime;\n        tournament.tournamentId = numTournaments;\n        tournament.roundLengthSeconds = roundLengthSeconds;\n        tournament.tokenRoundBonus = tokenRoundBonus;\n        tournament.minimumRank = minRank;\n        tournament.voiceUBI = voiceUBI;\n        tournament.tokenListENS = tokenListENS;\n        tournament.winnerOracle = oracle;\n        emit TournamentCreated(numTournaments, hash, startTime, roundLengthSeconds, tokenRoundBonus, minRank, voiceUBI, tokenListENS, oracle);\n    }\n\n\n\n    // this completes the round, and assigns it a winning choice, which enables deferred updates to voice credits\n    function resolveRound(uint tournamentId, uint roundId, uint winningOption) public {\n        Tournament storage tournament = tournaments[tournamentId];\n        require(msg.sender == tournament.winnerOracle, \u0027Only winner oracle can call this\u0027);\n        uint currentRoundId = getCurrentRoundId(tournamentId);\n        Round storage round = tournament.rounds[roundId];\n        require(roundAlreadyResolved(tournamentId, roundId) == false, \u0027Round already resolved\u0027);\n        require(currentRoundId \u003e roundId + 1, \u0027Too early to resolve\u0027);\n        round.roundId = roundId;\n        round.winningOption = winningOption;\n        emit RoundResolved(tournamentId, roundId, winningOption);\n    }\n\n    function voteCheck(uint voterId, uint tournamentId, uint roundId) internal view {\n        require(roundId \u003e 0, \u0027Tournament not started yet\u0027);\n        require(identity.ownerOf(voterId) == msg.sender, \u0027Must own identity to vote with it\u0027);\n        require(roundId \u003e identities[voterId].lastRoundVoted[tournamentId], \u0027Can only vote one time per round\u0027);\n        require(tournaments[tournamentId].minimumRank \u003c= identities[voterId].rank, \u0027Insufficient rank to participate in this tournament\u0027);\n    }\n\n    // this is called by an identity that wishes to vote on a given tournament, with the choices and weights\n    function vote(\n        uint voterId,\n        uint tournamentId,\n        uint[] memory choices,\n        uint[] memory weights,\n        bytes32 hash,\n        uint updateRoundId\n    ) public {\n        uint roundId = getCurrentRoundId(tournamentId);\n        Round storage currentRound = tournaments[tournamentId].rounds[roundId];\n\n        voteCheck(voterId, tournamentId, roundId);\n        require(choices.length == weights.length, \u0027Mismatched choices and lengths\u0027);\n\n        updateAccount(voterId, tournamentId, updateRoundId);\n\n        identities[voterId].lastRoundVoted[tournamentId] = roundId;\n\n        Vote storage currentVote = currentRound.votes[voterId];\n        currentVote.metadataHash = hash;\n        uint balance = getVoiceCredits(tournamentId, voterId);\n        uint sum = 0;\n\n        for (uint i = 0; i \u003c weights.length; i++) {\n            currentVote.weights[choices[i]] = weights[i];\n            currentRound.voteTotals[choices[i]] = currentRound.voteTotals[choices[i]].plus(weights[i]);\n            sum = sum.plus(weights[i].times(weights[i]));\n        }\n        require(sum \u003c= balance, \u0027Must not spend more than your balance\u0027);\n\n        emit VoteOccurred(tournamentId, roundId, voterId, choices, weights, hash);\n    }\n\n    function withdrawWinnings(uint voterId) public {\n        uint winnings = tokensWon[voterId];\n        address owner = identity.ownerOf(voterId);\n        require(winnings \u003e 0, \u0027Nothing to withdraw\u0027);\n        // doing it this way out of re-entry avoidance habit, not because it\u0027s actually possible here\n        tokensWon[voterId] = 0;\n        token.transfer(owner, winnings);\n    }\n\n    // this actually updates the voice credit balance to include the reward\n    function updateAccount(uint voterId, uint tournamentId, uint roundId) public {\n        IdMetadata storage id = identities[voterId];\n        Tournament storage tournament = tournaments[tournamentId];\n        bool roundResolved = roundAlreadyResolved(tournamentId, roundId);\n        bool shouldSync = isSynced(voterId, tournamentId, roundId) == false;\n\n        if (shouldSync \u0026\u0026 roundResolved) {\n            // idempotent condition, call twice, update once, since this function is public\n            syncMap[voterId][tournamentId][roundId] = true; // idempotence\n\n            (uint voiceCreditBonus, uint tokenBonus) = getRoundBonus(voterId, tournamentId, roundId);\n            tournament.voiceCredits[voterId] = getVoiceCredits(tournamentId, voterId).plus(voiceCreditBonus);\n            tokensWon[voterId] = tokensWon[voterId].plus(tokenBonus);\n            id.cumulativeBonus = id.cumulativeBonus.plus(voiceCreditBonus);\n            emit AccountSynced(tournamentId, voterId);\n        }\n    }\n\n\n/**\n====================================== GETTERS ==========================================================\n**/\n    function getRound(uint tournamentId, uint roundId) public view returns (uint[2] memory) {\n        Round storage round = tournaments[tournamentId].rounds[roundId];\n        return [round.roundId, round.winningOption];\n    }\n\n    // this computes the id of the current round for a given tournament, starting with round 1 on the startTime\n    function getCurrentRoundId(uint tournamentId) public view returns (uint) {\n        Tournament storage tournament = tournaments[tournamentId];\n        uint startTime = tournament.startTime;\n        uint roundLengthSeconds = tournament.roundLengthSeconds;\n        if (block.timestamp \u003e= startTime) {\n            return 1 + ((block.timestamp - startTime) / roundLengthSeconds);\n        } else {\n            return 0;\n        }\n    }\n\n    function getVoiceCredits(uint tournamentId, uint voterId) public view returns (uint) {\n        Tournament storage tournament = tournaments[tournamentId];\n        uint voiceCredits = tournament.voiceCredits[voterId];\n        if (voiceCredits \u003e 0) {\n            return voiceCredits;\n        } else {\n            return tournament.voiceUBI;\n        }\n    }\n\n    function getLastRoundVoted(uint tournamentId, uint voterId) public view returns (uint) {\n        return identities[voterId].lastRoundVoted[tournamentId];\n    }\n\n    function getVoteTotals(uint tournamentId, uint roundId, uint option) public view returns (uint) {\n        return tournaments[tournamentId].rounds[roundId].voteTotals[option];\n    }\n\n    function getVoteMetadata(uint tournamentId, uint roundId, uint voterId) public view returns (bytes32) {\n        return tournaments[tournamentId].rounds[roundId].votes[voterId].metadataHash;\n    }\n\n    function getVoiceUBI(uint tournamentId) public view  returns (uint)  {\n        return tournaments[tournamentId].voiceUBI;\n    }\n\n    function getRoundResults(uint voterId, uint tournamentId, uint roundId) public view returns (uint, uint) {\n        Tournament storage tournament = tournaments[tournamentId];\n        Round storage round = tournament.rounds[roundId];\n        Vote storage thisVote = round.votes[voterId];\n        return (thisVote.weights[round.winningOption], round.voteTotals[round.winningOption]);\n    }\n\n    // this actually updates the voice credit balance to include the reward\n    function getRoundBonus(uint voterId, uint tournamentId, uint roundId) public view returns (uint, uint) {\n        Tournament storage tournament = tournaments[tournamentId];\n        (uint voteWeight, uint totalVotes) = getRoundResults(voterId, tournamentId, roundId);\n        uint tokenBonus = 0;\n        // if this is the first round voterId has voted in, totalVotes will be 0\n        if (totalVotes \u003e 0) {\n            tokenBonus = tournament.tokenRoundBonus.times(voteWeight) / totalVotes;\n        }\n        uint voiceCreditBonus = voteWeight.times(voteWeight);\n        return (voiceCreditBonus, tokenBonus);\n    }\n\n    function isSynced(uint voterId, uint tournamentId, uint roundId) public view returns (bool) {\n        return syncMap[voterId][tournamentId][roundId];\n    }\n\n    function roundAlreadyResolved(uint tournamentId, uint roundId) public view returns (bool) {\n        return tournaments[tournamentId].rounds[roundId].winningOption \u003e 0;\n    }\n\n/**\n====================================== SETTERS ==========================================================\n**/\n\n    // change the site hash\n    function setSiteHash(bytes32 newHash) public managementOnly {\n        bytes32 oldHash = siteHash;\n        siteHash = newHash;\n        emit SiteHashUpdated(oldHash, newHash);\n    }\n\n    function setRank(uint voterId, uint newRank) public {\n        require(msg.sender == rankManager, \u0027Only rankManager may call this\u0027);\n        IdMetadata storage id = identities[voterId];\n        uint oldRank = id.rank;\n        id.rank = newRank;\n        emit RankUpdated(voterId, oldRank, newRank);\n    }\n\n    function setToken(address tokenAddr) public managementOnly {\n        token = IERC20(tokenAddr);\n    }\n\n    function updateTournament(uint tournamentId, bytes32 newMetadata, uint newBonus,  uint newMinRank, uint newUBI, bytes32 newTokenList, address newOracle) public managementOnly {\n        Tournament storage tournament = tournaments[tournamentId];\n        tournament.metadataHash = newMetadata;\n        // no changing round length\n        tournament.tokenRoundBonus = newBonus;\n        tournament.minimumRank = newMinRank;\n        tournament.voiceUBI = newUBI;\n        tournament.tokenListENS = newTokenList;\n        tournament.winnerOracle = newOracle;\n        emit TournamentUpdated(tournamentId, newMetadata, newBonus, newMinRank, newUBI, newTokenList, newOracle);\n    }\n\n    function setRankManager(address newManager) public managementOnly {\n        address oldManager = rankManager;\n        rankManager = newManager;\n        emit RankManagerUpdated(oldManager, newManager);\n    }\n\n    // change the management key\n    function setManagement(address newMgmt) public managementOnly {\n        address oldMgmt =  management;\n        management = newMgmt;\n        emit ManagementUpdated(oldMgmt, newMgmt);\n    }\n\n\n}\n"}}