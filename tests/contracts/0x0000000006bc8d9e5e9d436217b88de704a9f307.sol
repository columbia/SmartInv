{{
  "language": "Solidity",
  "sources": {
    "lib/shields-api-contract/contracts/interfaces/IEmblemWeaver.sol": {
      "content": "// SPDX-License-Identifier: The Unlicense\npragma solidity ^0.8.9;\n\nimport \"./IShields.sol\";\nimport \"./IFrameGenerator.sol\";\nimport \"./IFieldGenerator.sol\";\nimport \"./IHardwareGenerator.sol\";\nimport \"./IShieldBadgeSVGs.sol\";\n\ninterface IEmblemWeaver {\n    function fieldGenerator() external returns (IFieldGenerator);\n\n    function hardwareGenerator() external returns (IHardwareGenerator);\n\n    function frameGenerator() external returns (IFrameGenerator);\n\n    function shieldBadgeSVGGenerator() external returns (IShieldBadgeSVGs);\n\n    function generateShieldURI(IShields.Shield memory shield)\n        external\n        view\n        returns (string memory);\n\n    function generateShieldBadgeURI(IShields.ShieldBadge shieldBadge)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "lib/shields-api-contract/contracts/interfaces/IFieldGenerator.sol": {
      "content": "// SPDX-License-Identifier: The Unlicense\npragma solidity ^0.8.9;\n\ninterface IFieldGenerator {\n    enum FieldCategories {\n        MYTHIC,\n        HERALDIC\n    }\n    struct FieldData {\n        string title;\n        FieldCategories fieldType;\n        string svgString;\n    }\n\n    function generateField(uint16 field, uint24[4] memory colors)\n        external\n        view\n        returns (FieldData memory);\n}\n"
    },
    "lib/shields-api-contract/contracts/interfaces/IFrameGenerator.sol": {
      "content": "// SPDX-License-Identifier: The Unlicense\npragma solidity ^0.8.9;\n\ninterface IFrameGenerator {\n    struct FrameData {\n        string title;\n        uint256 fee;\n        string svgString;\n    }\n\n    function generateFrame(uint16 Frame)\n        external\n        view\n        returns (FrameData memory);\n}\n"
    },
    "lib/shields-api-contract/contracts/interfaces/IHardwareGenerator.sol": {
      "content": "// SPDX-License-Identifier: The Unlicense\npragma solidity ^0.8.9;\n\ninterface IHardwareGenerator {\n    enum HardwareCategories {\n        STANDARD,\n        SPECIAL\n    }\n    struct HardwareData {\n        string title;\n        HardwareCategories hardwareType;\n        string svgString;\n    }\n\n    function generateHardware(uint16 hardware)\n        external\n        view\n        returns (HardwareData memory);\n}\n"
    },
    "lib/shields-api-contract/contracts/interfaces/IShieldBadgeSVGs.sol": {
      "content": "// SPDX-License-Identifier: The Unlicense\npragma solidity ^0.8.9;\n\nimport \"./IShields.sol\";\n\ninterface IShieldBadgeSVGs {\n    function generateShieldBadgeSVG(IShields.ShieldBadge shieldBadge)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "lib/shields-api-contract/contracts/interfaces/IShields.sol": {
      "content": "// SPDX-License-Identifier: The Unlicense\npragma solidity ^0.8.9;\n\nimport \"./IEmblemWeaver.sol\";\n\ninterface IShields {\n    enum ShieldBadge {\n        MAKER,\n        STANDARD\n    }\n\n    struct Shield {\n        bool built;\n        uint16 field;\n        uint16 hardware;\n        uint16 frame;\n        ShieldBadge shieldBadge;\n        uint24[4] colors;\n    }\n\n    function emblemWeaver() external view returns (IEmblemWeaver);\n\n    function shields(uint256 tokenId)\n        external\n        view\n        returns (\n            uint16 field,\n            uint16 hardware,\n            uint16 frame,\n            uint24 color1,\n            uint24 color2,\n            uint24 color3,\n            uint24 color4,\n            ShieldBadge shieldBadge\n        );\n}\n"
    },
    "lib/shields-api-contract/contracts/interfaces/IShieldsAPI.sol": {
      "content": "// SPDX-License-Identifier: The Unlicense\npragma solidity ^0.8.9;\n\nimport \"./IShields.sol\";\nimport \"./IFieldGenerator.sol\";\nimport \"./IHardwareGenerator.sol\";\nimport \"./IFrameGenerator.sol\";\n\ninterface IShieldsAPI {\n    function getShield(uint256 shieldId)\n        external\n        view\n        returns (IShields.Shield memory);\n\n    function getShieldSVG(uint256 shieldId)\n        external\n        view\n        returns (string memory);\n\n    function getShieldSVG(\n        uint16 field,\n        uint24[4] memory colors,\n        uint16 hardware,\n        uint16 frame\n    ) external view returns (string memory);\n\n    function isShieldBuilt(uint256 shieldId) external view returns (bool);\n\n    function getField(uint16 field, uint24[4] memory colors)\n        external\n        view\n        returns (IFieldGenerator.FieldData memory);\n\n    function getFieldTitle(uint16 field, uint24[4] memory colors)\n        external\n        view\n        returns (string memory);\n\n    function getFieldSVG(uint16 field, uint24[4] memory colors)\n        external\n        view\n        returns (string memory);\n\n    function getHardware(uint16 hardware)\n        external\n        view\n        returns (IHardwareGenerator.HardwareData memory);\n\n    function getHardwareTitle(uint16 hardware)\n        external\n        view\n        returns (string memory);\n\n    function getHardwareSVG(uint16 hardware)\n        external\n        view\n        returns (string memory);\n\n    function getFrame(uint16 frame)\n        external\n        view\n        returns (IFrameGenerator.FrameData memory);\n\n    function getFrameTitle(uint16 frame) external view returns (string memory);\n\n    function getFrameSVG(uint16 frame) external view returns (string memory);\n}\n"
    },
    "lib/solady/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(uint256(-value));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksumed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, and(add(o, 31), not(31))) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            // Zeroize the slot after the string.\n            let last := add(add(result, 0x20), k)\n            mstore(last, 0)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n            // Store the length of the result.\n            mstore(result, k)\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 32)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(output, 0)\n                // Store the length.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(31)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 31), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(31)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 31), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 63), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(31)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(mload(a), 32), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, mload(a))\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 32), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 67108863)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                // Restore the result.\n                result := mload(0x40)\n                // Stores the string length.\n                mstore(result, length)\n                // Zeroize the slot after the string.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, and(add(last, 31), not(31)))\n            }\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store the bytes of the packed offsets and strides into the scratch space.\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n                mstore(0x1f, 0x900094)\n                mstore(0x08, 0xc0000000a6ab)\n                // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 31)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Restore the result to the start of the free memory.\n            result := mload(0x40)\n            // Store the length of the result.\n            mstore(result, sub(last, add(result, 0x20)))\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store \"\\\\u0000\" in scratch space.\n                // Store \"0123456789abcdef\" in scratch space.\n                // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n                // into the scratch space.\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n                // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            let last := result\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Restore the result to the start of the free memory.\n            result := mload(0x40)\n            // Store the length of the result.\n            mstore(result, sub(last, add(result, 0x20)))\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"
    },
    "lib/solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(\"1\"),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 id) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender]\n                || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0\n                || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\")\n                    == ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\n        public\n        virtual\n    {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0\n                || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)\n                    == ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\n            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0\n                || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\")\n                    == ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0\n                || ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)\n                    == ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(address, address, uint256, bytes calldata)\n        external\n        virtual\n        returns (bytes4)\n    {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "lib/solmate/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\n            let newFreeMemoryPointer := add(mload(0x40), 160)\n\n            // Update the free memory pointer to avoid overriding our string.\n            mstore(0x40, newFreeMemoryPointer)\n\n            // Assign str to the end of the zone of newly allocated memory.\n            str := sub(newFreeMemoryPointer, 32)\n\n            // Clean the last word of memory it may not be overwritten.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 { } {\n                // Move the pointer 1 byte to the left.\n                str := sub(str, 1)\n\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n\n                // Keep dividing temp until zero.\n                temp := div(temp, 10)\n\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute and cache the final total length of the string.\n            let length := sub(end, str)\n\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 32)\n\n            // Store the string's length at the start of memory allocated for our string.\n            mstore(str, length)\n        }\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(\n                freeMemoryPointer,\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\n            )\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success :=\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                    // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                    // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                    // Counterintuitively, this call must be positioned second to the or() call in the\n                    // surrounding and() call or else returndatasize() will be zero during the computation.\n                    call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n                )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(ERC20 token, address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(\n                freeMemoryPointer,\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\n            )\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success :=\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                    // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                    // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                    // Counterintuitively, this call must be positioned second to the or() call in the\n                    // surrounding and() call or else returndatasize() will be zero during the computation.\n                    call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n                )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(ERC20 token, address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(\n                freeMemoryPointer,\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\n            )\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success :=\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                    // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                    // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                    // Counterintuitively, this call must be positioned second to the or() call in the\n                    // surrounding and() call or else returndatasize() will be zero during the computation.\n                    call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n                )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "src/AuthorshipToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IShieldsAPI } from \"shields-api/interfaces/IShieldsAPI.sol\";\nimport { Owned } from \"solmate/auth/Owned.sol\";\nimport { ERC721 } from \"solmate/tokens/ERC721.sol\";\nimport { LibString } from \"solmate/utils/LibString.sol\";\n\nimport { ICurta } from \"@/contracts/interfaces/ICurta.sol\";\nimport { Base64 } from \"@/contracts/utils/Base64.sol\";\n\n/// @title The Authorship Token ERC-721 token contract\n/// @author fiveoutofnine\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\n/// @notice ``Authorship Tokens'' are ERC-721 tokens that are required to add\n/// puzzles to Curta. Each Authorship Token may be used like a ticket once.\n/// After an Authorship Token has been used to add a puzzle, it can never be\n/// used again to add another puzzle. As soon as a puzzle has been deployed and\n/// added to Curta, anyone may attempt to solve it.\n/// @dev Other than the initial distribution, the only way to obtain an\n/// Authorship Token will be to be the first solver to any puzzle on Curta.\ncontract AuthorshipToken is ERC721, Owned {\n    using LibString for uint256;\n\n    // -------------------------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------------------------\n\n    /// @notice The shields API contract.\n    /// @dev This is the mainnet address.\n    IShieldsAPI constant shieldsAPI = IShieldsAPI(0x740CBbF0116a82F64e83E1AE68c92544870B0C0F);\n\n    /// @notice Salt used to compute the seed in {AuthorshipToken.tokenURI}.\n    bytes32 constant SALT = bytes32(\"Curta.AuthorshipToken\");\n\n    // -------------------------------------------------------------------------\n    // Errors\n    // -------------------------------------------------------------------------\n\n    /// @notice Emitted when there are no tokens available to claim.\n    error NoTokensAvailable();\n\n    /// @notice Emitted when `msg.sender` is not authorized.\n    error Unauthorized();\n\n    // -------------------------------------------------------------------------\n    // Immutable Storage\n    // -------------------------------------------------------------------------\n\n    /// @notice The Curta / Flags contract.\n    address public immutable curta;\n\n    /// @notice The number of seconds until an additional token is made\n    /// available for minting by the author.\n    uint256 public immutable issueLength;\n\n    /// @notice The timestamp of when the contract was deployed.\n    uint256 public immutable deployTimestamp;\n\n    // -------------------------------------------------------------------------\n    // Storage\n    // -------------------------------------------------------------------------\n\n    /// @notice The number of tokens that have been claimed by the owner.\n    uint256 public numClaimedByOwner;\n\n    /// @notice The total supply of tokens.\n    uint256 public totalSupply;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    /// @param _curta The Curta / Flags contract.\n    /// @param _issueLength The number of seconds until an additional token is\n    /// made available for minting by the author.\n    /// @param _authors The list of authors in the initial batch.\n    constructor(address _curta, uint256 _issueLength, address[] memory _authors)\n        ERC721(\"Authorship Token\", \"AUTH\")\n        Owned(msg.sender)\n    {\n        curta = _curta;\n        issueLength = _issueLength;\n        deployTimestamp = block.timestamp;\n\n        // Mint tokens to the initial batch of authors.\n        uint256 length = _authors.length;\n        for (uint256 i; i < length;) {\n            _mint(_authors[i], i + 1);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // [MIGRATION] Mint 1 token to `sampriti.eth`\n        _mint(0x58593392d72A9D90b133e1C8ecEec581C354687f, length + 1);\n        totalSupply = length + 1;\n    }\n\n    // -------------------------------------------------------------------------\n    // Functions\n    // -------------------------------------------------------------------------\n\n    /// @notice Mints a token to `_to`.\n    /// @dev Only the Curta contract can call this function.\n    /// @param _to The address to mint the token to.\n    function curtaMint(address _to) external {\n        // Revert if the sender is not the Curta contract.\n        if (msg.sender != curta) revert Unauthorized();\n\n        unchecked {\n            uint256 tokenId = ++totalSupply;\n\n            _mint(_to, tokenId);\n        }\n    }\n\n    /// @notice Mints a token to `_to`.\n    /// @dev Only the owner can call this function. The owner may claim a token\n    /// every `issueLength` seconds.\n    /// @param _to The address to mint the token to.\n    function ownerMint(address _to) external onlyOwner {\n        unchecked {\n            uint256 numIssued = (block.timestamp - deployTimestamp) / issueLength;\n            uint256 numMintable = numIssued - numClaimedByOwner++;\n\n            // Revert if no tokens are available to mint.\n            if (numMintable == 0) revert NoTokensAvailable();\n\n            // Mint token\n            uint256 tokenId = ++totalSupply;\n\n            _mint(_to, tokenId);\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // ERC721Metadata\n    // -------------------------------------------------------------------------\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @param _tokenId The token ID.\n    /// @return URI for the token.\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n        require(_ownerOf[_tokenId] != address(0), \"NOT_MINTED\");\n\n        // Generate seed.\n        uint256 seed = uint256(keccak256(abi.encodePacked(_tokenId, SALT)));\n\n        // Bitpacked colors.\n        uint256 colors = 0x6351CEFF00FFB300FF6B00B5000A007FFF78503C323232FE7FFF6C28A2FF007A;\n\n        // Shuffle `colors` by performing 4 iterations of Fisher-Yates shuffle.\n        // We do this to pick 4 unique colors from `colors`.\n        unchecked {\n            uint256 shift = 24 * (seed % 11);\n            colors = (colors & ((type(uint256).max ^ (0xFFFFFF << shift)) ^ 0xFFFFFF))\n                | ((colors & 0xFFFFFF) << shift) | ((colors >> shift) & 0xFFFFFF);\n            seed >>= 4;\n\n            shift = 24 * (seed % 10);\n            colors = (colors & ((type(uint256).max ^ (0xFFFFFF << shift)) ^ (0xFFFFFF << 24)))\n                | (((colors >> 24) & 0xFFFFFF) << shift) | (((colors >> shift) & 0xFFFFFF) << 24);\n            seed >>= 4;\n\n            shift = 24 * (seed % 9);\n            colors = (colors & ((type(uint256).max ^ (0xFFFFFF << shift)) ^ (0xFFFFFF << 48)))\n                | (((colors >> 48) & 0xFFFFFF) << shift) | (((colors >> shift) & 0xFFFFFF) << 48);\n            seed >>= 4;\n\n            shift = 24 * (seed & 7);\n            colors = (colors & ((type(uint256).max ^ (0xFFFFFF << shift)) ^ (0xFFFFFF << 72)))\n                | (((colors >> 72) & 0xFFFFFF) << shift) | (((colors >> shift) & 0xFFFFFF) << 72);\n            seed >>= 3;\n        }\n\n        return string.concat(\n            \"data:application/json;base64,\",\n            Base64.encode(\n                abi.encodePacked(\n                    '{\"name\":\"Authorship Token #',\n                    _tokenId.toString(),\n                    '\",\"description\":\"This token allows 1 puzzle to be added to Curta. Once it has '\n                    'been used, it can never be used again.\",\"image_data\":\"data:image/svg+xml;base6'\n                    \"4,\",\n                    Base64.encode(\n                        abi.encodePacked(\n                            '<svg width=\"750\" height=\"750\" xmlns=\"http://www.w3.org/2000/svg\" fill='\n                            '\"none\" viewBox=\"0 0 750 750\"><style>.a{filter:url(#c)drop-shadow(0 0 2'\n                            \"px #007fff);fill:#fff;width:4px}.b{filter:drop-shadow(0 0 .5px #007fff\"\n                            \");fill:#000;width:3px}.c{height:13px}.d{height:6px}.e{height:4px}.f{he\"\n                            \"ight:12px}.g{height:5px}.h{height:3px}.i{width:320px;height:620px}.j{c\"\n                            \"x:375px;r:20px}.k{stroke:#27303d}.l{fill:#000}.n{fill:#0d1017}.o{strok\"\n                            'e-width:2px}@font-face{font-family:\"A\";src:url(data:font/woff2;charset'\n                            \"=utf-8;base64,d09GMgABAAAAABFIAA8AAAAAIkwAABDvAAEAAAAAAAAAAAAAAAAAAAAA\"\n                            \"AAAAAAAAHIFYBmAAPAiBCgmXYhEICp9Am3cLQgABNgIkA0IEIAWDTAcgDIExGzcfE24MPW\"\n                            \"wcDIypV8n+6wPbWHpYvwUfDDXpJJFBslTuUGiwURSfehX/e+bvN6mwulNEycH87rF0PSHI\"\n                            \"FQ6frhshySw8/9Scf9/MJISZENRCTVFJ1cErnlKV3fCVijl22lBTW3X3ffk7sF1tDOFpz3\"\n                            \"ulSlfAabKmnF0P4oO2fq29SR7sfaASK3SVZcuSrsSqs2ba0noIACigkR+0RR3auT4I9sP0\"\n                            \"SVMG/h9t36wowdPc8MB/BrGVwfJtxfAEzawVNUU9XXUyuP84V72fJk1TzgBQZhYxC9gekU\"\n                            \"Nhz5h1atzZDSj//9es7H0/lQGuGT4e6XiUalRBoP6vADYkPQw1aeL0ALMknWQQFKMiVrss\"\n                            \"zLp1cq3f5XA2MbxTH7ZlmG9qAh5RGLTi3/buX4sAOtmYKD17DyzGNX3c/JkkoAFYFiqgoL\"\n                            \"lcoKwN+8SZs2bQJpy/039f0IT07mYumDGX3OkeQKhtalzAJiHFqmDHRepg85j2HtMhYXoI\"\n                            \"Qja+acMcHkFiWRYc64dhBHE74RiyoF9YUybKGmygLFPKgQE3mWU0qdIeFGz+mufSyI0eTo\"\n                            \"/ebjdXaEmONvbHdNDGSrUbWQ8gfyoXADcUpJDKwxZTQlmjHdljgkI92rIAkHysWd+tiwiI\"\n                            \"D5Xor0lTmjPIn2Bl2xlLdc/6xALygxzlIHIGSp5aRIVlzTcyxsJaE5QLskMtpMy7JpvuPj\"\n                            \"Uo2MWFiwACT2mape1/WBm2jfvwKbF3yOytnKr/kmDe/ffSHOMjO3TegzdAmwwQWGKAQK+c\"\n                            \"Bhh0LF7h+dMwkwVOj6a4TfI4nt98Vtdg3vXfxfuD5LHZiSN72tFbVsUc3R0zeztLSohtiS\"\n                            \"0svM6iU/Uv3Qmfl4/otQv/jh3g4A0oOWcHRc4GbtNJzgEHmgru3bEQPEgIi7gWnfcZKgEO\"\n                            \"8+Z1XMUoKtO09Tjp2lUOvJjROEPveThU3/tfL0bd6jo8v07lwHVvcrLss7BvExTOLIdsVZ\"\n                            \"QXQPLOgBZIcA2J124CFjvY6BQaQwUxDEhIzTQBj/7xNBKgmC25O1wmzuk8DHIxcRpve9ih\"\n                            \"ai6Dx+eQS2Guk8G9aNoPq46hCuEQzpn0DrEA5cNx6ybsFycgDTIqICT1EGrGPKQhWGg3yT\"\n                            \"vz+bYPRKis1fC3mwRiQEUi5Jar7lMsZqIS3VOUGEgg0ul47PrH07gfVmIW9T9FbNECKbbf\"\n                            \"pconk3yVaGo/Ahrbr9P224ag88ZW7LKAitUe741kKQXVSBLZmCnMYw0TiopBOyYcr0WduE\"\n                            \"S4x/5FIgsNvUH1weP6wNRJz2bNhJwTgeqoZZ7qMnvnrUhnbAIRXAwkkj7vIhYqrV7vEolF\"\n                            \"TQks4hu8RBWo/k7XFtMKN7H/WQszwb877koOlFCxeSdgNLsxYo4J88ywwByLLLDEEsusYI\"\n                            \"U1WGWdETtghEGeEbdsv0umBvraHesHFh31K9LvwKb+RPo7pjtYICDGRl1S6pFSn5QGpDQk\"\n                            \"pREpjUlpQkpTUpqRjl1C7RrFylpIi8Z2N8fzOIYKy236t9kAq2A1DGxCmmsBx1i3Ys+Gde\"\n                            \"8VbuTYckbHpx02h1XI9jTdy8b5t0FJ3jV2B3qsK99NWYU0AuJQCE7aNgY7v4D+PpPntlJ3\"\n                            \"ZPt2YA9qNdc1B5B+QYF9NBfawMGwAORUY4sforK0c02NigE7EJM2+5e5DbfaKR06nyGLw4\"\n                            \"HI9tnbgSOAHbjDvTs1indO+g2T2v7IN9BxRA39GLhFjJj4+TxR3L5OP9np8qlbpuTlgxyf\"\n                            \"O6d6VD/EzLFZoYVyD4ry/OV4qUjBWI4Nh90xqbdg54Qoz1214l9VZxI826xbcYbHGcxXXc\"\n                            \"IqizxhNjenKLAfXHiH4BiD59GYroC6eA6eHavJMXIrTsbfkyREzrF25c922geeRUkzTZC2\"\n                            \"UOKsTVfeCebp8JgateYdrGE9IaY76Ppjgc0XcccsJd28zkURtobF+UkH2pkp9UZ75dR3ze\"\n                            \"OUC5gawFLO3iS1uakbsnXnr/7lIAcLsZjJ+w99NeIoGM56PeI4+t5HWymr6o9cC5wNG3H+\"\n                            \"m82F7F5/o0ytyLvC6ti+HVWv43Ed/ifmG09TXXtu2b+1FeeXOuqzfuJuIlxjZ/dRb/5KbM\"\n                            \"VcevBs78zQgCNonHE12BsOzeOkp1GF3ILsi9HPIw5XZKfCztTUaNYPK0ShfLQWg2Sn5c1o\"\n                            \"yAroqWgwEwxpJNBQJhgmQy8azgQjGglUzAQlMnSjUiYoayRQORNUyNCDKpmgqpFAI5lglA\"\n                            \"y9aTQTjGkk0FgmGCdDdxrPBBMaCTSRycRJnXy5UywmPwr6CrXNS0WYEiLCJg+q/XmYmCrl\"\n                            \"YZqUZ053yIMZ/vwCM6V8zJLyMVvKx5z6BZgrFWCeVID5UkGhBZ2O+2vKmy6je13YMcmnth\"\n                            \"q6+PUkQ2cEsSwCQY3cNPAwuRWoToMjDRmK4jL2YEBFAq9ic5UWqbQsykJncsHOgA6dDFtq\"\n                            \"+4iQ5CAXnilOc7mczhZuw5YU5wxKOBW47qqa18byl2C+0Je9kpLlr0VqXl27py+7c+UFmC\"\n                            \"9DuGxcFLhwtksTbHq5LlWGZuCUWZNSNub56z6vhzc8dklVXP+K19zMp2Gw+AWepkrKxCkB\"\n                            \"FNMmnkhS+mIiBmbzxbsYu3/5uNB70qcZioGOLk4pwVD1KjUAJ8b2o+fvE7IX0jP+UvmvC/\"\n                            \"9zTtTVhXlrXunL7lzwgXH0NT5eVVdNlAt0UumDdTUSxgQwsa7JiHLbdx+N9YpznKAMNccv\"\n                            \"n28rh84dOcYAj1WJhyfD9DWdacXBsxebjfKUwmfoQg8iRlXZ6fEy4xAa0pv0GejZgi9HNl\"\n                            \"+VPZ+h5aQJoqNPjcVobNAYnVcai9d8oi97lmY8z5j8lOLljWQ0fIrVgVlfWtNoRtVj1tWJ\"\n                            \"DV7Ri/UyugbiLSQ1l7NObx9m6qcSJ+t3Yl5J34KxaVImS1+88EXY68CjXjQW5jQmulLBDC\"\n                            \"g8RvQxjvrMq5i5pxp2kde0xy/bEDZNyghjc2O/U2E8VH9dXPONMSjesGUhiseWie5ddqqh\"\n                            \"QfPLSl3F46EWs64VBy/C8LoTXXhrtPOXPXi8rEaJvqHu5b0Giy5whUeCM2teY23Nxvnzp8\"\n                            \"m1O1bUrN2vYO2K/54OGzrbuyY5dHDt43aqy7UiJ3mN9zPjCpMFbBf7/IwolBQHNYAMMEi2\"\n                            \"eOax5Af+SYKk5Ftty4uNXpQhSvBSk+NwwKH6VqiSnNnJWieKCDxBEZkKR5BPuicuUQmnFt\"\n                            \"ZVM3IDfJHhfP2bzKbHE6ExyVcGyDdWqYxjDWwRi8A6SdIPtzB7tiQsWOxEcCciH3XnqlQ0\"\n                            \"dFMTH4SkRDvCZLv3v6pKrhriHBLZFMOC/hyD9ElxDduSi35Bk7+sFiGpgpnuNBRGBd6gSL\"\n                            \"mfVrbkv9wY10nPyEpPUJ4ZQA2VAEFUTLSAppnkp+575H1YSnKMePiKalkZ1NtrNCNp/NVu\"\n                            \"Jw4FSl2hQV5RYKBXFOqQOrH/T2W+sGC3CEVdvBviVPTZZumyrT4JJOk5c5lYPL2+VUgVec\"\n                            \"/vOTZm95Ve8r1Dspn8dClc+6DoO3+tc4xQSTC5uJeEkSpI6rG+HgaV9H5K5kFKQfj6VDYK\"\n                            \"jGns9YnhSohHfjraDQ17bfVIIZUw8pKLa+qQEOmMsoBgd0QUiHJHBAOLMyqyc0ZIUhgKsM\"\n                            \"Tg0NDEYAygSWEx804b0aBKnqbSZbQa03i73BmsmMQdGuwVm0xT8dAgiQv7Y5F6X6M9IgxD\"\n                            \"m6j98u1+cbdtM6ZKxNMOn803a3lsaXGvql6xvWpia6pQPWqUcmJ0Vf2N9J35T2/D0Aq9X9\"\n                            \"/LiNn0JZMYcyJK6HMiGXvW697jX0wUEYjticR2LoIQlZ6+1I2WZRL0qvgQc+804puiH+Rh\"\n                            \"XP3n178mUvxMxuoYGIfVlRgzue0ARYr9NLcGAD2Vl5jGAROR3cVwvUD6Q6Ep0iFtCjJOZI\"\n                            \"yKZAwPYx6mbEjYPWGXElHi/Vs3qPtvkD4H6C+zF15Ahg0FHXTyC1qDA+f1H7kBBjiGM+fF\"\n                            \"M4pJhNeMcH8p7KHTfHQ5SBjIUlxTGYZ01BVqq3QFGm2KOieINiqSMSr86jn1ur37gDd/Si\"\n                            \"+6sw1nXmDQnebqnfZNiSkbw3IOuCISSLdrnxIkfdu379sy4ZNmTychwnWgX9ewkKsoE/pz\"\n                            \"6N6QkL2hztbp5fhDpt8flVD9cML/Ozd7gN1lD7QH2YPtIfZQexgLv0pQLe5ZGLcxhqeWlf\"\n                            \"uo4AGTtzAGmPqke7wB+CPw7rP5phD/4Jp/h+u0/7/3F55NOEIenxjDI5A4wKXER8gNypPh\"\n                            \"7mw0qFXibtIdD6ScM3YFwUCrAKVFNJ+5ITNvUV/gOcCJ/kQXtJZy0VgDo1NeIe0RY+uZoD\"\n                            \"taIIocaM+8dXFDu3LB2AuHFF3gBZqRHhUpTFe+A6SFnM+wwSW04ZCm7MiidXk+1EVPLlEL\"\n                            \"Y/hGQkhQYo5RJS0u0QDUeCwoUVz3d51KuWyyNeO73UI02URWpMMm1LxDOuEvYoylo8WlV6\"\n                            \"lv8Lzp2XAOb1Bk5ZOsenamH1YDUthuPyzPR7q/Nl+uGHvnMSCEKixZKLwsClU+AW6h9Uwx\"\n                            \"c5zXtGgPZKTNLxYXmDFrPx+UBz64p2oHMlG8QFT8ZHKB8lpE6sh5Y29HLcPAzXnh0WFy+8\"\n                            \"QGHyHXM0kJj3YCbvJudjuZcNbbvrl6c5y5dbl9Ua9gUzaUnDH2DmZJluoxBAUqD0XRp4LT\"\n                            \"1zOAwXVS9SFma9Z3Ow4MZH0JNLw7mOOIMfkcd+UerSqKWJpkvnQbocRNTTvtzMLfyfKSbV\"\n                            \"zo+oftgP9JojCaNGPqtd8m9mu0oWybrQ62kidABygizeao16mU4mbSZFD5szXxu+2seN+f\"\n                            \"N/C+ONDR3z0QSXu1xac4z0BPi0WqXTHQiS23iyR6LYtzKOO/CNG8c2Tr7t/tAoYM/Z0syB\"\n                            \"80Rt//4bDt0xNOjWYyQczsMZTVX4lnibna/u9fw48fNgFIpNOyOCrpgaeOILkARCV5DiXe\"\n                            \"8EXPWQ4OdEcIGO720kah2SLjqQvJDI/8QxCp+ISkGFe3R3nHBbjptZqOhlrLslxLBpmZyk\"\n                            \"E4K2xIxAgAq+1G6J+KTlnejgNaJrWm7SmaNFuPJgOlFoxtKbSLWA4OaExq19dlBwsGPkHR\"\n                            \"rXTs0O0Q9rou9s3+eNiZd+dpjFVpKzWjZGOGhaCjqkKgBz9VUzEKPhhjXewSzahn/t/pS9\"\n                            \"uHUpZUqS1MbX6NCCB0X3Go/OuYwPz/mlj1O8Dz6R9eAbxMJbdG+3Ffma11B/xRABD44auE\"\n                            \"MhHN+jezsRbExZke8snDQxEpdF/kvhRZe3OPpzwY5Hs8Eh/s5PWHI4CbKdiZgw2FLhSyCG\"\n                            \"gwvqEigB+Vd+U1f2A0EHYUwhjdUcHF3I4q2ZgdNVpxpqON+XxIb6eFDKUHs5jNkqLJ1XiZ\"\n                            \"EkrvJpVkUsjETR/FZ7nk6Uzquh8zmUAX3u1D0/3DKcx5JT5pmzyJuSxUfGJS4ghmM44JlL\"\n                            \"mDmEViFoaazhcgH5fEU7iZLKtkHiUMoIzBh5vGHSyks52c68LcoVmqR3we1X0LuuWsP5QR\"\n                            \"NUrjU+r4fCbg+ReG8S5kh4kzGMc0JvXzyQ7rdKoZTypQxuRM0khPXNJMrcMqaFitk6QCwo\"\n                            \"kHnOHO8PJmkVUVPvmKMvPsZvy6nwRaaHR4OKlH7ymZ9va2cIfmqPTXi0I1WUm0n83ofjHY\"\n                            \"E3BFN20mGv4SgQMAJiae1Co9m1tJ7bByn6e2vMVE1maWcw4T0arYhOLybl7RX6FH70WOrZ\"\n                            'MW6dCcHc6I9atPW9msuGc/bptop2dPAAA=)}</style><defs><radialGradient id=\"'\n                            'b\"><stop stop-color=\"#007FFF\"/><stop offset=\"100%\" stop-opacity=\"0\"/><'\n                            '/radialGradient><filter id=\"c\"><feGaussianBlur stdDeviation=\"8\" in=\"So'\n                            'urceGraphic\" result=\"offset-blur\"/><feComposite operator=\"out\" in=\"Sou'\n                            'rceGraphic\" in2=\"offset-blur\" result=\"inverse\"/><feFlood flood-color=\"'\n                            '#007FFF\" flood-opacity=\".95\" result=\"color\"/><feComposite operator=\"in'\n                            '\" in=\"color\" in2=\"inverse\" result=\"shadow\"/><feComposite in=\"shadow\" i'\n                            'n2=\"SourceGraphic\"/><feComposite operator=\"atop\" in=\"shadow\" in2=\"Sour'\n                            'ceGraphic\"/></filter><mask id=\"a\"><path fill=\"#000\" d=\"M0 0h750v750H0z'\n                            '\"/><rect class=\"i\" x=\"215\" y=\"65\" rx=\"20\" fill=\"#FFF\"/><circle class=\"'\n                            'j l\" cy=\"65\"/><circle class=\"j l\" cy=\"685\"/></mask></defs><path fill=\"'\n                            '#10131C\" d=\"M0 0h750v750H0z\"/><rect class=\"i n\" x=\"215\" y=\"65\" mask=\"u'\n                            'rl(#a)\" rx=\"20\"/><circle mask=\"url(#a)\" fill=\"url(#b)\" cx=\"375\" cy=\"38'\n                            '1\" r=\"180\"/><circle class=\"j k n\" cy=\"125\"/><g transform=\"translate(35'\n                            '9 110)\"><circle class=\"n\" cy=\"16\" cx=\"16\" r=\"16\"/><rect class=\"a c\" x='\n                            '\"8\" y=\"7\" rx=\"2\"/><rect class=\"b f\" x=\"8.5\" y=\"7.5\" rx=\"1.5\"/><rect cl'\n                            'ass=\"a e\" x=\"8\" y=\"21\" rx=\"2\"/><rect class=\"b h\" x=\"8.5\" y=\"21.5\" rx=\"'\n                            '1.5\"/><rect class=\"a d\" x=\"14\" y=\"7\" rx=\"2\"/><rect class=\"b g\" x=\"14.5'\n                            '\" y=\"7.5\" rx=\"1.5\"/><rect class=\"a e\" x=\"14\" y=\"14\" rx=\"2\"/><rect clas'\n                            's=\"b h\" x=\"14.5\" y=\"14.5\" rx=\"1.5\"/><rect class=\"a d\" x=\"14\" y=\"19\" rx'\n                            '=\"2\"/><rect class=\"b g\" x=\"14.5\" y=\"19.5\" rx=\"1.5\"/><rect class=\"a c\" '\n                            'x=\"20\" y=\"12\" rx=\"2\"/><rect class=\"b f\" x=\"20.5\" y=\"12.5\" rx=\"1.5\"/><r'\n                            'ect class=\"a e\" x=\"20\" y=\"7\" rx=\"2\"/><rect class=\"b h\" x=\"20.5\" y=\"7.5'\n                            '\" rx=\"1.5\"/></g><path d=\"M338.814 168.856c-.373 0-.718-.063-1.037-.191'\n                            \"a2.829 2.829 0 0 1-.878-.606 2.828 2.828 0 0 1-.606-.878 2.767 2.767 0\"\n                            \" 0 1-.193-1.037v-.336c0-.372.064-.723.192-1.053.138-.319.34-.611.606-.\"\n                            \"877a2.59 2.59 0 0 1 .878-.59 2.58 2.58 0 0 1 1.038-.208h4.26c.245 0 .4\"\n                            \"8.032.703.096.212.053.425.143.638.27.223.118.415.256.574.416.16.16.304\"\n                            \".345.431.558.043.064.07.133.08.208a.301.301 0 0 1-.016.095.346.346 0 0\"\n                            \" 1-.175.256.42.42 0 0 1-.32.032.333.333 0 0 1-.239-.192 3.016 3.016 0 \"\n                            \"0 0-.303-.399 2.614 2.614 0 0 0-.415-.303 1.935 1.935 0 0 0-.463-.191 \"\n                            \"1.536 1.536 0 0 0-.495-.048c-.712 0-1.42-.006-2.122-.016-.713 0-1.425.\"\n                            \"005-2.138.016-.266 0-.51.042-.734.127-.234.096-.442.24-.623.431a1.988 \"\n                            \"1.988 0 0 0-.43.623 1.961 1.961 0 0 0-.144.75v.335a1.844 1.844 0 0 0 .\"\n                            \"574 1.356 1.844 1.844 0 0 0 1.356.574h4.261c.17 0 .33-.015.48-.047a2.0\"\n                            \"2 2.02 0 0 0 .446-.192c.149-.074.282-.165.399-.271.106-.107.207-.229.3\"\n                            \"03-.367a.438.438 0 0 1 .255-.144c.096-.01.187.01.272.064a.35.35 0 0 1 \"\n                            \".16.24.306.306 0 0 1-.033.27 2.653 2.653 0 0 1-.43.527c-.16.139-.346.2\"\n                            \"66-.559.383-.213.117-.42.197-.622.24-.213.053-.436.08-.67.08h-4.262Zm1\"\n                            \"7.553 0c-.713 0-1.324-.266-1.835-.797a2.69 2.69 0 0 1-.766-1.931v-2.66\"\n                            \"5c0-.117.037-.213.112-.287a.37.37 0 0 1 .27-.112c.118 0 .214.037.288.1\"\n                            \"12a.39.39 0 0 1 .112.287v2.664c0 .533.18.99.542 1.373a1.71 1.71 0 0 0 \"\n                            \"1.293.559h3.878c.51 0 .941-.187 1.292-.559a1.93 1.93 0 0 0 .543-1.372v\"\n                            \"-2.665a.39.39 0 0 1 .111-.287.389.389 0 0 1 .288-.112.37.37 0 0 1 .271\"\n                            \".112.39.39 0 0 1 .112.287v2.664c0 .756-.256 1.4-.766 1.932-.51.531-1.1\"\n                            \"28.797-1.851.797h-3.894Zm23.824-.718a.456.456 0 0 1 .16.192c.01.042.01\"\n                            \"6.09.016.143a.47.47 0 0 1-.016.112.355.355 0 0 1-.143.208.423.423 0 0 \"\n                            \"1-.24.063h-.048a.141.141 0 0 1-.064-.016c-.02 0-.037-.005-.047-.016a10\"\n                            \"4.86 104.86 0 0 1-1.18-.83c-.374-.265-.746-.531-1.118-.797-.011 0-.016\"\n                            \"-.006-.016-.016-.01 0-.016-.005-.016-.016-.01 0-.016-.005-.016-.016h-5\"\n                            \".553v1.324a.39.39 0 0 1-.112.288.425.425 0 0 1-.287.111.37.37 0 0 1-.2\"\n                            \"72-.111.389.389 0 0 1-.111-.288v-4.946c0-.054.005-.107.016-.16a.502.50\"\n                            \"2 0 0 1 .095-.128.374.374 0 0 1 .128-.08.316.316 0 0 1 .144-.031h6.893\"\n                            \"c.256 0 .49.048.702.143.224.085.42.218.59.4.182.18.32.377.416.59.085.2\"\n                            \"23.127.457.127.702v.335c0 .223-.032.43-.095.622a2.107 2.107 0 0 1-.32.\"\n                            \"527c-.138.18-.292.319-.462.415-.17.106-.362.186-.575.24l.702.51c.234.1\"\n                            \"7.469.345.703.526Zm-8.281-4.228v2.425h6.494a.954.954 0 0 0 .4-.08.776.\"\n                            \"776 0 0 0 .334-.223c.107-.106.186-.218.24-.335.053-.128.08-.266.08-.41\"\n                            \"5v-.32a.954.954 0 0 0-.08-.398 1.232 1.232 0 0 0-.224-.351 1.228 1.228\"\n                            \" 0 0 0-.35-.224.954.954 0 0 0-.4-.08h-6.494Zm24.67-.782c.106 0 .202.03\"\n                            \"7.287.111a.37.37 0 0 1 .112.272.39.39 0 0 1-.112.287.425.425 0 0 1-.28\"\n                            \"7.112h-3.64v4.579a.37.37 0 0 1-.111.272.348.348 0 0 1-.271.127.397.397\"\n                            \" 0 0 1-.288-.127.37.37 0 0 1-.111-.272v-4.579h-3.639a.37.37 0 0 1-.271\"\n                            \"-.111.39.39 0 0 1-.112-.287.37.37 0 0 1 .112-.272.37.37 0 0 1 .271-.11\"\n                            \"1h8.058Zm15.782-.048c.723 0 1.34.266 1.85.798.511.532.767 1.17.767 1.9\"\n                            \"15v2.68a.37.37 0 0 1-.112.272.397.397 0 0 1-.287.127.348.348 0 0 1-.27\"\n                            \"2-.127.348.348 0 0 1-.127-.272v-1.196h-7.532v1.196a.348.348 0 0 1-.128\"\n                            \".272.348.348 0 0 1-.271.127.348.348 0 0 1-.271-.127.348.348 0 0 1-.128\"\n                            \"-.272v-2.68c0-.745.255-1.383.766-1.915.51-.532 1.128-.798 1.851-.798h3\"\n                            \".894Zm-5.697 3.415h7.548v-.702c0-.532-.176-.984-.527-1.357-.362-.383-.\"\n                            \"792-.574-1.292-.574H408.5c-.51 0-.942.191-1.293.574a1.875 1.875 0 0 0-\"\n                            \".542 1.357v.702ZM297.898 204.5h4.16l1.792-5.152h9.408l1.824 5.152h4.44\"\n                            \"8l-8.704-23.2h-4.288l-8.64 23.2Zm10.624-18.496 3.52 9.952h-7.008l3.488\"\n                            \"-9.952Zm22.81 18.496h3.807v-17.216h-3.808v9.184c0 3.104-1.024 5.344-3.\"\n                            \"872 5.344s-3.168-2.272-3.168-4.608v-9.92h-3.808v10.848c0 4.096 1.664 6\"\n                            \".784 5.76 6.784 2.336 0 4.096-.992 5.088-2.784v2.368Zm7.678-17.216h-2.\"\n                            \"56v2.752h2.56v9.952c0 3.52.736 4.512 4.416 4.512h2.816v-2.912h-1.376c-\"\n                            \"1.632 0-2.048-.416-2.048-2.176v-9.376h3.456v-2.752h-3.456v-4.544h-3.80\"\n                            \"8v4.544Zm13.179-5.984h-3.809v23.2h3.808v-9.152c0-3.104 1.088-5.344 4-5\"\n                            \".344s3.264 2.272 3.264 4.608v9.888h3.808v-10.816c0-4.096-1.696-6.784-5\"\n                            \".856-6.784-2.4 0-4.224.992-5.216 2.784V181.3Zm16.86 14.624c0-3.968 2.1\"\n                            \"44-5.92 4.544-5.92 2.4 0 4.544 1.952 4.544 5.92s-2.144 5.888-4.544 5.8\"\n                            \"88c-2.4 0-4.544-1.92-4.544-5.888Zm4.544-9.024c-4.192 0-8.48 2.816-8.48\"\n                            \" 9.024 0 6.208 4.288 8.992 8.48 8.992s8.48-2.784 8.48-8.992c0-6.208-4.\"\n                            \"288-9.024-8.48-9.024Zm20.057.416a10.32 10.32 0 0 0-.992-.064c-2.08.032\"\n                            \"-3.744 1.184-4.672 3.104v-3.072h-3.744V204.5h3.808v-9.024c0-3.456 1.37\"\n                            \"6-4.416 3.776-4.416.576 0 1.184.032 1.824.096v-3.84Zm14.665 4.672c-.70\"\n                            \"4-3.456-3.776-5.088-7.136-5.088-3.744 0-7.008 1.952-7.008 4.992 0 3.13\"\n                            \"6 2.272 4.448 5.184 5.024l2.592.512c1.696.32 2.976.96 2.976 2.368s-1.4\"\n                            \"72 2.24-3.456 2.24c-2.24 0-3.52-1.024-3.872-2.784h-3.712c.416 3.264 3.\"\n                            \"232 5.664 7.456 5.664 3.904 0 7.296-1.984 7.296-5.568 0-3.36-2.656-4.4\"\n                            \"48-6.144-5.12l-2.432-.48c-1.472-.288-2.304-.896-2.304-2.048 0-1.152 1.\"\n                            \"536-1.888 3.2-1.888 1.92 0 3.36.608 3.776 2.176h3.584Zm6.284-10.688h-3\"\n                            \".808v23.2h3.808v-9.152c0-3.104 1.088-5.344 4-5.344s3.264 2.272 3.264 4\"\n                            \".608v9.888h3.808v-10.816c0-4.096-1.696-6.784-5.856-6.784-2.4 0-4.224.9\"\n                            \"92-5.216 2.784V181.3Zm14.076 0v3.84h3.808v-3.84h-3.808Zm0 5.984V204.5h\"\n                            \"3.808v-17.216h-3.808Zm10.781 8.608c0-3.968 1.952-5.888 4.448-5.888 2.6\"\n                            \"56 0 4.256 2.272 4.256 5.888 0 3.648-1.6 5.92-4.256 5.92-2.496 0-4.448\"\n                            \"-1.952-4.448-5.92Zm-3.648-8.608V210.1h3.808v-7.872c1.024 1.696 2.816 2\"\n                            \".688 5.12 2.688 4.192 0 7.392-3.488 7.392-9.024 0-5.504-3.2-8.992-7.39\"\n                            '2-8.992-2.304 0-4.096.992-5.12 2.688v-2.304h-3.808Z\" fill=\"#F0F6FC\"/><'\n                            'path class=\"k\" stroke-dashoffset=\"5\" stroke-dasharray=\"10\" d=\"M215 545'\n                            'h320\"/><g transform=\"translate(231 237) scale(0.384)\">',\n                            shieldsAPI.getShieldSVG({\n                                field: uint16(seed % 300),\n                                colors: [\n                                    uint24(colors & 0xFFFFFF),\n                                    uint24((colors >> 24) & 0xFFFFFF),\n                                    uint24((colors >> 48) & 0xFFFFFF),\n                                    uint24((colors >> 72) & 0xFFFFFF)\n                                ],\n                                hardware: uint16((seed >> 9) % 120),\n                                frame: uint16((seed >> 17) % 5)\n                            }),\n                            '</g><text font-family=\"A\" x=\"50%\" y=\"605\" fill=\"#F0F6FC\" font-size=\"40'\n                            '\" dominant-baseline=\"central\" text-anchor=\"middle\">#',\n                            _zfill(_tokenId),\n                            '</text><rect class=\"i k o\" x=\"215\" y=\"65\" mask=\"url(#a)\" rx=\"20\"/><cir'\n                            'cle class=\"j k o\" cy=\"65\" mask=\"url(#a)\"/><circle class=\"j k o\" cy=\"68'\n                            '5\" mask=\"url(#a)\"/></svg>'\n                        )\n                    ),\n                    '\",\"attributes\":[{\"trait_type\":\"Used\",\"value\":',\n                    ICurta(curta).hasUsedAuthorshipToken(_tokenId) ? \"true\" : \"false\",\n                    \"}]}\"\n                )\n            )\n        );\n    }\n\n    // -------------------------------------------------------------------------\n    // Helper Functions\n    // -------------------------------------------------------------------------\n\n    /// @notice Converts `_value` to a string with leading zeros to reach a\n    /// minimum of 7 characters.\n    /// @param _value Number to convert.\n    /// @return string memory The string representation of `_value` with leading\n    /// zeros.\n    function _zfill(uint256 _value) internal pure returns (string memory) {\n        string memory result = _value.toString();\n\n        if (_value < 10) return string.concat(\"000000\", result);\n        else if (_value < 100) return string.concat(\"00000\", result);\n        else if (_value < 1000) return string.concat(\"0000\", result);\n        else if (_value < 10_000) return string.concat(\"000\", result);\n        else if (_value < 100_000) return string.concat(\"00\", result);\n        else if (_value < 1_000_000) return string.concat(\"0\", result);\n\n        return result;\n    }\n}\n"
    },
    "src/Curta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// .===========================================================================.\n// | The Curta is a hand-held mechanical calculator designed by Curt           |\n// | Herzstark. It is known for its extremely compact design: a small cylinder |\n// | that fits in the palm of the hand.                                        |\n// |---------------------------------------------------------------------------|\n// | The nines' complement math breakthrough eliminated the significant        |\n// | mechanical complexity created when ``borrowing'' during subtraction. This |\n// | drum was the key to miniaturizing the Curta.                              |\n// '==========================================================================='\n\nimport { Owned } from \"solmate/auth/Owned.sol\";\nimport { LibString } from \"solmate/utils/LibString.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\n\nimport { FlagRenderer } from \"./FlagRenderer.sol\";\nimport { FlagsERC721 } from \"./FlagsERC721.sol\";\nimport { AuthorshipToken } from \"@/contracts/AuthorshipToken.sol\";\nimport { ICurta } from \"@/contracts/interfaces/ICurta.sol\";\nimport { IPuzzle } from \"@/contracts/interfaces/IPuzzle.sol\";\nimport { Base64 } from \"@/contracts/utils/Base64.sol\";\n\n/// @title Curta\n/// @author fiveoutofnine\n/// @notice A CTF protocol, where players create and solve EVM puzzles to earn\n/// NFTs (``Flag'').\ncontract Curta is ICurta, FlagsERC721, Owned {\n    using LibString for uint256;\n\n    // -------------------------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------------------------\n\n    /// @notice The length of Phase 1 in seconds.\n    uint256 constant PHASE_ONE_LENGTH = 2 days;\n\n    /// @notice The length of Phase 1 and Phase 2 combined (i.e. the solving\n    /// period) in seconds.\n    uint256 constant SUBMISSION_LENGTH = 5 days;\n\n    /// @notice The minimum fee required to submit a solution during Phase 2.\n    /// @dev This fee is transferred to the author of the relevant puzzle. Any\n    /// excess fees will also be transferred to the author. Note that the author\n    /// will receive at least 0.01 ether per Phase 2 solve.\n    uint256 constant PHASE_TWO_MINIMUM_FEE = 0.02 ether;\n\n    /// @notice The protocol fee required to submit a solution during Phase 2.\n    /// @dev This fee is transferred to the address returned by `owner`.\n    uint256 constant PHASE_TWO_PROTOCOL_FEE = 0.01 ether;\n\n    /// @notice The default Flag colors.\n    uint120 constant DEFAULT_FLAG_COLORS = 0x181E28181E2827303DF0F6FC94A3B3;\n\n    // -------------------------------------------------------------------------\n    // Immutable Storage\n    // -------------------------------------------------------------------------\n\n    /// @inheritdoc ICurta\n    AuthorshipToken public immutable override authorshipToken;\n\n    /// @inheritdoc ICurta\n    FlagRenderer public immutable override flagRenderer;\n\n    // -------------------------------------------------------------------------\n    // Storage\n    // -------------------------------------------------------------------------\n\n    /// @inheritdoc ICurta\n    uint32 public override puzzleId = 0;\n\n    /// @inheritdoc ICurta\n    Fermat public override fermat;\n\n    /// @inheritdoc ICurta\n    mapping(uint32 => PuzzleColorsAndSolves) public override getPuzzleColorsAndSolves;\n\n    /// @inheritdoc ICurta\n    mapping(uint32 => PuzzleData) public override getPuzzle;\n\n    /// @inheritdoc ICurta\n    mapping(uint32 => address) public override getPuzzleAuthor;\n\n    /// @inheritdoc ICurta\n    mapping(address => mapping(uint32 => bool)) public override hasSolvedPuzzle;\n\n    /// @inheritdoc ICurta\n    mapping(uint256 => bool) public override hasUsedAuthorshipToken;\n\n    // -------------------------------------------------------------------------\n    // Constructor + Functions\n    // -------------------------------------------------------------------------\n\n    /// @param _authorshipToken The address of the Authorship Token contract.\n    /// @param _flagRenderer The address of the Flag metadata and art renderer\n    /// contract.\n    constructor(AuthorshipToken _authorshipToken, FlagRenderer _flagRenderer)\n        FlagsERC721(\"Curta\", \"CTF\")\n        Owned(msg.sender)\n    {\n        authorshipToken = _authorshipToken;\n        flagRenderer = _flagRenderer;\n\n        // [MIGRATION] Set puzzle ID.\n        puzzleId = 1;\n        // [MIGRATION] Set `getPuzzleColorsAndSolves`\n        getPuzzleColorsAndSolves[1] = PuzzleColorsAndSolves({\n            colors: DEFAULT_FLAG_COLORS,\n            phase0Solves: 1,\n            phase1Solves: 1,\n            phase2Solves: 0,\n            solves: 2\n        });\n        // [MIGRATION] Set `getPuzzle`\n        getPuzzle[1] = PuzzleData({\n            puzzle: IPuzzle(0xc220AE2Ac78e9Fa4B8b0BBA87bdB0Bca23F368c2),\n            addedTimestamp: uint40(1677715079),\n            firstSolveTimestamp: uint40(1677719903)\n        });\n        // [MIGRATION] Set `getPuzzleAuthor` to fiveoutofnine.eth\n        getPuzzleAuthor[1] = 0xA85572Cd96f1643458f17340b6f0D6549Af482F5;\n        // [MIGRATION] Set `hasSolvedPuzzle`\n        hasSolvedPuzzle[0x58593392d72A9D90b133e1C8ecEec581C354687f][1] = true; // sampriti.eth\n        hasSolvedPuzzle[0x03433830468d771A921314D75b9A1DeA53C165d7][1] = true; // karmacoma.eth\n        // [MIGRATION] Set `hasUsedAuthorshipToken` true for AUTH #1\n        hasUsedAuthorshipToken[1] = true;\n    }\n\n    /// @inheritdoc ICurta\n    function solve(uint32 _puzzleId, uint256 _solution) external payable {\n        // Revert if `msg.sender` has already solved the puzzle.\n        if (hasSolvedPuzzle[msg.sender][_puzzleId]) {\n            revert PuzzleAlreadySolved(_puzzleId);\n        }\n\n        PuzzleData memory puzzleData = getPuzzle[_puzzleId];\n        IPuzzle puzzle = puzzleData.puzzle;\n\n        // Revert if the puzzle does not exist.\n        if (address(puzzle) == address(0)) revert PuzzleDoesNotExist(_puzzleId);\n\n        // Revert if submissions are closed.\n        uint40 firstSolveTimestamp = puzzleData.firstSolveTimestamp;\n        uint40 solveTimestamp = uint40(block.timestamp);\n        uint8 phase = _computePhase(firstSolveTimestamp, solveTimestamp);\n        if (phase == 3) revert SubmissionClosed(_puzzleId);\n\n        // Revert if the solution is incorrect.\n        if (!puzzle.verify(puzzle.generate(msg.sender), _solution)) {\n            revert IncorrectSolution();\n        }\n\n        // Update the puzzle's first solve timestamp if it was previously unset.\n        if (firstSolveTimestamp == 0) {\n            getPuzzle[_puzzleId].firstSolveTimestamp = solveTimestamp;\n            ++getPuzzleColorsAndSolves[_puzzleId].phase0Solves;\n\n            // Give first solver an Authorship Token\n            authorshipToken.curtaMint(msg.sender);\n        }\n\n        // Mark the puzzle as solved.\n        hasSolvedPuzzle[msg.sender][_puzzleId] = true;\n\n        uint256 ethRemaining = msg.value;\n        unchecked {\n            // Mint NFT.\n            _mint({\n                _to: msg.sender,\n                _id: (uint256(_puzzleId) << 128) | getPuzzleColorsAndSolves[_puzzleId].solves++,\n                _solveMetadata: uint56(((uint160(msg.sender) >> 132) << 28) | (_solution & 0xFFFFFFF)),\n                _phase: phase\n            });\n\n            if (phase == 1) {\n                ++getPuzzleColorsAndSolves[_puzzleId].phase1Solves;\n            } else if (phase == 2) {\n                // Revert if the puzzle is in Phase 2, and insufficient funds\n                // were sent.\n                if (ethRemaining < PHASE_TWO_MINIMUM_FEE) revert InsufficientFunds();\n                ++getPuzzleColorsAndSolves[_puzzleId].phase2Solves;\n\n                // Transfer protocol fee to `owner`.\n                SafeTransferLib.safeTransferETH(owner, PHASE_TWO_PROTOCOL_FEE);\n\n                // Subtract protocol fee from total value.\n                ethRemaining -= PHASE_TWO_PROTOCOL_FEE;\n            }\n        }\n\n        // Transfer untransferred funds to the puzzle author. Refunds are not\n        // checked, in case someone wants to ``tip'' the author.\n        SafeTransferLib.safeTransferETH(getPuzzleAuthor[_puzzleId], ethRemaining);\n\n        // Emit event\n        emit SolvePuzzle({ id: _puzzleId, solver: msg.sender, solution: _solution, phase: phase });\n    }\n\n    /// @inheritdoc ICurta\n    function addPuzzle(IPuzzle _puzzle, uint256 _tokenId) external {\n        // Revert if the Authorship Token doesn't belong to sender.\n        if (msg.sender != authorshipToken.ownerOf(_tokenId)) revert Unauthorized();\n\n        // Revert if the puzzle has already been used.\n        if (hasUsedAuthorshipToken[_tokenId]) revert AuthorshipTokenAlreadyUsed(_tokenId);\n\n        // Mark token as used.\n        hasUsedAuthorshipToken[_tokenId] = true;\n\n        unchecked {\n            uint32 curPuzzleId = ++puzzleId;\n\n            // Add puzzle.\n            getPuzzle[curPuzzleId] = PuzzleData({\n                puzzle: _puzzle,\n                addedTimestamp: uint40(block.timestamp),\n                firstSolveTimestamp: 0\n            });\n\n            // Add puzzle author.\n            getPuzzleAuthor[curPuzzleId] = msg.sender;\n\n            // Add puzzle Flag colors with default colors.\n            getPuzzleColorsAndSolves[curPuzzleId].colors = DEFAULT_FLAG_COLORS;\n\n            // Emit events.\n            emit AddPuzzle(curPuzzleId, msg.sender, _puzzle);\n        }\n    }\n\n    /// @inheritdoc ICurta\n    function setPuzzleColors(uint32 _puzzleId, uint120 _colors) external {\n        // Revert if `msg.sender` is not the author of the puzzle.\n        if (getPuzzleAuthor[_puzzleId] != msg.sender) revert Unauthorized();\n\n        // Set puzzle colors.\n        getPuzzleColorsAndSolves[_puzzleId].colors = _colors;\n\n        // Emit events.\n        emit UpdatePuzzleColors(_puzzleId, _colors);\n    }\n\n    /// @inheritdoc ICurta\n    function setFermat(uint32 _puzzleId) external {\n        // Revert if the puzzle has never been solved.\n        PuzzleData memory puzzleData = getPuzzle[_puzzleId];\n        if (puzzleData.firstSolveTimestamp == 0) revert PuzzleNotSolved(_puzzleId);\n\n        // Revert if the puzzle is already Fermat.\n        if (fermat.puzzleId == _puzzleId) revert PuzzleAlreadyFermat(_puzzleId);\n\n        unchecked {\n            uint40 timeTaken = puzzleData.firstSolveTimestamp - puzzleData.addedTimestamp;\n\n            // Revert if the puzzle is not Fermat.\n            if (timeTaken < fermat.timeTaken) revert PuzzleNotFermat(_puzzleId);\n\n            // Set Fermat.\n            fermat.puzzleId = _puzzleId;\n            fermat.timeTaken = timeTaken;\n        }\n\n        // Transfer Fermat to puzzle author.\n        address puzzleAuthor = getPuzzleAuthor[_puzzleId];\n        address currentOwner = getTokenData[0].owner;\n\n        unchecked {\n            // Delete ownership information about Fermat, if the owner is not\n            // `address(0)`.\n            if (currentOwner != address(0)) {\n                getUserBalances[currentOwner].balance--;\n\n                delete getApproved[0];\n\n                // Emit burn event.\n                emit Transfer(currentOwner, address(0), 0);\n            }\n\n            // Increment new Fermat author's balance.\n            getUserBalances[puzzleAuthor].balance++;\n        }\n\n        // Set new Fermat owner.\n        getTokenData[0].owner = puzzleAuthor;\n\n        // Emit mint event.\n        emit Transfer(address(0), puzzleAuthor, 0);\n    }\n\n    // -------------------------------------------------------------------------\n    // ERC721Metadata\n    // -------------------------------------------------------------------------\n\n    /// @inheritdoc FlagsERC721\n    function tokenURI(uint256 _tokenId) external view override returns (string memory) {\n        TokenData memory tokenData = getTokenData[_tokenId];\n        require(tokenData.owner != address(0), \"NOT_MINTED\");\n\n        // Puzzle is Fermat.\n        if (_tokenId == 0) {\n            return \"data:application/json;base64,eyJuYW1lIjoiRmVybWF0IiwiZGVzY3JpcHRpb24iOiJMb25nZX\"\n            \"N0IHVuc29sdmVkIHB1enpsZS4iLCJpbWFnZV9kYXRhIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4y\"\n            \"WnlCM2FXUjBhRDBpTlRVd0lpQm9aV2xuYUhROUlqVTFNQ0lnZG1sbGQwSnZlRDBpTUNBd0lEVTFNQ0ExTlRBaU\"\n            \"lHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQ\"\n            \"SEJoZEdnZ1ptbHNiRDBpSXpFNE1VVXlPQ0lnWkQwaVRUQWdNR2czTlRCMk56VXdTREI2SWk4K1BISmxZM1FnZU\"\n            \"QwaU1UUXpJaUI1UFNJMk9TSWdkMmxrZEdnOUlqSTJOQ0lnYUdWcFoyaDBQU0kwTVRJaUlISjRQU0k0SWlCbWFX\"\n            \"eHNQU0lqTWpjek1ETkVJaTgrUEhKbFkzUWdlRDBpTVRRM0lpQjVQU0kzTXlJZ2MzUnliMnRsUFNJak1UQXhNek\"\n            \"ZESWlCM2FXUjBhRDBpTWpVMklpQm9aV2xuYUhROUlqUXdOQ0lnY25nOUlqUWlJR1pwYkd3OUlpTXdaREV3TVRj\"\n            \"aUx6NDhMM04yWno0PSJ9\";\n        }\n\n        // Retrieve information about the puzzle.\n        uint32 _puzzleId = uint32(_tokenId >> 128);\n        PuzzleData memory puzzleData = getPuzzle[_puzzleId];\n        address author = getPuzzleAuthor[_puzzleId];\n        uint32 solves = getPuzzleColorsAndSolves[_puzzleId].solves;\n        uint120 colors = getPuzzleColorsAndSolves[_puzzleId].colors;\n\n        // Phase 0 if\n        // `tokenData.solveTimestamp == puzzleData.firstSolveTimestamp`\n        // Phase 1 if\n        // `tokenData.solveTimestamp == puzzleData.firstSolveTimestamp + PHASE_ONE_LENGTH`\n        // Phase 2 if\n        // `tokenData.solveTimestamp == puzzleData.firstSolveTimestamp + SUBMISSION_LENGTH`\n        uint8 phase = tokenData.solveTimestamp == puzzleData.firstSolveTimestamp\n            ? 0\n            : tokenData.solveTimestamp < puzzleData.firstSolveTimestamp + PHASE_ONE_LENGTH\n            ? 1\n            : 2;\n\n        return flagRenderer.render({\n            _puzzleData: puzzleData,\n            _tokenId: _tokenId + 1, // [MIGRATION] Increment to get rank.\n            _author: author,\n            _solveTime: tokenData.solveTimestamp - puzzleData.addedTimestamp,\n            _solveMetadata: tokenData.solveMetadata,\n            _phase: phase,\n            _solves: solves,\n            _colors: colors\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Helpers\n    // -------------------------------------------------------------------------\n\n    /// @notice Computes the phase the puzzle was at at some timestamp.\n    /// @param _firstSolveTimestamp The timestamp of the first solve.\n    /// @param _solveTimestamp The timestamp of the solve.\n    /// @return phase The phase of the puzzle: ``Phase 0'' refers to the period\n    /// before the puzzle has been solved, ``Phase 1'' refers to the period 2\n    /// days after the first solve, ``Phase 2'' refers to the period 3 days\n    /// after the end of ``Phase 1,'' and ``Phase 3'' is when submissions are\n    /// closed.\n    function _computePhase(uint40 _firstSolveTimestamp, uint40 _solveTimestamp)\n        internal\n        pure\n        returns (uint8 phase)\n    {\n        // Equivalent to:\n        // ```sol\n        // if (_firstSolveTimestamp == 0) {\n        //     phase = 0;\n        // } else {\n        //     if (_solveTimestamp > _firstSolveTimestamp + SUBMISSION_LENGTH) {\n        //         phase = 3;\n        //     } else if (_solveTimestamp > _firstSolveTimestamp + PHASE_ONE_LENGTH) {\n        //         phase = 2;\n        //     } else {\n        //         phase = 1;\n        //     }\n        // }\n        // ```\n        assembly {\n            phase :=\n                mul(\n                    iszero(iszero(_firstSolveTimestamp)),\n                    add(\n                        1,\n                        add(\n                            gt(_solveTimestamp, add(_firstSolveTimestamp, PHASE_ONE_LENGTH)),\n                            gt(_solveTimestamp, add(_firstSolveTimestamp, SUBMISSION_LENGTH))\n                        )\n                    )\n                )\n        }\n    }\n}\n"
    },
    "src/FlagRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibString } from \"solady/utils/LibString.sol\";\n\nimport { ICurta } from \"@/contracts/interfaces/ICurta.sol\";\nimport { IColormapRegistry } from \"@/contracts/interfaces/IColormapRegistry.sol\";\nimport { Base64 } from \"@/contracts/utils/Base64.sol\";\n\n/// @title Curta Flag Renderer\n/// @author fiveoutofnine\n/// @notice A contract that renders the JSON and SVG for a Flag token.\ncontract FlagRenderer {\n    using LibString for uint256;\n    using LibString for address;\n    using LibString for string;\n\n    // -------------------------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------------------------\n\n    /// @notice The colormap registry.\n    IColormapRegistry constant colormapRegistry =\n        IColormapRegistry(0x0000000012883D1da628e31c0FE52e35DcF95D50);\n\n    /// @notice Render the JSON and SVG for a Flag token.\n    /// @param _puzzleData The puzzle data.\n    /// @param _tokenId The token ID.\n    /// @param _author The author of the puzzle.\n    /// @param _solveTime The time it took to solve the puzzle.\n    /// @param _solveMetadata The metadata associated with the solve.\n    /// @param _phase The phase of the puzzle.\n    /// @param _solves The number of solves the puzzle has.\n    /// @param _colors The colors of the Flag.\n    /// @return string memory The JSON and SVG for the Flag token.\n    function render(\n        ICurta.PuzzleData memory _puzzleData,\n        uint256 _tokenId,\n        address _author,\n        uint40 _solveTime,\n        uint56 _solveMetadata,\n        uint8 _phase,\n        uint32 _solves,\n        uint120 _colors\n    ) external view returns (string memory) {\n        // Generate the puzzle's attributes.\n        string memory attributes;\n        {\n            attributes = string.concat(\n                '[{\"trait_type\":\"Puzzle\",\"value\":\"',\n                _puzzleData.puzzle.name(),\n                '\"},{\"trait_type\":\"Puzzle ID\",\"value\":',\n                uint256(_tokenId >> 128).toString(),\n                '},{\"trait_type\":\"Author\",\"value\":\"',\n                _author.toHexStringChecksumed(),\n                '\"},{\"trait_type\":\"Phase\",\"value\":\"',\n                uint256(_phase).toString(),\n                '\"},{\"trait_type\":\"Solver\",\"value\":\"',\n                _formatValueAsAddress(uint256(_solveMetadata & 0xFFFFFFF)),\n                '\"},{\"trait_type\":\"Solve time\",\"value\":',\n                uint256(_solveTime).toString(),\n                '},{\"trait_type\":\"Rank\",\"value\":',\n                uint256(uint128(_tokenId)).toString(),\n                \"}]\"\n            );\n        }\n\n        // Generate the puzzle's SVG.\n        string memory image;\n        {\n            image = string.concat(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"550\" height=\"550\" viewBox=\"0 0 550 '\n                '550\"><style>@font-face{font-family:A;src:url(data:font/woff2;charset-utf-8;base64,'\n                \"d09GMgABAAAAABIoABAAAAAAKLAAABHJAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGjobkE4ci2AGYD9TVE\"\n                \"FURACBHBEICqccoBELgRYAATYCJAOCKAQgBYNuByAMBxt3I6OimvUVZH+VwJOd1yhF0zgE5TExCEqYGJii\"\n                \"xbbnwP4dZ3ojLIOo9nusZ/fRJ8AQgAICFZmKIpSpqJRPjvUpssca0NE7gG12KCpiscLIQJvXhQltNGlMwA\"\n                \"rs/BmdK5fVh2tlJjmcJIfyqegIjKaFAkL2xmzu3G5f+LKucK0RgScgqNbInt05eA7IdyHLQlJ5ILKkAI2L\"\n                \"smRUYiTh5D8sgBvNUikgepThvv9/7Vt9l9274oNYWrFooc1GREOjlHln5tu8NRvMZ1WEJN6I4hZFQyGaVu\"\n                \"tEQvmh0iqJSMiE1ggNX4fm60G4VBK+hVS6yPZZNHETOvYf/6wI8AMAxSaiREKCqKkRPT1iaEjMNZdYzh2C\"\n                \"AK+6KbX/oC8NZO9cTOaDLAPg/gNAbl9N5AMKCBAGxaF4IxHCbAZIOiZOprfyvA2svxHYCN8xFXIgBO2JgJ\"\n                \"BkCIqIycqraOuabY655plvgYUWWWyJFXbwhFCsukQ59cgGY8Uaah88kjL5fx5QlZdkxUNbkDHIMQ++qS7D\"\n                \"1nnyFUqhHlNMvSuZK1fXqRhUhap69aRhnUyKyxTMwBwswBKswBpswPbkEbJ1HEqlntKpR3SrK716R994N1\"\n                \"DVqeeMDo7QrrukpSqSHZgDmAvzvM+v2ZzAQlgEi2EJWZsN0avrRGpFo5UcJiIGx7eiGrZDwnw0YhSkHLvi\"\n                \"Hr+vWx0joCfCKSOyA4H7P0c+r0GXbANfz4GrrMyyqmP3wDWW4+y7l4S762X1ZcwjQBoOINXvM01OAf7nvs\"\n                \"RQg0/rE+A09OW8FQJ4+UuJqyqznjiGunWqiav0+BQcegIjR2e5j2Vobwwvcie5j95yFcPCdxXG3bniECmQ\"\n                \"lY+G0onLqnE5DS6v7b2gZ4mitQ7WhOJHTYxPgMEWFybAIUDx8NO8gqIS0iKSADIiogBiACALcgDyAFIs+B\"\n                \"XiIyikKF4YBJxNgexM0bwcHj5yCokJx0MQ4KIC6SEOEmq18Mvyy89HgP8PidnpugQNSdmjaFy+GJcMSlf4\"\n                \"Ah5oXEtksEDvXgovEdwBIgtEBviBYrA4vPyCwqLikkCkVaxstBbdr7aCAF2wB26Tv5ZdCzwhHtqe5nGikN\"\n                \"jUSech2B6UOBAO1bDSwsivQJsoFjJWicmn36MiJaFvvWhFeqy57HUgEUphEVsjMGJDGFXREWOxEofjPCli\"\n                \"XRRB3WS0H+AVlcX3GTyC0n0fwWGX5vsENrNk3wewWCX5XsFkFPe9gDFa1PcIekTnewLVK/nqaBW9bsWjLI\"\n                \"Gg4ttD1jEkDgYSuSage1OPEAnn2F7zmWoV0dA4MSPis2P5kCECJk18nngCMT+BvSY+X6IJy2dgJ4kvsDYK\"\n                \"bK/AhogntE0/QbkGlkd8kfV9QNJmsEDii63/HrQ62JBY4kVwmW0dqNorftedTLNI/9Jwq8E8SEnWrpgFdt\"\n                \"eqYDJ9XG2eJUNcTB6su+JX1LfQZqHilGkzYd1Vb4kSByBCFgA0FcB2iABI0X4/xbtD+J1UEN+ZoPFO+YJI\"\n                \"CNIy8z4j+rLM2wgNzLklWiwtez2+AHI+9gGEcy3MK7eJBBZKWFDOEMW8OJ6ExdjdkHZ7ZkVYil/MtBgsS0\"\n                \"5lip5noyTbtpWVRQrGxJ5JiTGZtUBisHeMbYCvo5P+ZL0/k2J2AMUAAhxw+2E/KqzTdmtx5F8ggD9MGwHy\"\n                \"BoDFoYHzk9QOBeIg9R3dvx6djJADLt/h1ykwhAHpAVlvgYXzrkIe4H5liJiWz9Mk3l7DHUBRmBZUMzLPfK\"\n                \"uRMHBEiyOQJEVm/cPGYGyyDNmQSDI+F/Xbu3pUT2q9lg0b1K9Hlw7tWkI4CnCR+qdvsh4enfkaYG6Gcxjw\"\n                \"BeAbAIBal+6LTXcrxeKEiunCi8zS+1uXOjYHoSy4EXNuXkTrLUlJoxV2bJDH6MsjMRs2G8tvlsasojT2oc\"\n                \"V1t2yIQlPwMtICCfpWK9WZO4Gtw0u6s9hTS71G58ThjlakCzVBM+YjScM6npVwCfM87HwHH+taYCugEo46\"\n                \"imBSKa2zVdcKK2dXdqkxv+fATPp118TM+6zLjl8d9qi/nFU+7Z33ur7XwZ49VJKIDxrDoLtnrVnJqjCtyB\"\n                \"zUORSvqlCwuWmQ4ZFzVkjuR+3LenE5OgrwP9z1ydHwC0fDuRDNSl4Su2swM0M9LZu6qPGvbFWLJtQXztSm\"\n                \"XWVsBMMwICeOrkmssuxQS5FuyYRyhEp4ENa2fggVisSS8hKz6+VFpnzeUf7nKpa16O6PwSSpY3rPB6lkYd\"\n                \"mD2eiFl5fdD5UH7cvlUFsXSqADVrUGbd0qFemfJZd24YZXzPOJLiRp4+AkEPTEmBlDDhuxbsWnSyzsqWL6\"\n                \"qhuvebv4UDyR4ktUGqSewgqsJA8zzM+034SQLE6JQnFH2WMSFWX/Vjm3ScreuSFIcjRszN+KnHQh11XZAy\"\n                \"7epzEf3CyIdsPSF2HD2o3ZYuelKqikg6KzSHyV649Jnd4fc2iCgSBucqfLg2IO5RLfutpKusgmDxapq5HS\"\n                \"pD5+la82KwhVyt5s5uwS6/1rNoBtgOCIzT8kbSY36KqJKcgoulfNLFTbYPoNbvKgbg96Pb2qPjH70758+m\"\n                \"S13tbHYiV1G+/CA9mR8CT2hKIViO9KwYVq9oFYkOnvb5WViCClYQewYAHcAHH6YXP4Ijk+ZH12N/Km7AiJ\"\n                \"1FHBY9mdPusl8p9IdsP6MMCsMwx/zB8l45BuqXt1846SoAdDZt6noTlcl7wAOl3rhrKSN9YaTvXLRN/eui\"\n                \"WJb3YpB0vZ4tbnW4qlSBranIajAtSTVhxAq/hdmN+FKlMFOGlqAFVadqEYTaqDvZE9nAQUYO7qVTS8a8mO\"\n                \"mOnlseQ3x4kdT8+91dHd+tu2/tUJ29qTc22ZIUENg7SkVilBZOv2wILgtKHWgTTItPVLlQuh1+Sy+qzChx\"\n                \"FD9fhnrxrw0DcU2mORFxFYiQlKQWyur/h376Bx3LLs8I9P17x9vlyNd1J6XDfiycouNOQtAQoOWy59fnXC\"\n                \"Df/61J4vmXjLq6odtfavXtXaKbSdd4aTgAIqHnAHTIQ4ofkJXMOCAqkmTag4Knf3pw2v8dMDVoeODFp6TL\"\n                \"35Y3mqYjqCNszj0QZnQitpIH4SktQankeXnGkuiBgd5Jy3EUiVyAxjfS1sxBOKs3KK25KUCGRz/crlPZLh\"\n                \"vYJb1oup/FOtyNBL0nKp/Dl3RUlet79/LX1RhiTP2sCQsSGhcy29Arez6znwSWlRdXWQ8QdGItUXZksngz\"\n                \"k5y3J/dwIK2B+xyzHCyQA1g6ReIfVeYyPlVk9GSkZvNvlObR3lfl8e2GmoPSOszzM/vFngbjt+u+Z38MG9\"\n                \"Ap2Tglef6yAqoK8jLFowHBs6AdwrJYx90+xUYq5JWIA8nqyrXjx3dEscaHkUFcUCCphiG23zHzbN9LwpLk\"\n                \"CsXYxta++aqI1sotDaQcsTAAWxgAKwzVN74HVkgfX27QLHyA/ugUNYB76rmdlfQnpUVU163F+amT1QiuDq\"\n                \"qvRvrYESWANxiACMYdHpuiI1b2SRXxRT2ozVQQtqZJZCQFGsl/aFrQFJtrSEFgb4gTubmqwkhrthdvkUDE\"\n                \"Dd0G39rHWlgNcalyI15aPaY7LzO2II7mx6DFbM7rbppZswDNUd5xUSV2TtnoDnxZLMWBCHiA0Y67zX/ZPN\"\n                \"T0vyRVYuxrY1dI8XkBr9Itugzc1biCVQFQnYLES4t4a/GkXrqkYeVqcMg7Upy9dLXTPKqJ46HQpDTy0LH8\"\n                \"j8NVn9Zq59XkbaBBxn9L/d/bnnJhEIe65Gfvv6lfFtzzUCac/NyB9f7dfvZiZ85visjuTuv5MJPPjM9lsd\"\n                \"Abd0ABQkgXiz9F1L2u/tsCR9dIXDLe32aKQzAipafZicZgqlOYZxaFbdvvPUWVzrhNREUsCd2zJH90dyZY\"\n                \"V24EBSuU74/4CE2EQ6ksLKHPSI4o/6RpRDEIQyqleIBYtqizt7vEJKIBD8CXk1OyLDuz0YQhE6R3R8H9Kt\"\n                \"4dgZs5ZBRAdMnH4xqI25pvpUBPZPHJSltUJdlr4dPezrQJPO/92YvZZRWVdFC0FsKBxQALj7KsedmlYkxE\"\n                \"ajJbOPdFXyRlmMWUiAJNb8JDchBGa32RPsxBc0BuwSHNWk7d3PBQrXtKeGLY+cWnP2XgBHvEoDyLPvPS4U\"\n                \"gqKEoP2CikHjygGj5mXxLQM85ZSJqqIrjxPAXdYioD378Fb+gtr4sAkcgBOreJ/luya88RjWPAiAFzk7Gs\"\n                \"UjV7pExTnWAAliGfPjOwFhl7pH9pNdgAW42HEPgf19lXuBjQeRMAh5CdcO1qVtku3UOvgbBqFz9pttzbEj\"\n                \"NjVz37qGDv9u05JN27Rel3gtf+gQ0r/xjmrSKCGsFsKAwWwao/P443RmEzAgLKxmjCjhMRhe50MthUAIIB\"\n                \"fVe0YwGjxJRRAAgZSSBl/AXVdpACz73sPCLAWQiO+6oKrfuHrQqHlZYvMoTzljoqboypMEr5WNzDnscSJD\"\n                \"xrB+fMXVZ+WuadxENHOOD3E7k5EdRPMdq4EQw5wdq9R9W1CgELL4WGHM5Jl54BbQL2LaE7GHr5sKyAZuzy\"\n                \"MNvXa52B1Ay5aQ/FwIgaD6ACGBBbkQJO3MYjqKLnh2cXkQDHkkD6T0Tkz2BSVi0vPfdvSf/DNxIxk0SvfJ\"\n                \"07AjtBzK4MmFncKZxcnwP9DO2Jyp6fnsOYj2REmMvlFa+IiHpJXFUIJbENNlK9+XTI2l+Hwa/HzwwOHnR+\"\n                \"v8XAuK86K95grRX8+DsVzFef+URghHYhPdacGpXo5OGV4xKXtSAuJ3OOAiPSl+CVux3yA8tf4oJTtnLyW2\"\n                \"MiAkN50rgy6WqSphR2Q0XKIAafEk7J/ayPXok7hxtnbxk2jwx3d40JHLP0JPaBSJ+OGTuMMnOJXhR0jnhN\"\n                \"tEGcw9NnLa9vq8gvqflnKBnR9/OoTTGy1ImjzDAAe50ClcpZB8tnmPEHm/tHn+zd6N5X8/MXEe6fnjDWiD\"\n                \"HSNEBm88mNXNjU+aOMuqOBaUxfX1TmcHOYabOvipI3ak8aBJ/RIXTT4fekn9EQ9M5SqukjKrgjjNjQI5FA\"\n                \"eTVOZPExQd8BVmrfvyi2j+KWVsDCpxw65GVlBG1WVS2W63EG0rvOF/qfQAx3BdnIepazwx4rYf28vRgeVD\"\n                \"IEX6ODgyvOIGraSdncJVZpPPNu0WIu+/bl55sW9j2d9PDNy2jNyJekmjQ/1ENn88mNnNTUiYPMsoP+YYYY\"\n                \"4jWnsmc0PwEda2RAnE9gd82HsCBf8EooDkc3jWBlnrw/vnY4C1Dr8vfDfJK8qWTXyCCv6fjFjFGtaxgU1s\"\n                \"YRs72CUVSwPWsIEt7GCXci3124AqsIZ1bGATW9jGzohuTgCE/o9XfeCd/xvTsv2BwP+TjdPeYCCk30jV4P\"\n                \"+dKQI9GSFp3qePQUh/awUI1lFcFAHLLXuXTAHlGOgG0Dvf2Z+n5UzCSNAfIyGPN3bOeF/9PVIcRUPhSOh6\"\n                \"tKVcGMmKsbevN84MEsu+Lhh1f59JkajfBk9pPgMnx/e3M9A+R3HUZsstexfbDgVjFwB99wTovLN9/Cs5Qs\"\n                \"75W0d5CQC++bx7HYBvj5Kufrv/W6gSKw2ARQEQ/C8luPB4xOLz5x4A4Xiy65cCY8v0FbZNTj6fzTyZvsPJ\"\n                \"cTqQhJBpczx5isTxnayxWPq4z1q7a22ckZ5h0QkN18ZZL/7wo5k3086aBm+t41Vjk3F6MlT14xfYPWl6PK\"\n                \"ZImZQ9vN/1i2mTWhoZdCsfhZPOYrSub29aOZjBgjMdOd3FwDu5v+WeQSibhd5F/nrwjIrzgiDAertIu0Ci\"\n                \"hGdoEuBzlyhJSYB7AOsm8u65KUFv3bSpD6oa426m2X52teRDKx1CDvzhCjcMb3hXkc93mQhl4aDxIBAvQ6\"\n                \"IYUaIl0zA1DkrZzhZwsq/Dl4wj0e5uq0QCsThYTGWZlMii/6MVm0RDO4Ngdx8viaORkeNiRnefgsnMYQI8\"\n                \"5lB4khB0MnN1w1mUHTjm247hTiAOGwVHlBRxGBJZGxqbmGeB7aj8UDlJ+U2JvzjjtmMI8GmQpO9TbmrsIF\"\n                \"sTY7MdZeFQNhKgK5lM1STySmSEiTrO6X8Ln0n5Lv4Vj6wGAA==)}@font-face{font-family:B;src:u\"\n                \"rl(data:font/woff2;charset-utf-8;base64,d09GMgABAAAAAAhQABAAAAAAD4gAAAf2AAEAAAAAAA\"\n                \"AAAAAAAAAAAAAAAAAAAAAAGhYbhCocUAZgP1NUQVRIAHQRCAqPQIx0Cy4AATYCJANYBCAFg1YHIAwHG/YM\"\n                \"UZRR0hhkPxNMlbEboUgq+fBI0pEkVMwtRsc8kTqPvob/GX6NoH7st/e+aHLMEyXSaHjI5tU7oVEJRaw0mk\"\n                \"2nBHj/P27694UIJFCoHdq50ok6paJURELVmdGOUTWmxtTDXPn9zPxom4glMvErMJW4alpRu79ZXw6UtFRH\"\n                \"/wP4wv6/tVZ3013cAY9nCTwkHhFCIlPKnxP7J3PoDKpJxLtGOqGIyGnDsiZIBUIhtMhTmqVhJtyMGedU9E\"\n                \"0+RQBNABIEsYYgoG6AMbCFBeszo257Y86ocMBvxbAtP8gZBbBEOEyDoQ1DoYwEq3ZEjMdbW2SsoQwLL9Uh\"\n                \"NpGWBcwcl5DPdS1HrnGR9VrcRDbPruGaAV4JWAbmEqeVSq7ZMHXB1nex0hbQ7QIMGoIBRSRh5+0YDIXAw8\"\n                \"cnIpISHHITgyjoEDy8B/JkgkRVMjPzT0ne3bgMTGT5pDwUY8MWguETwiujkBoBKnOkFvhQmsKnmteaEAWY\"\n                \"WD5Z4+HCpeXNialh5VNv+btjzhGmFhB3gDI+YIIQClkOOkqaOegsIERWDHC0nRNKUiu0EeCAkCI1SO+AE4\"\n                \"ipIPIVYOpAkCGiaJwXSj7pfs51YvNESuDpkwVAc2RxpYRAv9NtV69OtSqVdLQhmCmgnBPDnjp9HpgAaRGY\"\n                \"wgN4i0LEjm6MCA/yIm5l/dGcHT5ukKVUUrUMxoUUjvZBN7psscGtpPxTq/D4bFn6FhxEFz65g2XefcoU3U\"\n                \"ZFwXAXP6GLn93jZd1/Lip6ajQyrPgy8C6k33lCWyDxCB/K0OgsTGKThMmsLuw4pBuRzJcbjRKoJz675Shy\"\n                \"M8IaR8dbz4jdf85bnhrlYYVT2BnD0GMZQhnGvnWOjwKmaDOIpBG9neMc9Tiq4LBwHGe9E8MyOLNNYIlkcO\"\n                \"GtW6No8Ey/60O677y3abuTVPjsnh9qqYNxJEMwSXO5Y3y/A8ZPGNPzLoAVsszIg05NKXOFnMNODMskJRfG\"\n                \"SkdB50AuxIVJEMXSiYsB4nhFEptEs/2FwESO8kv7S4xPCzIqBnJLp3Z2bpOwu7B2Ua3WGKwZTRqj011j8o\"\n                \"xzIpPHha8aCJpgXUCCXJmkQtrOSuUNnBlHLLWvo3k0x9g9NCkk0zPtzybSyaIkhg2a8EEKIy9UKCZclMjh\"\n                \"OlbA8MtvYnFa4MsODySK8Cs+J/27bXBorTb80ET/gyMObQ+j6SMQO+jPoelfaJ1t0Pfuuo3f7ndInLeS5f\"\n                \"/e3p43DwAYuRUA/r8bv0JDgd3msXUbu+/Zs1HqUNUlezKk4Zyny3aWdd133rdpN1ADRpys6J1V0ac3rwLk\"\n                \"uWBZ/q/5YP4FReQW5ZoVseyyPFnp1YkrbU4t3p0ad1rd1MEsqTQ9mFWy9w/TDIKYfM2NRcmlT92ymiL9o9\"\n                \"IOrAzp+Wvh//Ok/652HIRppafOjC3e/QnXwtb+G/4LL7qhyQ5o6HS/MSpYVGSpt1o1cjJ/U019feuxjYPW\"\n                \"Pl45teicrmtG7BJDv90hCXf3fTZdE0ZFRB1Y6X2z2BCm7PS689S3R6ZNssU6V6ZqnFegC7tXBd8pYPpsU+\"\n                \"6m0is1JwYfb/T5+LnRd+AJw6YdSs/ULT1MvH96P/7JTaWbzuh86YY6JX6mQqM+qfbBwMHQxzAKRrLPHzVA\"\n                \"6+ITGr3STVVu89kEfHhh6rHFsGWHMuZm6QLWTN8xFsYztQYA+tU1+NJndDB+9s0ezTrVoTSZOgInXLiW+H\"\n                \"blsZ1RA2/71lzanul/8XBcesmlwrCHafn6RPNtVZm7ZlxYcM+Vz2f2j2nV//CCO0CCCUigFsJ8pfucOUr3\"\n                \"+RQC7BrN6y+rbh9w8aZNr5MjgA+pnKb41lw/8qQOeiyCusn8nV6YbUYnG/M1FRfyJyVLpsS/L268QoAYN+\"\n                \"FtB9an1u04sfmNuUdWa02uW5W3V0eUAXrM1elMWi8yPvZ+qV73NjUDTl0zGfYcutAQtd3b7xCMS+9zbdJp\"\n                \"vU+XWe9HzmsP7mfu4kAXXb1ZdbHWm9JqvQUX66uqjkD0YaeaOwW3ZwJ/1ovPPd6CDdmMgPmzpqYsXvmNZG\"\n                \"jU/ZLCbsuRg3nnOuHoSL2bb13gJZi4AM71OPc6wgTEft8pSrc+4wbbPRt9M1FuNcf3qFy1LReWYLHF+Sgm\"\n                \"XJL0eZ1e/Tg17fKWw2c3Ou11Vh0ANxL654L5qIFu2eck/kDEzGnuVnZTr8ptsxj/wGGxwxMGVHy/h5x5Mj\"\n                \"w+Q9e2FPjZMIubRWZfGrtooUym+FjZQvrqYxfOA9vclhZu1qXt/P6O9b6hupPn9Ry3PTSR9fFJTycGEECh\"\n                \"+PB3s7bZUzztizLMAOD746FhAH7kq37/J79VI7EQgDIMIMA/MRs9B/Xnz5P/q/nfq5t9V8A9xYfvchFqyH\"\n                \"GgJjnNkZI9UA3AdFqI3+6QckegVpOREqmoyd0+3E61AmyUfZtlfcBL/bB44l2MhC8goGcTCEWSQ2KJ31aX\"\n                \"ioeKAgC3AA8DQlMbMBa0Bh6ZFgOumzsGwgQf9aRuMSQFEoMw5hgkQMcKlLoLda5C6QNEAiFEjCE7ij7WNW\"\n                \"Rv4GI55AEQq4C8PeZxhGK2B7FQUwAKOMSBQCUTC6OrsgDRIJW02jp85uWZrlBkKHiDHM/Xg/zFI0/gIWUB\"\n                \"Q6PIOJhsqjVONk6WsEh7Pr4zO4JXtRkVKeSIU0uSok0mEmMOtIMT+OlRClJ9471uzlPTJCrkYX7/PQbo/I\"\n                \"z+3axYAg==)}text,tspan{dominant-baseline:central}.a{font-family:A;letter-spacing:-\"\n                \".05em}.b{font-family:B}.c{font-size:16px}.d{font-size:12px}.f{fill:#\",\n                uint256((_colors >> 72) & 0xFFFFFF).toHexStringNoPrefix(3), // Fill\n                \"}.h{fill:#\",\n                uint256((_colors >> 24) & 0xFFFFFF).toHexStringNoPrefix(3), // Primary text\n                \"}.i{fill:#\",\n                uint256(_colors & 0xFFFFFF).toHexStringNoPrefix(3), // Secondary text\n                \"}.j{fill:none;stroke-linejoin:round;stroke-linecap:round;stroke:#\",\n                uint256(_colors & 0xFFFFFF).toHexStringNoPrefix(3) // Secondary text\n            );\n        }\n        {\n            image = string.concat(\n                image,\n                '}.x{width:1px;height:1px}</style><mask id=\"m\"><rect width=\"20\" height=\"20\" rx=\"0.3'\n                '70370\" fill=\"#FFF\"/></mask><path d=\"M0 0h550v550H0z\" style=\"fill:#',\n                uint256((_colors >> 96) & 0xFFFFFF).toHexStringNoPrefix(3), // Background\n                '\"/><rect x=\"143\" y=\"69\" width=\"264\" height=\"412\" rx=\"8\" fill=\"#',\n                uint256((_colors >> 48) & 0xFFFFFF).toHexStringNoPrefix(3), // Border\n                '\"/><rect class=\"f\" x=\"147\" y=\"73\" width=\"256\" height=\"404\" rx=\"4\"/>',\n                _drawStars(_phase)\n            );\n        }\n        {\n            image = string.concat(\n                image,\n                '<text class=\"a h\" x=\"163\" y=\"101\" font-size=\"20\">Puzzle #',\n                (_tokenId >> 128).toString(),\n                '</text><text x=\"163\" y=\"121\"><tspan class=\"b d i\">Created by </tspan><tspan class='\n                '\"a d h\">'\n            );\n        }\n        {\n            uint256 luma =\n                ((_colors >> 88) & 0xFF) + ((_colors >> 80) & 0xFF) + ((_colors >> 72) & 0xFF);\n            image = string.concat(\n                image,\n                _formatValueAsAddress(uint160(_author) >> 132), // Authors\n                '</tspan></text><rect x=\"163\" y=\"137\" width=\"224\" height=\"224\" fill=\"rgba(',\n                luma < ((255 * 3) >> 1) ? \"255,255,255\" : \"0,0,0\", // Background behind the heatmap\n                ',0.2)\" rx=\"8\"/>',\n                _drawDrunkenBishop(_solveMetadata, _tokenId),\n                '<path class=\"j\" d=\"M176.988 387.483A4.992 4.992 0 0 0 173 385.5a4.992 4.992 0 0 0-'\n                \"3.988 1.983m7.975 0a6 6 0 1 0-7.975 0m7.975 0A5.977 5.977 0 0 1 173 389a5.977 5.97\"\n                '7 0 0 1-3.988-1.517M175 381.5a2 2 0 1 1-4 0 2 2 0 0 1 4 0z\"/><text class=\"a c h\" x'\n                '=\"187\" y=\"383\">',\n                _formatValueAsAddress(_solveMetadata >> 28), // Captured by\n                '</text><text class=\"b d i\" x=\"187\" y=\"403\">Captured by</text><path class=\"j\" d=\"m2'\n                \"85.5 380 2 1.5-2 1.5m3 0h2m-6 5.5h9a1.5 1.5 0 0 0 1.5-1.5v-8a1.5 1.5 0 0 0-1.5-1.5\"\n                'h-9a1.5 1.5 0 0 0-1.5 1.5v8a1.5 1.5 0 0 0 1.5 1.5z\"/><text class=\"a c h\" x=\"303\" y'\n                '=\"383\">',\n                _formatValueAsAddress(_solveMetadata & 0xFFFFFFF), // Solution\n                '</text><text class=\"b d i\" x=\"303\" y=\"403\">Solution</text><path class=\"j\" d=\"M176 '\n                \"437.5h-6m6 0a2 2 0 0 1 2 2h-10a2 2 0 0 1 2-2m6 0v-2.25a.75.75 0 0 0-.75-.75h-.58m-\"\n                \"4.67 3v-2.25a.75.75 0 0 1 .75-.75h.581m3.338 0h-3.338m3.338 0a4.97 4.97 0 0 1-.654\"\n                \"-2.115m-2.684 2.115a4.97 4.97 0 0 0 .654-2.115m-3.485-4.561c-.655.095-1.303.211-1.\"\n                \"944.347a4.002 4.002 0 0 0 3.597 3.314m-1.653-3.661V428a4.49 4.49 0 0 0 1.653 3.485\"\n                \"m-1.653-3.661v-1.01a32.226 32.226 0 0 1 4.5-.314c1.527 0 3.03.107 4.5.313v1.011m-7\"\n                \".347 3.661a4.484 4.484 0 0 0 1.832.9m5.515-4.561V428a4.49 4.49 0 0 1-1.653 3.485m1\"\n                \".653-3.661a30.88 30.88 0 0 1 1.944.347 4.002 4.002 0 0 1-3.597 3.314m0 0a4.484 4.4\"\n                '84 0 0 1-1.832.9m0 0a4.515 4.515 0 0 1-2.03 0\"/><text><tspan class=\"a c h\" x=\"187\"'\n                ' y=\"433\">'\n            );\n        }\n        {\n            image = string.concat(\n                image,\n                uint256(uint128(_tokenId)).toString(), // Rank\n                ' </tspan><tspan class=\"a d i\" y=\"435\">/ ',\n                uint256(_solves).toString(), // Solvers\n                '</tspan></text><text class=\"b d i\" x=\"187\" y=\"453\">Rank</text><path class=\"j\" d=\"M'\n                '289 429v4h3m3 0a6 6 0 1 1-12 0 6 6 0 0 1 12 0z\"/><text class=\"a c h\" x=\"303\" y=\"43'\n                '3\">',\n                _formatTime(_solveTime), // Solve time\n                '</text><text class=\"b d i\" x=\"303\" y=\"453\">Solve time</text></svg>'\n            );\n        }\n\n        return string.concat(\n            \"data:application/json;base64,\",\n            Base64.encode(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    _puzzleData.puzzle.name(),\n                    \": Flag #\",\n                    uint256(uint128(_tokenId)).toString(),\n                    '\",\"description\":\"This token represents solve #',\n                    uint256(uint128(_tokenId)).toString(),\n                    \" in puzzle #\",\n                    uint256(_tokenId >> 128).toString(),\n                    '.\",\"image_data\": \"data:image/svg+xml;base64,',\n                    Base64.encode(abi.encodePacked(image)),\n                    '\",\"attributes\":',\n                    attributes,\n                    \"}\"\n                )\n            )\n        );\n    }\n\n    /// @notice Returns the SVG component for the ``heatmap'' generated by\n    /// applying the Drunken Bishop algorithm.\n    /// @param _solveMetadata A bitpacked `uint56` containing metadata of the\n    /// solver and solution.\n    /// @param _tokenId The token ID of the Flag.\n    /// @return string memory The SVG for the heatmap.\n    function _drawDrunkenBishop(uint56 _solveMetadata, uint256 _tokenId)\n        internal\n        view\n        returns (string memory)\n    {\n        uint256 seed = uint256(keccak256(abi.encodePacked(_tokenId, _solveMetadata)));\n        // Select the colormap.\n        bytes32 colormapHash = [\n            bytes32(0xfd29b65966772202ffdb08f653439b30c849f91409915665d99dbfa5e5dab938),\n            bytes32(0x850ce48e7291439b1e41d21fc3f75dddd97580a4ff94aa9ebdd2bcbd423ea1e8),\n            bytes32(0x4f5e8ea8862eff315c110b682ee070b459ba8983a7575c9a9c4c25007039109d),\n            bytes32(0xf2e92189cb6903b98d854cd74ece6c3fafdb2d3472828a950633fdaa52e05032),\n            bytes32(0xa33e6c7c5627ecabfd54c4d85f9bf04815fe89a91379fcf56ccd8177e086db21),\n            bytes32(0xaa84b30df806b46f859a413cb036bc91466307aec5903fc4635c00a421f25d5c),\n            bytes32(0x864a6ee98b9b21ac0291523750d637250405c24a6575e1f75cfbd7209a810ce6),\n            bytes32(0xfd60cd3811f002814944a7d36167b7c9436187a389f2ee476dc883e37dc76bd2),\n            bytes32(0xa8309447f8bd3b5e5e88a0abc05080b7682e4456c388b8636d45f5abb2ad2587),\n            bytes32(0x3be719b0c342797212c4cb33fde865ed9cbe486eb67176265bc0869b54dee925),\n            bytes32(0xca0da6b6309ed2117508207d68a59a18ccaf54ba9aa329f4f60a77481fcf2027),\n            bytes32(0x5ccb29670bb9de0e3911d8e47bde627b0e3640e49c3d6a88d51ff699160dfbe1),\n            bytes32(0x3de8f27f386dab3dbab473f3cc16870a717fe5692b4f6a45003d175c559dfcba),\n            bytes32(0x026736ef8439ebcf8e7b8006bf8cb7482ced84d71b900407a9ed63e1b7bfe234),\n            bytes32(0xc1806ea961848ac00c1f20aa0611529da522a7bd125a3036fe4641b07ee5c61c),\n            bytes32(0x87970b686eb726750ec792d49da173387a567764d691294d764e53439359c436),\n            bytes32(0xaa6277ab923279cf59d78b9b5b7fb5089c90802c353489571fca3c138056fb1b),\n            bytes32(0xdc1cecffc00e2f3196daaf53c27e53e6052a86dc875adb91607824d62469b2bf)\n        ][seed % 18];\n\n        // We start at the middle of the board.\n        uint256 index = 210;\n        uint256 max = 1;\n        uint8[] memory counts = new uint8[](400);\n        counts[index] = 1;\n\n        // Apply Drunken Bishop algorithm.\n        unchecked {\n            while (seed != 0) {\n                (uint256 x, uint256 y) = (index % 20, index / 20);\n\n                assembly {\n                    // Read down/up\n                    switch and(shr(1, seed), 1)\n                    // Up case\n                    case 0 { index := add(index, mul(20, iszero(eq(y, 19)))) }\n                    // Down case\n                    default { index := sub(index, mul(20, iszero(eq(y, 0)))) }\n\n                    // Read left/right\n                    switch and(seed, 1)\n                    // Left case\n                    case 0 { index := add(index, iszero(eq(x, 19))) }\n                    // Right case\n                    default { index := sub(index, iszero(eq(y, 0))) }\n                }\n                if (++counts[index] > max) max = counts[index];\n                seed >>= 2;\n            }\n        }\n\n        // Draw heatmap from counts.\n        string memory image = '<g transform=\"translate(167 141) scale(10.8)\" mask=\"url(#m)\">';\n        unchecked {\n            for (uint256 i; i < 400; ++i) {\n                image = string.concat(\n                    image,\n                    '<rect class=\"x\" x=\"',\n                    (i % 20).toString(),\n                    '\" y=\"',\n                    (i / 20).toString(),\n                    '\" fill=\"#',\n                    colormapRegistry.getValueAsHexString(\n                        colormapHash, uint8((uint256(counts[i]) * 255) / max)\n                    ),\n                    '\"/>'\n                );\n            }\n        }\n\n        return string.concat(image, \"</g>\");\n    }\n\n    /// @notice Returns the SVG component for the stars corresponding to the\n    /// phase, including the background pill.\n    /// @dev Phase 0 = 3 stars; Phase 1 = 2 stars; Phase 2 = 1 star. Also, note\n    /// that the SVGs are returned positioned relative to the whole SVG for the\n    /// Flag.\n    /// @param _phase The phase of the solve.\n    /// @return string memory The SVG for the stars.\n    function _drawStars(uint8 _phase) internal pure returns (string memory) {\n        // This will never underflow because `_phase` is always in the range\n        // [0, 4].\n        unchecked {\n            uint256 width = ((4 - _phase) << 4);\n\n            return string.concat(\n                '<rect class=\"h\" x=\"',\n                (383 - width).toString(),\n                '\" y=\"97\" width=\"',\n                width.toString(),\n                '\" height=\"24\" rx=\"12\"/><path id=\"s\" d=\"M366.192 103.14c.299-.718 1.317-.718 1.616 '\n                \"0l1.388 3.338 3.603.289c.776.062 1.09 1.03.499 1.536l-2.745 2.352.838 3.515c.181.7\"\n                \"57-.642 1.355-1.306.95L367 113.236l-3.085 1.884c-.664.405-1.487-.193-1.306-.95l.83\"\n                '8-3.515-2.745-2.352c-.591-.506-.277-1.474.5-1.536l3.602-.289 1.388-3.337z\"/>',\n                _phase < 2 ? '<use href=\"#s\" x=\"-16\" />' : \"\",\n                _phase < 1 ? '<use href=\"#s\" x=\"-32\" />' : \"\"\n            );\n        }\n    }\n\n    /// @notice Helper function to format the last 28 bits of a value as a\n    /// hexstring of length 7. If the value is less than 24 bits, it is padded\n    /// with leading zeros.\n    /// @param _value The value to format.\n    /// @return string memory The formatted string.\n    function _formatValueAsAddress(uint256 _value) internal pure returns (string memory) {\n        return string.concat(\n            string(abi.encodePacked(bytes32(\"0123456789ABCDEF\")[(_value >> 24) & 0xF])),\n            (_value & 0xFFFFFF).toHexStringNoPrefix(3).toCase(true)\n        );\n    }\n\n    /// @notice Helper function to format seconds into a length string. In order\n    /// to fit the solve time in the card, we format it as follows:\n    ///     * 0:00:00 to 95:59:59\n    ///     * 96 hours to 983 hours\n    ///     * 41 days to 729 days\n    ///     * 2 years onwards\n    /// @param _solveTime The solve time in seconds.\n    /// @return string memory The formatted string.\n    function _formatTime(uint40 _solveTime) internal pure returns (string memory) {\n        if (_solveTime < 96 hours) {\n            uint256 numHours = _solveTime / (1 hours);\n            uint256 numMinutes = (_solveTime % (1 hours)) / (1 minutes);\n            uint256 numSeconds = _solveTime % (1 minutes);\n\n            return string.concat(\n                _zeroPadOne(numHours), \":\", _zeroPadOne(numMinutes), \":\", _zeroPadOne(numSeconds)\n            );\n        } else if (_solveTime < 41 days) {\n            return string.concat(uint256(_solveTime / (1 hours)).toString(), \" hours\");\n        } else if (_solveTime < 730 days) {\n            return string.concat(uint256(_solveTime / (1 days)).toString(), \" days\");\n        }\n        return string.concat(uint256(_solveTime / (365 days)).toString(), \" years\");\n    }\n\n    /// @notice Helper function to zero pad a number by 1 if it is less than 10.\n    /// @param _value The number to zero pad.\n    /// @return string memory The zero padded string.\n    function _zeroPadOne(uint256 _value) internal pure returns (string memory) {\n        if (_value < 10) {\n            return string.concat(\"0\", _value.toString());\n        }\n        return _value.toString();\n    }\n}\n"
    },
    "src/FlagsERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { ERC721TokenReceiver } from \"solmate/tokens/ERC721.sol\";\n\n/// @title The Flags ERC-721 token contract\n/// @author fiveoutofnine\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\n/// @notice A ``Flag'' is an NFT minted to a player when they successfuly solve\n/// a puzzle.\n/// @dev The NFT with token ID 0 is reserved to denote ``Fermat''—the author's\n/// whose puzzle went the longest unsolved.\nabstract contract FlagsERC721 {\n    // -------------------------------------------------------------------------\n    // Events\n    // -------------------------------------------------------------------------\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    // -------------------------------------------------------------------------\n    // Structs\n    // -------------------------------------------------------------------------\n\n    /// @param owner The owner of the token.\n    /// @param solveTimestamp The timestamp of when the token was solved/minted.\n    /// @param solveMetadata A bitpacked `uint56` containing the following\n    /// information:\n    ///     * The first 28 bits are the first 28 bits of the solver.\n    ///     * The last 28 bits are the last 28 bits of the solution.\n    struct TokenData {\n        address owner;\n        uint40 solveTimestamp;\n        uint56 solveMetadata;\n    }\n\n    /// @param phase0Solves The number of puzzles someone solved during Phase 0.\n    /// @param phase1Solves The number of puzzles someone solved during Phase 1.\n    /// @param phase2Solves The number of puzzles someone solved during Phase 2.\n    /// @param solves The total number of solves someone has.\n    /// @param balance The number of tokens someone owns.\n    struct UserBalance {\n        uint32 phase0Solves;\n        uint32 phase1Solves;\n        uint32 phase2Solves;\n        uint32 solves;\n        uint32 balance;\n    }\n\n    // -------------------------------------------------------------------------\n    // ERC721Metadata Storage\n    // -------------------------------------------------------------------------\n\n    /// @notice The name of the contract.\n    string public name;\n\n    /// @notice An abbreviated name for the contract.\n    string public symbol;\n\n    // -------------------------------------------------------------------------\n    // ERC721 Storage (+ Custom)\n    // -------------------------------------------------------------------------\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    mapping(uint256 => TokenData) public getTokenData;\n\n    mapping(address => UserBalance) public getUserBalances;\n\n    // -------------------------------------------------------------------------\n    // Constructor + Functions\n    // -------------------------------------------------------------------------\n\n    /// @param _name The name of the contract.\n    /// @param _symbol An abbreviated name for the contract.\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n\n        // [MIGRATION] Set `getTokenData` for sampriti.eth\n        getTokenData[(1 << 128)] = TokenData({\n            owner: address(0x58593392d72A9D90b133e1C8ecEec581C354687f), // sampriti.eth\n            solveTimestamp: uint40(1677719903),\n            solveMetadata: uint56(24867875967088679)\n        });\n        // [MIGRATION] Set `getTokenData` for karmacoma.eth\n        getTokenData[(1 << 128) | 1] = TokenData({\n            owner: address(0x03433830468d771A921314D75b9A1DeA53C165d7), // karmacoma.eth\n            solveTimestamp: uint40(1677724451),\n            solveMetadata: uint56(918333653799954)\n        });\n        // [MIGRATION] Set `getUserBalances` for sampriti.eth\n        getUserBalances[0x58593392d72A9D90b133e1C8ecEec581C354687f] = UserBalance({\n            phase0Solves: 1,\n            phase1Solves: 0,\n            phase2Solves: 0,\n            solves: 1,\n            balance: 1\n        });\n        // [MIGRATION] Set `getUserBalances` for karmacoma.eth\n        getUserBalances[0x03433830468d771A921314D75b9A1DeA53C165d7] = UserBalance({\n            phase0Solves: 0,\n            phase1Solves: 1,\n            phase2Solves: 0,\n            solves: 1,\n            balance: 1\n        });\n    }\n\n    /// @notice Mints a Flag token to `_to`.\n    /// @dev This function is only called by {Curta}, so it makes a few\n    /// assumptions. For example, the ID of the token is always in the form\n    /// `(puzzleId << 128) + zeroIndexedSolveRanking`.\n    /// @param _to The address to mint the token to.\n    /// @param _id The ID of the token.\n    /// @param _solveMetadata The metadata for the solve (see\n    /// {FlagsERC721.TokenData}).\n    /// @param _phase The phase the token was solved in.\n    function _mint(address _to, uint256 _id, uint56 _solveMetadata, uint8 _phase) internal {\n        // We do not check whether the `_to` is `address(0)` or that the token\n        // was previously minted because {Curta} ensures these conditions are\n        // never true.\n\n        unchecked {\n            ++getUserBalances[_to].balance;\n\n            // `_mint` is only called when a puzzle is solved, so we can safely\n            // increment the solve count.\n            ++getUserBalances[_to].solves;\n\n            // Same logic as the previous comment here.\n            if (_phase == 0) ++getUserBalances[_to].phase0Solves;\n            else if (_phase == 1) ++getUserBalances[_to].phase1Solves;\n            else ++getUserBalances[_to].phase2Solves;\n        }\n\n        getTokenData[_id] = TokenData({\n            owner: _to,\n            solveMetadata: _solveMetadata,\n            solveTimestamp: uint40(block.timestamp)\n        });\n\n        // Emit event.\n        emit Transfer(address(0), _to, _id);\n    }\n\n    // -------------------------------------------------------------------------\n    // ERC721\n    // -------------------------------------------------------------------------\n\n    function ownerOf(uint256 _id) public view returns (address owner) {\n        require((owner = getTokenData[_id].owner) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        require(_owner != address(0), \"ZERO_ADDRESS\");\n\n        return getUserBalances[_owner].balance;\n    }\n\n    function approve(address _spender, uint256 _id) external {\n        address owner = getTokenData[_id].owner;\n\n        // Revert if the sender is not the owner, or the owner has not approved\n        // the sender to operate the token.\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Set the spender as approved for the token.\n        getApproved[_id] = _spender;\n\n        // Emit event.\n        emit Approval(owner, _spender, _id);\n    }\n\n    function setApprovalForAll(address _operator, bool _approved) external {\n        // Set the operator as approved for the sender.\n        isApprovedForAll[msg.sender][_operator] = _approved;\n\n        // Emit event.\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _id) public virtual {\n        // Revert if the token is not being transferred from the current owner.\n        require(_from == getTokenData[_id].owner, \"WRONG_FROM\");\n\n        // Revert if the recipient is the zero address.\n        require(_to != address(0), \"INVALID_RECIPIENT\");\n\n        // Revert if the sender is not the owner, or the owner has not approved\n        // the sender to operate the token.\n        require(\n            msg.sender == _from || isApprovedForAll[_from][msg.sender]\n                || msg.sender == getApproved[_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Update balances.\n        unchecked {\n            // Will never underflow because of the token ownership check above.\n            getUserBalances[_from].balance--;\n\n            getUserBalances[_to].balance++;\n        }\n\n        // Set new owner.\n        getTokenData[_id].owner = _to;\n\n        // Clear previous approval data for the token.\n        delete getApproved[_id];\n\n        // Emit event.\n        emit Transfer(_from, _to, _id);\n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _id) external {\n        transferFrom(_from, _to, _id);\n\n        require(\n            _to.code.length == 0\n                || ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _id, \"\")\n                    == ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _id, bytes calldata _data)\n        external\n    {\n        transferFrom(_from, _to, _id);\n\n        require(\n            _to.code.length == 0\n                || ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _id, _data)\n                    == ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    // -------------------------------------------------------------------------\n    // ERC721Metadata\n    // -------------------------------------------------------------------------\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @param _tokenId The token ID.\n    /// @return URI for the token.\n    function tokenURI(uint256 _tokenId) external view virtual returns (string memory);\n\n    // -------------------------------------------------------------------------\n    // ERC165\n    // -------------------------------------------------------------------------\n\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        return _interfaceId == 0x01FFC9A7 // ERC165 Interface ID for ERC165\n            || _interfaceId == 0x80AC58CD // ERC165 Interface ID for ERC721\n            || _interfaceId == 0x5B5E139F; // ERC165 Interface ID for ERC721Metadata\n    }\n}\n"
    },
    "src/interfaces/IColormapRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IPaletteGenerator } from \"@/contracts/interfaces/IPaletteGenerator.sol\";\n\n/// @title The interface for the colormap registry.\n/// @author fiveoutofnine\n/// @dev A colormap may be defined in 2 ways: (1) via segment data and (2) via a\n/// ``palette generator.''\n///     1. via segment data\n///     2. or via a palette generator ({IPaletteGenerator}).\n/// Segment data contains 1 `uint256` each for red, green, and blue describing\n/// their intensity values along the colormap. Each `uint256` contains 24-bit\n/// words bitpacked together with the following structure (bits are\n/// right-indexed):\n///     | Bits      | Meaning                                              |\n///     | --------- | ---------------------------------------------------- |\n///     | `23 - 16` | Position in the colormap the segment begins from     |\n///     | `15 - 08` | Intensity of R, G, or B the previous segment ends at |\n///     | `07 - 00` | Intensity of R, G, or B the next segment starts at   |\n/// Given some position, the output will be computed via linear interpolations\n/// on the segment data for R, G, and B. A maximum of 10 of these segments fit\n/// within 256 bits, so up to 9 segments can be defined. If you need more\n/// granularity or a nonlinear palette function, you may implement\n/// {IPaletteGenerator} and define a colormap with that.\ninterface IColormapRegistry {\n    // -------------------------------------------------------------------------\n    // Errors\n    // -------------------------------------------------------------------------\n\n    /// @notice Emitted when a colormap already exists.\n    /// @param _colormapHash Hash of the colormap's definition.\n    error ColormapAlreadyExists(bytes32 _colormapHash);\n\n    /// @notice Emitted when a colormap does not exist.\n    /// @param _colormapHash Hash of the colormap's definition.\n    error ColormapDoesNotExist(bytes32 _colormapHash);\n\n    /// @notice Emitted when a segment data used to define a colormap does not\n    /// follow the representation outlined in {IColormapRegistry}.\n    /// @param _segmentData Segment data for 1 of R, G, or B. See\n    /// {IColormapRegistry} for its representation.\n    error SegmentDataInvalid(uint256 _segmentData);\n\n    // -------------------------------------------------------------------------\n    // Structs\n    // -------------------------------------------------------------------------\n\n    /// @notice Segment data that defines a colormap when read via piece-wise\n    /// linear interpolation.\n    /// @dev Each param contains 24-bit words, so each one may contain at most\n    /// 9 (24*10 - 1) segments. See {IColormapRegistry} for how the segment data\n    /// should be structured.\n    /// @param r Segment data for red's color value along the colormap.\n    /// @param g Segment data for green's color value along the colormap.\n    /// @param b Segment data for blue's color value along the colormap.\n    struct SegmentData {\n        uint256 r;\n        uint256 g;\n        uint256 b;\n    }\n\n    // -------------------------------------------------------------------------\n    // Events\n    // -------------------------------------------------------------------------\n\n    /// @notice Emitted when a colormap is registered via a palette generator\n    /// function.\n    /// @param _hash Hash of `_paletteGenerator`.\n    /// @param _paletteGenerator Instance of {IPaletteGenerator} for the\n    /// colormap.\n    event RegisterColormap(bytes32 _hash, IPaletteGenerator _paletteGenerator);\n\n    /// @notice Emitted when a colormap is registered via segment data.\n    /// @param _hash Hash of `_segmentData`.\n    /// @param _segmentData Segment data defining the colormap.\n    event RegisterColormap(bytes32 _hash, SegmentData _segmentData);\n\n    // -------------------------------------------------------------------------\n    // Storage\n    // -------------------------------------------------------------------------\n\n    /// @param _colormapHash Hash of the colormap's definition (segment data).\n    /// @return uint256 Segment data for red's color value along the colormap.\n    /// @return uint256 Segment data for green's color value along the colormap.\n    /// @return uint256 Segment data for blue's color value along the colormap.\n    function segments(bytes32 _colormapHash) external view returns (uint256, uint256, uint256);\n\n    /// @param _colormapHash Hash of the colormap's definition (palette\n    /// generator).\n    /// @return IPaletteGenerator Instance of {IPaletteGenerator} for the\n    /// colormap.\n    function paletteGenerators(bytes32 _colormapHash) external view returns (IPaletteGenerator);\n\n    // -------------------------------------------------------------------------\n    // Actions\n    // -------------------------------------------------------------------------\n\n    /// @notice Register a colormap with a palette generator.\n    /// @param _paletteGenerator Instance of {IPaletteGenerator} for the\n    /// colormap.\n    function register(IPaletteGenerator _paletteGenerator) external;\n\n    /// @notice Register a colormap with segment data that will be read via\n    /// piece-wise linear interpolation.\n    /// @dev See {IColormapRegistry} for how the segment data should be\n    /// structured.\n    /// @param _segmentData Segment data defining the colormap.\n    function register(SegmentData memory _segmentData) external;\n\n    // -------------------------------------------------------------------------\n    // View\n    // -------------------------------------------------------------------------\n\n    /// @notice Get the red, green, and blue color values of a color in a\n    /// colormap at some position.\n    /// @dev Each color value will be returned as a 18 decimal fixed-point\n    /// number in [0, 1]. Note that the function *will not* revert if\n    /// `_position` is an invalid input (i.e. greater than 1e18). This\n    /// responsibility is left to the implementation of {IPaletteGenerator}s.\n    /// @param _colormapHash Hash of the colormap's definition.\n    /// @param _position 18 decimal fixed-point number in [0, 1] representing\n    /// the position in the colormap (i.e. 0 being min, and 1 being max).\n    /// @return uint256 Intensity of red in that color at the position\n    /// `_position`.\n    /// @return uint256 Intensity of green in that color at the position\n    /// `_position`.\n    /// @return uint256 Intensity of blue in that color at the position\n    /// `_position`.\n    function getValue(bytes32 _colormapHash, uint256 _position)\n        external\n        view\n        returns (uint256, uint256, uint256);\n\n    /// @notice Get the red, green, and blue color values of a color in a\n    /// colormap at some position.\n    /// @dev Each color value will be returned as a `uint8` number in [0, 255].\n    /// @param _colormapHash Hash of the colormap's definition.\n    /// @param _position Position in the colormap (i.e. 0 being min, and 255\n    /// being max).\n    /// @return uint8 Intensity of red in that color at the position\n    /// `_position`.\n    /// @return uint8 Intensity of green in that color at the position\n    /// `_position`.\n    /// @return uint8 Intensity of blue in that color at the position\n    /// `_position`.\n    function getValueAsUint8(bytes32 _colormapHash, uint8 _position)\n        external\n        view\n        returns (uint8, uint8, uint8);\n\n    /// @notice Get the hexstring for a color in a colormap at some position.\n    /// @param _colormapHash Hash of the colormap's definition.\n    /// @param _position Position in the colormap (i.e. 0 being min, and 255\n    /// being max).\n    /// @return string Hexstring excluding ``#'' (e.g. `007CFF`) of the color\n    /// at the position `_position`.\n    function getValueAsHexString(bytes32 _colormapHash, uint8 _position)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "src/interfaces/ICurta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IPuzzle } from \"./IPuzzle.sol\";\nimport { AuthorshipToken } from \"@/contracts/AuthorshipToken.sol\";\nimport { FlagRenderer } from \"@/contracts/FlagRenderer.sol\";\n\n/// @title The interface for Curta\n/// @notice A CTF protocol, where players create and solve EVM puzzles to earn\n/// NFTs.\n/// @dev Each solve is represented by an NFT. However, the NFT with token ID 0\n/// is reserved to denote ``Fermat''—the author's whose puzzle went the longest\n/// unsolved.\ninterface ICurta {\n    // -------------------------------------------------------------------------\n    // Errors\n    // -------------------------------------------------------------------------\n\n    /// @notice Emitted when an Authorship Token has already been used to add a\n    /// puzzle to Curta.\n    /// @param _tokenId The ID of an Authorship Token.\n    error AuthorshipTokenAlreadyUsed(uint256 _tokenId);\n\n    /// @notice Emitted when a puzzle's solution is incorrect.\n    error IncorrectSolution();\n\n    /// @notice Emitted when insufficient funds are sent during \"Phase 2\"\n    /// submissions.\n    error InsufficientFunds();\n\n    /// @notice Emitted when a puzzle is already marked as Fermat.\n    /// @param _puzzleId The ID of a puzzle.\n    error PuzzleAlreadyFermat(uint32 _puzzleId);\n\n    /// @notice Emitted when a solver has already solved a puzzle.\n    /// @param _puzzleId The ID of a puzzle.\n    error PuzzleAlreadySolved(uint32 _puzzleId);\n\n    /// @notice Emitted when a puzzle does not exist.\n    /// @param _puzzleId The ID of a puzzle.\n    error PuzzleDoesNotExist(uint32 _puzzleId);\n\n    /// @notice Emitted when the puzzle was not the one that went longest\n    /// unsolved.\n    /// @param _puzzleId The ID of a puzzle.\n    error PuzzleNotFermat(uint32 _puzzleId);\n\n    /// @notice Emitted when a puzzle has not been solved yet.\n    /// @param _puzzleId The ID of a puzzle.\n    error PuzzleNotSolved(uint32 _puzzleId);\n\n    /// @notice Emitted when submissions for a puzzle is closed.\n    /// @param _puzzleId The ID of a puzzle.\n    error SubmissionClosed(uint32 _puzzleId);\n\n    /// @notice Emitted when `msg.sender` is not authorized.\n    error Unauthorized();\n\n    // -------------------------------------------------------------------------\n    // Structs\n    // -------------------------------------------------------------------------\n\n    /// @notice A struct containing data about the puzzle corresponding to\n    /// Fermat (i.e. the puzzle that went the longest unsolved).\n    /// @param puzzleId The ID of the puzzle.\n    /// @param timeTaken The number of seconds it took to first solve the\n    /// puzzle.\n    struct Fermat {\n        uint32 puzzleId;\n        uint40 timeTaken;\n    }\n\n    /// @notice A struct containing data about a puzzle.\n    /// @param puzzle The address of the puzzle.\n    /// @param addedTimestamp The timestamp at which the puzzle was added.\n    /// @param firstSolveTimestamp The timestamp at which the first valid\n    /// solution was submitted.\n    struct PuzzleData {\n        IPuzzle puzzle;\n        uint40 addedTimestamp;\n        uint40 firstSolveTimestamp;\n    }\n\n    /// @notice A struct containing the number of solves a puzzle has.\n    /// @param colors A bitpacked `uint120` of 5 24-bit colors for the puzzle's\n    /// Flags in the following order (left-to-right):\n    ///     * Background color\n    ///     * Fill color\n    ///     * Border color\n    ///     * Primary text color\n    ///     * Secondary text color\n    /// @param phase0Solves The total number of Phase 0 solves a puzzle has.\n    /// @param phase1Solves The total number of Phase 1 solves a puzzle has.\n    /// @param phase2Solves The total number of Phase 2 solves a puzzle has.\n    /// @param solves The total number of solves a puzzle has.\n    struct PuzzleColorsAndSolves {\n        uint120 colors;\n        uint32 phase0Solves;\n        uint32 phase1Solves;\n        uint32 phase2Solves;\n        uint32 solves;\n    }\n\n    // -------------------------------------------------------------------------\n    // Events\n    // -------------------------------------------------------------------------\n\n    /// @notice Emitted when a puzzle is added.\n    /// @param id The ID of the puzzle.\n    /// @param author The address of the puzzle author.\n    /// @param puzzle The address of the puzzle.\n    event AddPuzzle(uint32 indexed id, address indexed author, IPuzzle puzzle);\n\n    /// @notice Emitted when a puzzle is solved.\n    /// @param id The ID of the puzzle.\n    /// @param solver The address of the solver.\n    /// @param solution The solution.\n    /// @param phase The phase in which the puzzle was solved.\n    event SolvePuzzle(uint32 indexed id, address indexed solver, uint256 solution, uint8 phase);\n\n    /// @notice Emitted when a puzzle's colors are updated.\n    /// @param id The ID of the puzzle.\n    /// @param colors A bitpacked `uint120` of 5 24-bit colors for the puzzle's\n    /// Flags.\n    event UpdatePuzzleColors(uint32 indexed id, uint256 colors);\n\n    // -------------------------------------------------------------------------\n    // Immutable Storage\n    // -------------------------------------------------------------------------\n\n    /// @notice The Flag metadata and art renderer contract.\n    function flagRenderer() external view returns (FlagRenderer);\n\n    /// @return The Authorship Token contract.\n    function authorshipToken() external view returns (AuthorshipToken);\n\n    // -------------------------------------------------------------------------\n    // Storage\n    // -------------------------------------------------------------------------\n\n    /// @return The total number of puzzles.\n    function puzzleId() external view returns (uint32);\n\n    /// @return puzzleId The ID of the puzzle corresponding to Fermat.\n    /// @return timeTaken The number of seconds it took to solve the puzzle.\n    function fermat() external view returns (uint32 puzzleId, uint40 timeTaken);\n\n    /// @param _puzzleId The ID of a puzzle.\n    /// @return colors A bitpacked `uint120` of 5 24-bit colors for the puzzle's\n    /// Flags.\n    /// @return phase0Solves The total number of Phase 0 solves a puzzle has.\n    /// @return phase1Solves The total number of Phase 1 solves a puzzle has.\n    /// @return phase2Solves The total number of Phase 2 solves a puzzle has.\n    /// @return solves The total number of solves a puzzle has.\n    function getPuzzleColorsAndSolves(uint32 _puzzleId)\n        external\n        view\n        returns (\n            uint120 colors,\n            uint32 phase0Solves,\n            uint32 phase1Solves,\n            uint32 phase2Solves,\n            uint32 solves\n        );\n\n    /// @param _puzzleId The ID of a puzzle.\n    /// @return puzzle The address of the puzzle.\n    /// @return addedTimestamp The timestamp at which the puzzle was added.\n    /// @return firstSolveTimestamp The timestamp at which the first solution\n    /// was submitted.\n    function getPuzzle(uint32 _puzzleId)\n        external\n        view\n        returns (IPuzzle puzzle, uint40 addedTimestamp, uint40 firstSolveTimestamp);\n\n    /// @param _puzzleId The ID of a puzzle.\n    /// @return The address of the puzzle author.\n    function getPuzzleAuthor(uint32 _puzzleId) external view returns (address);\n\n    /// @param _solver The address of a solver.\n    /// @param _puzzleId The ID of a puzzle.\n    /// @return Whether `_solver` has solved the puzzle of ID `_puzzleId`.\n    function hasSolvedPuzzle(address _solver, uint32 _puzzleId) external view returns (bool);\n\n    /// @param _tokenId The ID of an Authorship Token.\n    /// @return Whether the Authorship Token of ID `_tokenId` has been used to\n    /// add a puzzle.\n    function hasUsedAuthorshipToken(uint256 _tokenId) external view returns (bool);\n\n    // -------------------------------------------------------------------------\n    // Functions\n    // -------------------------------------------------------------------------\n\n    /// @notice Mints a Flag NFT if the provided solution solves the puzzle.\n    /// @param _puzzleId The ID of the puzzle.\n    /// @param _solution The solution.\n    function solve(uint32 _puzzleId, uint256 _solution) external payable;\n\n    /// @notice Adds a puzzle to the contract. Note that an unused Authorship\n    /// Token is required to add a puzzle (see {AuthorshipToken}).\n    /// @param _puzzle The address of the puzzle.\n    /// @param _id The ID of the Authorship Token to burn.\n    function addPuzzle(IPuzzle _puzzle, uint256 _id) external;\n\n    /// @notice Set the colors for a puzzle's Flags.\n    /// @dev Only the author of the puzzle of ID `_puzzleId` may set its token\n    /// renderer.\n    /// @param _puzzleId The ID of the puzzle.\n    /// @param _colors A bitpacked `uint120` of 5 24-bit colors for the puzzle's\n    /// Flags.\n    function setPuzzleColors(uint32 _puzzleId, uint120 _colors) external;\n\n    /// @notice Burns and mints NFT #0 to the author of the puzzle of ID\n    /// `_puzzleId` if it is the puzzle that went longest unsolved.\n    /// @dev The puzzle of ID `_puzzleId` must have been solved at least once.\n    /// @param _puzzleId The ID of the puzzle.\n    function setFermat(uint32 _puzzleId) external;\n}\n"
    },
    "src/interfaces/IPaletteGenerator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// @title The interface for a palette generator.\n/// @author fiveoutofnine\n/// @dev `IPaletteGenerator` contains generator functions for a color's red,\n/// green, and blue color values. Each of these functions is intended to take in\n/// a 18 decimal fixed-point number in [0, 1] representing the position in the\n/// colormap and return the corresponding 18 decimal fixed-point number in\n/// [0, 1] representing the value of each respective color.\ninterface IPaletteGenerator {\n    // -------------------------------------------------------------------------\n    // Errors\n    // -------------------------------------------------------------------------\n\n    /// @notice Reverts if the position is not a valid input.\n    /// @dev The position is not a valid input if it is greater than 1e18.\n    /// @param _position Position in the colormap.\n    error InvalidPosition(uint256 _position);\n\n    // -------------------------------------------------------------------------\n    // Generators\n    // -------------------------------------------------------------------------\n\n    /// @notice Computes the intensity of red of the palette at some position.\n    /// @dev The function should revert if `_position` is not a valid input\n    /// (i.e. greater than 1e18). Also, the return value for all inputs must be\n    /// a 18 decimal.\n    /// @param _position Position in the colormap.\n    /// @return uint256 Intensity of red in that color at the position\n    /// `_position`.\n    function r(uint256 _position) external pure returns (uint256);\n\n    /// @notice Computes the intensity of green of the palette at some position.\n    /// @dev The function should revert if `_position` is not a valid input\n    /// (i.e. greater than 1e18). Also, the return value for all inputs must be\n    /// a 18 decimal.\n    /// @param _position Position in the colormap.\n    /// @return uint256 Intensity of green in that color at the position\n    /// `_position`.\n    function g(uint256 _position) external pure returns (uint256);\n\n    /// @notice Computes the intensity of blue of the palette at some position.\n    /// @dev The function should revert if `_position` is not a valid input\n    /// (i.e. greater than 1e18). Also, the return value for all inputs must be\n    /// a 18 decimal.\n    /// @param _position Position in the colormap.\n    /// @return uint256 Intensity of blue in that color at the position\n    /// `_position`.\n    function b(uint256 _position) external pure returns (uint256);\n}\n"
    },
    "src/interfaces/IPuzzle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// @title The interface for a puzzle on Curta\n/// @notice The goal of players is to view the source code of the puzzle (may\n/// range from just the bytecode to Solidity—whatever the author wishes to\n/// provide), interpret the code, solve it as if it was a regular puzzle, then\n/// verify the solution on-chain.\n/// @dev Since puzzles are on-chain, everyone can view everyone else's\n/// submissions. The generative aspect prevents front-running and allows for\n/// multiple winners: even if players view someone else's solution, they still\n/// have to figure out what the rules/constraints of the puzzle are and apply\n/// the solution to their respective starting position.\ninterface IPuzzle {\n    /// @notice Returns the puzzle's name.\n    /// @return The puzzle's name.\n    function name() external pure returns (string memory);\n\n    /// @notice Generates the puzzle's starting position based on a seed.\n    /// @dev The seed is intended to be `msg.sender` of some wrapper function or\n    /// call.\n    /// @param _seed The seed to use to generate the puzzle.\n    /// @return The puzzle's starting position.\n    function generate(address _seed) external returns (uint256);\n\n    /// @notice Verifies that a solution is valid for the puzzle.\n    /// @dev `_start` is intended to be an output from {IPuzzle-generate}.\n    /// @param _start The puzzle's starting position.\n    /// @param _solution The solution to the puzzle.\n    /// @return Whether the solution is valid.\n    function verify(uint256 _start, uint256 _solution) external returns (bool);\n}\n"
    },
    "src/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678\" \"9+/\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n        string memory table = TABLE;\n        uint256 encodedLength = ((data.length + 2) / 3) << 2;\n        string memory result = new string(encodedLength + 0x20);\n\n        assembly {\n            mstore(result, encodedLength)\n            let tablePtr := add(table, 1)\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            let resultPtr := add(result, 0x20)\n\n            for { } lt(dataPtr, endPtr) { } {\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n                mstore(resultPtr, shl(0xF8, mload(add(tablePtr, and(shr(0x12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(0xF8, mload(add(tablePtr, and(shr(0xC, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(0xF8, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(0xF8, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(0xF0, 0x3D3D)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(0xF8, 0x3D)) }\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@/contracts/=src/",
      "@/script/=script/",
      "@/test/=test/",
      "colormap-registry/=lib/colormap-registry/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "shields-api-contract/=lib/shields-api-contract/contracts/",
      "shields-api/=lib/shields-api-contract/contracts/",
      "solady/=lib/solady/src/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 875
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {
      "src/utils/LibRLP.sol": {
        "LibRLP": "0xcf6ab024429c9709e5de85647fea31b078d71915"
      }
    }
  }
}}