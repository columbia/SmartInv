{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/BMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0;\n\nimport \"./BNum.sol\";\n\n\ncontract BMath is BNum {\n  function calcSingleInGivenPoolOut(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 poolSupply,\n    uint256 totalWeight,\n    uint256 poolAmountOut,\n    uint256 swapFee\n  ) internal pure returns (uint256 tokenAmountIn) {\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n    uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\n\n    //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n    uint256 boo = bdiv(BONE, normalizedWeight);\n    uint256 tokenInRatio = bpow(poolRatio, boo);\n    uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n    uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n    // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\n    //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n    //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n    uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\n    tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\n    return tokenAmountIn;\n  }\n}"
    },
    "contracts/BNum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0;\n\n\ncontract BNum {\n  uint256 internal constant BONE = 1e18;\n  uint256 internal constant MIN_BPOW_BASE = 1 wei;\n  uint256 internal constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n  uint256 internal constant BPOW_PRECISION = BONE / 10**10;\n  uint256 internal constant MIN_WEIGHT = BONE / 4;\n\n  function btoi(uint256 a) internal pure returns (uint256) {\n    return a / BONE;\n  }\n\n  function bfloor(uint256 a) internal pure returns (uint256) {\n    return btoi(a) * BONE;\n  }\n\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"ERR_ADD_OVERFLOW\");\n    return c;\n  }\n\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n    (uint256 c, bool flag) = bsubSign(a, b);\n    require(!flag, \"ERR_SUB_UNDERFLOW\");\n    return c;\n  }\n\n  function bsubSign(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256, bool)\n  {\n    if (a >= b) {\n      return (a - b, false);\n    } else {\n      return (b - a, true);\n    }\n  }\n\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c0 = a * b;\n    require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n    uint256 c1 = c0 + (BONE / 2);\n    require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n    uint256 c2 = c1 / BONE;\n    return c2;\n  }\n\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"ERR_DIV_ZERO\");\n    uint256 c0 = a * BONE;\n    require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n    uint256 c1 = c0 + (b / 2);\n    require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n    uint256 c2 = c1 / b;\n    return c2;\n  }\n\n  // DSMath.wpow\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n    uint256 z = n % 2 != 0 ? a : BONE;\n\n    for (n /= 2; n != 0; n /= 2) {\n      a = bmul(a, a);\n\n      if (n % 2 != 0) {\n        z = bmul(z, a);\n      }\n    }\n    return z;\n  }\n\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n  // of approximation of b^0.w\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n    require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n    require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n    uint256 whole = bfloor(exp);\n    uint256 remain = bsub(exp, whole);\n\n    uint256 wholePow = bpowi(base, btoi(whole));\n\n    if (remain == 0) {\n      return wholePow;\n    }\n\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n    return bmul(wholePow, partialResult);\n  }\n\n  function bpowApprox(\n    uint256 base,\n    uint256 exp,\n    uint256 precision\n  ) internal pure returns (uint256) {\n    // term 0:\n    uint256 a = exp;\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\n    uint256 term = BONE;\n    uint256 sum = term;\n    bool negative = false;\n\n    // term(k) = numer / denom\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\n    // continue until term is less than precision\n    for (uint256 i = 1; term >= precision; i++) {\n      uint256 bigK = i * BONE;\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n      term = bmul(term, bmul(c, x));\n      term = bdiv(term, bigK);\n      if (term == 0) break;\n\n      if (xneg) negative = !negative;\n      if (cneg) negative = !negative;\n      if (negative) {\n        sum = bsub(sum, term);\n      } else {\n        sum = badd(sum, term);\n      }\n    }\n\n    return sum;\n  }\n}\n"
    },
    "contracts/IndexedNarwhalRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./NarwhalRouter.sol\";\nimport \"./BMath.sol\";\nimport \"./interfaces/IIndexPool.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./libraries/TransferHelper.sol\";\n\n\ncontract IndexedNarwhalRouter is NarwhalRouter, BMath {\n  using TokenInfo for bytes32;\n  using TokenInfo for address;\n  using TransferHelper for address;\n  using SafeMath for uint256;\n\n  constructor(\n    address _uniswapFactory,\n    address _sushiswapFactory,\n    address _weth\n  ) NarwhalRouter(_uniswapFactory, _sushiswapFactory, _weth) {}\n\n/** ========== Mint Single: Exact In ========== */\n\n  /**\n   * @dev Swaps ether for each token in `path` using their Uniswap pairs,\n   * then mints at least `minPoolAmountOut` pool tokens from `indexPool`.\n   *\n   * @param path Array of encoded tokens to swap using the Narwhal router.\n   * @param indexPool Address of the index pool to mint tokens from.\n   * @param minPoolAmountOut Amount of pool tokens that must be received to not revert.\n   */\n  function swapExactETHForTokensAndMint(\n    bytes32[] calldata path,\n    address indexPool,\n    uint minPoolAmountOut\n  ) external payable returns (uint poolAmountOut) {\n    require(path[0].readToken() == address(weth), \"NRouter: INVALID_PATH\");\n    uint256[] memory amounts = getAmountsOut(path, msg.value);\n\n    weth.deposit{value: amounts[0]}();\n    address(weth).safeTransfer(pairFor(path[0], path[1]), amounts[0]);\n    _swap(amounts, path, address(this));\n\n    uint amountOut =  amounts[amounts.length - 1];\n    return _mintExactIn(\n      path[path.length - 1].readToken(),\n      amountOut,\n      indexPool,\n      minPoolAmountOut\n    );\n  }\n\n  /**\n   * @dev Swaps a token for each other token in `path` using their Uniswap pairs,\n   * then mints at least `minPoolAmountOut` pool tokens from `indexPool`.\n   *\n   * @param amountIn Amount of the first token in `path` to swap.\n   * @param path Array of encoded tokens to swap using the Narwhal router.\n   * @param indexPool Address of the index pool to mint tokens from.\n   * @param minPoolAmountOut Amount of pool tokens that must be received to not revert.\n   */\n  function swapExactTokensForTokensAndMint(\n    uint amountIn,\n    bytes32[] calldata path,\n    address indexPool,\n    uint minPoolAmountOut\n  ) external returns (uint poolAmountOut) {\n    uint256[] memory amounts = getAmountsOut(path, amountIn);\n    path[0].readToken().safeTransferFrom(\n      msg.sender, pairFor(path[0], path[1]), amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    uint amountOut = amounts[amounts.length - 1];\n\n    return _mintExactIn(\n      path[path.length - 1].readToken(),\n      amountOut,\n      indexPool,\n      minPoolAmountOut\n    );\n  }\n\n  function _mintExactIn(\n    address tokenIn,\n    uint amountIn,\n    address indexPool,\n    uint minPoolAmountOut\n  ) internal returns (uint poolAmountOut) {\n    TransferHelper.safeApprove(tokenIn, indexPool, amountIn);\n    poolAmountOut = IIndexPool(indexPool).joinswapExternAmountIn(\n      tokenIn,\n      amountIn,\n      minPoolAmountOut\n    );\n    TransferHelper.safeTransfer(indexPool, msg.sender, poolAmountOut);\n  }\n\n/** ========== Burn Single: Exact In ========== */\n\n\n  /**\n   * @dev Redeems `poolAmountIn` pool tokens for the first token in `path`\n   * and swaps it to at least `minAmountOut` of the last token in `path`.\n   *\n   * @param indexPool Address of the index pool to burn tokens from.\n   * @param poolAmountIn Amount of pool tokens to burn.\n   * @param path Array of encoded tokens to swap using the Narwhal router.\n   * @param minAmountOut Amount of last token in `path` that must be received to not revert.\n   * @return amountOut Amount of output tokens received.\n   */\n  function burnExactAndSwapForTokens(\n    address indexPool,\n    uint poolAmountIn,\n    bytes32[] calldata path,\n    uint minAmountOut\n  ) external returns (uint amountOut) {\n    amountOut = _burnExactAndSwap(\n      indexPool,\n      poolAmountIn,\n      path,\n      minAmountOut,\n      msg.sender\n    );\n  }\n\n  /**\n   * @dev Redeems `poolAmountIn` pool tokens for the first token in `path`\n   * and swaps it to at least `minAmountOut` ether.\n   *\n   * @param indexPool Address of the index pool to burn tokens from.\n   * @param poolAmountIn Amount of pool tokens to burn.\n   * @param path Array of encoded tokens to swap using the Narwhal router.\n   * @param minAmountOut Amount of ether that must be received to not revert.\n   * @return amountOut Amount of ether received.\n   */\n  function burnExactAndSwapForETH(\n    address indexPool,\n    uint poolAmountIn,\n    bytes32[] calldata path,\n    uint minAmountOut\n  ) external returns (uint amountOut) {\n    require(path[path.length - 1].readToken() == address(weth), \"NRouter: INVALID_PATH\");\n    amountOut = _burnExactAndSwap(\n      indexPool,\n      poolAmountIn,\n      path,\n      minAmountOut,\n      address(this)\n    );\n    IWETH(weth).withdraw(amountOut);\n    TransferHelper.safeTransferETH(msg.sender, amountOut);\n  }\n\n  function _burnExactAndSwap(\n    address indexPool,\n    uint poolAmountIn,\n    bytes32[] memory path,\n    uint minAmountOut,\n    address recipient\n  ) internal returns (uint amountOut) {\n    // Transfer the pool tokens to the router.\n    TransferHelper.safeTransferFrom(\n      indexPool,\n      msg.sender,\n      address(this),\n      poolAmountIn\n    );\n    // Burn the pool tokens for the first token in `path`.\n    uint redeemedAmountOut = IIndexPool(indexPool).exitswapPoolAmountIn(\n      path[0].readToken(),\n      poolAmountIn,\n      0\n    );\n    // Calculate the swap amounts for the redeemed amount of the first token in `path`.\n    uint[] memory amounts = getAmountsOut(path, redeemedAmountOut);\n    amountOut = amounts[amounts.length - 1];\n    require(amountOut >= minAmountOut, \"NRouter: MIN_OUT\");\n    // Transfer the redeemed tokens to the first Uniswap pair.\n    TransferHelper.safeTransfer(\n      path[0].readToken(),\n      pairFor(path[0], path[1]),\n      amounts[0]\n    );\n    // Execute the routed swaps and send the output tokens to `recipient`.\n    _swap(amounts, path, recipient);\n  }\n\n/** ========== Mint Single: Exact Out ========== */\n\n  /**\n   * @dev Swaps ether for each token in `path` through Uniswap,\n   * then mints `poolAmountOut` pool tokens from `indexPool`.\n   *\n   * @param path Array of encoded tokens to swap using the Narwhal router.\n   * @param indexPool Address of the index pool to mint tokens from.\n   * @param poolAmountOut Amount of pool tokens that must be received to not revert.\n   */\n  function swapETHForTokensAndMintExact(\n    bytes32[] calldata path,\n    address indexPool,\n    uint poolAmountOut\n  ) external payable {\n    address swapTokenOut = path[path.length - 1].readToken();\n    uint amountOut = _tokenInGivenPoolOut(indexPool, swapTokenOut, poolAmountOut);\n    require(path[0].readToken() == address(weth), \"INVALID_PATH\");\n\n    uint[] memory amounts = getAmountsIn(path, amountOut);\n    require(amounts[0] <= msg.value, \"NRouter: MAX_IN\");\n\n    weth.deposit{value: amounts[0]}();\n    address(weth).safeTransfer(pairFor(path[0], path[1]), amounts[0]);\n    _swap(amounts, path, address(this));\n\n    // refund dust eth, if any\n    if (msg.value > amounts[0]) {\n      TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    return _mintExactOut(\n      swapTokenOut,\n      amountOut,\n      indexPool,\n      poolAmountOut\n    );\n  }\n\n  /**\n   * @dev Swaps a token for each other token in `path` through Uniswap,\n   * then mints at least `poolAmountOut` pool tokens from `indexPool`.\n   *\n   * @param amountInMax Maximum amount of the first token in `path` to give.\n   * @param path Array of encoded tokens to swap using the Narwhal router.\n   * @param indexPool Address of the index pool to mint tokens from.\n   * @param poolAmountOut Amount of pool tokens that must be received to not revert.\n   */\n  function swapTokensForTokensAndMintExact(\n    uint amountInMax,\n    bytes32[] calldata path,\n    address indexPool,\n    uint poolAmountOut\n  ) external {\n    address swapTokenOut = path[path.length - 1].readToken();\n    uint amountOut = _tokenInGivenPoolOut(indexPool, swapTokenOut, poolAmountOut);\n    uint[] memory amounts = getAmountsIn(path, amountOut);\n    require(amounts[0] <= amountInMax, \"NRouter: MAX_IN\");\n    path[0].readToken().safeTransferFrom(\n      msg.sender, pairFor(path[0], path[1]), amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    _mintExactOut(\n      swapTokenOut,\n      amountOut,\n      indexPool,\n      poolAmountOut\n    );\n  }\n\n  function _mintExactOut(\n    address tokenIn,\n    uint amountIn,\n    address indexPool,\n    uint poolAmountOut\n  ) internal {\n    TransferHelper.safeApprove(tokenIn, indexPool, amountIn);\n    IIndexPool(indexPool).joinswapPoolAmountOut(\n      tokenIn,\n      poolAmountOut,\n      amountIn\n    );\n    TransferHelper.safeTransfer(indexPool, msg.sender, poolAmountOut);\n  }\n\n  function _tokenInGivenPoolOut(\n    address indexPool,\n    address tokenIn,\n    uint256 poolAmountOut\n  ) internal view returns (uint256 amountIn) {\n    IIndexPool.Record memory record = IIndexPool(indexPool).getTokenRecord(tokenIn);\n    if (!record.ready) {\n      uint256 minimumBalance = IIndexPool(indexPool).getMinimumBalance(tokenIn);\n      uint256 realToMinRatio = bdiv(\n        bsub(minimumBalance, record.balance),\n        minimumBalance\n      );\n      uint256 weightPremium = bmul(MIN_WEIGHT / 10, realToMinRatio);\n      record.balance = minimumBalance;\n      record.denorm = uint96(badd(MIN_WEIGHT, weightPremium));\n    }\n\n    uint256 totalSupply = IERC20(indexPool).totalSupply();\n    uint256 totalWeight = IIndexPool(indexPool).getTotalDenormalizedWeight();\n    uint256 swapFee = IIndexPool(indexPool).getSwapFee();\n\n    return calcSingleInGivenPoolOut(\n      record.balance,\n      record.denorm,\n      totalSupply,\n      totalWeight,\n      poolAmountOut,\n      swapFee\n    );\n  }\n\n/** ========== Burn Single: Exact Out ========== */\n\n  /**\n   * @dev Redeems up to `poolAmountInMax` pool tokens for the first token in `path`\n   * and swaps it to exactly `tokenAmountOut` of the last token in `path`.\n   *\n   * @param indexPool Address of the index pool to burn tokens from.\n   * @param poolAmountInMax Maximum amount of pool tokens to burn.\n   * @param path Array of encoded tokens to swap using the Narwhal router.\n   * @param tokenAmountOut Amount of last token in `path` to receive.\n   * @return poolAmountIn Amount of pool tokens burned.\n   */\n  function burnAndSwapForExactTokens(\n    address indexPool,\n    uint poolAmountInMax,\n    bytes32[] calldata path,\n    uint tokenAmountOut\n  ) external returns (uint poolAmountIn) {\n    poolAmountIn = _burnAndSwapForExact(\n      indexPool,\n      poolAmountInMax,\n      path,\n      tokenAmountOut,\n      msg.sender\n    );\n  }\n\n  /**\n   * @dev Redeems up to `poolAmountInMax` pool tokens for the first token in `path`\n   * and swaps it to exactly `ethAmountOut` ether.\n   *\n   * @param indexPool Address of the index pool to burn tokens from.\n   * @param poolAmountInMax Maximum amount of pool tokens to burn.\n   * @param path Array of encoded tokens to swap using the Narwhal router.\n   * @param ethAmountOut Amount of eth to receive.\n   * @return poolAmountIn Amount of pool tokens burned.\n   */\n  function burnAndSwapForExactETH(\n    address indexPool,\n    uint poolAmountInMax,\n    bytes32[] calldata path,\n    uint ethAmountOut\n  ) external returns (uint poolAmountIn) {\n    require(path[path.length - 1].readToken() == address(weth), \"NRouter: INVALID_PATH\");\n    poolAmountIn = _burnAndSwapForExact(\n      indexPool,\n      poolAmountInMax,\n      path,\n      ethAmountOut,\n      address(this)\n    );\n    IWETH(weth).withdraw(ethAmountOut);\n    TransferHelper.safeTransferETH(msg.sender, ethAmountOut);\n  }\n\n  function _burnAndSwapForExact(\n    address indexPool,\n    uint poolAmountInMax,\n    bytes32[] memory path,\n    uint tokenAmountOut,\n    address recipient\n  ) internal returns (uint poolAmountIn) {\n    // Transfer the maximum pool tokens to the router.\n    indexPool.safeTransferFrom(\n      msg.sender,\n      address(this),\n      poolAmountInMax\n    );\n    // Calculate the swap amounts for `tokenAmountOut` of the last token in `path`.\n    uint[] memory amounts = getAmountsIn(path, tokenAmountOut);\n    // Burn the pool tokens for the exact amount of the first token in `path`.\n    poolAmountIn = IIndexPool(indexPool).exitswapExternAmountOut(\n      path[0].readToken(),\n      amounts[0],\n      poolAmountInMax\n    );\n    // Transfer the redeemed tokens to the first Uniswap pair.\n    TransferHelper.safeTransfer(\n      path[0].readToken(),\n      pairFor(path[0], path[1]),\n      amounts[0]\n    );\n    // Execute the routed swaps and send the output tokens to `recipient`.\n    _swap(amounts, path, recipient);\n    // Return any unburned pool tokens to the caller.\n    indexPool.safeTransfer(\n      msg.sender,\n      poolAmountInMax.sub(poolAmountIn)\n    );\n  }\n\n/** ========== Mint All: Exact Out ========== */\n\n  /**\n   * @dev Swaps an input token for every underlying token in an index pool,\n   * then mints `poolAmountOut` pool tokens from the pool.\n   *\n   * Up to one intermediary token may be provided in `intermediaries` for each\n   * underlying token in the index pool.\n   *\n   * If a null address is provided as an intermediary, the input token will be\n   * swapped directly for the output token.\n   *\n   * `intermediaries` is an encoded Narwhal path with a one-byte prefix indicating\n   * whether the first swap should use sushiswap.\n   *\n   * @param indexPool Address of the index pool to mint tokens with.\n   * @param intermediaries Encoded Narwhal tokens array with a one-byte prefix\n   * indicating whether the swap to the underlying token should use sushiswap.\n   * @param poolAmountOut Amount of index pool tokens to mint.\n   * @param tokenIn Token to buy the underlying tokens with.\n   * @param amountInMax Maximumm amount of `tokenIn` to spend.\n   * @return Amount of `tokenIn` spent.\n   */\n  function swapTokensForAllTokensAndMintExact(\n    address indexPool,\n    bytes32[] calldata intermediaries,\n    uint256 poolAmountOut,\n    address tokenIn,\n    uint256 amountInMax\n  ) external returns (uint256) {\n    uint256 remainder = amountInMax;\n    address[] memory tokens = IIndexPool(indexPool).getCurrentTokens();\n    require(\n      tokens.length == intermediaries.length,\n      \"NRouter: ARR_LEN\"\n    );\n    tokenIn.safeTransferFrom(msg.sender, address(this), amountInMax);\n    uint256[] memory amountsToPool = new uint256[](tokens.length);\n\n    uint256 ratio = bdiv(poolAmountOut, IERC20(indexPool).totalSupply());\n\n    // Reserve 3 slots in memory for the addresses\n    bytes32[] memory path = new bytes32[](3);\n    path[0] = tokenIn.pack(false);\n    for (uint256 i = 0; i < tokens.length; i++) {\n      (amountsToPool[i], remainder) = _handleMintInput(\n        indexPool,\n        intermediaries[i],\n        tokens[i],\n        path,\n        ratio,\n        remainder\n      );\n    }\n    IIndexPool(indexPool).joinPool(poolAmountOut, amountsToPool);\n    TransferHelper.safeTransfer(indexPool, msg.sender, poolAmountOut);\n    if (remainder > 0) {\n      tokenIn.safeTransfer(msg.sender, remainder);\n    }\n    return amountInMax.sub(remainder);\n  }\n\n  /**\n   * @dev Swaps ether for every underlying token in an index pool,\n   * then mints `poolAmountOut` pool tokens from the pool.\n   *\n   * Up to one intermediary token may be provided in `intermediaries` for each\n   * underlying token in the index pool.\n   *\n   * If a null address is provided as an intermediary, the input token will be\n   * swapped directly for the output token.\n   *\n   * `intermediaries` is an encoded Narwhal path with a one-byte prefix indicating\n   * whether the first swap should use sushiswap.\n   *\n   * @param indexPool Address of the index pool to mint tokens with.\n   * @param intermediaries Encoded Narwhal tokens array with a one-byte prefix\n   * indicating whether the swap to the underlying token should use sushiswap.\n   * @param poolAmountOut Amount of index pool tokens to mint.\n   * @return Amount of ether spent.\n   */\n  function swapETHForAllTokensAndMintExact(\n    address indexPool,\n    bytes32[] calldata intermediaries,\n    uint256 poolAmountOut\n  ) external payable returns (uint) {\n    uint256 remainder = msg.value;\n    IWETH(weth).deposit{value: msg.value}();\n    address[] memory tokens = IIndexPool(indexPool).getCurrentTokens();\n    require(tokens.length == intermediaries.length, \"NRouter: ARR_LEN\");\n    uint256[] memory amountsToPool = new uint256[](tokens.length);\n\n    uint256 ratio = bdiv(poolAmountOut, IERC20(indexPool).totalSupply());\n\n    // Reserve 3 slots in memory for the addresses\n    bytes32[] memory path = new bytes32[](3);\n    path[0] = address(weth).pack(false);\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      (amountsToPool[i], remainder) = _handleMintInput(\n        indexPool,\n        intermediaries[i],\n        tokens[i],\n        path,\n        ratio,\n        remainder\n      );\n    }\n    IIndexPool(indexPool).joinPool(poolAmountOut, amountsToPool);\n    TransferHelper.safeTransfer(indexPool, msg.sender, poolAmountOut);\n\n    if (remainder > 0) {\n      IWETH(weth).withdraw(remainder);\n      TransferHelper.safeTransferETH(msg.sender, remainder);\n    }\n    return msg.value.sub(remainder);\n  }\n\n  function _handleMintInput(\n    address indexPool,\n    bytes32 intermediate,\n    address poolToken,\n    bytes32[] memory path,\n    uint256 poolRatio,\n    uint256 amountInMax\n  ) internal returns (uint256 amountToPool, uint256 remainder) {\n    address tokenIn = path[0].readToken();\n    uint256 usedBalance = IIndexPool(indexPool).getUsedBalance(poolToken);\n    amountToPool = bmul(poolRatio, usedBalance);\n    if (tokenIn == poolToken) {\n      remainder = amountInMax.sub(amountToPool, \"NRouter: MAX_IN\");\n    } else {\n      bool sushiFirst;\n      assembly {\n        sushiFirst := shr(168,  intermediate)\n        intermediate := and(\n          0x0000000000000000000000ffffffffffffffffffffffffffffffffffffffffff,\n          intermediate\n        )\n      }\n      path[0] = tokenIn.pack(sushiFirst);\n      if (intermediate == bytes32(0)) {\n        // If no intermediate token is given, set path length to 2 so the other\n        // functions will not use the 3rd address.\n        assembly { mstore(path, 2) }\n        // It doesn't matter whether a token is set to use sushi or not\n        // if it is the last token in the list.\n        path[1] = poolToken.pack(false);\n      } else {\n        // If an intermediary is given, set path length to 3 so the other\n        // functions will use all addresses.\n        assembly { mstore(path, 3) }\n        path[1] = intermediate;\n        path[2] = poolToken.pack(false);\n      }\n      uint[] memory amounts = getAmountsIn(path, amountToPool);\n      remainder = amountInMax.sub(amounts[0], \"NRouter: MAX_IN\");\n      tokenIn.safeTransfer(pairFor(path[0], path[1]), amounts[0]);\n      _swap(amounts, path, address(this));\n    }\n    poolToken.safeApprove(indexPool, amountToPool);\n  }\n\n/** ========== Burn All: Exact In ========== */\n\n  /**\n   * @dev Burns `poolAmountOut` for all the underlying tokens in a pool, then\n   * swaps each of them on Uniswap for at least `minAmountOut` of `tokenOut`.\n   *\n   * Up to one intermediary token may be provided in `intermediaries` for each\n   * underlying token in the index pool.\n   *\n   * If a null address is provided as an intermediary, the input token will be\n   * swapped directly for the output token.\n   *\n   * @param indexPool Address of the index pool to burn tokens from.\n   * @param minAmountsOut Minimum amount of each underlying token that must be\n   * received from the pool to not revert.\n   * @param intermediaries Encoded Narwhal tokens array with a one-byte prefix\n   * indicating whether the swap to the underlying token should use sushiswap.\n   * @param poolAmountIn Amount of index pool tokens to burn.\n   * @param tokenOut Address of the token to buy.\n   * @param minAmountOut Minimum amount of `tokenOut` that must be received to\n   * not revert.\n   * @return amountOutTotal Amount of `tokenOut` received.\n   */\n  function burnForAllTokensAndSwapForTokens(\n    address indexPool,\n    uint256[] calldata minAmountsOut,\n    bytes32[] calldata intermediaries,\n    uint256 poolAmountIn,\n    address tokenOut,\n    uint256 minAmountOut\n  ) external returns (uint256 amountOutTotal) {\n    amountOutTotal = _burnForAllTokensAndSwap(\n      indexPool,\n      tokenOut,\n      minAmountsOut,\n      intermediaries,\n      poolAmountIn,\n      minAmountOut,\n      msg.sender\n    );\n  }\n\n  /**\n   * @dev Burns `poolAmountOut` for all the underlying tokens in a pool, then\n   * swaps each of them on Uniswap for at least `minAmountOut` ether.\n   *\n   * Up to one intermediary token may be provided in `intermediaries` for each\n   * underlying token in the index pool.\n   *\n   * If a null address is provided as an intermediary, the input token will be\n   * swapped directly for the output token.\n   *\n   * @param indexPool Address of the index pool to burn tokens from.\n   * @param minAmountsOut Minimum amount of each underlying token that must be\n   * received from the pool to not revert.\n   * @param intermediaries Encoded Narwhal tokens array with a one-byte prefix\n   * indicating whether the swap to the underlying token should use sushiswap.\n   * @param poolAmountIn Amount of index pool tokens to burn.\n   * @param minAmountOut Minimum amount of ether that must be received to\n   * not revert.\n   * @return amountOutTotal Amount of ether received.\n   */\n  function burnForAllTokensAndSwapForETH(\n    address indexPool,\n    uint256[] calldata minAmountsOut,\n    bytes32[] calldata intermediaries,\n    uint256 poolAmountIn,\n    uint256 minAmountOut\n  ) external returns (uint amountOutTotal) {\n    amountOutTotal = _burnForAllTokensAndSwap(\n      indexPool,\n      address(weth),\n      minAmountsOut,\n      intermediaries,\n      poolAmountIn,\n      minAmountOut,\n      address(this)\n    );\n    IWETH(weth).withdraw(amountOutTotal);\n    TransferHelper.safeTransferETH(msg.sender, amountOutTotal);\n  }\n\n  function _burnForAllTokensAndSwap(\n    address indexPool,\n    address tokenOut,\n    uint256[] calldata minAmountsOut,\n    bytes32[] calldata intermediaries,\n    uint256 poolAmountIn,\n    uint256 minAmountOut,\n    address recipient\n  ) internal returns (uint amountOutTotal) {\n    // Transfer the pool tokens from the caller.\n    TransferHelper.safeTransferFrom(indexPool, msg.sender, address(this), poolAmountIn);\n    address[] memory tokens = IIndexPool(indexPool).getCurrentTokens();\n    require(\n      intermediaries.length == tokens.length && minAmountsOut.length == tokens.length,\n      \"IndexedUniswapRouterBurner: BAD_ARRAY_LENGTH\"\n    );\n    IIndexPool(indexPool).exitPool(poolAmountIn, minAmountsOut);\n    // Reserve 3 slots in memory for the addresses\n    bytes32[] memory path = new bytes32[](3);\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      uint amountOut = _handleBurnOutput(\n        tokens[i],\n        intermediaries[i],\n        tokenOut,\n        path,\n        recipient\n      );\n      amountOutTotal = amountOutTotal.add(amountOut);\n    }\n    require(amountOutTotal >= minAmountOut, \"NRouter: MIN_OUT\");\n  }\n\n  function _handleBurnOutput(\n    address tokenIn,\n    bytes32 intermediate,\n    address tokenOut,\n    bytes32[] memory path,\n    address recipient\n  ) internal returns (uint amountOut) {\n    uint256 _balance = IERC20(tokenIn).balanceOf(address(this));\n    if (tokenIn == tokenOut) {\n      amountOut = _balance;\n      if (recipient != address(this)) {\n        tokenIn.safeTransfer(recipient, _balance);\n      }\n    } else {\n      bool sushiFirst;\n      assembly {\n        sushiFirst := shr(168,  intermediate)\n        intermediate := and(\n          0x0000000000000000000000ffffffffffffffffffffffffffffffffffffffffff,\n          intermediate\n        )\n      }\n      path[0] = tokenIn.pack(sushiFirst);\n      if (intermediate == bytes32(0)) {\n        // If no intermediate token is given, set path length to 2 so the other\n        // functions will not use the 3rd address.\n        assembly { mstore(path, 2) }\n        // It doesn't matter whether a token is set to use sushi or not\n        // if it is the last token in the list.\n        path[1] = tokenOut.pack(false);\n      } else {\n        // If an intermediary is given, set path length to 3 so the other\n        // functions will use all addresses.\n        assembly { mstore(path, 3) }\n        path[1] = intermediate;\n        path[2] = tokenOut.pack(false);\n      }\n      uint[] memory amounts = getAmountsOut(path, _balance);\n      tokenIn.safeTransfer(pairFor(path[0], path[1]), amounts[0]);\n      _swap(amounts, path, recipient);\n      amountOut = amounts[amounts.length - 1];\n    }\n  }\n}"
    },
    "contracts/Narwhal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/TokenInfo.sol\";\n\n\ncontract Narwhal {\n  using SafeMath for uint256;\n  using TokenInfo for bytes32;\n\n  address public immutable uniswapFactory;\n  address public immutable sushiswapFactory;\n  IWETH public immutable weth;\n\n/** ========== Constructor ========== */\n\n  constructor(\n    address _uniswapFactory,\n    address _sushiswapFactory,\n    address _weth\n  ) {\n    uniswapFactory = _uniswapFactory;\n    sushiswapFactory = _sushiswapFactory;\n    weth = IWETH(_weth);\n  }\n\n/** ========== Fallback ========== */\n\n  receive() external payable {\n    assert(msg.sender == address(weth)); // only accept ETH via fallback from the WETH contract\n  }\n\n/** ========== Swaps ========== */\n\n  // requires the initial amount to have already been sent to the first pair\n  function _swap(uint[] memory amounts, bytes32[] memory path, address recipient) internal {\n    for (uint i; i < path.length - 1; i++) {\n      (bytes32 input, bytes32 output) = (path[i], path[i + 1]);\n      uint amountOut = amounts[i + 1];\n      (uint amount0Out, uint amount1Out) = (input < output) ? (uint(0), amountOut) : (amountOut, uint(0));\n      address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : recipient;\n      IUniswapV2Pair(pairFor(input, output)).swap(\n        amount0Out, amount1Out, to, new bytes(0)\n      );\n    }\n  }\n\n/** ========== Pair Calculation & Sorting ========== */\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function zeroForOne(bytes32 tokenA, bytes32 tokenB) internal pure returns (bool) {\n    return tokenA < tokenB;\n  }\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(bytes32 tokenA, bytes32 tokenB)\n    internal\n    pure\n    returns (bytes32 token0, bytes32 token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != bytes32(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function calculateUniPair(address token0, address token1 ) internal view returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            uniswapFactory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  function calculateSushiPair(address token0, address token1) internal view returns (address pair) {\n    pair = address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            hex\"ff\",\n            sushiswapFactory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\" // init code hash\n          )\n        )\n      )\n    );\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address tokenA,\n    address tokenB,\n    bool sushi\n  ) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = sushi ? calculateSushiPair(token0, token1) : calculateUniPair(token0, token1);\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(bytes32 tokenInfoA, bytes32 tokenInfoB) internal view returns (address pair) {\n    (address tokenA, bool sushi) = tokenInfoA.unpack();\n    address tokenB = tokenInfoB.readToken();\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = sushi ? calculateSushiPair(token0, token1) : calculateUniPair(token0, token1);\n  }\n\n/** ========== Pair Reserves ========== */\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    bytes32 tokenInfoA,\n    bytes32 tokenInfoB\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(tokenInfoA, tokenInfoB)).getReserves();\n    (reserveA, reserveB) = tokenInfoA < tokenInfoB\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n  }\n\n/** ========== Swap Amounts ========== */\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 amountInWithFee = amountIn.mul(997);\n    uint256 numerator = amountInWithFee.mul(reserveOut);\n    uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n    uint256 denominator = reserveOut.sub(amountOut).mul(997);\n    amountIn = (numerator / denominator).add(1);\n  }\n\n  // performs chained getAmountOut calculations on any number of pairs\n  function getAmountsOut(\n    bytes32[] memory path,\n    uint256 amountIn\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint[](path.length);\n    amounts[0] = amountIn;\n    for (uint i; i < path.length - 1; i++) {\n      (uint reserveIn, uint reserveOut) = getReserves(path[i], path[i + 1]);\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    bytes32[] memory path,\n    uint256 amountOut\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(path[i - 1], path[i]);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n"
    },
    "contracts/NarwhalRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./Narwhal.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IUniswapV2Factory.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IWETH.sol\";\n\n\ncontract NarwhalRouter is Narwhal {\n  using TokenInfo for bytes32;\n  using TokenInfo for address;\n  using TransferHelper for address;\n  using SafeMath for uint256;\n\n  modifier ensure(uint256 deadline) {\n    require(deadline >= block.timestamp, \"NRouter: EXPIRED\");\n    _;\n  }\n\n  constructor(\n    address _uniswapFactory,\n    address _sushiswapFactory,\n    address _weth\n  ) Narwhal(_uniswapFactory, _sushiswapFactory, _weth) {}\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    bytes32[] calldata path,\n    address to,\n    uint256 deadline\n  ) external ensure(deadline) returns (uint256[] memory amounts) {\n    amounts = getAmountsOut(path, amountIn);\n    require(amounts[amounts.length - 1] >= amountOutMin, \"NRouter: MIN_OUT\");\n    path[0].readToken().safeTransferFrom(\n      msg.sender,\n      pairFor(path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    bytes32[] calldata path,\n    address to,\n    uint256 deadline\n  ) external ensure(deadline) returns (uint256[] memory amounts) {\n    amounts = getAmountsIn(path, amountOut);\n    require(amounts[0] <= amountInMax, \"NRouter: MAX_IN\");\n    path[0].readToken().safeTransferFrom(\n      msg.sender,\n      pairFor(path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    bytes32[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable ensure(deadline) returns (uint256[] memory amounts) {\n    require(path[0].readToken() == address(weth), \"NRouter: INVALID_PATH\");\n    amounts = getAmountsOut(path, msg.value);\n    require(amounts[amounts.length - 1] >= amountOutMin, \"NRouter: MIN_OUT\");\n    weth.deposit{value: amounts[0]}();\n    address(weth).safeTransfer(pairFor(path[0], path[1]), amounts[0]);\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    bytes32[] calldata path,\n    address to,\n    uint256 deadline\n  ) external ensure(deadline) returns (uint256[] memory amounts) {\n    require(path[path.length - 1].readToken() == address(weth), \"NRouter: INVALID_PATH\");\n    amounts = getAmountsIn(path, amountOut);\n    require(amounts[0] <= amountInMax, \"NRouter: MAX_IN\");\n    path[0].readToken().safeTransferFrom(\n      msg.sender,\n      pairFor(path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    weth.withdraw(amounts[amounts.length - 1]);\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n  }\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    bytes32[] calldata path,\n    address to,\n    uint256 deadline\n  ) external ensure(deadline) returns (uint256[] memory amounts) {\n    require(path[path.length - 1].readToken() == address(weth), \"NRouter: INVALID_PATH\");\n    amounts = getAmountsOut(path, amountIn);\n    require(amounts[amounts.length - 1] >= amountOutMin, \"NRouter: MIN_OUT\");\n    path[0].readToken().safeTransferFrom(\n      msg.sender,\n      pairFor(path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    weth.withdraw(amounts[amounts.length - 1]);\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n  }\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    bytes32[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable ensure(deadline) returns (uint256[] memory amounts) {\n    require(path[0].readToken() == address(weth), \"NRouter: INVALID_PATH\");\n    amounts = getAmountsIn(path, amountOut);\n    require(amounts[0] <= msg.value, \"NRouter: MAX_IN\");\n    weth.deposit{value: amounts[0]}();\n    address(weth).safeTransfer(pairFor(path[0], path[1]), amounts[0]);\n    _swap(amounts, path, to);\n    // // refund dust eth, if any\n    if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n  }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}"
    },
    "contracts/interfaces/IIndexPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\n\ninterface IIndexPool is IERC20 {\n  /**\n   * @dev Token record data structure\n   * @param bound is token bound to pool\n   * @param ready has token been initialized\n   * @param lastDenormUpdate timestamp of last denorm change\n   * @param denorm denormalized weight\n   * @param desiredDenorm desired denormalized weight (used for incremental changes)\n   * @param index index of address in tokens array\n   * @param balance token balance\n   */\n  struct Record {\n    bool bound;\n    bool ready;\n    uint40 lastDenormUpdate;\n    uint96 denorm;\n    uint96 desiredDenorm;\n    uint8 index;\n    uint256 balance;\n  }\n\n  event LOG_SWAP(\n    address indexed caller,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint256 tokenAmountIn,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_JOIN(\n    address indexed caller,\n    address indexed tokenIn,\n    uint256 tokenAmountIn\n  );\n\n  event LOG_EXIT(\n    address indexed caller,\n    address indexed tokenOut,\n    uint256 tokenAmountOut\n  );\n\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\n\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\n\n  event LOG_TOKEN_REMOVED(address token);\n\n  event LOG_TOKEN_ADDED(\n    address indexed token,\n    uint256 desiredDenorm,\n    uint256 minimumBalance\n  );\n\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\n\n  event LOG_TOKEN_READY(address indexed token);\n\n  event LOG_PUBLIC_SWAP_ENABLED();\n\n  event LOG_MAX_TOKENS_UPDATED(uint256 maxPoolTokens);\n\n  event LOG_SWAP_FEE_UPDATED(uint256 swapFee);\n\n  function configure(\n    address controller,\n    string calldata name,\n    string calldata symbol\n  ) external;\n\n  function initialize(\n    address[] calldata tokens,\n    uint256[] calldata balances,\n    uint96[] calldata denorms,\n    address tokenProvider,\n    address unbindHandler,\n    address exitFeeRecipient\n  ) external;\n\n  function setMaxPoolTokens(uint256 maxPoolTokens) external;\n\n  function setSwapFee(uint256 swapFee) external;\n\n  function delegateCompLikeToken(address token, address delegatee) external;\n\n  function reweighTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms\n  ) external;\n\n  function reindexTokens(\n    address[] calldata tokens,\n    uint96[] calldata desiredDenorms,\n    uint256[] calldata minimumBalances\n  ) external;\n\n  function setMinimumBalance(address token, uint256 minimumBalance) external;\n\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    uint256 minPoolAmountOut\n  ) external returns (uint256/* poolAmountOut */);\n\n  function joinswapPoolAmountOut(\n    address tokenIn,\n    uint256 poolAmountOut,\n    uint256 maxAmountIn\n  ) external returns (uint256/* tokenAmountIn */);\n\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  function exitswapPoolAmountIn(\n    address tokenOut,\n    uint256 poolAmountIn,\n    uint256 minAmountOut\n  )\n    external returns (uint256/* tokenAmountOut */);\n\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPoolAmountIn\n  ) external returns (uint256/* poolAmountIn */);\n\n  function gulp(address token) external;\n\n  function flashBorrow(\n    address recipient,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256/* tokenAmountOut */, uint256/* spotPriceAfter */);\n\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 /* tokenAmountIn */, uint256 /* spotPriceAfter */);\n\n  function isPublicSwap() external view returns (bool);\n\n  function getSwapFee() external view returns (uint256/* swapFee */);\n\n  function getController() external view returns (address);\n\n  function getMaxPoolTokens() external view returns (uint256);\n\n  function isBound(address t) external view returns (bool);\n\n  function getNumTokens() external view returns (uint256);\n\n  function getCurrentTokens() external view returns (address[] memory tokens);\n\n  function getCurrentDesiredTokens() external view returns (address[] memory tokens);\n\n  function getDenormalizedWeight(address token) external view returns (uint256/* denorm */);\n\n  function getTokenRecord(address token) external view returns (Record memory record);\n\n  function extrapolatePoolValueFromToken() external view returns (address/* token */, uint256/* extrapolatedValue */);\n\n  function getTotalDenormalizedWeight() external view returns (uint256);\n\n  function getBalance(address token) external view returns (uint256);\n\n  function getMinimumBalance(address token) external view returns (uint256);\n\n  function getUsedBalance(address token) external view returns (uint256);\n\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);\n}"
    },
    "contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n  function feeTo() external view returns (address);\n\n  function feeToSetter() external view returns (address);\n\n  function migrator() external view returns (address);\n\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n  function allPairs(uint256) external view returns (address pair);\n\n  function allPairsLength() external view returns (uint256);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n\n  function setMigrator(address) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n\nlibrary SafeMath {\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require((z = x + y) >= x, \"ds-math-add-overflow\");\n  }\n\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require((z = x - y) <= x, \"ds-math-sub-underflow\");\n  }\n\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n  }\n\n\n  function add(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n    require((z = x + y) >= x, errorMessage);\n  }\n\n  function sub(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n    require((z = x - y) <= x, errorMessage);\n  }\n\n  function mul(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n    require(y == 0 || (z = x * y) / y == x, errorMessage);\n  }\n}"
    },
    "contracts/libraries/TokenInfo.sol": {
      "content": "pragma solidity >=0.5.0;\n\n\nlibrary TokenInfo {\n  function unpack(bytes32 tokenInfo) internal pure returns (address token, bool useSushiNext) {\n    assembly {\n      token := shr(8, tokenInfo)\n      useSushiNext := byte(31, tokenInfo)\n    }\n  }\n\n  function pack(address token, bool sushi) internal pure returns (bytes32 tokenInfo) {\n    assembly {\n      tokenInfo := or(\n        shl(8, token),\n        sushi\n      )\n    }\n  }\n\n  function readToken(bytes32 tokenInfo) internal pure returns (address token) {\n    assembly {\n      token := shr(8, tokenInfo)\n    }\n  }\n\n  function readSushi(bytes32 tokenInfo) internal pure returns (bool useSushiNext) {\n    assembly {\n      useSushiNext := byte(31, tokenInfo)\n    }\n  }\n}"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash cfedb1f55864dcf8cc0831fdd8ec18eb045b7fd1.\n\nSubject to the MIT license\n*************************************************************************************************/\n\n\nlibrary TransferHelper {\n  function safeApproveMax(address token, address to) internal {\n    safeApprove(token, to, type(uint256).max);\n  }\n\n  function safeUnapprove(address token, address to) internal {\n    safeApprove(token, to, 0);\n  }\n\n  function safeApprove(address token, address to, uint value) internal {\n    // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"TH:SA\");\n  }\n\n  function safeTransfer(address token, address to, uint value) internal {\n    // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"TH:ST\");\n  }\n\n  function safeTransferFrom(address token, address from, address to, uint value) internal {\n    // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"TH:STF\");\n  }\n\n  function safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(\"\");\n    require(success, \"TH:STE\");\n  }\n}"
    }
  }
}}