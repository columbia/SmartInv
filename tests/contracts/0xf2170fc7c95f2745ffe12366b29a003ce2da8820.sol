{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"CappedTimedCrowdsale.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./SafeMath.sol\";\nimport \"./TimedCrowdsale.sol\";\n\n/**\n * @title CappedCrowdsale\n * @dev Crowdsale with a limit for total contributions based on time.\n */\nabstract contract CappedTimedCrowdsale is TimedCrowdsale {\n    using SafeMath for uint256;\n\n    uint256 private _cap;\n\n    /**\n     * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\n     * @param capReceived Max amount of wei to be contributed\n     */\n    constructor (uint256 capReceived) {\n        require(capReceived \u003e 0, \"CappedCrowdsale: cap is 0\");\n        _cap = capReceived;\n    }\n\n    /**\n     * @return the cap of the crowdsale.\n     */\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    /*\n    ** Updates cap\n    */\n    function changeCap(uint256 newCap) internal {\n        _cap = newCap;\n    }\n\n    /**\n     * @dev Checks whether the period in which the crowdsale is open has already elapsed or if the cap has been reached.\n     */\n    function hasClosed() public view override virtual returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return capReached() || super.hasClosed();\n    }\n\n    /**\n     * @dev Checks whether the cap has been reached.\n     * @return Whether the cap was reached\n     */\n    function capReached() public view returns (bool) {\n        return weiRaised() \u003e= _cap;\n    }\n\n    /**\n     * @dev Extend parent behavior requiring purchase to respect the funding cap.\n     * @param beneficiary Token purchaser\n     * @param weiAmount Amount of wei contributed\n     */\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal override virtual view {\n        super._preValidatePurchase(beneficiary, weiAmount);\n        require(weiRaised().add(weiAmount) \u003c= _cap, \"CappedCrowdsale: cap exceeded\");\n    }\n}"},"ConditionalEscrow.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Escrow.sol\";\n\n/**\n * @title ConditionalEscrow\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\n * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.\n */\nabstract contract ConditionalEscrow is Escrow {\n    /**\n     * @dev Returns whether an address is allowed to withdraw their funds. To be\n     * implemented by derived contracts.\n     * @param payee The destination address of the funds.\n     */\n    function withdrawalAllowed(address payee) public view virtual returns (bool);\n\n    function withdraw(address payable payee) public virtual override {\n        require(withdrawalAllowed(payee), \"ConditionalEscrow: payee is not allowed to withdraw\");\n        super.withdraw(payee);\n    }\n}\n"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"CrowdsaleMint.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./LBCToken.sol\";\nimport \"./ReentrancyGuard.sol\";\n\n/**\n  * Based on OpenZeppelin\u0027s Crowdsale legacy contract\n */\ncontract CrowdsaleMint is Context, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // The token being sold\n    LBCToken private _token;\n\n    // Address where funds are collected\n    address payable private _wallet;\n\n    // How many token units a buyer gets per wei.\n    // The rate is the conversion between wei and the smallest and indivisible token unit.\n    // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\n    // 1 wei will give you 1 unit, or 0.001 TOK.\n    uint256 private _rate;\n\n    // Amount of wei raised\n    uint256 private _weiRaised;\n\n    /**\n     * Event for token purchase logging\n     * @param purchaser who paid for the tokens\n     * @param beneficiary who got the tokens\n     * @param value weis paid for purchase\n     * @param amount amount of tokens purchased\n     */\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    /**\n     * @param rateReceived Number of token units a buyer gets per wei\n     * @dev The rate is the conversion between wei and the smallest and indivisible\n     * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\n     * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\n     * @param walletReceived Address where collected funds will be forwarded to\n     * @param tokenReceived Address of the token being sold\n     */\n    constructor (uint256 rateReceived, address payable walletReceived, LBCToken tokenReceived) {\n        require(rateReceived \u003e 0, \"Crowdsale: rate is 0\");\n        require(walletReceived != address(0), \"Crowdsale: wallet is the zero address\");\n        require(address(tokenReceived) != address(0), \"Crowdsale: token is the zero address\");\n\n        _rate = rateReceived;\n        _wallet = walletReceived;\n        _token = tokenReceived;\n    }\n\n    /**\n     * @dev fallback function ***DO NOT OVERRIDE***\n     * Note that other contracts will transfer funds with a base gas stipend\n     * of 2300, which is not enough to call buyTokens. Consider calling\n     * buyTokens directly when purchasing tokens from a contract.\n     */\n    receive() external payable {\n        buyTokens(_msgSender());\n    }\n\n    fallback() external payable {\n        buyTokens(_msgSender());\n    }\n\n    /**\n     * @return the token being sold.\n     */\n    function token() public view returns (LBCToken) {\n        return _token;\n    }\n\n    function _changeToken(LBCToken newToken) internal {\n        _token = newToken;\n    }\n\n    /**\n     * @return the address where funds are collected.\n     */\n    function wallet() public view returns (address payable) {\n        return _wallet;\n    }\n\n    /**\n     * @return the number of token units a buyer gets per wei.\n     */\n    function rate() public view virtual returns (uint256) {\n        return _rate;\n    }\n\n    /**\n     * @return the amount of wei raised.\n     */\n    function weiRaised() public view returns (uint256) {\n        return _weiRaised;\n    }\n\n    /**\n     * @dev low level token purchase ***DO NOT OVERRIDE***\n     * This function has a non-reentrancy guard, so it shouldn\u0027t be called by\n     * another `nonReentrant` function.\n     * @param beneficiary Recipient of the token purchase\n     */\n    function buyTokens(address beneficiary) public nonReentrant payable {\n        uint256 weiAmount = msg.value;\n        _preValidatePurchase(beneficiary, weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = _getTokenAmount(weiAmount);\n\n        // update state\n        _weiRaised = _weiRaised.add(weiAmount);\n\n\n        _processPurchase(beneficiary, tokens);\n        emit TokensPurchased(_msgSender(), beneficiary, weiAmount, tokens);\n\n        _updatePurchasingState(beneficiary, weiAmount);\n\n        _forwardFunds();\n        _postValidatePurchase(beneficiary, weiAmount);\n    }\n\n    /**\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.\n     * Use `super` in contracts that inherit from Crowdsale to extend their validations.\n     * Example from CappedCrowdsale.sol\u0027s _preValidatePurchase method:\n     *     super._preValidatePurchase(beneficiary, weiAmount);\n     *     require(weiRaised().add(weiAmount) \u003c= cap);\n     * @param beneficiary Address performing the token purchase\n     * @param weiAmount Value in wei involved in the purchase\n     */\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal virtual view {\n        require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");\n        require(weiAmount != 0, \"Crowdsale: weiAmount is 0\");\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    }\n\n    /**\n     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid\n     * conditions are not met.\n     * @param beneficiary Address performing the token purchase\n     * @param weiAmount Value in wei involved in the purchase\n     */\n    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends\n     * its tokens.\n     * @param beneficiary Address performing the token purchase\n     * @param tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\n        require( _token.mint(beneficiary, tokenAmount) == true, \"Crowdsale: minting failed\");\n    }\n\n    /**\n     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn\u0027t necessarily emit/send\n     * tokens.\n     * @param beneficiary Address receiving the tokens\n     * @param tokenAmount Number of tokens to be purchased\n     */\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal virtual {\n        _deliverTokens(beneficiary, tokenAmount);\n    }\n\n    /**\n     * @dev Override for extensions that require an internal state to check for validity (current user contributions,\n     * etc.)\n     * @param beneficiary Address receiving the tokens\n     * @param weiAmount Value in wei involved in the purchase\n     */\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param weiAmount Value in wei to be converted into tokens\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n     */\n    function _getTokenAmount(uint256 weiAmount) internal virtual returns (uint256) {\n        return weiAmount.mul(_rate);\n    }\n\n    /**\n     * @dev Determines how ETH is stored/forwarded on purchases.\n     */\n    function _forwardFunds() virtual internal {\n        _wallet.transfer(msg.value);\n    }\n}"},"ERC20CappedUnburnable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ERC20PausableUnburnable.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\n */\nabstract contract ERC20CappedUnburnable is ERC20PausableUnburnable {\n    using SafeMath for uint256;\n\n    uint256 private _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor (uint256 capGiven) {\n        require(capGiven \u003e 0, \"ERC20Capped: cap is 0\");\n        _cap = capGiven;\n    }\n\n    /**\n     * @dev Returns the cap on the token\u0027s total supply.\n     */\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - minted tokens must not cause the total supply to go over the cap.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) { // When minting tokens\n            require(totalSupply().add(amount) \u003c= _cap, \"ERC20Capped: cap exceeded\");\n        }\n    }\n}\n"},"ERC20PausableUnburnable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ERC20Unburnable.sol\";\nimport \"./Pausable.sol\";\n\n/**\n * OpenZeppelin ERC20Pausable based on ERC20Unbernable\n */\nabstract contract ERC20PausableUnburnable is ERC20Unburnable, Pausable {\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20PausableUnburnable: token transfer while paused\");\n    }\n}"},"ERC20Unburnable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n  * OpenZeppelin Erc20 implementation without _burn private method and with cap mechanism\n */\ncontract ERC20Unburnable is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory nameGiven, string memory symbolGiven) {\n        _name = nameGiven;\n        _symbol = symbolGiven;\n        _decimals = 18;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20Unburnable: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20Unburnable: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20Unburnable: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20Unburnable: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20Unburnable: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20Unburnable: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20Unburnable: approve from the zero address\");\n        require(spender != address(0), \"ERC20Unburnable: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\n     }\n}\n"},"Escrow.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"./Address.sol\";\n\n /**\n  * @title Escrow\n  * @dev Base escrow contract, holds funds designated for a payee until they\n  * withdraw them.\n  *\n  * Intended usage: This contract (and derived escrow contracts) should be a\n  * standalone contract, that only interacts with the contract that instantiated\n  * it. That way, it is guaranteed that all Ether will be handled according to\n  * the `Escrow` rules, and there is no need to check for payable functions or\n  * transfers in the inheritance tree. The contract that uses the escrow as its\n  * payment method should be its owner, and provide public methods redirecting\n  * to the escrow\u0027s deposit and withdraw.\n  */\ncontract Escrow is Ownable {\n    using SafeMath for uint256;\n    using Address for address payable;\n\n    event Deposited(address indexed payee, uint256 weiAmount);\n    event Withdrawn(address indexed payee, uint256 weiAmount);\n\n    mapping(address =\u003e uint256) private _deposits;\n\n    function depositsOf(address payee) public view returns (uint256) {\n        return _deposits[payee];\n    }\n\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     * @param payee The destination address of the funds.\n     */\n    function deposit(address payee) public virtual payable onlyOwner {\n        uint256 amount = msg.value;\n        _deposits[payee] = _deposits[payee].add(amount);\n\n        emit Deposited(payee, amount);\n    }\n\n    /**\n     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the\n     * recipient.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     * @param payee The address whose funds will be withdrawn and transferred to.\n     */\n    function withdraw(address payable payee) public virtual onlyOwner {\n        uint256 payment = _deposits[payee];\n\n        _deposits[payee] = 0;\n\n        payee.sendValue(payment);\n\n        emit Withdrawn(payee, payment);\n    }\n}\n"},"FinalizableCrowdsale.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./SafeMath.sol\";\nimport \"./TimedCrowdsale.sol\";\n\n/**\n * @title FinalizableCrowdsale\n * @dev Extension of TimedCrowdsale with a one-off finalization action, where one\n * can do extra work after finishing.\n */\nabstract contract FinalizableCrowdsale is TimedCrowdsale {\n    using SafeMath for uint256;\n\n    bool private _finalized;\n\n    event CrowdsaleFinalized();\n\n    constructor () {\n        _finalized = false;\n    }\n\n    /**\n     * @return true if the crowdsale is finalized, false otherwise.\n     */\n    function finalized() public view returns (bool) {\n        return _finalized;\n    }\n\n    /**\n     * @dev Must be called after crowdsale ends, to do some extra finalization\n     * work. Calls the contract\u0027s finalization function.\n     */\n    function finalize() public {\n        require(!_finalized, \"FinalizableCrowdsale: already finalized\");\n        require(hasClosed(), \"FinalizableCrowdsale: not closed\");\n\n        _finalized = true;\n\n        _finalization();\n        emit CrowdsaleFinalized();\n    }\n\n    /**\n     * @dev Can be overridden to add finalization logic. The overriding function\n     * should call super._finalization() to ensure the chain of finalization is\n     * executed entirely.\n     */\n    function _finalization() internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}"},"HLBICO.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./SafeMath.sol\";\nimport \"./CappedTimedCrowdsale.sol\";\nimport \"./RefundPostdevCrowdsale.sol\";\n\n\n/**\n**  ICO Contract for the LBC crowdsale\n*/\ncontract HLBICO is CappedTimedCrowdsale, RefundablePostDeliveryCrowdsale {\n    using SafeMath for uint256;\n\n    /*\n    ** Global State\n    */\n    bool public initialized; // default : false\n\n    /*\n    ** Addresses\n    */\n    address public _deployingAddress; // should remain the same as deployer\u0027s address\n    address public _whitelistingAddress; // should be oracle\n    address public _reserveAddress; // should be deployer then humble reserve\n\n    /*\n    ** Events\n    */\n    event InitializedContract(address indexed changerAddress, address indexed whitelistingAddress);\n    event ChangedWhitelisterAddress(address indexed whitelisterAddress, address indexed changerAddress);\n    event ChangedReserveAddress(address indexed reserveAddress, address indexed changerAddress);\n    event ChangedDeployerAddress(address indexed deployerAddress, address indexed changerAddress);\n    event BlacklistedAdded(address indexed account);\n    event BlacklistedRemoved(address indexed account);\n    event UpdatedCaps(uint256 newGoal, uint256 newCap, uint256 newTranche, uint256 newMaxInvest, uint256 newRate, uint256 newRateCoef);\n\n    /*\n    ** Attrs\n    */\n    uint256 private _currentRate;\n    uint256 private _rateCoef;\n    mapping(address =\u003e bool) private _blacklistedAddrs;\n    mapping(address =\u003e uint256) private _investmentAddrs;\n    uint256 private _weiMaxInvest;\n    uint256 private _etherTranche;\n    uint256 private _currentWeiTranche; // Holds the current invested value for a tranche\n    uint256 private _deliverToReserve;\n    uint256 private _minimumInvest;\n\n    /*\n    * initialRateReceived : Number of token units a buyer gets per wei for the first investment slice. Should be 5000 (diving by 1000 for 3 decimals).\n    * walletReceived : Wallet that will get the invested eth at the end of the crowdsale\n    * tokenReceived : Address of the LBC token being sold\n    * openingTimeReceived : Starting date of the ICO\n    * closingtimeReceived : Ending date of the ICO\n    * capReceived : Max amount of wei to be contributed\n    * goalReceived : Funding goal\n    * etherMaxInvestReceived : Maximum ether that can be invested\n    */\n    constructor(uint256 initialRateReceived,\n        uint256 rateCoefficientReceived,\n        address payable walletReceived,\n        LBCToken tokenReceived,\n        uint256 openingTimeReceived,\n        uint256 closingTimeReceived,\n        uint256 capReceived,\n        uint256 goalReceived)\n        CrowdsaleMint(initialRateReceived, walletReceived, tokenReceived)\n        TimedCrowdsale(openingTimeReceived, closingTimeReceived)\n        CappedTimedCrowdsale(capReceived)\n        RefundableCrowdsale(goalReceived) {\n        _deployingAddress = msg.sender;\n        _etherTranche = 250000000000000000000; // 300000€; For eth = 1200 €\n        _weiMaxInvest = 8340000000000000000; // 10008€; for eth = 1200 €\n        _currentRate = initialRateReceived;\n        _rateCoef = rateCoefficientReceived;\n        _currentWeiTranche = 0;\n        _deliverToReserve = 0;\n        _minimumInvest = 1000000000000000; // 1.20€; for eth = 1200€\n    }\n\n    /*\n    ** Initializes the contract address and affects addresses to their roles.\n    */\n    function init(\n        address whitelistingAddress,\n        address reserveAddress\n    )\n    public\n    isNotInitialized\n    onlyDeployingAddress\n    {\n        require(whitelistingAddress != address(0), \"HLBICO: whitelistingAddress cannot be 0x\");\n        require(reserveAddress != address(0), \"HLBICO: reserveAddress cannot be 0x\");\n\n        _whitelistingAddress = whitelistingAddress;\n        _reserveAddress = reserveAddress;\n        initialized = true;\n\n        emit InitializedContract(_msgSender(), whitelistingAddress);\n    }\n\n    /**\n     * @dev Returns the rate of tokens per wei at the present time and computes rate depending on tranche.\n     * @param weiAmount The value in wei to be converted into tokens\n     * @return The number of tokens a buyer gets per wei for a given tranche\n     */\n    function _getCustomAmount(uint256 weiAmount) internal returns (uint256) {\n        if (!isOpen()) {\n            return 0;\n        }\n\n        uint256 calculatedAmount = 0;\n\n        _currentWeiTranche = _currentWeiTranche.add(weiAmount);\n\n        if (_currentWeiTranche \u003e _etherTranche) {\n            _currentWeiTranche = _currentWeiTranche.sub(_etherTranche);\n\n            //If we updated the tranche manually to a smaller one\n            uint256 manualSkew = weiAmount.sub(_currentWeiTranche);\n\n            if (manualSkew \u003e= 0) {\n                calculatedAmount = calculatedAmount.add(weiAmount.sub(_currentWeiTranche).mul(rate()));\n                _currentRate -= _rateCoef; // coefficient for 35 tokens reduction for each tranche\n                calculatedAmount = calculatedAmount.add(_currentWeiTranche.mul(rate()));\n            }\n            //If there is a skew between invested wei and calculated wei for a tranche\n            else {\n                _currentRate -= _rateCoef; // coefficient for 35 tokens reduction for each tranche\n                calculatedAmount = calculatedAmount.add(weiAmount.mul(rate()));\n            }\n        }\n        else\n            calculatedAmount = calculatedAmount.add(weiAmount.mul(rate()));\n\n        uint256 participationAmount = calculatedAmount.mul(5).div(100);\n\n        calculatedAmount = calculatedAmount.sub(participationAmount);\n        _deliverToReserve = _deliverToReserve.add(participationAmount);\n\n        return calculatedAmount;\n    }\n\n    /*\n    ** Adjusts all parameters influenced by Ether value based on a percentage coefficient\n    ** coef is based on 4 digits for decimal representation with 1 precision\n    ** i.e : 934 -\u003e 93.4%; 1278 -\u003e 127.8%\n    */\n    function adjustEtherValue(uint256 coef)\n    public\n    onlyDeployingAddress {\n        require(coef \u003e 0 \u0026\u0026 coef \u003c 10000, \"HLBICO: coef isn\u0027t within range of authorized values\");\n\n        uint256 baseCoef = 1000;\n\n        changeGoal(goal().mul(coef).div(1000));\n        changeCap(cap().mul(coef).div(1000));\n        _etherTranche = _etherTranche.mul(coef).div(1000);\n        _weiMaxInvest = _weiMaxInvest.mul(coef).div(1000);\n        \n        if (coef \u003e 1000) {\n            coef = coef.sub(1000);\n            _currentRate = _currentRate.sub(_currentRate.mul(coef).div(1000));\n            _rateCoef = _rateCoef.sub(_rateCoef.mul(coef).div(1000));\n        } else {\n            coef = baseCoef.sub(coef);\n            _currentRate = _currentRate.add(_currentRate.mul(coef).div(1000));\n            _rateCoef = _rateCoef.add(_rateCoef.mul(coef).div(1000));\n        }\n\n        emit UpdatedCaps(goal(), cap(), _etherTranche, _weiMaxInvest, _currentRate, _rateCoef);\n    }\n\n    function rate() public view override returns (uint256) {\n       return _currentRate;\n    }\n\n    function getNextRate() public view returns (uint256) {\n        return _currentRate.sub(_rateCoef);\n    }\n\n    /*\n    ** Changes the address of the token contract. Must only be callable by deployer\n    */\n    function changeToken(LBCToken newToken)\n    public\n    onlyDeployingAddress\n    {\n        _changeToken(newToken);\n    }\n\n    /*\n    ** Changes the address with whitelisting role and can only be called by deployer\n    */\n    function changeWhitelister(address newWhitelisterAddress)\n    public\n    onlyDeployingAddress\n    {\n        _whitelistingAddress = newWhitelisterAddress;\n        emit ChangedWhitelisterAddress(newWhitelisterAddress, _msgSender());\n    }\n    \n    /*\n    ** Changes the address with deployer role and can only be called by deployer\n    */\n    function changeDeployer(address newDeployerAddress)\n    public\n    onlyDeployingAddress\n    {\n        _deployingAddress = newDeployerAddress;\n        emit ChangedDeployerAddress(_deployingAddress, _msgSender());\n    }\n\n    /*\n    ** Changes the address with pause role and can only be called by deployer\n    */\n    function changeReserveAddress(address newReserveAddress)\n    public\n    onlyDeployingAddress\n    {\n        _reserveAddress = newReserveAddress;\n        emit ChangedReserveAddress(newReserveAddress, _msgSender());\n    }\n\n    /**\n     * @dev Escrow finalization task, called when finalize() is called.\n     */\n    function _finalization() override virtual internal {\n        // Mints the 5% participation and sends it to humblereserve\n        if (goalReached()) {\n            _deliverTokens(_reserveAddress, _deliverToReserve);\n        }\n\n        super._finalization();\n    }\n\n    /*\n    ** Checks if an adress has been blacklisted before letting them withdraw their funds\n    */\n    function withdrawTokens(address beneficiary) override virtual public {\n        require(!isBlacklisted(beneficiary), \"HLBICO: account is blacklisted\");\n\n        super.withdrawTokens(beneficiary);\n    }\n\n    /**\n     * @dev Overrides parent method taking into account variable rate.\n     * @param weiAmount The value in wei to be converted into tokens\n     * @return The number of tokens _weiAmount wei will buy at present time\n     */\n    function _getTokenAmount(uint256 weiAmount) internal override returns (uint256) {\n       return _getCustomAmount(weiAmount);\n    }\n\n    function _forwardFunds() internal override(CrowdsaleMint, RefundablePostDeliveryCrowdsale) {\n        RefundablePostDeliveryCrowdsale._forwardFunds();\n    }\n\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal override(TimedCrowdsale, CappedTimedCrowdsale) view {\n        require(weiAmount \u003e= _minimumInvest, \"HLBICO: Investment must be greater than or equal to 0.001 eth\");\n        _dontExceedAmount(beneficiary, weiAmount);\n        CappedTimedCrowdsale._preValidatePurchase(beneficiary, weiAmount);\n    }\n\n    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal override {\n        require(beneficiary != address(0), \"HLBICO: _postValidatePurchase benificiary is the zero address\");\n\n        _investmentAddrs[beneficiary] = _investmentAddrs[beneficiary].add(weiAmount);        \n    }\n\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal override(CrowdsaleMint, RefundablePostDeliveryCrowdsale) {\n        RefundablePostDeliveryCrowdsale._processPurchase(beneficiary, tokenAmount);\n    }\n\n    function hasClosed() public view override(TimedCrowdsale, CappedTimedCrowdsale) returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return CappedTimedCrowdsale.hasClosed();\n    }\n\n    function etherTranche() public view returns (uint256) {\n        return _etherTranche;\n    }\n\n    function maxInvest() public view returns (uint256) {\n        return _weiMaxInvest;\n    }\n\n    function addBlacklisted(address account) public onlyWhitelistingAddress {\n        _addBlacklisted(account);\n    }\n\n    function removeBlacklisted(address account) public onlyWhitelistingAddress {\n        _removeBlacklisted(account);\n    }\n\n    function isBlacklisted(address account) public view returns (bool) {\n        require(account != address(0), \"HLBICO: account is zero address\");\n        return _blacklistedAddrs[account];\n    }\n\n    function _addBlacklisted(address account) internal {\n        require(!isBlacklisted(account), \"HLBICO: account already blacklisted\");\n        _blacklistedAddrs[account] = true;\n        emit BlacklistedAdded(account);\n    }\n\n    function _removeBlacklisted(address account) internal {\n        require(isBlacklisted(account), \"HLBICO: account is not blacklisted\");\n        _blacklistedAddrs[account] = true;\n        emit BlacklistedRemoved(account);\n    }\n\n    function _dontExceedAmount(address beneficiary, uint256 weiAmount) internal view {\n        require(_investmentAddrs[beneficiary].add(weiAmount) \u003c= _weiMaxInvest,\n          \"HLBICO: Cannot invest more than KYC limit.\");\n    }\n\n    modifier onlyWhitelistingAddress() {\n        require(_msgSender() == _whitelistingAddress, \"HLBICO: caller does not have the Whitelisted role\");\n        _;\n    }\n\n    /*\n    ** Checks if the contract hasn\u0027t already been initialized\n    */\n    modifier isNotInitialized() {\n        require(initialized == false, \"HLBICO: contract is already initialized.\");\n        _;\n    }\n\n    /*\n    ** Checks if the sender is the minter controller address\n    */\n    modifier onlyDeployingAddress() {\n        require(msg.sender == _deployingAddress, \"HLBICO: only the deploying address can call this method.\");\n        _;\n    }\n\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"LBCToken.sol":{"content":"// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\nimport \"./ERC20CappedUnburnable.sol\";\nimport \"./ERC20Unburnable.sol\";\nimport \"./ERC20PausableUnburnable.sol\";\n\ncontract LBCToken is Context, ERC20CappedUnburnable {\n\n    /*\n    ** Global State\n    */\n    bool public initialized; // default : false\n\n    /*\n    ** Addresses\n    */\n    address public _deployingAddress; // should be changed to multisig contract address\n    address public _pauserAddress; // should be deployer\u0027s\n    address public _minterAddress; // should be ico\u0027s address then poe\u0027s\n    address public _reserveAddress; // should be multisig then humble reserve\n\n    /*\n    ** Events\n    */\n    event InitializedContract(address indexed reserveAddress);\n    event ChangedMinterAddress(address indexed minterAddress, address indexed changerAddress);\n    event ChangedPauserAddress(address indexed pauserAddress, address indexed changerAddress);\n    event ChangedReserveAddress(address indexed reserveAddress, address indexed changerAddress);\n    event ChangedDeployerAddress(address indexed deployerAddress, address indexed changerAddress);\n\n\n    constructor(\n        string memory name,\n        string memory symbol\n    )\n    ERC20Unburnable(name, symbol)\n    ERC20CappedUnburnable(300000000000000000000000000)\n    {\n        _deployingAddress = msg.sender;\n    }\n\n    /*\n    ** Initializes the contract address and affects addresses to their roles.\n    */\n    function init(\n        address minterAddress,\n        address pauserAddress,\n        address reserveAddress\n    )\n    public\n    isNotInitialized\n    onlyDeployingAddress\n    {\n        require(minterAddress != address(0), \"_minterAddress cannot be 0x\");\n        require(pauserAddress != address(0), \"_pauserAddress cannot be 0x\");\n        require(reserveAddress != address(0), \"_reserveAddress cannot be 0x\");\n\n        _minterAddress = minterAddress;\n        _pauserAddress = pauserAddress;\n        _reserveAddress = reserveAddress;\n\n        initialized = true;\n\n        emit InitializedContract(reserveAddress);\n    }\n\n    /*\n    ** Mint function that can only be called by minter address and mints a specified amount and sends it to an address\n    */\n    function mint(address to, uint256 amount)\n    public\n    onlyMinterAddress\n    virtual\n    returns (bool) {\n       _mint(to, amount);\n       return true;\n    }\n\n    /*\n    ** Freeze function that stops transactions and can only be called by pauser address\n    */\n    function pause()\n    public\n    onlyPauserAddress\n    virtual {\n        _pause();\n    }\n\n    /*\n    ** Unfreeze function that resumes transactions and can only be called by pauser address\n    */\n    function unpause()\n    public\n    onlyPauserAddress\n    virtual {\n        _unpause();\n    }\n\n    /*\n    ** Changes the address with pause role and can only be called by previous pauser address\n    */\n    function changePauser(address newPauserAddress)\n    public\n    onlyDeployingAddress\n    whenNotPaused\n    {\n        _pauserAddress = newPauserAddress;\n        emit ChangedPauserAddress(newPauserAddress, _msgSender());\n    }\n\n    /*\n    ** Changes the address with minter role and can only be called by previous minter address\n    */\n    function changeMinter(address newMinterAddress)\n    public\n    onlyDeployingAddress\n    whenNotPaused\n    {\n        _minterAddress = newMinterAddress;\n        emit ChangedMinterAddress(newMinterAddress, _msgSender());\n    }\n\n    /*\n    ** Changes the address with deployer role and can only be called by deployer\n    */\n    function changeDeployer(address newDeployerAddress)\n    public\n    onlyDeployingAddress\n    {\n        _deployingAddress = newDeployerAddress;\n        emit ChangedDeployerAddress(_deployingAddress, _msgSender());\n    }\n\n    /*\n    ** Checks if the sender is the minter controller address\n    */\n    modifier onlyDeployingAddress() {\n        require(msg.sender == _deployingAddress, \"Only the deploying address can call this method.\");\n        _;\n    }\n\n    /*\n    ** Checks if the sender is the minter controller address\n    */\n    modifier onlyMinterAddress() {\n        require(msg.sender == _minterAddress, \"Only the minter address can call this method.\");\n        _;\n    }\n\n    /*\n    ** Checks if the sender is the pauser controller address\n    */\n    modifier onlyPauserAddress() {\n        require(msg.sender == _pauserAddress, \"Only the pauser address can call this method.\");\n        _;\n    }\n\n    /*\n    ** Checks if the contract hasn\u0027t already been initialized\n    */\n    modifier isNotInitialized() {\n        require(initialized == false, \"Contract is already initialized.\");\n        _;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20CappedUnburnable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"Pausable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"},"PostDeliveryCrowdsale.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./TimedCrowdsale.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Secondary.sol\";\nimport \"./IERC20.sol\";\n\n/**\n * @title PostDeliveryCrowdsale\n * @dev Crowdsale that locks tokens from withdrawal until it ends.\n */\nabstract contract PostDeliveryCrowdsale is TimedCrowdsale {\n    using SafeMath for uint256;\n\n    mapping(address =\u003e uint256) private _balances;\n    __unstable__TokenVault private _vault;\n\n    constructor() {\n        _vault = new __unstable__TokenVault();\n    }\n\n    /**\n     * @dev Withdraw tokens only after crowdsale ends.\n     * @param beneficiary Whose tokens will be withdrawn.\n     */\n    function withdrawTokens(address beneficiary) public virtual {\n        require(hasClosed(), \"PostDeliveryCrowdsale: not closed\");\n        uint256 amount = _balances[beneficiary];\n        require(amount \u003e 0, \"PostDeliveryCrowdsale: beneficiary is not due any tokens\");\n\n        _balances[beneficiary] = 0;\n        _vault.transfer(token(), beneficiary, amount);\n    }\n\n    /**\n     * @return the balance of an account.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev Overrides parent by storing due balances, and delivering tokens to the vault instead of the end user. This\n     * ensures that the tokens will be available by the time they are withdrawn (which may not be the case if\n     * `_deliverTokens` was called later).\n     * @param beneficiary Token purchaser\n     * @param tokenAmount Amount of tokens purchased\n     */\n    function _processPurchase(address beneficiary, uint256 tokenAmount) override virtual internal {\n        _balances[beneficiary] = _balances[beneficiary].add(tokenAmount);\n        _deliverTokens(address(_vault), tokenAmount);\n    }\n}\n\n/**\n * @title __unstable__TokenVault\n * @dev Similar to an Escrow for tokens, this contract allows its primary account to spend its tokens as it sees fit.\n * This contract is an internal helper for PostDeliveryCrowdsale, and should not be used outside of this context.\n */\n// solhint-disable-next-line contract-name-camelcase\ncontract __unstable__TokenVault is Secondary {\n    function transfer(IERC20 token, address to, uint256 amount) public onlyPrimary {\n        token.transfer(to, amount);\n    }\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\u0027s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\u0027s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\u0027s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"RefundableCrowdsale.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./FinalizableCrowdsale.sol\";\nimport \"./RefundEscrow.sol\";\n\n/**\n * @title RefundableCrowdsale\n * @dev Extension of `FinalizableCrowdsale` contract that adds a funding goal, and the possibility of users\n * getting a refund if goal is not met.\n *\n * Deprecated, use `RefundablePostDeliveryCrowdsale` instead. Note that if you allow tokens to be traded before the goal\n * is met, then an attack is possible in which the attacker purchases tokens from the crowdsale and when they sees that\n * the goal is unlikely to be met, they sell their tokens (possibly at a discount). The attacker will be refunded when\n * the crowdsale is finalized, and the users that purchased from them will be left with worthless tokens.\n */\nabstract contract RefundableCrowdsale is Context, FinalizableCrowdsale {\n    using SafeMath for uint256;\n\n    // minimum amount of funds to be raised in weis\n    uint256 private _goal;\n\n    // refund escrow used to hold funds while crowdsale is running\n    RefundEscrow private _escrow;\n\n    /**\n     * @dev Constructor, creates RefundEscrow.\n     * @param goalReceived Funding goal\n     */\n    constructor (uint256 goalReceived) {\n        require(goalReceived \u003e 0, \"RefundableCrowdsale: goal is 0\");\n        _escrow = new RefundEscrow(wallet());\n        _goal = goalReceived;\n    }\n\n    /**\n     * @return minimum amount of funds to be raised in wei.\n     */\n    function goal() public view returns (uint256) {\n        return _goal;\n    }\n\n    /**\n    ** Updates goal\n    */\n    function changeGoal(uint256 newGoal) internal {\n        _goal = newGoal;\n    }\n\n    /**\n     * @dev Investors can claim refunds here if crowdsale is unsuccessful.\n     * @param refundee Whose refund will be claimed.\n     */\n    function claimRefund(address payable refundee) public {\n        require(finalized(), \"RefundableCrowdsale: not finalized\");\n        require(!goalReached(), \"RefundableCrowdsale: goal reached\");\n\n        _escrow.withdraw(refundee);\n    }\n\n    /**\n     * @dev Checks whether funding goal was reached.\n     * @return Whether funding goal was reached\n     */\n    function goalReached() public view returns (bool) {\n        return weiRaised() \u003e= _goal;\n    }\n\n    /**\n     * @dev Escrow finalization task, called when finalize() is called.\n     */\n    function _finalization() override virtual internal {\n        if (goalReached()) {\n            _escrow.close();\n            _escrow.beneficiaryWithdraw();\n        } else {\n            _escrow.enableRefunds();\n        }\n\n        super._finalization();\n    }\n\n    /**\n     * @dev Overrides Crowdsale fund forwarding, sending funds to escrow.\n     */\n    function _forwardFunds() override virtual internal {\n        _escrow.deposit{value : msg.value}(_msgSender());\n    }\n}"},"RefundEscrow.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ConditionalEscrow.sol\";\n\n/**\n * @title RefundEscrow\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple\n * parties.\n * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.\n * @dev The owner account (that is, the contract that instantiates this\n * contract) may deposit, close the deposit period, and allow for either\n * withdrawal by the beneficiary, or refunds to the depositors. All interactions\n * with `RefundEscrow` will be made through the owner contract.\n */\ncontract RefundEscrow is ConditionalEscrow {\n    enum State { Active, Refunding, Closed }\n\n    event RefundsClosed();\n    event RefundsEnabled();\n\n    State private _state;\n    address payable private _beneficiary;\n\n    /**\n     * @dev Constructor.\n     * @param beneficiaryReceived The beneficiary of the deposits.\n     */\n    constructor (address payable beneficiaryReceived) {\n        require(beneficiaryReceived != address(0), \"RefundEscrow: beneficiary is the zero address\");\n        _beneficiary = beneficiaryReceived;\n        _state = State.Active;\n    }\n\n    /**\n     * @return The current state of the escrow.\n     */\n    function state() public view returns (State) {\n        return _state;\n    }\n\n    /**\n     * @return The beneficiary of the escrow.\n     */\n    function beneficiary() public view returns (address) {\n        return _beneficiary;\n    }\n\n    /**\n     * @dev Stores funds that may later be refunded.\n     * @param refundee The address funds will be sent to if a refund occurs.\n     */\n    function deposit(address refundee) public payable virtual override {\n        require(_state == State.Active, \"RefundEscrow: can only deposit while active\");\n        super.deposit(refundee);\n    }\n\n    /**\n     * @dev Allows for the beneficiary to withdraw their funds, rejecting\n     * further deposits.\n     */\n    function close() public onlyOwner virtual {\n        require(_state == State.Active, \"RefundEscrow: can only close while active\");\n        _state = State.Closed;\n        emit RefundsClosed();\n    }\n\n    /**\n     * @dev Allows for refunds to take place, rejecting further deposits.\n     */\n    function enableRefunds() public onlyOwner virtual {\n        require(_state == State.Active, \"RefundEscrow: can only enable refunds while active\");\n        _state = State.Refunding;\n        emit RefundsEnabled();\n    }\n\n    /**\n     * @dev Withdraws the beneficiary\u0027s funds.\n     */\n    function beneficiaryWithdraw() public virtual {\n        require(_state == State.Closed, \"RefundEscrow: beneficiary can only withdraw while closed\");\n        _beneficiary.transfer(address(this).balance);\n    }\n\n    /**\n     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a\n     * \u0027payee\u0027 argument, but we ignore it here since the condition is global, not per-payee.\n     */\n    function withdrawalAllowed(address) public view override returns (bool) {\n        return _state == State.Refunding;\n    }\n}\n"},"RefundPostdevCrowdsale.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\nimport \"./RefundableCrowdsale.sol\";\nimport \"./PostDeliveryCrowdsale.sol\";\n\n\n/**\n * @title RefundablePostDeliveryCrowdsale\n * @dev Extension of RefundableCrowdsale contract that only delivers the tokens\n * once the crowdsale has closed and the goal met, preventing refunds to be issued\n * to token holders.\n */\nabstract contract RefundablePostDeliveryCrowdsale is RefundableCrowdsale, PostDeliveryCrowdsale {\n\n    function _forwardFunds() internal override(CrowdsaleMint,RefundableCrowdsale) virtual {\n        RefundableCrowdsale._forwardFunds();\n    }\n\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal override(CrowdsaleMint, PostDeliveryCrowdsale) virtual {\n        PostDeliveryCrowdsale._processPurchase(beneficiary, tokenAmount);\n    }\n\n    function withdrawTokens(address beneficiary) override virtual public {\n        require(finalized(), \"RefundablePostDeliveryCrowdsale: not finalized\");\n        require(goalReached(), \"RefundablePostDeliveryCrowdsale: goal not reached\");\n\n        super.withdrawTokens(beneficiary);\n    }\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \u0027safeIncreaseAllowance\u0027 and \u0027safeDecreaseAllowance\u0027\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\u0027s return data size checking mechanism, since\n        // we\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"Secondary.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n/**\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\n */\nabstract contract Secondary is Context {\n    address private _primary;\n\n    /**\n     * @dev Emitted when the primary contract changes.\n     */\n    event PrimaryTransferred(\n        address recipient\n    );\n\n    /**\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _primary = msgSender;\n        emit PrimaryTransferred(msgSender);\n    }\n\n    /**\n     * @dev Reverts if called from any account other than the primary.\n     */\n    modifier onlyPrimary() {\n        require(_msgSender() == _primary, \"Secondary: caller is not the primary account\");\n        _;\n    }\n\n    /**\n     * @return the address of the primary.\n     */\n    function primary() public view returns (address) {\n        return _primary;\n    }\n\n    /**\n     * @dev Transfers contract to a new primary.\n     * @param recipient The address of new primary.\n     */\n    function transferPrimary(address recipient) public onlyPrimary {\n        require(recipient != address(0), \"Secondary: new primary is the zero address\");\n        _primary = recipient;\n        emit PrimaryTransferred(recipient);\n    }\n}"},"TimedCrowdsale.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./SafeMath.sol\";\nimport \"./CrowdsaleMint.sol\";\n\n/**\n  * Based on OpenZeppelin\u0027s TimedCrowdsale legacy contract\n */\nabstract contract TimedCrowdsale is CrowdsaleMint {\n    using SafeMath for uint256;\n\n    uint256 private _openingTime;\n    uint256 private _closingTime;\n\n    /**\n     * Event for crowdsale extending\n     * @param newClosingTime new closing time\n     * @param prevClosingTime old closing time\n     */\n    event TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime);\n\n    /**\n     * @dev Reverts if not in crowdsale time range.\n     */\n    modifier onlyWhileOpen {\n        require(isOpen(), \"TimedCrowdsale: not open\");\n        _;\n    }\n\n    /**\n     * @dev Constructor, takes crowdsale opening and closing times.\n     * @param openingTimeReceived Crowdsale opening time\n     * @param closingTimeReceived Crowdsale closing time\n     */\n    constructor (uint256 openingTimeReceived, uint256 closingTimeReceived) {\n        // solhint-disable-next-line not-rely-on-time\n        require(openingTimeReceived \u003e= block.timestamp, \"TimedCrowdsale: opening time is before current time\");\n        // solhint-disable-next-line max-line-length\n        require(closingTimeReceived \u003e openingTimeReceived, \"TimedCrowdsale: opening time is not before closing time\");\n\n        _openingTime = openingTimeReceived;\n        _closingTime = closingTimeReceived;\n    }\n\n    /**\n     * @return the crowdsale opening time.\n     */\n    function openingTime() public view returns (uint256) {\n        return _openingTime;\n    }\n\n    /**\n     * @return the crowdsale closing time.\n     */\n    function closingTime() public view returns (uint256) {\n        return _closingTime;\n    }\n\n    /**\n     * @return true if the crowdsale is open, false otherwise.\n     */\n    function isOpen() public view returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp \u003e= _openingTime \u0026\u0026 block.timestamp \u003c= _closingTime;\n    }\n\n    /**\n     * @dev Checks whether the period in which the crowdsale is open has already elapsed.\n     * @return Whether crowdsale period has elapsed\n     */\n    function hasClosed() public view virtual returns (bool) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp \u003e _closingTime;\n    }\n\n    /**\n     * @dev Extend parent behavior requiring to be within contributing period.\n     * @param beneficiary Token purchaser\n     * @param weiAmount Amount of wei contributed\n     */\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal override virtual onlyWhileOpen view {\n        super._preValidatePurchase(beneficiary, weiAmount);\n    }\n\n    /**\n     * @dev Extend crowdsale.\n     * @param newClosingTime Crowdsale closing time\n     */\n    function _extendTime(uint256 newClosingTime) internal {\n        require(!hasClosed(), \"TimedCrowdsale: already closed\");\n        // solhint-disable-next-line max-line-length\n        require(newClosingTime \u003e _closingTime, \"TimedCrowdsale: new closing time is before current closing time\");\n\n        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);\n        _closingTime = newClosingTime;\n    }\n}"}}