{{
  "language": "Solidity",
  "sources": {
    "contracts/KeeperBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ncontract KeeperBase {\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution()\n    internal\n    view\n  {\n    require(tx.origin == address(0), \"only for simulated backend\");\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute()\n  {\n    preventExecution();\n    _;\n  }\n\n}\n"
    },
    "contracts/KeeperRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/contracts/src/v0.7/interfaces/LinkTokenInterface.sol\";\nimport \"@chainlink/contracts/src/v0.7/vendor/SafeMathChainlink.sol\";\nimport \"./vendor/Owned.sol\";\nimport \"./vendor/Address.sol\";\nimport \"./vendor/Pausable.sol\";\nimport \"./vendor/ReentrancyGuard.sol\";\nimport \"./vendor/SignedSafeMath.sol\";\nimport \"./SafeMath96.sol\";\nimport \"./KeeperBase.sol\";\nimport \"./KeeperCompatibleInterface.sol\";\nimport \"./KeeperRegistryInterface.sol\";\n\n/**\n  * @notice Registry for adding work for Chainlink Keepers to perform on client\n  * contracts. Clients must support the Upkeep interface.\n  */\ncontract KeeperRegistry is\n  Owned,\n  KeeperBase,\n  ReentrancyGuard,\n  Pausable,\n  KeeperRegistryExecutableInterface\n{\n  using Address for address;\n  using SafeMathChainlink for uint256;\n  using SafeMath96 for uint96;\n  using SignedSafeMath for int256;\n\n  address constant private ZERO_ADDRESS = address(0);\n  address constant private IGNORE_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n  bytes4 constant private CHECK_SELECTOR = KeeperCompatibleInterface.checkUpkeep.selector;\n  bytes4 constant private PERFORM_SELECTOR = KeeperCompatibleInterface.performUpkeep.selector;\n  uint256 constant private CALL_GAS_MAX = 2_500_000;\n  uint256 constant private CALL_GAS_MIN = 2_300;\n  uint256 constant private CANCELATION_DELAY = 50;\n  uint256 constant private CUSHION = 5_000;\n  uint256 constant private REGISTRY_GAS_OVERHEAD = 80_000;\n  uint256 constant private PPB_BASE = 1_000_000_000;\n  uint64 constant private UINT64_MAX = 2**64 - 1;\n  uint96 constant private LINK_TOTAL_SUPPLY = 1e27;\n\n  uint256 private s_upkeepCount;\n  uint256[] private s_canceledUpkeepList;\n  address[] private s_keeperList;\n  mapping(uint256 => Upkeep) private s_upkeep;\n  mapping(address => KeeperInfo) private s_keeperInfo;\n  mapping(address => address) private s_proposedPayee;\n  mapping(uint256 => bytes) private s_checkData;\n  Config private s_config;\n  int256 private s_fallbackGasPrice;  // not in config object for gas savings\n  int256 private s_fallbackLinkPrice; // not in config object for gas savings\n\n  LinkTokenInterface public immutable LINK;\n  AggregatorV3Interface public immutable LINK_ETH_FEED;\n  AggregatorV3Interface public immutable FAST_GAS_FEED;\n\n  address private s_registrar;\n\n  struct Upkeep {\n    address target;\n    uint32 executeGas;\n    uint96 balance;\n    address admin;\n    uint64 maxValidBlocknumber;\n    address lastKeeper;\n  }\n\n  struct KeeperInfo {\n    address payee;\n    uint96 balance;\n    bool active;\n  }\n\n  struct Config {\n    uint32 paymentPremiumPPB;\n    uint24 blockCountPerTurn;\n    uint32 checkGasLimit;\n    uint24 stalenessSeconds;\n    uint16 gasCeilingMultiplier;\n  }\n\n  struct PerformParams {\n    address from;\n    uint256 id;\n    bytes performData;\n  }\n\n  event UpkeepRegistered(\n    uint256 indexed id,\n    uint32 executeGas,\n    address admin\n  );\n  event UpkeepPerformed(\n    uint256 indexed id,\n    bool indexed success,\n    address indexed from,\n    uint96 payment,\n    bytes performData\n  );\n  event UpkeepCanceled(\n    uint256 indexed id,\n    uint64 indexed atBlockHeight\n  );\n  event FundsAdded(\n    uint256 indexed id,\n    address indexed from,\n    uint96 amount\n  );\n  event FundsWithdrawn(\n    uint256 indexed id,\n    uint256 amount,\n    address to\n  );\n  event ConfigSet(\n    uint32 paymentPremiumPPB,\n    uint24 blockCountPerTurn,\n    uint32 checkGasLimit,\n    uint24 stalenessSeconds,\n    uint16 gasCeilingMultiplier,\n    int256 fallbackGasPrice,\n    int256 fallbackLinkPrice\n  );\n  event KeepersUpdated(\n    address[] keepers,\n    address[] payees\n  );\n  event PaymentWithdrawn(\n    address indexed keeper,\n    uint256 indexed amount,\n    address indexed to,\n    address payee\n  );\n  event PayeeshipTransferRequested(\n    address indexed keeper,\n    address indexed from,\n    address indexed to\n  );\n  event PayeeshipTransferred(\n    address indexed keeper,\n    address indexed from,\n    address indexed to\n  );\n  event RegistrarChanged(\n    address indexed from,\n    address indexed to\n  );\n  /**\n   * @param link address of the LINK Token\n   * @param linkEthFeed address of the LINK/ETH price feed\n   * @param fastGasFeed address of the Fast Gas price feed\n   * @param paymentPremiumPPB payment premium rate oracles receive on top of\n   * being reimbursed for gas, measured in parts per billion\n   * @param blockCountPerTurn number of blocks each oracle has during their turn to\n   * perform upkeep before it will be the next keeper's turn to submit\n   * @param checkGasLimit gas limit when checking for upkeep\n   * @param stalenessSeconds number of seconds that is allowed for feed data to\n   * be stale before switching to the fallback pricing\n   * @param gasCeilingMultiplier multiplier to apply to the fast gas feed price\n   * when calculating the payment ceiling for keepers\n   * @param fallbackGasPrice gas price used if the gas price feed is stale\n   * @param fallbackLinkPrice LINK price used if the LINK price feed is stale\n   */\n  constructor(\n    address link,\n    address linkEthFeed,\n    address fastGasFeed,\n    uint32 paymentPremiumPPB,\n    uint24 blockCountPerTurn,\n    uint32 checkGasLimit,\n    uint24 stalenessSeconds,\n    uint16 gasCeilingMultiplier,\n    int256 fallbackGasPrice,\n    int256 fallbackLinkPrice\n  ) {\n    LINK = LinkTokenInterface(link);\n    LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\n    FAST_GAS_FEED = AggregatorV3Interface(fastGasFeed);\n\n    setConfig(\n      paymentPremiumPPB,\n      blockCountPerTurn,\n      checkGasLimit,\n      stalenessSeconds,\n      gasCeilingMultiplier,\n      fallbackGasPrice,\n      fallbackLinkPrice\n    );\n  }\n\n\n  // ACTIONS\n\n  /**\n   * @notice adds a new upkeep\n   * @param target address to peform upkeep on\n   * @param gasLimit amount of gas to provide the target contract when\n   * performing upkeep\n   * @param admin address to cancel upkeep and withdraw remaining funds\n   * @param checkData data passed to the contract when checking for upkeep\n   */\n  function registerUpkeep(\n    address target,\n    uint32 gasLimit,\n    address admin,\n    bytes calldata checkData\n  )\n    external\n    override\n    onlyOwnerOrRegistrar()\n    returns (\n      uint256 id\n    )\n  {\n    require(target.isContract(), \"target is not a contract\");\n    require(gasLimit >= CALL_GAS_MIN, \"min gas is 2300\");\n    require(gasLimit <= CALL_GAS_MAX, \"max gas is 2500000\");\n\n    id = s_upkeepCount;\n    s_upkeep[id] = Upkeep({\n      target: target,\n      executeGas: gasLimit,\n      balance: 0,\n      admin: admin,\n      maxValidBlocknumber: UINT64_MAX,\n      lastKeeper: address(0)\n    });\n    s_checkData[id] = checkData;\n    s_upkeepCount++;\n\n    emit UpkeepRegistered(id, gasLimit, admin);\n\n    return id;\n  }\n\n  /**\n   * @notice simulated by keepers via eth_call to see if the upkeep needs to be\n   * performed. If it does need to be performed then the call simulates the\n   * transaction performing upkeep to make sure it succeeds. It then eturns the\n   * success status along with payment information and the perform data payload.\n   * @param id identifier of the upkeep to check\n   * @param from the address to simulate performing the upkeep from\n   */\n  function checkUpkeep(\n    uint256 id,\n    address from\n  )\n    external\n    override\n    whenNotPaused()\n    cannotExecute()\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      int256 gasWei,\n      int256 linkEth\n    )\n  {\n    Upkeep storage upkeep = s_upkeep[id];\n    gasLimit = upkeep.executeGas;\n    (gasWei, linkEth) = getFeedData();\n    maxLinkPayment = calculatePaymentAmount(gasLimit, gasWei, linkEth);\n    require(maxLinkPayment < upkeep.balance, \"insufficient funds\");\n\n    bytes memory callData = abi.encodeWithSelector(CHECK_SELECTOR, s_checkData[id]);\n    (\n      bool success,\n      bytes memory result\n    ) = upkeep.target.call{gas: s_config.checkGasLimit}(callData);\n    require(success, \"call to check target failed\");\n\n    (\n      success,\n      performData\n    ) = abi.decode(result, (bool, bytes));\n    require(success, \"upkeep not needed\");\n\n    success = performUpkeepWithParams(PerformParams({\n      from: from,\n      id: id,\n      performData: performData\n    }));\n    require(success, \"call to perform upkeep failed\");\n\n    return (performData, maxLinkPayment, gasLimit, gasWei, linkEth);\n  }\n\n  /**\n   * @notice executes the upkeep with the perform data returned from\n   * checkUpkeep, validates the keeper's permissions, and pays the keeper.\n   * @param id identifier of the upkeep to execute the data with.\n   * @param performData calldata paramter to be passed to the target upkeep.\n   */\n  function performUpkeep(\n    uint256 id,\n    bytes calldata performData\n  )\n    external\n    override\n    returns (\n      bool success\n    )\n  {\n    return performUpkeepWithParams(PerformParams({\n      from: msg.sender,\n      id: id,\n      performData: performData\n    }));\n  }\n\n  /**\n   * @notice prevent an upkeep from being performed in the future\n   * @param id upkeep to be canceled\n   */\n  function cancelUpkeep(\n    uint256 id\n  )\n    external\n    override\n  {\n    uint64 maxValid = s_upkeep[id].maxValidBlocknumber;\n    bool notCanceled = maxValid == UINT64_MAX;\n    bool isOwner = msg.sender == owner;\n    require(notCanceled || (isOwner && maxValid > block.number), \"too late to cancel upkeep\");\n    require(isOwner|| msg.sender == s_upkeep[id].admin, \"only owner or admin\");\n\n    uint256 height = block.number;\n    if (!isOwner) {\n      height = height.add(CANCELATION_DELAY);\n    }\n    s_upkeep[id].maxValidBlocknumber = uint64(height);\n    if (notCanceled) {\n      s_canceledUpkeepList.push(id);\n    }\n\n    emit UpkeepCanceled(id, uint64(height));\n  }\n\n  /**\n   * @notice adds LINK funding for an upkeep by tranferring from the sender's\n   * LINK balance\n   * @param id upkeep to fund\n   * @param amount number of LINK to transfer\n   */\n  function addFunds(\n    uint256 id,\n    uint96 amount\n  )\n    external\n    override\n    validUpkeep(id)\n  {\n    s_upkeep[id].balance = s_upkeep[id].balance.add(amount);\n    LINK.transferFrom(msg.sender, address(this), amount);\n    emit FundsAdded(id, msg.sender, amount);\n  }\n\n  /**\n   * @notice uses LINK's transferAndCall to LINK and add funding to an upkeep\n   * @dev safe to cast uint256 to uint96 as total LINK supply is under UINT96MAX\n   * @param sender the account which transferred the funds\n   * @param amount number of LINK transfer\n   */\n  function onTokenTransfer(\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  )\n    external\n  {\n    require(msg.sender == address(LINK), \"only callable through LINK\");\n    require(data.length == 32, \"data must be 32 bytes\");\n    uint256 id = abi.decode(data, (uint256));\n    validateUpkeep(id);\n\n    s_upkeep[id].balance = s_upkeep[id].balance.add(uint96(amount));\n\n    emit FundsAdded(id, sender, uint96(amount));\n  }\n\n  /**\n   * @notice removes funding from a cancelled upkeep\n   * @param id upkeep to withdraw funds from\n   * @param to destination address for sending remaining funds\n   */\n  function withdrawFunds(\n    uint256 id,\n    address to\n  )\n    external\n    validateRecipient(to)\n  {\n    require(s_upkeep[id].admin == msg.sender, \"only callable by admin\");\n    require(s_upkeep[id].maxValidBlocknumber <= block.number, \"upkeep must be canceled\");\n\n    uint256 amount = s_upkeep[id].balance;\n    s_upkeep[id].balance = 0;\n    emit FundsWithdrawn(id, amount, to);\n\n    LINK.transfer(to, amount);\n  }\n\n  /**\n   * @notice recovers LINK funds improperly transfered to the registry\n   * @dev In principle this functionâ€™s execution cost could exceed block\n   * gaslimit. However, in our anticipated deployment, the number of upkeeps and\n   * keepers will be low enough to avoid this problem.\n   */\n  function recoverFunds()\n    external\n    onlyOwner()\n  {\n    uint96 locked = 0;\n    uint256 max = s_upkeepCount;\n    for (uint256 i = 0; i < max; i++) {\n      locked = s_upkeep[i].balance.add(locked);\n    }\n    max = s_keeperList.length;\n    for (uint256 i = 0; i < max; i++) {\n      address addr = s_keeperList[i];\n      locked = s_keeperInfo[addr].balance.add(locked);\n    }\n\n    uint256 total = LINK.balanceOf(address(this));\n    LINK.transfer(msg.sender, total.sub(locked));\n  }\n\n  /**\n   * @notice withdraws a keeper's payment, callable only by the keeper's payee\n   * @param from keeper address\n   * @param to address to send the payment to\n   */\n  function withdrawPayment(\n    address from,\n    address to\n  )\n    external\n    validateRecipient(to)\n  {\n    KeeperInfo memory keeper = s_keeperInfo[from];\n    require(keeper.payee == msg.sender, \"only callable by payee\");\n\n    s_keeperInfo[from].balance = 0;\n    emit PaymentWithdrawn(from, keeper.balance, to, msg.sender);\n\n    LINK.transfer(to, keeper.balance);\n  }\n\n  /**\n   * @notice proposes the safe transfer of a keeper's payee to another address\n   * @param keeper address of the keeper to transfer payee role\n   * @param proposed address to nominate for next payeeship\n   */\n  function transferPayeeship(\n    address keeper,\n    address proposed\n  )\n    external\n  {\n    require(s_keeperInfo[keeper].payee == msg.sender, \"only callable by payee\");\n    require(proposed != msg.sender, \"cannot transfer to self\");\n\n    if (s_proposedPayee[keeper] != proposed) {\n      s_proposedPayee[keeper] = proposed;\n      emit PayeeshipTransferRequested(keeper, msg.sender, proposed);\n    }\n  }\n\n  /**\n   * @notice accepts the safe transfer of payee role for a keeper\n   * @param keeper address to accept the payee role for\n   */\n  function acceptPayeeship(\n    address keeper\n  )\n    external\n  {\n    require(s_proposedPayee[keeper] == msg.sender, \"only callable by proposed payee\");\n    address past = s_keeperInfo[keeper].payee;\n    s_keeperInfo[keeper].payee = msg.sender;\n    s_proposedPayee[keeper] = ZERO_ADDRESS;\n\n    emit PayeeshipTransferred(keeper, past, msg.sender);\n  }\n\n  /**\n   * @notice signals to keepers that they should not perform upkeeps until the\n   * contract has been unpaused\n   */\n  function pause()\n    external\n    onlyOwner()\n  {\n    _pause();\n  }\n\n  /**\n   * @notice signals to keepers that they can perform upkeeps once again after\n   * having been paused\n   */\n  function unpause()\n    external\n    onlyOwner()\n  {\n    _unpause();\n  }\n\n\n  // SETTERS\n\n  /**\n   * @notice updates the configuration of the registry\n   * @param paymentPremiumPPB payment premium rate oracles receive on top of\n   * being reimbursed for gas, measured in parts per billion\n   * @param blockCountPerTurn number of blocks an oracle should wait before\n   * checking for upkeep\n   * @param checkGasLimit gas limit when checking for upkeep\n   * @param stalenessSeconds number of seconds that is allowed for feed data to\n   * be stale before switching to the fallback pricing\n   * @param fallbackGasPrice gas price used if the gas price feed is stale\n   * @param fallbackLinkPrice LINK price used if the LINK price feed is stale\n   */\n  function setConfig(\n    uint32 paymentPremiumPPB,\n    uint24 blockCountPerTurn,\n    uint32 checkGasLimit,\n    uint24 stalenessSeconds,\n    uint16 gasCeilingMultiplier,\n    int256 fallbackGasPrice,\n    int256 fallbackLinkPrice\n  )\n    onlyOwner()\n    public\n  {\n    s_config = Config({\n      paymentPremiumPPB: paymentPremiumPPB,\n      blockCountPerTurn: blockCountPerTurn,\n      checkGasLimit: checkGasLimit,\n      stalenessSeconds: stalenessSeconds,\n      gasCeilingMultiplier: gasCeilingMultiplier\n    });\n    s_fallbackGasPrice = fallbackGasPrice;\n    s_fallbackLinkPrice = fallbackLinkPrice;\n\n    emit ConfigSet(\n      paymentPremiumPPB,\n      blockCountPerTurn,\n      checkGasLimit,\n      stalenessSeconds,\n      gasCeilingMultiplier,\n      fallbackGasPrice,\n      fallbackLinkPrice\n    );\n  }\n\n  /**\n   * @notice update the list of keepers allowed to peform upkeep\n   * @param keepers list of addresses allowed to perform upkeep\n   * @param payees addreses corresponding to keepers who are allowed to\n   * move payments which have been acrued\n   */\n  function setKeepers(\n    address[] calldata keepers,\n    address[] calldata payees\n  )\n    external\n    onlyOwner()\n  {\n    for (uint256 i = 0; i < s_keeperList.length; i++) {\n      address keeper = s_keeperList[i];\n      s_keeperInfo[keeper].active = false;\n    }\n    for (uint256 i = 0; i < keepers.length; i++) {\n      address keeper = keepers[i];\n      KeeperInfo storage s_keeper = s_keeperInfo[keeper];\n      address oldPayee = s_keeper.payee;\n      address newPayee = payees[i];\n      require(oldPayee == ZERO_ADDRESS || oldPayee == newPayee || newPayee == IGNORE_ADDRESS, \"cannot change payee\");\n      require(!s_keeper.active, \"cannot add keeper twice\");\n      s_keeper.active = true;\n      if (newPayee != IGNORE_ADDRESS) {\n        s_keeper.payee = newPayee;\n      }\n    }\n    s_keeperList = keepers;\n    emit KeepersUpdated(keepers, payees);\n  }\n\n  /**\n   * @notice update registrar\n   * @param registrar new registrar\n   */\n  function setRegistrar(\n    address registrar\n  )\n    external\n    onlyOwnerOrRegistrar()\n  {\n    address previous = s_registrar;\n    require(registrar != previous, \"Same registrar\");\n    s_registrar = registrar;\n    emit RegistrarChanged(previous, registrar);\n  }\n\n  // GETTERS\n\n  /**\n   * @notice read all of the details about an upkeep\n   */\n  function getUpkeep(\n    uint256 id\n  )\n    external\n    view\n    override\n    returns (\n      address target,\n      uint32 executeGas,\n      bytes memory checkData,\n      uint96 balance,\n      address lastKeeper,\n      address admin,\n      uint64 maxValidBlocknumber\n    )\n  {\n    Upkeep memory reg = s_upkeep[id];\n    return (\n      reg.target,\n      reg.executeGas,\n      s_checkData[id],\n      reg.balance,\n      reg.lastKeeper,\n      reg.admin,\n      reg.maxValidBlocknumber\n    );\n  }\n\n  /**\n   * @notice read the total number of upkeep's registered\n   */\n  function getUpkeepCount()\n    external\n    view\n    override\n    returns (\n      uint256\n    )\n  {\n    return s_upkeepCount;\n  }\n\n  /**\n   * @notice read the current list canceled upkeep IDs\n   */\n  function getCanceledUpkeepList()\n    external\n    view\n    override\n    returns (\n      uint256[] memory\n    )\n  {\n    return s_canceledUpkeepList;\n  }\n\n  /**\n   * @notice read the current list of addresses allowed to perform upkeep\n   */\n  function getKeeperList()\n    external\n    view\n    override\n    returns (\n      address[] memory\n    )\n  {\n    return s_keeperList;\n  }\n\n /**\n   * @notice read the current registrar\n   */\n  function getRegistrar()\n    external\n    view\n    returns (\n      address\n    )\n  {\n    return s_registrar;\n  }\n\n  /**\n   * @notice read the current info about any keeper address\n   */\n  function getKeeperInfo(\n    address query\n  )\n    external\n    view\n    override\n    returns (\n      address payee,\n      bool active,\n      uint96 balance\n    )\n  {\n    KeeperInfo memory keeper = s_keeperInfo[query];\n    return (keeper.payee, keeper.active, keeper.balance);\n  }\n\n  /**\n   * @notice read the current configuration of the registry\n   */\n  function getConfig()\n    external\n    view\n    override\n    returns (\n      uint32 paymentPremiumPPB,\n      uint24 blockCountPerTurn,\n      uint32 checkGasLimit,\n      uint24 stalenessSeconds,\n      uint16 gasCeilingMultiplier,\n      int256 fallbackGasPrice,\n      int256 fallbackLinkPrice\n    )\n  {\n    Config memory config = s_config;\n    return (\n      config.paymentPremiumPPB,\n      config.blockCountPerTurn,\n      config.checkGasLimit,\n      config.stalenessSeconds,\n      config.gasCeilingMultiplier,\n      s_fallbackGasPrice,\n      s_fallbackLinkPrice\n    );\n  }\n\n\n  // PRIVATE\n\n  /**\n   * @dev retrieves feed data for fast gas/eth and link/eth prices. if the feed\n   * data is stale it uses the configured fallback price. Once a price is picked\n   * for gas it takes the min of gas price in the transaction or the fast gas\n   * price in order to reduce costs for the upkeep clients.\n   */\n  function getFeedData()\n    private\n    view\n    returns (\n      int256 gasWei,\n      int256 linkEth\n    )\n  {\n    uint32 stalenessSeconds = s_config.stalenessSeconds;\n    bool staleFallback = stalenessSeconds > 0;\n    uint256 timestamp;\n    (,gasWei,,timestamp,) = FAST_GAS_FEED.latestRoundData();\n    if (staleFallback && stalenessSeconds < block.timestamp - timestamp) {\n      gasWei = s_fallbackGasPrice;\n    }\n    (,linkEth,,timestamp,) = LINK_ETH_FEED.latestRoundData();\n    if (staleFallback && stalenessSeconds < block.timestamp - timestamp) {\n      linkEth = s_fallbackLinkPrice;\n    }\n    return (gasWei, linkEth);\n  }\n\n  /**\n   * @dev calculates LINK paid for gas spent plus a configure premium percentage\n   */\n  function calculatePaymentAmount(\n    uint256 gasLimit,\n    int256 gasWei,\n    int256 linkEth\n  )\n    private\n    view\n    returns (\n      uint96 payment\n    )\n  {\n    uint256 weiForGas = uint256(gasWei).mul(gasLimit.add(REGISTRY_GAS_OVERHEAD));\n    uint256 premium = PPB_BASE.add(s_config.paymentPremiumPPB);\n    uint256 total = weiForGas.mul(1e9).mul(premium).div(uint256(linkEth));\n    require(total <= LINK_TOTAL_SUPPLY, \"payment greater than all LINK\");\n    return uint96(total); // LINK_TOTAL_SUPPLY < UINT96_MAX\n  }\n\n  /**\n   * @dev calls target address with exactly gasAmount gas and data as calldata\n   * or reverts if at least gasAmount gas is not available\n   */\n  function callWithExactGas(\n    uint256 gasAmount,\n    address target,\n    bytes memory data\n  )\n    private\n    returns (\n      bool success\n    )\n  {\n    assembly{\n      let g := gas()\n      // Compute g -= CUSHION and check for underflow\n      if lt(g, CUSHION) { revert(0, 0) }\n      g := sub(g, CUSHION)\n      // if g - g//64 <= gasAmount, revert\n      // (we subtract g//64 because of EIP-150)\n      if iszero(gt(sub(g, div(g, 64)), gasAmount)) { revert(0, 0) }\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      if iszero(extcodesize(target)) { revert(0, 0) }\n      // call and return whether we succeeded. ignore return data\n      success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\n    }\n    return success;\n  }\n\n  /**\n   * @dev calls the Upkeep target with the performData param passed in by the\n   * keeper and the exact gas required by the Upkeep\n   */\n  function performUpkeepWithParams(\n    PerformParams memory params\n  )\n    private\n    nonReentrant()\n    validUpkeep(params.id)\n    returns (\n      bool success\n    )\n  {\n    require(s_keeperInfo[params.from].active, \"only active keepers\");\n    Upkeep memory upkeep = s_upkeep[params.id];\n    uint256 gasLimit = upkeep.executeGas;\n    (int256 gasWei, int256 linkEth) = getFeedData();\n    gasWei = adjustGasPrice(gasWei);\n    uint96 payment = calculatePaymentAmount(gasLimit, gasWei, linkEth);\n    require(upkeep.balance >= payment, \"insufficient payment\");\n    require(upkeep.lastKeeper != params.from, \"keepers must take turns\");\n\n    uint256  gasUsed = gasleft();\n    bytes memory callData = abi.encodeWithSelector(PERFORM_SELECTOR, params.performData);\n    success = callWithExactGas(gasLimit, upkeep.target, callData);\n    gasUsed = gasUsed - gasleft();\n\n    payment = calculatePaymentAmount(gasUsed, gasWei, linkEth);\n    upkeep.balance = upkeep.balance.sub(payment);\n    upkeep.lastKeeper = params.from;\n    s_upkeep[params.id] = upkeep;\n    uint96 newBalance = s_keeperInfo[params.from].balance.add(payment);\n    s_keeperInfo[params.from].balance = newBalance;\n\n    emit UpkeepPerformed(\n      params.id,\n      success,\n      params.from,\n      payment,\n      params.performData\n    );\n    return success;\n  }\n\n  /**\n   * @dev ensures a upkeep is valid\n   */\n  function validateUpkeep(\n    uint256 id\n  )\n    private\n    view\n  {\n    require(s_upkeep[id].maxValidBlocknumber > block.number, \"invalid upkeep id\");\n  }\n\n  /**\n   * @dev adjusts the gas price to min(ceiling, tx.gasprice)\n   */\n  function adjustGasPrice(\n    int256 gasWei\n  )\n    private\n    view\n    returns(int256 adjustedPrice)\n  {\n    adjustedPrice = int256(tx.gasprice);\n    int256 ceiling = gasWei.mul(s_config.gasCeilingMultiplier);\n    if(adjustedPrice > ceiling) {\n      adjustedPrice = ceiling;\n    }\n  }\n\n\n  // MODIFIERS\n\n  /**\n   * @dev ensures a upkeep is valid\n   */\n  modifier validUpkeep(\n    uint256 id\n  ) {\n    validateUpkeep(id);\n    _;\n  }\n\n  /**\n   * @dev ensures that burns don't accidentally happen by sending to the zero\n   * address\n   */\n  modifier validateRecipient(\n    address to\n  ) {\n    require(to != address(0), \"cannot send to zero address\");\n    _;\n  }\n\n    /**\n   * @dev Reverts if called by anyone other than the contract owner or registrar.\n   */\n  modifier onlyOwnerOrRegistrar() {\n    require(msg.sender == owner || msg.sender == s_registrar, \"Only callable by owner or registrar\");\n    _;\n  }\n\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.7/vendor/SafeMathChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathChainlink {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n"
    },
    "contracts/vendor/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @title The Owned contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract Owned {\n\n  address public owner;\n  address private pendingOwner;\n\n  event OwnershipTransferRequested(\n    address indexed from,\n    address indexed to\n  );\n  event OwnershipTransferred(\n    address indexed from,\n    address indexed to\n  );\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address _to)\n    external\n    onlyOwner()\n  {\n    pendingOwner = _to;\n\n    emit OwnershipTransferRequested(owner, _to);\n  }\n\n  /**\n   * @dev Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership()\n    external\n  {\n    require(msg.sender == pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = owner;\n    owner = msg.sender;\n    pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @dev Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only callable by owner\");\n    _;\n  }\n\n}\n"
    },
    "contracts/vendor/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// github.com/OpenZeppelin/openzeppelin-contracts@fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/vendor/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// github.com/OpenZeppelin/openzeppelin-contracts@fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/vendor/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// github.com/OpenZeppelin/openzeppelin-contracts@fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/vendor/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/SafeMath96.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * This library is a version of Open Zeppelin's SafeMath, modified to support\n * unsigned 96 bit integers.\n */\nlibrary SafeMath96 {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint96 a, uint96 b) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint96 a, uint96 b) internal pure returns (uint96) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint96 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint96 a, uint96 b) internal pure returns (uint96) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint96 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint96 a, uint96 b) internal pure returns (uint96) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint96 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint96 a, uint96 b) internal pure returns (uint96) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n"
    },
    "contracts/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface KeeperCompatibleInterface {\n\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easilly be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(\n    bytes calldata checkData\n  )\n    external\n    returns (\n      bool upkeepNeeded,\n      bytes memory performData\n    );\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(\n    bytes calldata performData\n  ) external;\n}\n"
    },
    "contracts/KeeperRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface KeeperRegistryBaseInterface {\n  function registerUpkeep(\n    address target,\n    uint32 gasLimit,\n    address admin,\n    bytes calldata checkData\n  ) external returns (\n      uint256 id\n    );\n  function performUpkeep(\n    uint256 id,\n    bytes calldata performData\n  ) external returns (\n      bool success\n    );\n  function cancelUpkeep(\n    uint256 id\n  ) external;\n  function addFunds(\n    uint256 id,\n    uint96 amount\n  ) external;\n\n  function getUpkeep(uint256 id)\n    external view returns (\n      address target,\n      uint32 executeGas,\n      bytes memory checkData,\n      uint96 balance,\n      address lastKeeper,\n      address admin,\n      uint64 maxValidBlocknumber\n    );\n  function getUpkeepCount()\n    external view returns (uint256);\n  function getCanceledUpkeepList()\n    external view returns (uint256[] memory);\n  function getKeeperList()\n    external view returns (address[] memory);\n  function getKeeperInfo(address query)\n    external view returns (\n      address payee,\n      bool active,\n      uint96 balance\n    );\n  function getConfig()\n    external view returns (\n      uint32 paymentPremiumPPB,\n      uint24 checkFrequencyBlocks,\n      uint32 checkGasLimit,\n      uint24 stalenessSeconds,\n      uint16 gasCeilingMultiplier,\n      int256 fallbackGasPrice,\n      int256 fallbackLinkPrice\n    );\n}\n\n/**\n  * @dev The view methods are not actually marked as view in the implementation\n  * but we want them to be easily queried off-chain. Solidity will not compile\n  * if we actually inherrit from this interface, so we document it here.\n  */\ninterface KeeperRegistryInterface is KeeperRegistryBaseInterface {\n  function checkUpkeep(\n    uint256 upkeepId,\n    address from\n  )\n    external\n    view\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      int256 gasWei,\n      int256 linkEth\n    );\n}\n\ninterface KeeperRegistryExecutableInterface is KeeperRegistryBaseInterface {\n  function checkUpkeep(\n    uint256 upkeepId,\n    address from\n  )\n    external\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      int256 gasWei,\n      int256 linkEth\n    );\n}\n"
    },
    "contracts/vendor/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// github.com/OpenZeppelin/openzeppelin-contracts@fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/UpkeepRegistrationRequests.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"./vendor/Owned.sol\";\nimport \"./KeeperRegistryInterface.sol\";\n\n/**\n * @notice Contract to accept requests for upkeep registrations\n * @dev There are 2 registration workflows in this contract\n * Flow 1. auto approve OFF / manual registration - UI calls `register` function on this contract, this contract owner at a later time then manually\n *  calls `approve` to register upkeep and emit events to inform UI and others interested.\n * Flow 2. auto approve ON / real time registration - UI calls `register` function as before, which calls the `registerUpkeep` function directly on\n *  keeper registry and then emits approved event to finish the flow automatically without manual intervention.\n * The idea is to have same interface(functions,events) for UI or anyone using this contract irrespective of auto approve being enabled or not.\n * they can just listen to `RegistrationRequested` & `RegistrationApproved` events and know the status on registrations.\n */\ncontract UpkeepRegistrationRequests is Owned {\n    bytes4 private constant REGISTER_REQUEST_SELECTOR = this.register.selector;\n\n    uint256 private s_minLINKJuels;\n\n    address public immutable LINK_ADDRESS;\n\n    struct AutoApprovedConfig {\n        bool enabled;\n        uint16 allowedPerWindow;\n        uint32 windowSizeInBlocks;\n        uint64 windowStart;\n        uint16 approvedInCurrentWindow;\n    }\n\n    AutoApprovedConfig private s_config;\n    KeeperRegistryBaseInterface private s_keeperRegistry;\n\n    event MinLINKChanged(uint256 from, uint256 to);\n\n    event RegistrationRequested(\n        bytes32 indexed hash,\n        string name,\n        bytes encryptedEmail,\n        address indexed upkeepContract,\n        uint32 gasLimit,\n        address adminAddress,\n        bytes checkData,\n        uint8 indexed source\n    );\n\n    event RegistrationApproved(\n        bytes32 indexed hash,\n        string displayName,\n        uint256 indexed upkeepId\n    );\n\n    constructor(\n        address LINKAddress, \n        uint256 minimumLINKJuels\n    ) \n    {\n        LINK_ADDRESS = LINKAddress;\n        s_minLINKJuels = minimumLINKJuels;\n    }\n\n    //EXTERNAL\n\n    /**\n     * @notice register can only be called through transferAndCall on LINK contract\n     * @param name name of the upkeep to be registered\n     * @param encryptedEmail Amount of LINK sent (specified in Juels)\n     * @param upkeepContract address to peform upkeep on\n     * @param gasLimit amount of gas to provide the target contract when\n     * performing upkeep\n     * @param adminAddress address to cancel upkeep and withdraw remaining funds\n     * @param checkData data passed to the contract when checking for upkeep\n     * @param source application sending this request\n     */\n    function register(\n        string memory name,\n        bytes calldata encryptedEmail,\n        address upkeepContract,\n        uint32 gasLimit,\n        address adminAddress,\n        bytes calldata checkData,\n        uint8 source\n    ) \n      external \n      onlyLINK() \n    {\n        bytes32 hash = keccak256(msg.data);\n\n        emit RegistrationRequested(\n            hash,\n            name,\n            encryptedEmail,\n            upkeepContract,\n            gasLimit,\n            adminAddress,\n            checkData,\n            source\n        );\n\n        AutoApprovedConfig memory config = s_config;\n\n        // if auto approve is true send registration request to the Keeper Registry contract\n        if (config.enabled) {\n            _resetWindowIfRequired(config);\n            if (config.approvedInCurrentWindow < config.allowedPerWindow) {\n                config.approvedInCurrentWindow++;\n                s_config = config;\n\n                _approve(\n                    name,\n                    upkeepContract,\n                    gasLimit,\n                    adminAddress,\n                    checkData,\n                    hash\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev register upkeep on KeeperRegistry contract and emit RegistrationApproved event\n     */\n    function approve(\n        string memory name,\n        address upkeepContract,\n        uint32 gasLimit,\n        address adminAddress,\n        bytes calldata checkData,\n        bytes32 hash\n    ) \n      external \n      onlyOwner() \n    {\n        _approve(\n            name,\n            upkeepContract,\n            gasLimit,\n            adminAddress,\n            checkData,\n            hash\n        );    \n    }\n\n    /**\n     * @notice owner calls this function to set minimum LINK required to send registration request\n     * @param minimumLINKJuels minimum LINK required to send registration request\n     */\n    function setMinLINKJuels(\n        uint256 minimumLINKJuels\n    ) \n      external \n      onlyOwner() \n    {\n        emit MinLINKChanged(s_minLINKJuels, minimumLINKJuels);\n        s_minLINKJuels = minimumLINKJuels;\n    }\n\n    /**\n     * @notice read the minimum LINK required to send registration request\n     */\n    function getMinLINKJuels() \n      external \n      view \n      returns (\n          uint256\n      )\n    {\n        return s_minLINKJuels;\n    }\n\n    /**\n     * @notice owner calls this function to set if registration requests should be sent directly to the Keeper Registry\n     * @param enabled setting for autoapprove registrations\n     * @param windowSizeInBlocks window size defined in number of blocks\n     * @param allowedPerWindow number of registrations that can be auto approved in above window\n     * @param keeperRegistry new keeper registry address\n     */\n    function setRegistrationConfig(\n        bool enabled,\n        uint32 windowSizeInBlocks,\n        uint16 allowedPerWindow,\n        address keeperRegistry\n    )\n      external \n      onlyOwner() \n    {\n        s_config = AutoApprovedConfig({\n            enabled: enabled,\n            allowedPerWindow: allowedPerWindow,\n            windowSizeInBlocks: windowSizeInBlocks,\n            windowStart: 0,\n            approvedInCurrentWindow: 0\n        });\n        s_keeperRegistry = KeeperRegistryBaseInterface(keeperRegistry);\n    }\n\n    /**\n     * @notice read the current registration configuration\n     */\n    function getRegistrationConfig()\n        external\n        view\n        returns (\n            bool enabled,\n            uint32 windowSizeInBlocks,\n            uint16 allowedPerWindow,\n            address keeperRegistry,\n            uint64 windowStart,\n            uint16 approvedInCurrentWindow\n        )\n    {\n        AutoApprovedConfig memory config = s_config;\n        return (\n            config.enabled,\n            config.windowSizeInBlocks,\n            config.allowedPerWindow,\n            address(s_keeperRegistry),\n            config.windowStart,\n            config.approvedInCurrentWindow\n        );\n    }\n\n    /**\n     * @notice Called when LINK is sent to the contract via `transferAndCall`\n     * @param amount Amount of LINK sent (specified in Juels)\n     * @param data Payload of the transaction\n     */\n    function onTokenTransfer(\n        address, /* sender */\n        uint256 amount,\n        bytes calldata data\n    ) \n      external \n      onlyLINK() \n      permittedFunctionsForLINK(data) \n    {\n        require(amount >= s_minLINKJuels, \"Insufficient payment\");\n        (bool success, ) = address(this).delegatecall(data); // calls register\n        require(success, \"Unable to create request\");\n    }\n\n    //PRIVATE\n\n    /**\n     * @dev reset auto approve window if passed end of current window\n     */\n    function _resetWindowIfRequired(\n        AutoApprovedConfig memory config\n    ) \n      private \n    {\n        uint64 blocksPassed = uint64(block.number - config.windowStart);\n        if (blocksPassed >= config.windowSizeInBlocks) {\n            config.windowStart = uint64(block.number);\n            config.approvedInCurrentWindow = 0;\n            s_config = config;\n        }\n    }\n\n    /**\n     * @dev register upkeep on KeeperRegistry contract and emit RegistrationApproved event\n     */\n    function _approve(\n        string memory name,\n        address upkeepContract,\n        uint32 gasLimit,\n        address adminAddress,\n        bytes calldata checkData,\n        bytes32 hash\n    ) \n      private \n    {\n        //call register on keeper Registry\n        uint256 upkeepId =\n            s_keeperRegistry.registerUpkeep(\n                upkeepContract,\n                gasLimit,\n                adminAddress,\n                checkData\n            );\n\n        // emit approve event\n        emit RegistrationApproved(hash, name, upkeepId);\n    }\n\n    //MODIFIERS\n\n    /**\n     * @dev Reverts if not sent from the LINK token\n     */\n    modifier onlyLINK() {\n        require(msg.sender == LINK_ADDRESS, \"Must use LINK token\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if the given data does not begin with the `register` function selector\n     * @param _data The data payload of the request\n     */\n    modifier permittedFunctionsForLINK(\n        bytes memory _data\n    ) \n    {\n        bytes4 funcSelector;\n        assembly {\n            // solhint-disable-next-line avoid-low-level-calls\n            funcSelector := mload(add(_data, 32))\n        }\n        require(\n            funcSelector == REGISTER_REQUEST_SELECTOR,\n            \"Must use whitelisted functions\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/KeeperCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport './KeeperBase.sol';\nimport './KeeperCompatibleInterface.sol';\n\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\n"
    },
    "contracts/test/UpkeepReverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport '../KeeperCompatible.sol';\n\ncontract UpkeepReverter is KeeperCompatible {\n\n  function checkUpkeep(bytes calldata data)\n    public\n    view\n    override\n    cannotExecute()\n    returns (\n      bool callable,\n      bytes calldata executedata\n    )\n  {\n    require(false, \"!working\");\n    return (true, data);\n  }\n\n  function performUpkeep(\n    bytes calldata\n  )\n    external\n    pure\n    override\n  {\n    require(false, \"!working\");\n  }\n\n}\n"
    },
    "contracts/test/UpkeepMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport '../KeeperCompatible.sol';\n\ncontract UpkeepMock is KeeperCompatible {\n  bool public canCheck;\n  bool public canPerform;\n\n  event UpkeepPerformedWith(bytes upkeepData);\n\n  function setCanCheck(bool value)\n    public\n  {\n    canCheck = value;\n  }\n\n  function setCanPerform(bool value)\n    public\n  {\n    canPerform = value;\n  }\n\n  function checkUpkeep(bytes calldata data)\n    external\n    override\n    cannotExecute()\n    returns (\n      bool callable,\n      bytes calldata executedata\n    )\n  {\n    bool couldCheck = canCheck;\n\n    setCanCheck(false); // test that state modifcations don't stick\n\n    return (couldCheck, data);\n  }\n\n  function performUpkeep(\n    bytes calldata data\n  )\n    external\n    override\n  {\n    require(canPerform, \"Cannot perform\");\n\n    setCanPerform(false);\n\n    emit UpkeepPerformedWith(data);\n  }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}}