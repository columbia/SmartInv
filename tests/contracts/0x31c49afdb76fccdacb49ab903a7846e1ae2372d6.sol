{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "details": {
        "constantOptimizer": true,
        "cse": true,
        "deduplicate": true,
        "inliner": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "peephole": true,
        "yul": true,
        "yulDetails": {
          "optimizerSteps": "dhfoDgvulfnTUtnIf",
          "stackAllocation": true
        }
      },
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/ShatteredEON.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"./interfaces/IShatteredEON.sol\";\r\nimport \"./interfaces/IPytheas.sol\";\r\nimport \"./interfaces/IOrbitalBlockade.sol\";\r\nimport \"./interfaces/IColonist.sol\";\r\nimport \"./interfaces/ITColonist.sol\";\r\nimport \"./interfaces/IEON.sol\";\r\nimport \"./interfaces/IRAW.sol\";\r\nimport \"./interfaces/IImperialGuild.sol\";\r\nimport \"./interfaces/IRandomizer.sol\";\r\n\r\ncontract ShatteredEON is IShatteredEON, Pausable {\r\n    uint256 public OnosiaLiquorId;\r\n\r\n    uint256 public constant maxRawEonCost = 250000; //250k rEON\r\n    uint256 public constant maxEonCost = 200000 ether; //200k EON \r\n\r\n    address public auth;\r\n\r\n    bool public eonOnlyActive;\r\n\r\n    // address => can call setters\r\n    mapping(address => bool) private admins;\r\n\r\n    event newUser(address newUser); \r\n\r\n    bytes32 internal entropySauce;\r\n\r\n    // reference to Pytheas for mint and stake of colonist\r\n    IPytheas public pytheas;\r\n    //reference to the oribitalBlockade of pirates for choosing random theives\r\n    IOrbitalBlockade public orbital;\r\n    // reference to $rEON for minting and refining\r\n    IRAW public raw;\r\n    // reference to refined EON for mininting and burning\r\n    IEON public EON;\r\n    // reference to colonist traits\r\n    ITColonist public colTraits;\r\n    // reference to the colonist NFT collection\r\n    IColonist public colonistNFT;\r\n    // reference to the galactic imperialGuild collection\r\n    IImperialGuild public imperialGuild;\r\n    //randy the randomizer\r\n    IRandomizer public randomizer;\r\n\r\n    constructor() {\r\n        _pause();\r\n        auth = msg.sender;\r\n        admins[msg.sender] = true;\r\n    }\r\n\r\n    modifier noCheaters() {\r\n        uint256 size = 0;\r\n        address acc = msg.sender;\r\n        assembly {\r\n            size := extcodesize(acc)\r\n        }\r\n\r\n        require(\r\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\r\n            \"you're trying to cheat!\"\r\n        );\r\n        _;\r\n\r\n        // We'll use the last caller hash to add entropy to next caller\r\n        entropySauce = keccak256(abi.encodePacked(acc, block.coinbase));\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == auth);\r\n        _;\r\n    }\r\n\r\n    /** CRITICAL TO SETUP */\r\n    modifier requireContractsSet() {\r\n        require(\r\n            address(raw) != address(0) &&\r\n                address(EON) != address(0) &&\r\n                address(colTraits) != address(0) &&\r\n                address(colonistNFT) != address(0) &&\r\n                address(pytheas) != address(0) &&\r\n                address(orbital) != address(0) &&\r\n                address(imperialGuild) != address(0) &&\r\n                address(randomizer) != address(0),\r\n            \"Contracts not set\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setContracts(\r\n        address _rEON,\r\n        address _EON,\r\n        address _colTraits,\r\n        address _colonistNFT,\r\n        address _pytheas,\r\n        address _orbital,\r\n        address _imperialGuild,\r\n        address _randomizer\r\n    ) external onlyOwner {\r\n        raw = IRAW(_rEON);\r\n        EON = IEON(_EON);\r\n        colTraits = ITColonist(_colTraits);\r\n        colonistNFT = IColonist(_colonistNFT);\r\n        pytheas = IPytheas(_pytheas);\r\n        orbital = IOrbitalBlockade(_orbital);\r\n        imperialGuild = IImperialGuild(_imperialGuild);\r\n        randomizer = IRandomizer(_randomizer);\r\n    }\r\n\r\n    /** EXTERNAL */\r\n\r\n    /** Mint colonist. Payable with either rEON or EON after gen 0.\r\n     * payments scaled accordingly\r\n     *bool rayPayment = rEON payment */\r\n    function mintColonist(\r\n        uint256 amount,\r\n        uint8 paymentId,\r\n        bool stake\r\n    ) external noCheaters {\r\n        uint16 minted = colonistNFT.minted();\r\n        uint256 MAX_TOKENS = colonistNFT.getMaxTokens();\r\n        require(amount > 0 && amount <= 5, \"5 max mints pers tx\");\r\n        if (eonOnlyActive) {\r\n            require(paymentId == 0, \"Only Eon sales phase\");\r\n        }\r\n        uint16[] memory tokenIds = new uint16[](amount);\r\n        uint256 seed;\r\n        // Loop through the amount of\r\n        uint256 rawCost = 0;\r\n        uint256 eonCost = 0;\r\n        address origin = tx.origin;\r\n        bytes32 blockies = blockhash(block.number - 1);\r\n        bytes32 sauce = entropySauce;\r\n        uint256 blockTime = block.timestamp;\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            minted++;\r\n            seed = random(origin, blockies, sauce, minted, blockTime);\r\n            address recipient = selectRecipient(seed);\r\n            if (\r\n                recipient != msg.sender &&\r\n                imperialGuild.getBalance(msg.sender, OnosiaLiquorId) > 0\r\n            ) {\r\n                // If the mint is going to be stolen, there's a 50% chance\r\n                //  a pirate will prefer a fine crafted eon liquor over it\r\n                if (seed & 1 == 1) {\r\n                    imperialGuild.safeTransferFrom(\r\n                        msg.sender,\r\n                        recipient,\r\n                        OnosiaLiquorId,\r\n                        1,\r\n                        \"\"\r\n                    );\r\n                    recipient = msg.sender;\r\n                }\r\n            }\r\n            tokenIds[i] = minted;\r\n            if (!stake || recipient != msg.sender) {\r\n                colonistNFT._mintColonist(recipient, seed);\r\n            } else {\r\n                colonistNFT._mintColonist(address(pytheas), seed);\r\n                tokenIds[i] = minted;\r\n            }\r\n        }\r\n        if (paymentId == 1) {\r\n            rawCost = rawMintCost(minted, MAX_TOKENS) * amount;\r\n            raw.burn(1, rawCost, msg.sender);\r\n        } else {\r\n            eonCost = EONmintCost(minted, MAX_TOKENS) * amount;\r\n            EON.burn(msg.sender, eonCost);\r\n        }\r\n        if (stake) {\r\n            pytheas.addColonistToPytheas(msg.sender, tokenIds);\r\n        }\r\n\r\n        emit newUser(msg.sender); \r\n    }\r\n\r\n    /**\r\n     * @param tokenId the ID to check the cost of to mint\r\n     * @return the cost of the given token ID\r\n     */\r\n    function rawMintCost(uint256 tokenId, uint256 maxTokens)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (tokenId <= (maxTokens * 8) / 24) return 4000; //10k-20k\r\n        if (tokenId <= (maxTokens * 12) / 24) return 16000; //20k-30k\r\n        if (tokenId <= (maxTokens * 16) / 24) return 48000; //30k-40k\r\n        if (tokenId <= (maxTokens * 20) / 24) return 122500; //40k-50k\r\n        if (tokenId <= (maxTokens * 22) / 24) return 250000; //50k-60k\r\n        return maxRawEonCost;\r\n    }\r\n\r\n    function EONmintCost(uint256 tokenId, uint256 maxTokens)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (tokenId <= (maxTokens * 8) / 24) return 3000 ether; //10k-20k\r\n        if (tokenId <= (maxTokens * 12) / 24) return 12000 ether; //20k-30k\r\n        if (tokenId <= (maxTokens * 16) / 24) return 36000 ether; //30k-40k\r\n        if (tokenId <= (maxTokens * 20) / 24) return 98000 ether; //40k-50k\r\n        if (tokenId <= (maxTokens * 22) / 24) return 200000 ether; //50k-60k\r\n        return maxEonCost;\r\n    }\r\n\r\n    /** INTERNAL */\r\n\r\n    /**\r\n     * the first 10k go to the minter\r\n     * the remaining 50k have a 10% chance to be given to a random staked pirate\r\n     * @param seed a random value to select a recipient from\r\n     * @return the address of the recipient (either the minter or the pirate thief's owner)\r\n     */\r\n    function selectRecipient(uint256 seed) internal view returns (address) {\r\n        if (((seed >> 245) % 10) != 0) return _msgSender();\r\n        address thief = orbital.randomPirateOwner(seed >> 144); // 144 bits reserved for trait selection\r\n        if (thief == address(0x0)) return msg.sender;\r\n        return thief;\r\n    }\r\n\r\n    /**\r\n     * enables owner to pause / unpause contract\r\n     */\r\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\r\n        if (_paused) _pause();\r\n        else _unpause();\r\n    }\r\n\r\n    function setOnosiaLiquorId(uint256 typeId) external onlyOwner {\r\n        OnosiaLiquorId = typeId;\r\n    }\r\n\r\n    function setEonOnly(bool _eonOnlyActive) external onlyOwner {\r\n        eonOnlyActive = _eonOnlyActive;\r\n    }\r\n\r\n    /**\r\n     * enables an address to mint / burn\r\n     * @param addr the address to enable\r\n     */\r\n    function addAdmin(address addr) external onlyOwner {\r\n        admins[addr] = true;\r\n    }\r\n\r\n    /**\r\n     * disables an address from minting / burning\r\n     * @param addr the address to disbale\r\n     */\r\n    function removeAdmin(address addr) external onlyOwner {\r\n        admins[addr] = false;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        auth = newOwner;\r\n    }\r\n\r\n    function random(address origin, bytes32 blockies,\r\n    bytes32 sauce, uint16 seed, uint256 blockTime) internal pure returns (uint256) {\r\n        return\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        origin,\r\n                        blockies,\r\n                        blockTime,\r\n                        sauce,\r\n                        seed\r\n                    )\r\n                )\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IColonist.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IColonist {\r\n    // struct to store each Colonist's traits\r\n    struct Colonist {\r\n        bool isColonist;\r\n        uint8 background;\r\n        uint8 body;\r\n        uint8 shirt;\r\n        uint8 jacket;\r\n        uint8 jaw;\r\n        uint8 eyes;\r\n        uint8 hair;\r\n        uint8 held;\r\n        uint8 gen;\r\n    }\r\n\r\n    struct HColonist {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function totalCir() external returns (uint256);\r\n\r\n    function _mintColonist(address recipient, uint256 seed) external;\r\n\r\n    function _mintToHonors(address recipient, uint256 seed) external;\r\n\r\n    function _mintHonors(address recipient, uint8 id) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getMaxTokens() external view returns (uint256);\r\n\r\n    function getPaidTokens() external view returns (uint256);\r\n\r\n    function getTokenTraitsColonist(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Colonist memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HColonist memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function nameColonist(uint256 tokenId, string memory newName) external;\r\n}\r\n"
    },
    "contracts/interfaces/IEON.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IEON {\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    function burn(address from, uint256 amount) external;\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IImperialGuild.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IImperialGuild {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 paymentId,\r\n        uint16 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint16 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function handlePayment(uint256 amount) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IOrbitalBlockade.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\n\npragma solidity ^0.8.0;\n\ninterface IOrbitalBlockade {\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\n        external;\n    \n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\n        external;\n\n    function payPirateTax(uint256 amount) external;\n\n    function randomPirateOwner(uint256 seed) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IPytheas.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPytheas {\r\n    function addColonistToPytheas(address account, uint16[] calldata tokenIds)\r\n        external;\r\n\r\n    function claimColonistFromPytheas(address account, uint16[] calldata tokenIds, bool unstake)\r\n        external;\r\n\r\n    function getColonistMined(address account, uint16 tokenId)\r\n        external\r\n        returns (uint256);\r\n\r\n    function handleJoinPirates(address addr, uint16 tokenId) external;\r\n\r\n    function payUp(\r\n        uint16 tokenId,\r\n        uint256 amtMined,\r\n        address addr\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IRAW.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRAW {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function updateMintBurns(\r\n        uint256 typeId,\r\n        uint256 mintQty,\r\n        uint256 burnQty\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n\r\n}\r\n"
    },
    "contracts/interfaces/IRandomizer.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRandomizer {\r\n    function random(uint256) external returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IShatteredEON.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IShatteredEON {}\r\n"
    },
    "contracts/interfaces/ITColonist.sol": {
      "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITColonist {\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
    }
  }
}}