{{
  "language": "Solidity",
  "sources": {
    "src/QuantumUnlocked.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {ERC721 as ERC721S} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport \"@rari-capital/solmate/src/auth/Auth.sol\";\nimport \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./ERC2981V2.sol\";\n\n\n/// @title The Quantum Unlocked. Speciality drops for the quantum keys are released here\n/// @author jcbdev\ncontract QuantumUnlocked is ERC721S, ERC2981, Auth {\n    using Strings for uint256;\n    using BitMaps for BitMaps.BitMap;\n\n    /// >>>>>>>>>>>>>>>>>>>>>>>  EVENTS  <<<<<<<<<<<<<<<<<<<<<<<<<< ///\n\n    event DropMint(address indexed to, uint256 indexed dropId, uint256 indexed variant, uint256 id);\n\n    /// >>>>>>>>>>>>>>>>>>>>>>>  STATE  <<<<<<<<<<<<<<<<<<<<<<<<<< ///\n\n    mapping (uint128 => string) public dropCID;\n    mapping (uint128 => uint128) public dropSupply;\n    mapping (uint256 => uint256) public tokenVariant;\n\n    string private _baseURI = \"https://core-api.quantum.art/v1/metadata/unlocked/\";\n    string private _ipfsURI = \"ipfs://\";\n    address private _minter;\n\n    /// >>>>>>>>>>>>>>>>>>>>>  CONSTRUCTOR  <<<<<<<<<<<<<<<<<<<<<< ///\n\n\t/// @notice Deploys QuantumUnlocked\n    /// @dev Initiates the Auth module with no authority and the sender as the owner\n    /// @param owner The owner of the contract\n    /// @param authority address of the deployed authority\n    constructor(address owner, address authority) ERC721S(\"QuantumUnlocked\", \"QKU\") Auth(owner, Authority(authority)) {\n        _baseURI = \"https://core-api.quantum.art/v1/metadata/unlocked/\";\n        _ipfsURI = \"ipfs://\";\n    }\n\n    /// >>>>>>>>>>>>>>>>>>>>>  INTERNAL  <<<<<<<<<<<<<<<<<<<<<< ///\n    /// @notice get the token id from the drop id and sequence number\n    /// @param dropId The drop id\n    /// @param sequence the sequence number of the minted token within the drop \n    /// @return tokenId the combined token id \n    function _tokenId(uint128 dropId, uint128 sequence) internal pure returns (uint256 tokenId) {\n        tokenId |= uint256(dropId) << 128;\n        tokenId |= uint256(sequence);\n        return tokenId;\n    }\n\n    /// @notice extract the drop id and the sequence number from the token id\n    /// @param tokenId The token id to extract the values from\n    /// @return uint128 the drop id\n    /// @return uint128 the sequence number\n    function _splitTokenId(uint256 tokenId) internal pure returns (uint128, uint128) {\n        return (uint128(tokenId >> 128), uint128(tokenId));\n    }\n\n    /// >>>>>>>>>>>>>>>>>>>>>  RESTRICTED  <<<<<<<<<<<<<<<<<<<<<< ///\n\n    /// @notice set address of the minter\n    /// @param minter The address of the minter - should be Sales Platform\n    function setMinter(address minter) public requiresAuth {\n        _minter = minter;\n    }\n\n    /// @notice set the baseURI\n    /// @param baseURI new base\n    function setBaseURI(string calldata baseURI) public requiresAuth {\n        _baseURI = baseURI;\n    }\n\n    /// @notice set the base ipfs URI\n    /// @param ipfsURI new base\n    function setIpfsURI(string calldata ipfsURI) public requiresAuth {\n        _ipfsURI = ipfsURI;\n    }\n\n    /// @notice set the IPFS CID\n    /// @param dropId The drop id\n    /// @param cid cid\n    function setCID(uint128 dropId, string calldata cid) public requiresAuth {\n        dropCID[dropId] = cid;\n    }\n\n    /// @notice sets the recipient of the royalties\n    /// @param recipient address of the recipient\n    function setRoyaltyRecipient(address recipient) public requiresAuth {\n        _royaltyRecipient = recipient;\n    }\n\n    /// @notice sets the fee of royalties\n    /// @dev The fee denominator is 10000 in BPS.\n    /// @param fee fee\n    /*\n        Example\n\n        This would set the fee at 5%\n        ```\n        KeyUnlocks.setRoyaltyFee(500)\n        ```\n    */\n    function setRoyaltyFee(uint256 fee) public requiresAuth {\n        _royaltyFee = fee;\n    }\n\n    /// @notice Mints new tokens\n    /// @dev there is no check regarding limiting supply\n    /// @param to recipient of newly minted tokens\n    /// @param dropId id of the key\n    function mint(address to, uint128 dropId, uint256 variant) public returns (uint256) {\n        require(msg.sender == owner || msg.sender == _minter, \"NOT_AUTHORIZED\");\n\n        dropSupply[dropId] += 1;\n        uint256 tokenId = _tokenId(dropId, uint128(dropSupply[dropId]));\n        _safeMint(to, tokenId);\n        if (variant > 0) {\n            tokenVariant[tokenId] = variant;\n        }\n        emit DropMint(to, dropId, variant, tokenId);\n        return tokenId;\n    }\n\n    /// @notice Burns token that has been redeemed for something else\n    /// @dev Sales platform only\n    /// @param tokenId id of the tokens\n    function redeemBurn(uint256 tokenId) public requiresAuth {\n        _burn(tokenId);\n    }\n\n    /// >>>>>>>>>>>>>>>>>>>>>  VIEW  <<<<<<<<<<<<<<<<<<<<<< ///\n\n    /// @notice Returns the URI of the token\n    /// @param tokenId id of the token\n    /// @return URI for the token ; expected to be ipfs://<cid>\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        (uint128 dropId, uint128 sequenceNumber) = _splitTokenId(tokenId);\n        uint256 actualSequence = tokenVariant[tokenId] > 0 ? tokenVariant[tokenId] : sequenceNumber;\n        if (bytes(dropCID[dropId]).length > 0)\n            return string(abi.encodePacked(_ipfsURI, dropCID[dropId], \"/\" , actualSequence.toString()));\n        else\n            return string(abi.encodePacked(_baseURI, uint256(dropId).toString(), \"/\" , actualSequence.toString()));\n    }\n\n    /// >>>>>>>>>>>>>>>>>>>>>  EXTERNAL  <<<<<<<<<<<<<<<<<<<<<< ///\n\n    /// @notice Burns token\n    /// @dev Can be called by the owner or approved operator\n    /// @param tokenId id of the tokens\n    function burn(uint256 tokenId) public {\n        address owner = ownerOf[tokenId];\n        require(\n            msg.sender == owner || msg.sender == getApproved[tokenId] || isApprovedForAll[owner][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n        _burn(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual override(ERC721S, ERC2981) returns (bool) {\n        return ERC721S.supportsInterface(interfaceId) || ERC2981.supportsInterface(interfaceId);\n    }\n}"
    },
    "@rari-capital/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@rari-capital/solmate/src/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnerUpdated(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n */\nlibrary BitMaps {\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(\n        BitMap storage bitmap,\n        uint256 index,\n        bool value\n    ) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/ERC2981V2.sol": {
      "content": "pragma solidity >=0.8.0;\n\n/// @title Minimalist ERC2981 implementation.\n/// @notice To be used within Quantum, as it was written for its needs.\n/// @author exp.table\nabstract contract ERC2981 {\n\n    /// @dev one global fee for all royalties.\n    uint256 internal _royaltyFee;\n    /// @dev one global recipient for all royalties.\n    address internal _royaltyRecipient;\n\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (\n        address receiver,\n        uint256 royaltyAmount\n    ) {\n        receiver = _royaltyRecipient;\n        royaltyAmount = (salePrice * _royaltyFee) / 10000;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x2a55205a; // ERC165 Interface ID for ERC2981\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}