{{
  "language": "Solidity",
  "sources": {
    "contracts/GenArtNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport \"./NFTDescriptor.sol\";\n\ncontract GenArtNFT is ERC721 {\n    uint256 internal constant MAX_SUPPLY = 3000;\n\n    bool public mintable;\n    uint16 public dimensionLimits;\n    uint24 public totalSupply;\n    address public tokenDescriptor;\n    address public owner;\n    uint128[MAX_SUPPLY] public tokenData;\n\n    constructor() ERC721(unicode\"███\", unicode\"███\") {\n        owner = msg.sender;\n        dimensionLimits = 0x6166;\n    }\n\n    function mint(uint128 data) external {\n        require(mintable, \"Minting disabled\");\n        uint256 ncol = (data >> 0) & 0x7;\n        uint256 nrow = (data >> 3) & 0x7;\n        uint256 dim = dimensionLimits;\n        //prettier-ignore\n        require(\n            ncol >= ((dim >> 0)  & 0xF) &&\n            ncol <= ((dim >> 4)  & 0xF) &&\n            nrow >= ((dim >> 8)  & 0xF) &&\n            nrow <= ((dim >> 12) & 0xF),\n            \"Invalid Data\"\n        );\n        uint256 tokenId = ++totalSupply;\n        require(tokenId <= MAX_SUPPLY, \"Exceed max supply\");\n        uint256 rand = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.number, tokenId))) % 8;\n        tokenData[tokenId] = (uint128(rand) << 120) | uint120(data);\n        _mint(msg.sender, tokenId);\n    }\n\n    function _getData(uint256 tokenId)\n        internal\n        view\n        returns (\n            uint256 ncol,\n            uint256 nrow,\n            uint256 result,\n            uint256 salt\n        )\n    {\n        uint256 data = tokenData[tokenId];\n        require(data != 0, \"Token not exists\");\n        ncol = (data >> 0) & 0x7;\n        nrow = (data >> 3) & 0x7;\n        result = uint120(data) >> 6;\n        salt = data;\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (tokenDescriptor != address(0)) {\n            return IERC721Descriptor(tokenDescriptor).tokenURI(tokenId);\n        }\n        (uint256 ncol, uint256 nrow, uint256 result, uint256 salt) = _getData(tokenId);\n        return NFTDescriptor.constructTokenURI(tokenId, result, ncol, nrow, salt, name);\n    }\n\n    function imageURI(uint256 tokenId) external view returns (string memory) {\n        (uint256 ncol, uint256 nrow, uint256 result, uint256 salt) = _getData(tokenId);\n        return NFTDescriptor.makeImageURI(result, ncol, nrow, salt);\n    }\n\n    function squares(uint256 tokenId) external view returns (string memory) {\n        (uint256 ncol, uint256 nrow, uint256 result, ) = _getData(tokenId);\n        return NFTDescriptor.makeSquares(result, ncol, nrow);\n    }\n\n    // ----------\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n    }\n\n    function setInfo(string calldata _name, string calldata _symbol) external onlyOwner {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function setMintable(bool _mintable) external onlyOwner {\n        mintable = _mintable;\n    }\n\n    function setDimensionLimit(uint16 _dimensionLimits) external onlyOwner {\n        dimensionLimits = _dimensionLimits;\n    }\n\n    // only in case we need to patch the art logic\n    function setTokenDescriptor(address _descriptor) external onlyOwner {\n        tokenDescriptor = _descriptor;\n    }\n}\n\ninterface IERC721Descriptor {\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/NFTDescriptor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"./NFTArt.sol\";\nimport \"base64-sol/base64.sol\";\n\nlibrary NFTDescriptor {\n    function constructTokenURI(\n        uint256 tokenId,\n        uint256 result,\n        uint256 ncol,\n        uint256 nrow,\n        uint256 salt,\n        string memory collectionName\n    ) internal pure returns (string memory) {\n        string memory image = Base64.encode(NFTArt.drawSVG(result, ncol, nrow, salt));\n        bytes memory metadata = abi.encodePacked(\n            '{\"name\":\"',\n            collectionName,\n            \" #\",\n            uintToString(tokenId),\n            '\", \"description\":\"',\n            \"Completely on-chain generative art collection. Art is uniquely generated based on the minter's result in our rebranding game. Limited edition. \\\\n\\\\nThe minter's result:\\\\n\",\n            makeSquares(result, ncol, nrow),\n            '\", \"image\": \"',\n            \"data:image/svg+xml;base64,\",\n            image,\n            '\"}'\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(metadata)));\n    }\n\n    function makeSquares(\n        uint256 result,\n        uint256 ncol,\n        uint256 nrow\n    ) internal pure returns (string memory) {\n        unchecked {\n            bytes[8] memory rows;\n            for (uint256 q = 0; q < nrow; ++q) {\n                string[8] memory strs;\n                for (uint256 p = ncol - 1; p != type(uint256).max; --p) {\n                    uint256 res = result % 3;\n                    strs[p] = res == 0 ? hex\"e2ac9cefb88f\" : res == 1 ? hex\"f09f9fa8\" : hex\"f09f9fa9\";\n                    result /= 3;\n                }\n                rows[q] = abi.encodePacked(strs[0], strs[1], strs[2], strs[3], strs[4], strs[5], strs[6], strs[7], \"\\\\n\");\n            }\n            return string(abi.encodePacked(rows[0], rows[1], rows[2], rows[3], rows[4], rows[5], rows[6], rows[7]));\n        }\n    }\n\n    function makeImageURI(\n        uint256 result,\n        uint256 ncol,\n        uint256 nrow,\n        uint256 salt\n    ) internal pure returns (string memory) {\n        string memory image = Base64.encode(NFTArt.drawSVG(result, ncol, nrow, salt));\n        return string(abi.encodePacked(\"data:image/svg+xml;base64,\", image));\n    }\n\n    function uintToString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/NFTArt.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"./RNG.sol\";\n\nlibrary NFTArt {\n    using RNG for RNG.Data;\n\n    uint256 internal constant W_BASE = 30;\n    uint256 internal constant W_RAND = 30;\n    uint256 internal constant L_BASE = 30;\n    uint256 internal constant L_RAND = 30;\n    uint256 internal constant H_BASE = 20;\n    uint256 internal constant H_RAND = 40;\n    uint256 internal constant LAST_ROW_MIN_L = 55;\n    uint256 internal constant FIRST_COL_MIN_W = 25;\n\n    bytes6 internal constant FRAME_COLOR = \"332E22\";\n    bytes6 internal constant COLOR1 = \"E8E4DC\";\n    bytes internal constant COLOR2 = \"6688EE6688EEFCBC18FDBD2EFE514EF2532DE7AC52EC6B2558C9EDEC6B25457DB6FCD265999999C3B89FF4AB13208793\";\n    bytes internal constant COLOR3 = \"EE6666EE666628A7914561CC6CC2820B9594639AA0639AA0EF8FA3623A53DC5357DC505355555550978E9FBBC1C92B28\";\n    bytes internal constant BG_COLOR = \"FBF5E9FBF5E9FBECE9F7F2E6ECEBE8EAEAEAF5EEE6\";\n\n    int256 internal constant LOGO_LENGTH = 112 * 35; // logo scale: 35\n    int256 internal constant SCALE = 100;\n    int256 internal constant OFFSET_X = ((600 / 2) + 0) * SCALE;\n    int256 internal constant OFFSET_Y = ((600 / 2) + 20) * SCALE;\n    int256 internal constant COS_30 = 86602540;\n    int256 internal constant SIN_30 = 50000000;\n\n    /**\n     * w:       block width\n     * l:       block length\n     * h:       block height\n     * (p, q):  block position in virtual plane\n     * (x, y):  block position in projected plane\n     */\n\n    function isometric(int256 p, int256 q) internal pure returns (int256 x, int256 y) {\n        unchecked {\n            x = ((p + q) * COS_30) / 1e8 + OFFSET_X;\n            y = ((q - p) * SIN_30) / 1e8 + OFFSET_Y;\n        }\n    }\n\n    function intToString(int256 value) internal pure returns (bytes5 buffer) {\n        assert(value >= 0 && value <= 99999);\n        unchecked {\n            // prettier-ignore\n            buffer = bytes5(0x3030303030 + uint40(\n                ((((uint256(value) / 1e0) % 10)) << 0) |\n                ((((uint256(value) / 1e1) % 10)) << 8) |\n                ((((uint256(value) / 1e2) % 10)) << 16) |\n                ((((uint256(value) / 1e3) % 10)) << 24) |\n                ((((uint256(value) / 1e4) % 10)) << 32)\n            ));\n        }\n    }\n\n    function pickColor(bytes memory choices, uint256 rand) internal pure returns (bytes6 picked) {\n        unchecked {\n            uint256 i = (rand % (choices.length / 6)) * 6;\n            assembly {\n                picked := mload(add(add(choices, 32), i))\n            }\n        }\n    }\n\n    struct Plane {\n        int256 ax;\n        int256 ay;\n        int256 bx;\n        int256 by;\n        int256 cx;\n        int256 cy;\n        int256 dx;\n        int256 dy;\n    }\n\n    function makeBlock(\n        int256 p,\n        int256 q,\n        int256 w,\n        int256 l,\n        int256 h,\n        bytes6 color,\n        bool addLogo\n    ) internal pure returns (bytes memory blk) {\n        unchecked {\n            Plane memory ground;\n            (ground.ax, ground.ay) = isometric(p, q);\n            (ground.bx, ground.by) = isometric(p + w, q);\n            (ground.cx, ground.cy) = isometric(p + w, q + l);\n            (ground.dx, ground.dy) = isometric(p, q + l);\n\n            Plane memory cover = Plane({\n                ax: ground.ax,\n                ay: ground.ay - h,\n                bx: ground.bx,\n                by: ground.by - h,\n                cx: ground.cx,\n                cy: ground.cy - h,\n                dx: ground.dx,\n                dy: ground.dy - h\n            });\n\n            // prettier-ignore\n            bytes memory coverCode = abi.encodePacked(\n                '<path d=\"M', intToString(cover.ax), \",\", intToString(cover.ay),\n                \"L\", intToString(cover.bx), \",\", intToString(cover.by),\n                \"L\", intToString(cover.cx), \",\", intToString(cover.cy),\n                \"L\", intToString(cover.dx), \",\", intToString(cover.dy), 'Z\" fill=\"#', color, '\"/>'\n            );\n            // prettier-ignore\n            bytes memory sides = abi.encodePacked(\n                '<path d=\"M', intToString(cover.ax), \",\", intToString(cover.ay),\n                \"L\", intToString(cover.dx), \",\", intToString(cover.dy),\n                \"L\", intToString(cover.cx), \",\", intToString(cover.cy),\n                \"V\", intToString(ground.cy),\n                \"L\", intToString(ground.dx), \",\", intToString(ground.dy),\n                \"L\", intToString(ground.ax), \",\", intToString(ground.ay), 'Z\"/>'\n            );\n            blk = abi.encodePacked(sides, coverCode);\n\n            if (addLogo) {\n                (int256 x, int256 y) = isometric(p + w / 2, q + (l - LOGO_LENGTH) / 2);\n                blk = abi.encodePacked(blk, '<use href=\"#logo\" x=\"', intToString(x), '\" y=\"', intToString(y - h), '\"/>');\n            }\n        }\n    }\n\n    function makeBlocks(Config memory cfg) internal pure returns (bytes[8] memory rows) {\n        unchecked {\n            int256 qMemo = 0;\n            for (uint256 q = 0; q < cfg.nrow; q++) {\n                bytes[8] memory bs;\n                int256 l = int256(cfg.ls[q]);\n\n                uint256 i = 0;\n                for (uint256 p = cfg.ncol - 1; p != type(uint256).max; --p) {\n                    bytes6 color = cfg.colors[cfg.result % 3];\n                    int256 w = int256(cfg.ws[p]);\n                    int256 h = int256(cfg.hs[q][p]);\n                    int256 pAdjusted = cfg.offsetP + int256(p == 0 ? 0 : cfg.wsCumSum[p - 1]);\n                    int256 qAdjusted = cfg.offsetQ + qMemo;\n                    bool addLogo = q == cfg.nrow - 1 && p == 0;\n\n                    bs[i++] = makeBlock(pAdjusted, qAdjusted, w, l, h, color, addLogo);\n                    cfg.result /= 3;\n                }\n                rows[q] = abi.encodePacked(bs[0], bs[1], bs[2], bs[3], bs[4], bs[5], bs[6], bs[7]);\n                qMemo += l;\n            }\n        }\n    }\n\n    function makeSvg(Config memory cfg) internal pure returns (bytes memory svg) {\n        bytes[8] memory rows = makeBlocks(cfg);\n        svg = abi.encodePacked(\n            '<svg viewBox=\"0 0 60000 60000\" xmlns=\"http://www.w3.org/2000/svg\">'\n            '<def><g id=\"logo\" fill=\"#332E22\" stroke-width=\"0\" transform=\"scale(35)\">'\n            '<path d=\"M18 20c2 1 2.3 2.3.6 3.2S14 24 12 23c-2-1-2.2-2.4-.6-3.2s4.6-1 6.6.1zm5.3 12.6c1.7-1 1.4-2.3-.6-3.2s-5-1-6.5-.2-1.3 2.3.6 3.2c2 1 4.8 1 6.5.2z\"/>'\n            '<path fill-rule=\"evenodd\" d=\"M80 19.5C84.6 1 29.2-3.6 11 8-8.7 17.8 1 48 35.7 44.4c.2.2.5.3.8.4l23 9.8c1.8.8 4.3.7 6-.2L99.8 35c1.6-1 1.6-2.2.1-3.2l-19-12c-.3-.2-.6-.3-1-.4zM48.6 34C16.5 51-6.8 22.3 16 10.5 10 22 78 15.4 48.6 34zm45.2-.6l-13 7.4c-3-1-9.8-6.7-13.5-4.3-4.4 2 6.6 5.5 8.6 7L71 46.3c-3-1-11-6.5-14-4-3.8 2 7.4 5.2 9.5 6.6l-4 2.3L42.8 43l35-19.7 16 10.2z\"/>'\n            \"</g></def>\"\n            '<rect width=\"60000\" height=\"60000\" fill=\"#',\n            cfg.frameColor,\n            '\"/>'\n            '<rect x=\"2500\" y=\"2500\" width=\"55000\" height=\"55000\" stroke=\"#332E22\" stroke-width=\"200\" fill=\"#',\n            cfg.bgColor,\n            '\"/>'\n            '<g fill=\"#332E22\" stroke=\"#332E22\" stroke-width=\"100\">'\n        );\n        svg = abi.encodePacked(svg, rows[0], rows[1], rows[2], rows[3], rows[4], rows[5], rows[6], rows[7], \"</g></svg>\");\n    }\n\n    // ------- config -------\n\n    struct Config {\n        uint256 result;\n        uint256 ncol;\n        uint256 nrow;\n        int256 offsetP;\n        int256 offsetQ;\n        uint256[8] ws;\n        uint256[8] ls;\n        uint256[8][8] hs;\n        uint256[8] wsCumSum;\n        bytes6[3] colors;\n        bytes6 bgColor;\n        bytes6 frameColor;\n    }\n\n    function generateConfig(\n        uint256 result,\n        uint256 ncol,\n        uint256 nrow,\n        uint256 salt\n    ) internal pure returns (Config memory cfg) {\n        RNG.Data memory rng = RNG.Data(salt, 0);\n\n        cfg.result = result;\n        cfg.ncol = ncol;\n        cfg.nrow = nrow;\n\n        cfg.colors[0] = COLOR1;\n        cfg.colors[1] = pickColor(COLOR2, rng.rand());\n        cfg.colors[2] = pickColor(COLOR3, rng.rand());\n        cfg.bgColor = pickColor(BG_COLOR, rng.rand());\n        cfg.frameColor = FRAME_COLOR;\n\n        while (true) {\n            // generate widths\n            unchecked {\n                uint256[8] memory ws = cfg.ws;\n                uint256[8] memory wsCumSum = cfg.wsCumSum;\n                uint256 rand = rng.rand();\n                uint256 memo = 0;\n                for (uint256 p = 0; p < ncol; ++p) {\n                    uint256 w = (W_BASE + ((rand >> (8 * p)) % W_RAND)) * uint256(SCALE);\n                    if (p == 0 && w < FIRST_COL_MIN_W) w = FIRST_COL_MIN_W;\n                    wsCumSum[p] = (memo += (ws[p] = w));\n                }\n                cfg.offsetP = -int256(memo) / 2;\n            }\n\n            // generate lengths\n            unchecked {\n                uint256[8] memory ls = cfg.ls;\n                uint256 rand = rng.rand();\n                uint256 memo = 0;\n                for (uint256 q = 0; q < nrow; ++q) {\n                    uint256 l = (L_BASE + ((rand >> (8 * q)) % L_RAND)) * uint256(SCALE);\n                    if (q == nrow - 1 && l < LAST_ROW_MIN_L) l = LAST_ROW_MIN_L;\n                    memo += (ls[q] = l);\n                }\n                cfg.offsetQ = -int256(memo) / 2;\n            }\n\n            // ensure no \"out of canvas\"\n            (int256 x0, ) = isometric(cfg.offsetP, cfg.offsetQ);\n            if (x0 >= 3000) break;\n        }\n\n        // generate heights\n        unchecked {\n            uint256[8][8] memory hs = cfg.hs;\n            for (uint256 q = 0; q < nrow; ++q) {\n                uint256 rand = rng.rand();\n                for (uint256 p = 0; p < ncol; ++p) {\n                    hs[q][p] = (H_BASE + ((rand >> (8 * p)) % H_RAND)) * uint256(SCALE);\n                }\n            }\n        }\n    }\n\n    // ------- entry point -------\n\n    function drawSVG(\n        uint256 result,\n        uint256 ncol,\n        uint256 nrow,\n        uint256 salt\n    ) internal pure returns (bytes memory svg) {\n        return makeSvg(generateConfig(result, ncol, nrow, salt));\n    }\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/RNG.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.10;\n\nlibrary RNG {\n    struct Data {\n        uint256 seed;\n        uint256 i;\n    }\n\n    function rand(Data memory rng) internal pure returns (uint256) {\n        unchecked {\n            return uint256(keccak256(abi.encode(rng.seed, rng.i++)));\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}