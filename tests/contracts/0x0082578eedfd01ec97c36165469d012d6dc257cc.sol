{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Infinity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./libraries/InfiniteArt.sol\";\nimport \"./libraries/InfiniteBags.sol\";\nimport \"./libraries/InfiniteGenerator.sol\";\nimport \"./libraries/InfiniteMetadata.sol\";\n\nimport \"./standards/ERC1155.sol\";\n\n/// @title Infinity token contract.\n/// @notice Imo notable.\n/// @author Visualize Value\ncontract Infinity is ERC1155 {\n\n    /// @notice The name of the collection.\n    string public name = \"Infinity\";\n\n    /// @notice The symbol of the collection.\n    string public symbol = unicode\"∞\";\n\n    /// @notice The price of an infinity token.\n    uint public price = 0.008 ether;\n\n    /// @dev VV creator account.\n    address private constant VV = 0xc8f8e2F59Dd95fF67c3d39109ecA2e2A017D4c8a;\n\n    /// @dev Instanciate the contract...\n    constructor(address[] memory genesisRecipients) ERC1155() payable {\n        _checkDeposit(genesisRecipients.length);\n\n        uint count = genesisRecipients.length;\n        for (uint i = 0; i < count;) {\n            _mint(genesisRecipients[i], 0, 1, \"\");\n\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Deposit ether, receive random infinities\n    receive() external payable {\n        _generateViaDeposit(msg.sender, _randomId());\n    }\n\n    /// @notice Create a new infinity check and deposit 0.008 ETH for each token.\n    /// @param recipient The address that should receive the token.\n    /// @param message Mint the token with an optional message.\n    function generate(\n        address recipient,\n        string calldata message\n    ) public payable {\n        uint tokenId = _randomId();\n\n        _generateViaDeposit(recipient, tokenId);\n\n        _message(recipient, tokenId, message);\n    }\n\n    /// @notice Copy an existing infinity check owned by someone and deposit 0.008 ETH for each token.\n    /// @param source The address of an existing owner of the token.\n    /// @param recipient The address that should receive the token.\n    /// @param tokenId The token ID to mint.\n    /// @param message Mint the token with an optional message.\n    function generateExisting(\n        address source,\n        address recipient,\n        uint tokenId,\n        string calldata message\n    ) public payable {\n        _validateId(tokenId, source);\n\n        _generateViaDeposit(recipient, tokenId);\n\n        _message(recipient, tokenId, message);\n    }\n\n    /// @notice Swap an inifinity token for a new one.\n    /// @param id The token ID to burn.\n    /// @param amount The token amount to burn / recreate.\n    function regenerate(uint id, uint amount) public {\n        // Execute burn\n        _burn(msg.sender, id, amount);\n\n        // Mint a new token\n        _mint(msg.sender, _randomId(), amount, \"\");\n    }\n\n    /// @notice Destroy the token to withdraw its desposited ETH.\n    /// @param id The token ID to destroy.\n    /// @param amount The amount to degenerate (withdraws 0.008 ETH per item).\n    function degenerate(\n        uint id,\n        uint amount\n    ) public {\n        // Execute burn\n        _burn(msg.sender, id, amount);\n\n        // Withdraw funds\n        _send(msg.sender, amount * price);\n    }\n\n    /// @notice Create multiple infinity check tokens and deposit 0.008 ETH in each.\n    /// @param recipients The addresses that should receive the token.\n    /// @param amounts The number of tokens to send to each recipient.\n    function generateMany(\n        address[] calldata recipients,\n        uint[] calldata amounts\n    ) public payable {\n        _checkDeposit(_totalAmount(amounts));\n\n        uint count = recipients.length;\n        for (uint i = 0; i < count;) {\n            _mint(recipients[i], _randomId(), amounts[i], \"\");\n\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Copy multiple infinity check tokens and deposit 0.008 ETH in each.\n    /// @param sources The addresses of existing owners of each token.\n    /// @param recipients The addresses that should receive the token.\n    /// @param tokenIds The tokenIDs to mint.\n    /// @param amounts The number of tokens to send for each token.\n    function generateManyExisting(\n        address[] calldata sources,\n        address[] calldata recipients,\n        uint[] calldata tokenIds,\n        uint[] calldata amounts\n    ) public payable {\n        _checkDeposit(_totalAmount(amounts));\n\n        uint count = sources.length;\n        for (uint i = 0; i < count;) {\n            _validateId(tokenIds[i], sources[i]);\n\n            _mint(recipients[i], tokenIds[i], amounts[i], \"\");\n\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Create multiple new infinity check tokens and deposit 0.008 ETH in each.\n    /// @param ids The existing token IDs that should be destroyed in the process.\n    /// @param degenerateAmounts The number of tokens per id to burn.\n    /// @param amounts The number of tokens per id recreate.\n    function regenerateMany(\n        uint[] calldata ids,\n        uint[] calldata degenerateAmounts,\n        uint[] calldata amounts\n    ) public payable {\n        if (_totalAmount(degenerateAmounts) != _totalAmount(amounts)) revert InvalidInput();\n\n        uint count = ids.length;\n        for (uint i = 0; i < count;) {\n            _burn(msg.sender, ids[i], degenerateAmounts[i]);\n            _mint(msg.sender, _randomId(), amounts[i], \"\");\n\n            unchecked { ++i; }\n        }\n    }\n\n    /// @notice Degenerate multiple tokens at once.\n    /// @param ids The tokenIDs to destroy.\n    /// @param amounts The amounts to degenerate (withdraws 0.008 ETH per item).\n    function degenerateMany(\n        uint[] memory ids,\n        uint[] memory amounts\n    ) public {\n        if (ids.length != amounts.length) revert InvalidInput();\n\n        // Execute burn\n        _burnBatch(msg.sender, ids, amounts);\n\n        // Withdraw funds\n        _send(msg.sender, _totalAmount(amounts) * price);\n    }\n\n    /// @notice Render SVG of the token.\n    /// @param tokenId The token ID to render.\n    function svg(uint tokenId) public pure returns (string memory) {\n        return InfiniteArt.renderSVG(InfiniteGenerator.tokenData(tokenId));\n    }\n\n    /// @notice Render the encoded token metadata-URI.\n    /// @param tokenId The token ID to get metadata for.\n    function uri(uint tokenId) public pure override returns (string memory) {\n        return InfiniteMetadata.tokenURI(InfiniteGenerator.tokenData(tokenId));\n    }\n\n    /// @notice Supply is (in)finite: (2^256 - 1)^2.\n    function totalSupply() public pure returns (uint) { return type(uint).max; }\n    function totalSupply(uint) public pure returns (uint) { return type(uint).max; }\n\n    /// @dev Mint a token n times, based on the amount of ETH sent.\n    function _generateViaDeposit(address recipient, uint tokenId) internal {\n        uint amount  = msg.value / price;\n        uint surplus = msg.value % price;\n\n        if (amount == 0) revert InvalidDesposit();\n\n        _mint(recipient, tokenId, amount, \"\");\n        _send(recipient, surplus);\n    }\n\n    /// @dev Validate IDs to minted tokens or randomize for initial mints. Exception for VV mints.\n    function _validateId(uint id, address source) internal view {\n        bool minted = balanceOf(source, id) > 0;\n\n        // If it's not already minted piece, or we are not VV, revert.\n        if(! minted && msg.sender != VV) revert InvalidToken();\n    }\n\n    /// @dev Make a random generative token ID.\n    function _randomId() internal view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.prevrandao, msg.sender, gasleft())));\n    }\n\n    /// @dev Check whether the deposited Ether is a correct {price} multipe of the token {amount}\n    function _checkDeposit(uint amount) internal {\n        if (msg.value != amount * price) revert InvalidDesposit();\n    }\n\n    /// @dev Get the sum of all given amounts\n    function _totalAmount(uint[] memory amounts) internal pure returns (uint amount) {\n        for (uint i = 0; i < amounts.length; i++) {\n            amount += amounts[i];\n        }\n    }\n\n    /// @dev Send ETH to an address\n    function _send(address to, uint value) internal {\n        (bool success, ) = payable(to).call{value: value}(\"\");\n        require(success, \"Unable to send value, recipient may have reverted\");\n    }\n\n    /// @dev Emit a mint message, if provided\n    function _message(address recipient, uint tokenId, string calldata message) internal {\n        if (bytes(message).length > 0) {\n            emit Message(msg.sender, recipient, tokenId, message);\n        }\n    }\n}\n"
    },
    "contracts/libraries/InfiniteArt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./InfiniteBags.sol\";\nimport \"./Utilities.sol\";\n\n/**\n@title  InfiniteArt\n@author VisualizeValue\n@notice Renders the Infinity visuals.\n*/\nlibrary InfiniteArt {\n\n    /// @dev Generate the SVG code for an Infinity token.\n    function renderSVG(Token memory data) public pure returns (string memory) {\n        return string.concat(\n            '<svg viewBox=\"0 0 800 800\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">',\n                renderStyle(data),\n                renderDefs(),\n                '<rect width=\"800\" height=\"800\" fill=\"var(--bg)\" />',\n                '<g transform=\"scale(0.95)\" transform-origin=\"center\">',\n                    renderGrid(),\n                '</g>',\n                renderNoise(data),\n                '<g transform=\"scale(0.95)\" transform-origin=\"center\">',\n                    renderSymbols(data),\n                '</g>',\n            '</svg>'\n        );\n    }\n\n    /// @dev Render CSS variables.\n    function renderStyle(Token memory data) public pure returns (string memory) {\n        return string.concat(\n            '<style>',\n                ':root {',\n                    '--bg: ', data.background, ';',\n                    '--gr: ', data.gridColor, ';',\n                '}',\n            '</style>'\n        );\n    }\n\n    /// @dev Render SVG meta defenitions.\n    function renderDefs() public pure returns (string memory) {\n        return string.concat(\n            '<defs>',\n                '<rect id=\"box\" width=\"100\" height=\"100\" stroke=\"var(--gr)\" stroke-width=\"3\" style=\"paint-order: stroke;\" />'\n                '<g id=\"row\">', renderGridRow(), '</g>',\n                '<mask id=\"mask\"><rect width=\"800\" height=\"800\" fill=\"white\"/></mask>',\n                '<path id=\"loop\" d=\"M 100 0 A 100 100, 0, 1, 1, 0 100 L 0 0 Z\"/>',\n                '<g id=\"infinity\">',\n                    '<use href=\"#loop\" />',\n                    '<use href=\"#loop\" transform=\"scale(-1,-1)\" />',\n                '</g>',\n                '<filter id=\"noise\">',\n                    '<feTurbulence type=\"fractalNoise\" baseFrequency=\"0.8\" stitchTiles=\"stitch\" numOctaves=\"1\" seed=\"8\"/>',\n                    '<feColorMatrix type=\"saturate\" values=\"0\"/>',\n                '</filter>',\n            '</defs>'\n        );\n    }\n\n    /// @dev Generate the SVG code for the entire 8x8 grid.\n    function renderGrid() public pure returns (string memory) {\n        string memory grid;\n        for (uint256 i; i < 8; i++) {\n            grid = string.concat(\n                grid,\n                '<use href=\"#row\" transform=\"translate(0,', str(i*100), ')\" />'\n            );\n        }\n\n        return grid;\n    }\n\n    /// @dev Generate the SVG code for rows in the 8x8 grid.\n    function renderGridRow() public pure returns (string memory) {\n        string memory row;\n        for (uint256 i; i < 8; i++) {\n            row = string.concat(\n                row,\n                '<use transform=\"translate(', str(i*100), ')\" href=\"#box\" />'\n            );\n        }\n        return row;\n    }\n\n    /// @dev Render the noise layer.\n    function renderNoise(Token memory data) public pure returns (string memory) {\n        return string.concat(\n            '<rect mask=\"url(#mask)\" width=\"800\" height=\"800\" fill=\"black\" filter=\"url(#noise)\" ',\n                'style=\"mix-blend-mode: multiply;\" opacity=\"', data.light ? '0.248\"' : '0.8\"',\n            '/>'\n        );\n    }\n\n    /// @dev Generate SVG code for the symbols.\n    function renderSymbols(Token memory data) public pure returns (string memory) {\n        uint space  = 800 / data.grid;\n        uint center = space / 4;\n        uint width  = space / 2;\n\n        string memory symbols;\n        for (uint i = 0; i < data.count; i++) {\n            Symbol memory symbol = data.symbols[i];\n\n            uint baseStroke = symbol.isInfinity ? 8 : 4;\n            uint stroke = (data.grid < 8 ? baseStroke : baseStroke * 3 / 4) * data.grid / 2;\n            uint scale  = width * 1000 / symbol.formWidth;\n\n            symbol.x      = str(i % data.grid * space + center);\n            symbol.y      = str(i / data.grid * space + center);\n            symbol.stroke = str(stroke);\n            symbol.center = str(center);\n            symbol.width  = str(width);\n            symbol.scale  = scale < 1000\n                ? string.concat('0.', str(scale))\n                : str(scale / 1000);\n\n            symbols = string.concat(symbols, renderSymbol(symbol));\n        }\n        return symbols;\n    }\n\n    /// @dev Generate SVG code for the symbols.\n    function renderSymbol(Symbol memory symbol) public pure returns (string memory) {\n        symbol.color.rendered = renderColor(symbol.color);\n\n        string memory rendered = symbol.form == 1 ? renderLoop(symbol)\n                               : symbol.form == 2 ? renderInfinitySingle(symbol)\n                               : symbol.form == 3 ? render90Loop(symbol)\n                               : symbol.form == 4 ? renderInfinityPair(symbol)\n                               : symbol.form == 5 ? render180Loop(symbol)\n                               : symbol.form == 8 ? renderInfinityCheck(symbol)\n                                                  : render360Loop(symbol);\n\n        return string.concat(\n            '<g transform=\"translate(',symbol.x,',',symbol.y,') rotate(',symbol.rotation,')\" ',\n                'transform-origin=\"',symbol.center,' ',symbol.center,'\" ',\n                'stroke-width=\"', symbol.stroke,\n            '\">',\n                rendered,\n            '</g>'\n        );\n    }\n\n    /// @dev Helper to render a color to its SVG compliant HSL string.\n    function renderColor(Color memory color) public pure returns (string memory) {\n        if (bytes(color.rendered).length > 0) return color.rendered;\n\n        return string.concat('hsl(', str(color.h), ' ', str(color.s), '% ', str(color.l), '%)');\n    }\n\n    /// @dev Render a single loop symbol.\n    function renderLoop(Symbol memory symbol) public pure returns (string memory) {\n        return string.concat(\n            '<use href=\"#loop\" transform=\"scale(', symbol.scale, ')\" stroke=\"', symbol.color.rendered, '\" />'\n        );\n    }\n\n    /// @dev Render two loop symbols, one rotated by 90 degrees.\n    function render90Loop(Symbol memory symbol) public pure returns (string memory) {\n        return string.concat(\n            '<g transform=\"scale(', symbol.scale, ')\" stroke=\"', symbol.color.rendered, '\">',\n                '<use href=\"#loop\" />',\n                '<use href=\"#loop\" transform=\"translate(200,0) scale(-1,1)\" />',\n            '</g>'\n        );\n    }\n\n    /// @dev Render two loop symbols, one rotated by 180 degrees.\n    function render180Loop(Symbol memory symbol) public pure returns (string memory) {\n        return string.concat(\n            '<g transform=\"scale(', symbol.scale, ')\" stroke=\"', symbol.color.rendered, '\">',\n                '<use href=\"#loop\" />',\n                '<use href=\"#loop\" transform=\"translate(200,200) scale(-1,-1)\" />',\n            '</g>'\n        );\n    }\n\n    /// @dev Render four loop symbols to form a square.\n    function render360Loop(Symbol memory symbol) public pure returns (string memory) {\n        return string.concat(\n            '<g transform=\"scale(', symbol.scale, ')\" stroke=\"', symbol.color.rendered, '\">',\n                '<use href=\"#loop\" />',\n                '<use href=\"#loop\" transform=\"translate(200,0) scale(-1,1)\" />',\n                '<use href=\"#loop\" transform=\"translate(0,200) scale(1,-1)\" />',\n                '<use href=\"#loop\" transform=\"translate(200,200) scale(-1,-1)\" />',\n            '</g>'\n        );\n    }\n\n    /// @dev Check: Render a single infinity.\n    function renderInfinitySingle(Symbol memory symbol) public pure returns (string memory) {\n        return string.concat(\n            '<g transform=\"scale(', symbol.scale, ')\" stroke=\"', symbol.color.rendered, '\">',\n                '<g transform=\"translate(200,200)\">'\n                    '<use href=\"#infinity\" />',\n                '</g>'\n            '</g>'\n        );\n    }\n\n    /// @dev Double check: Render an infinity pair.\n    function renderInfinityPair(Symbol memory symbol) public pure returns (string memory) {\n        return string.concat(\n            '<g transform=\"scale(', symbol.scale, ')\" stroke=\"', symbol.color.rendered, '\">',\n                '<g transform=\"translate(200,200)\">'\n                    '<use href=\"#infinity\" />',\n                    '<use href=\"#infinity\" transform=\"rotate(90)\" />',\n                '</g>'\n            '</g>'\n        );\n    }\n\n    /// @dev Quadruple check: Render an infinity check.\n    function renderInfinityCheck(Symbol memory symbol) public pure returns (string memory) {\n        return string.concat(\n            '<g transform=\"scale(', symbol.scale, ')\" stroke=\"', symbol.color.rendered, '\">',\n                '<g transform=\"translate(200,200)\">'\n                    '<use href=\"#infinity\" />',\n                    '<use href=\"#infinity\" transform=\"rotate(45)\" />',\n                    '<use href=\"#infinity\" transform=\"rotate(90)\" />',\n                    '<use href=\"#infinity\" transform=\"rotate(135)\" />',\n                '</g>'\n            '</g>'\n        );\n    }\n\n    /// @dev Uint to string helper.\n    function str(uint n) public pure returns (string memory) {\n        return Utilities.uint2str(n);\n    }\n}\n"
    },
    "contracts/libraries/InfiniteBags.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n@title  InfiniteBags\n@author VisualizeValue\n@notice Bags to hold infinity token data. Imo pretty funny...\n*/\n\n/// @dev Bag holding computed token data.\nstruct Token {\n    uint seed;\n    string background;\n    string gridColor;\n    uint8 alloy;\n    uint8 grid;\n    uint8 count;\n    uint8 band;\n    uint8 gradient;\n    bool continuous;\n    bool mapColors;\n    bool light;\n    Symbol[64] symbols;\n}\n\n/// @dev Bag holding computed symbol data.\nstruct Symbol {\n    uint form;\n    uint16 formWidth;\n    bool isInfinity;\n    string rotation;\n    string stroke;\n    string center;\n    string scale;\n    string width;\n    string x;\n    string y;\n    uint colorIdx;\n    Color color;\n}\n\n/// @dev Bag holding color data.\nstruct Color {\n    uint16 h;\n    uint16 s;\n    uint16 l;\n    string rendered;\n}\n"
    },
    "contracts/libraries/InfiniteGenerator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./InfiniteBags.sol\";\nimport \"./Utilities.sol\";\n\n/**\n@title  InfiniteGenerator\n@author VisualizeValue\n@notice Gathers the data to render Infinity visuals.\n*/\nlibrary InfiniteGenerator {\n\n    /// @dev 16 distinct colors + void.\n    uint8 public constant ELEMENTS = 17;\n\n    /// @dev Number of shades for each color.\n    uint8 public constant SHADES = 4;\n\n    /// @dev Collect relevant rendering data for easy access across functions.\n    function tokenData(uint tokenId) public pure returns (Token memory data) {\n        data.seed        = tokenId;\n        data.light       = tokenId % 4096 == 0 ? true : false;\n        data.background  = data.light == true ? '#FFFFFF' : '#111111';\n        data.gridColor   = data.light == true ? '#F5F5F5' : '#19181B';\n        data.grid        = getGrid(data);\n        data.count       = data.grid ** 2;\n        data.alloy       = getAlloy(data);\n        data.band        = getBand(data);\n        data.continuous  = getContinuous(data);\n        data.gradient    = getGradient(data);\n        data.mapColors   = getColorMap(data);\n        data.symbols     = getSymbols(data);\n    }\n\n    /// @dev Define the grid for a token.\n    function getGrid(Token memory data) public pure returns (uint8) {\n        if (data.seed == 0) return 1; // Genesis token override.\n\n        uint n = Utilities.random(data.seed, 'grid', 160);\n\n        return n <  1 ? 1\n             : n <  8 ? 2\n             : n < 32 ? 4\n                      : 8;\n    }\n\n    /// @dev Define the color band size for a token.\n    function getBand(Token memory data) public pure returns (uint8) {\n        // Four times the number of used elements, min 1.\n        return Utilities.max(data.alloy * SHADES, 1);\n    }\n\n    /// @dev Whether to map symbols to colors.\n    function getColorMap(Token memory data) public pure returns (bool) {\n        // 20% for gradients; 8% for skittles.\n        return data.gradient > 0\n            ? Utilities.random(data.seed, 'color_map', 100) < 20\n            : Utilities.random(data.seed, 'color_map', 100) < 8;\n    }\n\n    /// @dev Whether color banding is continuous or random. 50/50.\n    function getContinuous(Token memory data) public pure returns (bool) {\n        return Utilities.random(data.seed, 'continuous', 2) < 1;\n    }\n\n    /// @dev Get the number of distinct elements used. 0 for Isolates.\n    function getAlloy(Token memory data) public pure returns (uint8) {\n        if (data.grid == 1) return 0;\n\n        uint8 n = uint8(Utilities.random(data.seed, 'alloy', 100));\n\n        return n >= 56 ? 4 + n % (ELEMENTS - 4) // Complete\n             : n >= 24 ? 2                     // Compound\n             : n >=  4 ? 1                    // Composite\n                       : 0;                  // Isolate\n    }\n\n    /// @dev Choose a gradient for the token.\n    function getGradient(Token memory data) public pure returns (uint8) {\n        if (data.grid == 1 || data.alloy == 0) return 0; // No gradients for 1x1 or isolate tokens\n        if (Utilities.random(data.seed, 'gradient', 10) < 8) return 0; // 80% have no gradient\n\n        uint8 options = data.grid == 2 ? 2 : 7;\n        uint8[7] memory GRADIENTS = data.grid == 2 ? [1, 2, 0, 0, 0, 0, 0]\n                                  : data.grid == 4 ? [1, 2, 3, 4, 5, 8, 10]\n                                                   : [1, 2, 4, 7, 8, 9, 16];\n\n        return GRADIENTS[Utilities.random(data.seed, 'select_gradient', options)];\n    }\n\n    /// @dev Get the symbols for all slots on the grid.\n    function getSymbols(Token memory data) public pure returns (Symbol[64] memory symbols) {\n        uint8[7] memory forms          = [1, 2, 3, 4, 5, 8, 9]; // Seven distinct symbols.\n        uint8[7] memory rotationCounts = [2, 4, 4, 2, 2, 0, 0]; // How often we rotate.\n\n        (uint[64] memory colorIndexes, Color[64] memory colors) = getColors(data);\n        uint[64] memory formColorMap;\n\n        for (uint i = 0; i < data.count; i++) {\n            symbols[i].colorIdx = colorIndexes[i];\n            symbols[i].color = colors[i];\n\n            uint formIdx = getFormIdx(data, i);\n            uint form = forms[formIdx];\n            if (data.mapColors) {\n                (formColorMap, form) = setGetMap(formColorMap, symbols[i].colorIdx, form);\n            }\n            symbols[i].form = form;\n\n            symbols[i].isInfinity = symbols[i].form % 2 == 0;\n            symbols[i].formWidth = symbols[i].isInfinity ? 400 : 200;\n\n            uint rotationIncrement = symbols[i].isInfinity ? 45 : 90;\n            uint rotations = rotationCounts[formIdx] > 0\n                ? Utilities.random(\n                    data.seed,\n                    string.concat('rotation', str(i)),\n                    rotationCounts[formIdx]\n                )\n                : 0;\n            symbols[i].rotation = str(rotations * rotationIncrement);\n        }\n    }\n\n    /// @dev Get shape of a given symbol of a token.\n    function getFormIdx(Token memory data, uint i) public pure returns (uint) {\n        if (data.seed == 0) return 5; // Genesis token is an infinity flower.\n\n        uint random = Utilities.random(data.seed, string.concat('form', str(i)), 10);\n        if (random == 0) return 0; // 10% Single Loops\n\n        uint8[3] memory common = [1, 3, 5]; // Infinities\n        uint8[3] memory uncommon = [2, 4, 6]; // Loops\n\n        uint idx = Utilities.random(data.seed, string.concat('form-idx', str(i)), 3);\n        return random < 8 ? common[idx] : uncommon[idx];\n    }\n\n    /// @dev Get all colors available to choose from.\n    function allColors() public pure returns (Color[68] memory colors) {\n        // One \"Void\" color with 4 shades.\n        uint8[4] memory voidLums = [16, 32, 80, 96];\n        for (uint i = 0; i < SHADES; i++) {\n            colors[i].h = 270;\n            colors[i].s = 8;\n            colors[i].l = voidLums[i];\n        }\n\n        // 16 distinct colors with 4 shades each.\n        uint8 count = 4*4;\n        uint16 startHue = 256;\n        uint8[4] memory lums = [56, 60, 64, 72];\n        for (uint8 i = 0; i < 16; i++) {\n            uint16 hue = (startHue + 360 * i / count) % 360;\n\n            for(uint8 e = 0; e < 4; e++) {\n                uint8 idx = 4+i*4+e;\n                colors[idx].h = hue;\n                colors[idx].s = 88;\n                colors[idx].l = lums[e];\n            }\n        }\n    }\n\n    /// @dev Get the color variations for a specific token. Compute gradients / skittles.\n    function getColors(Token memory data) public pure returns (\n        uint[64] memory colorIndexes,\n        Color[64] memory colors\n    ) {\n        Color[68] memory all = allColors();\n        uint[68] memory options = getColorOptions(data);\n        bool reverse = Utilities.random(data.seed, 'reverse', 2) > 0;\n\n        for (uint i = 0; i < data.count; i++) {\n            colorIndexes[i] = (\n                data.gradient > 0\n                    ? getGradientColor(data, i)\n                    : getRandomColor(data, i)\n            ) % 68;\n\n            uint idx = reverse ? data.count - 1 - i : i;\n\n            colors[idx] = all[options[colorIndexes[i]]];\n\n            // Paradoxical, i know. Opepen your eyes. All one. Common fate.\n            if (data.light) colors[idx].rendered = '#080808';\n        }\n    }\n\n    /// @dev Get the colors to choose from for a given token.\n    function getColorOptions(Token memory data) public pure returns (uint[68] memory options) {\n        uint count = Utilities.max(1, data.alloy);\n        for (uint element = 0; element < count; element++) {\n            uint idx = element * SHADES;\n\n            uint chosen = data.continuous && element > 0\n                // Increment previous by one for a continuous band.\n                ? (options[idx - 1] / SHADES + 1) % ELEMENTS\n                // Random selection for hard shifts in color.\n                : Utilities.random(data.seed, string.concat('element', str(element)), ELEMENTS);\n\n            uint chosenIdx = chosen * SHADES;\n\n            for (uint shade = 0; shade < SHADES; shade++) {\n                options[idx + shade] = chosenIdx + shade;\n            }\n        }\n    }\n\n    /// @dev Compute the gradient colors for a gradient token.\n    function getGradientColor(Token memory data, uint i) public pure returns (uint) {\n        uint offset;\n        if (data.gradient == 3 || data.gradient == 7) {\n            // Fix angled gradient y-shift.\n            offset = data.grid + 1;\n        }\n\n        return ((offset + i) * data.gradient * data.band / data.count) % data.band;\n    }\n\n    /// @dev Compute colors for a skittle tokens.\n    function getRandomColor(Token memory data, uint i) public pure returns (uint) {\n        uint8 max = Utilities.max(SHADES, data.band);\n        string memory key = data.alloy == 0 ? '0' : str(i);\n        return Utilities.random(data.seed, string.concat('random_color_', key), max);\n    }\n\n    /// @dev Helper to keep track of a key value store in memory.\n    function setGetMap(\n        uint[64] memory map, uint key, uint value\n    ) public pure returns (uint[64] memory, uint) {\n        uint k = key % 64;\n\n        if (map[k] == 0) {\n            map[k] = value;\n        }\n\n        return (map, map[k]);\n    }\n\n    /// @dev Uint to string helper.\n    function str(uint n) public pure returns (string memory) {\n        return Utilities.uint2str(n);\n    }\n}\n"
    },
    "contracts/libraries/InfiniteMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\n\nimport \"./InfiniteBags.sol\";\nimport \"./InfiniteArt.sol\";\nimport \"./Utilities.sol\";\n\n/**\n@title  InfiniteMetadata\n@author VisualizeValue\n@notice Renders ERC1155 compatible metadata for Infinity tokens.\n*/\nlibrary InfiniteMetadata {\n\n    /// @dev Render the JSON Metadata for a given Infinity token.\n    /// @param data The render data for our token\n    function tokenURI(\n        Token memory data\n    ) public pure returns (string memory) {\n        bytes memory metadata = abi.encodePacked(\n            '{',\n                '\"name\": \"Infinity\",',\n                unicode'\"description\": \"∞\",',\n                '\"image\": ',\n                    '\"data:image/svg+xml;base64,',\n                    Base64.encode(abi.encodePacked(InfiniteArt.renderSVG(data))),\n                    '\",',\n                '\"attributes\": [', attributes(data), ']',\n            '}'\n        );\n\n        return string.concat(\n            \"data:application/json;base64,\",\n            Base64.encode(metadata)\n        );\n    }\n\n    /// @dev Render the JSON atributes for a given Infinity token.\n    /// @param data The check to render.\n    function attributes(Token memory data) public pure returns (string memory) {\n        return string.concat(\n            trait('Light', light(data.light), ','),\n            trait('Grid', grid(data), ','),\n            data.light  ? '' : trait('Elements',  elements(data), ','),\n            data.light  ? '' : trait('Gradient',  gradient(data), ','),\n            data.light  ? '' : trait('Band',      band(data), ','),\n            trait('Symbols',   symbols(data), '')\n        );\n    }\n\n    /// @dev Get the value for the 'Light' attribute.\n    function light(bool on) public pure returns (string memory) {\n        return on ? 'On' : 'Off';\n    }\n\n    /// @dev Get the value for the 'Grid' attribute.\n    function grid(Token memory data) public pure returns (string memory) {\n        string memory g = Utilities.uint2str(data.grid);\n\n        return string.concat(g, 'x', g);\n    }\n\n    /// @dev Get the value for the 'Elements' attribute.\n    function elements(Token memory data) public pure returns (string memory) {\n        return data.alloy == 0 ? 'Isolate'\n             : data.alloy == 1 ? 'Composite'\n             : data.alloy == 2 ? 'Compound'\n                               : 'Complete';\n    }\n\n    /// @dev Get the value for the 'Band' attribute.\n    function band(Token memory data) public pure returns (string memory) {\n        return (data.continuous || data.alloy < 2) ? 'Continuous' : 'Cut';\n    }\n\n    /// @dev Get the value for the 'Gradient' attribute.\n    function gradient(Token memory data) public pure returns (string memory) {\n        return [\n            // [0, 1, 2, 3, 4, 5, _, 7, 8, 9, 10, _, _, _, _, _, 16]\n            'None', 'Linear', 'Double Linear', 'Angled Down', 'Ordered', 'Angled Up', '', 'Angled Down', 'Linear Z',\n            'Angled', 'Angled Up', '', '', '', '', '', 'Double Linear Z'\n        ][data.gradient];\n    }\n\n    /// @dev Get the value for the 'Symbols' attribute.\n    function symbols(Token memory data) public pure returns (string memory) {\n        return data.mapColors ? 'Mapped' : 'Random';\n    }\n\n    /// @dev Generate the SVG snipped for a single attribute.\n    /// @param traitType The `trait_type` for this trait.\n    /// @param traitValue The `value` for this trait.\n    /// @param append Helper to append a comma.\n    function trait(\n        string memory traitType, string memory traitValue, string memory append\n    ) public pure returns (string memory) {\n        return string(abi.encodePacked(\n            '{',\n                '\"trait_type\": \"', traitType, '\",'\n                '\"value\": \"', traitValue, '\"'\n            '}',\n            append\n        ));\n    }\n\n}\n"
    },
    "contracts/libraries/Utilities.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary Utilities {\n    /// @dev Zero-index based pseudorandom number based on one input and max bound\n    function random(uint256 input, uint256 _max) public pure returns (uint256) {\n        return (uint256(keccak256(abi.encodePacked(input))) % _max);\n    }\n\n    /// @dev Zero-index based salted pseudorandom number based on two inputs and max bound\n    function random(uint256 input, string memory salt, uint256 _max) public pure returns (uint256) {\n        return (uint256(keccak256(abi.encodePacked(input, salt))) % _max);\n    }\n\n    /// @dev Convert an integer to a string\n    function uint2str(uint256 _i) public pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            ++len;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    /// @dev Get the smallest non zero number\n    function minGt0(uint8 one, uint8 two) public pure returns (uint8) {\n        return one > two\n            ? two > 0\n                ? two\n                : one\n            : one;\n    }\n\n    /// @dev Get the smaller number\n    function min(uint8 one, uint8 two) public pure returns (uint8) {\n        return one < two ? one : two;\n    }\n\n    /// @dev Get the larger number\n    function max(uint8 one, uint8 two) public pure returns (uint8) {\n        return one > two ? one : two;\n    }\n\n    /// @dev Get the average between two numbers\n    function avg(uint8 one, uint8 two) public pure returns (uint8 result) {\n        unchecked {\n            result = (one >> 1) + (two >> 1) + (one & two & 1);\n        }\n    }\n\n    /// @dev Get the days since another date (input is seconds)\n    function day(uint256 from, uint256 to) public pure returns (uint24) {\n        return uint24((to - from) / 24 hours + 1);\n    }\n}\n"
    },
    "contracts/standards/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Derived from OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev Simplified implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    /**\n     * @dev Emitted when minting a token with a message.\n     */\n    event Message(address indexed from, address indexed to, uint256 indexed id, string message);\n\n    /**\n     * @dev Custom revert errors.\n     */\n    error InvalidToken();\n    error InvalidInput();\n    error InvalidDesposit();\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {}\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        if (account == address(0)) return 0;\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @notice Infinities are never approved.\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address, bool) public virtual override {\n        revert(\"No approvals on infinities\");\n    }\n\n    /**\n     * @notice Infinities are never approved.\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address, address) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender(),\n            \"ERC1155: caller is not token owner\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender(),\n            \"ERC1155: caller is not token owner\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(from, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(from, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(from, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(from, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(_msgSender(), from, address(0), id, amount);\n    }\n\n    /**\n     * @dev Batched version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (_isContract(to)) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (_isContract(to)) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "contracts/libraries/InfiniteArt.sol": {
        "InfiniteArt": "0xc6b17cafcc2439ef4833fe6a073ba71438112f87"
      },
      "contracts/libraries/InfiniteGenerator.sol": {
        "InfiniteGenerator": "0xb0047233de84066b491f093380b8ca3cff4f7333"
      },
      "contracts/libraries/InfiniteMetadata.sol": {
        "InfiniteMetadata": "0x12b7f0e2f3d562b0cd012bd58e2d620bfdfe542f"
      }
    }
  }
}}