{{
  "language": "Solidity",
  "sources": {
    "contracts/PBAB+Collabs/plottables-flex/GenArt721Minter_PlottablesFlex.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"../../interfaces/0.8.x/IGenArt721CoreV2_PBAB.sol\";\nimport \"../../interfaces/0.8.x/IBonusContract.sol\";\n\nimport \"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin-4.5/contracts/utils/Strings.sol\";\nimport \"@openzeppelin-4.5/contracts/interfaces/IERC20.sol\";\n\npragma solidity 0.8.9;\n\n/**\n * @title Powered by Art Blocks minter contract that allows tokens to be\n * minted with ETH or any ERC-20 token.\n * @author Art Blocks Inc.\n */\ncontract GenArt721Minter_PlottablesFlex is ReentrancyGuard {\n    /// PBAB core contract this minter may interact with.\n    IGenArt721CoreV2_PBAB public genArtCoreContract;\n\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    address payable public ownerAddress;\n    uint256 public ownerPercentage;\n\n    mapping(uint256 => bool) public projectIdToBonus;\n    mapping(uint256 => address) public projectIdToBonusContractAddress;\n    mapping(uint256 => bool) public contractFilterProject;\n    mapping(address => mapping(uint256 => uint256)) public projectMintCounter;\n    mapping(uint256 => uint256) public projectMintLimit;\n    mapping(uint256 => bool) public projectMaxHasBeenInvoked;\n    mapping(uint256 => uint256) public projectMaxInvocations;\n\n    /**\n     * @notice Initializes contract to be a Minter for PBAB core contract at\n     * address `_genArt721Address`.\n     */\n    constructor(address _genArt721Address) ReentrancyGuard() {\n        genArtCoreContract = IGenArt721CoreV2_PBAB(_genArt721Address);\n    }\n\n    /**\n     * @notice Gets your balance of the ERC-20 token currently set\n     * as the payment currency for project `_projectId`.\n     * @param _projectId Project ID to be queried.\n     * @return balance Balance of ERC-20\n     */\n    function getYourBalanceOfProjectERC20(uint256 _projectId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 balance = IERC20(\n            genArtCoreContract.projectIdToCurrencyAddress(_projectId)\n        ).balanceOf(msg.sender);\n        return balance;\n    }\n\n    /**\n     * @notice Gets your allowance for this minter of the ERC-20\n     * token currently set as the payment currency for project\n     * `_projectId`.\n     * @param _projectId Project ID to be queried.\n     * @return remaining Remaining allowance of ERC-20\n     */\n    function checkYourAllowanceOfProjectERC20(uint256 _projectId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 remaining = IERC20(\n            genArtCoreContract.projectIdToCurrencyAddress(_projectId)\n        ).allowance(msg.sender, address(this));\n        return remaining;\n    }\n\n    /**\n     * @notice Sets the mint limit of a single purchaser for project\n     * `_projectId` to `_limit`.\n     * @param _projectId Project ID to set the mint limit for.\n     * @param _limit Number of times a given address may mint the project's\n     * tokens.\n     */\n    function setProjectMintLimit(uint256 _projectId, uint8 _limit) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        projectMintLimit[_projectId] = _limit;\n    }\n\n    /**\n     * @notice Sets the maximum invocations of project `_projectId` based\n     * on the value currently defined in the core contract.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @dev also checks and may refresh projectMaxHasBeenInvoked for project\n     */\n    function setProjectMaxInvocations(uint256 _projectId) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        uint256 maxInvocations;\n        uint256 invocations;\n        (, , invocations, maxInvocations, , , , , ) = genArtCoreContract\n            .projectTokenInfo(_projectId);\n        projectMaxInvocations[_projectId] = maxInvocations;\n        if (invocations < maxInvocations) {\n            projectMaxHasBeenInvoked[_projectId] = false;\n        }\n    }\n\n    /**\n     * @notice Sets the owner address to `_ownerAddress`.\n     * @param _ownerAddress New owner address.\n     */\n    function setOwnerAddress(address payable _ownerAddress) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        ownerAddress = _ownerAddress;\n    }\n\n    /**\n     * @notice Sets the owner mint revenue to `_ownerPercentage` percent.\n     * @param _ownerPercentage New owner percentage.\n     */\n    function setOwnerPercentage(uint256 _ownerPercentage) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        ownerPercentage = _ownerPercentage;\n    }\n\n    /**\n     * @notice Toggles if contracts are allowed to mint tokens for\n     * project `_projectId`.\n     * @param _projectId Project ID to be toggled.\n     */\n    function toggleContractFilter(uint256 _projectId) public {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"can only be set by admin\"\n        );\n        contractFilterProject[_projectId] = !contractFilterProject[_projectId];\n    }\n\n    /**\n     * @notice Toggles if bonus contract for project `_projectId`.\n     * @param _projectId Project ID to be toggled.\n     */\n    function artistToggleBonus(uint256 _projectId) public {\n        require(\n            msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId),\n            \"can only be set by artist\"\n        );\n        projectIdToBonus[_projectId] = !projectIdToBonus[_projectId];\n    }\n\n    /**\n     * @notice Sets bonus contract for project `_projectId` to\n     * `_bonusContractAddress`.\n     * @param _projectId Project ID to be toggled.\n     * @param _bonusContractAddress Bonus contract.\n     */\n    function artistSetBonusContractAddress(\n        uint256 _projectId,\n        address _bonusContractAddress\n    ) public {\n        require(\n            msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId),\n            \"can only be set by artist\"\n        );\n        projectIdToBonusContractAddress[_projectId] = _bonusContractAddress;\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId`.\n     * @param _projectId Project ID to mint a token on.\n     * @return _tokenId Token ID of minted token\n     */\n    function purchase(uint256 _projectId)\n        public\n        payable\n        returns (uint256 _tokenId)\n    {\n        return purchaseTo(msg.sender, _projectId);\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId` and sets\n     * the token's owner to `_to`.\n     * @param _to Address to be the new token's owner.\n     * @param _projectId Project ID to mint a token on.\n     * @return _tokenId Token ID of minted token\n     */\n    function purchaseTo(address _to, uint256 _projectId)\n        public\n        payable\n        nonReentrant\n        returns (uint256 _tokenId)\n    {\n        // CHECKS\n        require(\n            !projectMaxHasBeenInvoked[_projectId],\n            \"Maximum number of invocations reached\"\n        );\n        // if contract filter is active prevent calls from another contract\n        if (contractFilterProject[_projectId]) {\n            require(msg.sender == tx.origin, \"No Contract Buys\");\n        }\n\n        // limit mints per address by project\n        if (projectMintLimit[_projectId] > 0) {\n            require(\n                projectMintCounter[msg.sender][_projectId] <\n                    projectMintLimit[_projectId],\n                \"Reached minting limit\"\n            );\n            // EFFECTS\n            projectMintCounter[msg.sender][_projectId]++;\n        }\n\n        uint256 tokenId = genArtCoreContract.mint(_to, _projectId, msg.sender);\n\n        // What if this overflows, since default value of uint256 is 0?\n        // That is intended, so that by default the minter allows infinite\n        // transactions, allowing the `genArtCoreContract` to stop minting\n        // `uint256 tokenInvocation = tokenId % ONE_MILLION;`\n        if (\n            projectMaxInvocations[_projectId] > 0 &&\n            tokenId % ONE_MILLION == projectMaxInvocations[_projectId] - 1\n        ) {\n            projectMaxHasBeenInvoked[_projectId] = true;\n        }\n\n        // INTERACTIONS\n        // bonus contract\n        if (projectIdToBonus[_projectId]) {\n            require(\n                IBonusContract(projectIdToBonusContractAddress[_projectId])\n                    .bonusIsActive(),\n                \"bonus must be active\"\n            );\n            IBonusContract(projectIdToBonusContractAddress[_projectId])\n                .triggerBonus(msg.sender);\n        }\n\n        // validate and split funds\n        if (\n            keccak256(\n                abi.encodePacked(\n                    genArtCoreContract.projectIdToCurrencySymbol(_projectId)\n                )\n            ) != keccak256(abi.encodePacked(\"ETH\"))\n        ) {\n            require(\n                msg.value == 0,\n                \"this project accepts a different currency and cannot accept ETH\"\n            );\n            require(\n                IERC20(\n                    genArtCoreContract.projectIdToCurrencyAddress(_projectId)\n                ).allowance(msg.sender, address(this)) >=\n                    genArtCoreContract.projectIdToPricePerTokenInWei(\n                        _projectId\n                    ),\n                \"Insufficient Funds Approved for TX\"\n            );\n            require(\n                IERC20(\n                    genArtCoreContract.projectIdToCurrencyAddress(_projectId)\n                ).balanceOf(msg.sender) >=\n                    genArtCoreContract.projectIdToPricePerTokenInWei(\n                        _projectId\n                    ),\n                \"Insufficient balance.\"\n            );\n            _splitFundsERC20(_projectId);\n        } else {\n            require(\n                msg.value >=\n                    genArtCoreContract.projectIdToPricePerTokenInWei(\n                        _projectId\n                    ),\n                \"Must send minimum value to mint!\"\n            );\n            _splitFundsETH(_projectId);\n        }\n\n        return tokenId;\n    }\n\n    /**\n     * @dev splits ETH funds between sender (if refund), foundation,\n     * artist, and artist's additional payee for a token purchased on\n     * project `_projectId`.\n     * @dev utilizes transfer() to send ETH, so access lists may need to be\n     * populated when purchasing tokens.\n     */\n    function _splitFundsETH(uint256 _projectId) internal {\n        if (msg.value > 0) {\n            uint256 pricePerTokenInWei = genArtCoreContract\n                .projectIdToPricePerTokenInWei(_projectId);\n            uint256 refund = msg.value -\n                genArtCoreContract.projectIdToPricePerTokenInWei(_projectId);\n            if (refund > 0) {\n                (bool success_, ) = msg.sender.call{value: refund}(\"\");\n                require(success_, \"Refund failed\");\n            }\n            uint256 renderProviderAmount = (pricePerTokenInWei *\n                genArtCoreContract.renderProviderPercentage()) / 100;\n            if (renderProviderAmount > 0) {\n                (bool success_, ) = genArtCoreContract\n                    .renderProviderAddress()\n                    .call{value: renderProviderAmount}(\"\");\n                require(success_, \"Renderer payment failed\");\n            }\n\n            uint256 remainingFunds = pricePerTokenInWei - renderProviderAmount;\n\n            uint256 ownerFunds = (remainingFunds * ownerPercentage) / 100;\n            if (ownerFunds > 0) {\n                (bool success_, ) = ownerAddress.call{value: ownerFunds}(\"\");\n                require(success_, \"Owner payment failed\");\n            }\n\n            uint256 projectFunds = pricePerTokenInWei -\n                renderProviderAmount -\n                ownerFunds;\n            uint256 additionalPayeeAmount;\n            if (\n                genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                    _projectId\n                ) > 0\n            ) {\n                additionalPayeeAmount =\n                    (projectFunds *\n                        genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                            _projectId\n                        )) /\n                    100;\n                if (additionalPayeeAmount > 0) {\n                    (bool success_, ) = genArtCoreContract\n                        .projectIdToAdditionalPayee(_projectId)\n                        .call{value: additionalPayeeAmount}(\"\");\n                    require(success_, \"Additional payment failed\");\n                }\n            }\n            uint256 creatorFunds = projectFunds - additionalPayeeAmount;\n            if (creatorFunds > 0) {\n                (bool success_, ) = genArtCoreContract\n                    .projectIdToArtistAddress(_projectId)\n                    .call{value: creatorFunds}(\"\");\n                require(success_, \"Artist payment failed\");\n            }\n        }\n    }\n\n    /**\n     * @dev splits ERC-20 funds between render provider, owner, artist, and\n     * artist's additional payee, for a token purchased on project\n     `_projectId`.\n     */\n    function _splitFundsERC20(uint256 _projectId) internal {\n        uint256 pricePerTokenInWei = genArtCoreContract\n            .projectIdToPricePerTokenInWei(_projectId);\n        uint256 renderProviderAmount = (pricePerTokenInWei *\n            genArtCoreContract.renderProviderPercentage()) / 100;\n        if (renderProviderAmount > 0) {\n            IERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\n                .transferFrom(\n                    msg.sender,\n                    genArtCoreContract.renderProviderAddress(),\n                    renderProviderAmount\n                );\n        }\n        uint256 remainingFunds = pricePerTokenInWei - renderProviderAmount;\n\n        uint256 ownerFunds = (remainingFunds * ownerPercentage) / 100;\n        if (ownerFunds > 0) {\n            IERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\n                .transferFrom(msg.sender, ownerAddress, ownerFunds);\n        }\n\n        uint256 projectFunds = pricePerTokenInWei -\n            renderProviderAmount -\n            ownerFunds;\n        uint256 additionalPayeeAmount;\n        if (\n            genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                _projectId\n            ) > 0\n        ) {\n            additionalPayeeAmount =\n                (projectFunds *\n                    genArtCoreContract.projectIdToAdditionalPayeePercentage(\n                        _projectId\n                    )) /\n                100;\n            if (additionalPayeeAmount > 0) {\n                IERC20(\n                    genArtCoreContract.projectIdToCurrencyAddress(_projectId)\n                ).transferFrom(\n                        msg.sender,\n                        genArtCoreContract.projectIdToAdditionalPayee(\n                            _projectId\n                        ),\n                        additionalPayeeAmount\n                    );\n            }\n        }\n        uint256 creatorFunds = projectFunds - additionalPayeeAmount;\n        if (creatorFunds > 0) {\n            IERC20(genArtCoreContract.projectIdToCurrencyAddress(_projectId))\n                .transferFrom(\n                    msg.sender,\n                    genArtCoreContract.projectIdToArtistAddress(_projectId),\n                    creatorFunds\n                );\n        }\n    }\n}\n"
    },
    "contracts/interfaces/0.8.x/IGenArt721CoreV2_PBAB.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IGenArt721CoreV2_PBAB {\n    /**\n     * @notice Token ID `_tokenId` minted on project ID `_projectId` to `_to`.\n     */\n    event Mint(\n        address indexed _to,\n        uint256 indexed _tokenId,\n        uint256 indexed _projectId\n    );\n\n    // getter function of public variable\n    function admin() external view returns (address);\n\n    // getter function of public variable\n    function nextProjectId() external view returns (uint256);\n\n    // getter function of public mapping\n    function tokenIdToProjectId(uint256 tokenId)\n        external\n        view\n        returns (uint256 projectId);\n\n    function isWhitelisted(address sender) external view returns (bool);\n\n    function projectIdToCurrencySymbol(uint256 _projectId)\n        external\n        view\n        returns (string memory);\n\n    function projectIdToCurrencyAddress(uint256 _projectId)\n        external\n        view\n        returns (address);\n\n    function projectIdToArtistAddress(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToPricePerTokenInWei(uint256 _projectId)\n        external\n        view\n        returns (uint256);\n\n    function projectIdToAdditionalPayee(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayeePercentage(uint256 _projectId)\n        external\n        view\n        returns (uint256);\n\n    function projectTokenInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            address,\n            uint256,\n            string memory,\n            address\n        );\n\n    function renderProviderAddress() external view returns (address payable);\n\n    function renderProviderPercentage() external view returns (uint256);\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n\n    function getRoyaltyData(uint256 _tokenId)\n        external\n        view\n        returns (\n            address artistAddress,\n            address additionalPayee,\n            uint256 additionalPayeePercentage,\n            uint256 royaltyFeeByID\n        );\n}\n"
    },
    "contracts/interfaces/0.8.x/IBonusContract.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Creatd By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IBonusContract {\n    function triggerBonus(address _to) external returns (bool);\n\n    function bonusIsActive() external view returns (bool);\n}\n"
    },
    "@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin-4.5/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin-4.5/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin-4.5/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 25
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}