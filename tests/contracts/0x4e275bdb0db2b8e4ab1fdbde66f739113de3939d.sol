{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@cartesi/pos/contracts/IPoS.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Interface PoS\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IPoS {\n    /// @notice Produce a block\n    /// @param _index the index of the instance of pos you want to interact with\n    /// @dev this function can only be called by a worker, user never calls it directly\n    function produceBlock(uint256 _index) external returns (bool);\n\n    /// @notice Get reward manager address\n    /// @param _index index of instance\n    /// @return address of instance's RewardManager\n    function getRewardManagerAddress(uint256 _index)\n        external\n        view\n        returns (address);\n\n    /// @notice Get block selector address\n    /// @param _index index of instance\n    /// @return address of instance's block selector\n    function getBlockSelectorAddress(uint256 _index)\n        external\n        view\n        returns (address);\n\n    /// @notice Get block selector index\n    /// @param _index index of instance\n    /// @return index of instance's block selector\n    function getBlockSelectorIndex(uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Get staking address\n    /// @param _index index of instance\n    /// @return address of instance's staking contract\n    function getStakingAddress(uint256 _index) external view returns (address);\n\n    /// @notice Get state of a particular instance\n    /// @param _index index of instance\n    /// @param _user address of user\n    /// @return bool if user is eligible to produce next block\n    /// @return address of user that was chosen to build the block\n    /// @return current reward paid by the network for that block\n    function getState(uint256 _index, address _user)\n        external\n        view\n        returns (\n            bool,\n            address,\n            uint256\n        );\n\n    function terminate(uint256 _index) external;\n}\n"
    },
    "@cartesi/pos/contracts/IRewardManager.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Interface RewardManager\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IRewardManager {\n    /// @notice Rewards address\n    /// @param _address address be rewarded\n    /// @param _amount reward\n    /// @dev only the pos contract can call this\n    function reward(address _address, uint256 _amount) external;\n\n    /// @notice Get RewardManager's balance\n    function getBalance() external view returns (uint256);\n\n    /// @notice Get current reward amount\n    function getCurrentReward() external view returns (uint256);\n}\n"
    },
    "@cartesi/pos/contracts/IStaking.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Interface Staking\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IStaking {\n    /// @notice Returns total amount of tokens counted as stake\n    /// @param _userAddress user to retrieve staked balance from\n    /// @return finalized staked of _userAddress\n    function getStakedBalance(address _userAddress)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the timestamp when next deposit can be finalized\n    /// @return timestamp of when finalizeStakes() is callable\n    function getMaturingTimestamp(address _userAddress)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the timestamp when next withdraw can be finalized\n    /// @return timestamp of when finalizeWithdraw() is callable\n    function getReleasingTimestamp(address _userAddress)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the balance waiting/ready to be matured\n    /// @return amount that will get staked after finalization\n    function getMaturingBalance(address _userAddress)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the balance waiting/ready to be released\n    /// @return amount that will get withdrew after finalization\n    function getReleasingBalance(address _userAddress)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Deposit CTSI to be staked. The money will turn into staked\n    ///         balance after timeToStake days\n    /// @param _amount The amount of tokens that are gonna be deposited.\n    function stake(uint256 _amount) external;\n\n    /// @notice Remove tokens from staked balance. The money can\n    ///         be released after timeToRelease seconds, if the\n    ///         function withdraw is called.\n    /// @param _amount The amount of tokens that are gonna be unstaked.\n    function unstake(uint256 _amount) external;\n\n    /// @notice Transfer tokens to user's wallet.\n    /// @param _amount The amount of tokens that are gonna be transferred.\n    function withdraw(uint256 _amount) external;\n\n    // events\n    /// @notice CTSI tokens were deposited, they count as stake after _maturationDate\n    /// @param user address of msg.sender\n    /// @param amount amount deposited for staking\n    /// @param maturationDate date when the stake can be finalized\n    event Stake(address indexed user, uint256 amount, uint256 maturationDate);\n\n    /// @notice Unstake tokens, moving them to releasing structure\n    /// @param user address of msg.sender\n    /// @param amount amount of tokens to be released\n    /// @param maturationDate date when the tokens can be withdrew\n    event Unstake(address indexed user, uint256 amount, uint256 maturationDate);\n\n    /// @notice Withdraw process was finalized\n    /// @param user address of msg.sender\n    /// @param amount amount of tokens withdrawn\n    event Withdraw(address indexed user, uint256 amount);\n}\n"
    },
    "@cartesi/pos/contracts/IWorkerManagerAuthManager.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Interface WorkerManager\n/// @author Danilo Tuler\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IWorkerManagerAuthManager {\n    /// @notice Asks the worker to work for the sender. Sender needs to pay something.\n    /// @param workerAddress address of the worker\n    function hire(address payable workerAddress) external payable;\n\n    /// @notice Called by the user to cancel a job offer\n    /// @param workerAddress address of the worker node\n    function cancelHire(address workerAddress) external;\n\n    /// @notice Called by the user to retire his worker.\n    /// @param workerAddress address of the worker to be retired\n    /// @dev this also removes all authorizations in place\n    function retire(address payable workerAddress) external;\n\n    /// @notice Gives worker permission to act on a DApp\n    /// @param _workerAddress address of the worker node to given permission\n    /// @param _dappAddress address of the dapp that permission will be given to\n    function authorize(address _workerAddress, address _dappAddress) external;\n\n    /// @notice Called by the worker to accept the job\n    function acceptJob() external;\n\n    /// @notice Called by the worker to reject a job offer\n    function rejectJob() external payable;\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\n    function setResolver(bytes32 node, address resolver) external virtual;\n    function setOwner(bytes32 node, address owner) external virtual;\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\n    function setApprovalForAll(address operator, bool approved) external virtual;\n    function owner(bytes32 node) external virtual view returns (address);\n    function resolver(bytes32 node) external virtual view returns (address);\n    function ttl(bytes32 node) external virtual view returns (uint64);\n    function recordExists(bytes32 node) external virtual view returns (bool);\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/ReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../root/Controllable.sol\";\n\nabstract contract NameResolver {\n    function setName(bytes32 node, string memory name) public virtual;\n}\n\nbytes32 constant lookup = 0x3031323334353637383961626364656600000000000000000000000000000000;\n\nbytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n// namehash('addr.reverse')\n\ncontract ReverseRegistrar is Ownable, Controllable {\n    ENS public ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     * @param resolverAddr The address of the default reverse resolver.\n     */\n    constructor(ENS ensAddr, NameResolver resolverAddr) {\n        ens = ensAddr;\n        defaultResolver = resolverAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ens.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            \"Caller is not a controller or authorised by address or the address itself\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public returns (bytes32) {\n        return _claimWithResolver(msg.sender, owner, address(0x0));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(address addr, address owner)\n        public\n        authorised(addr)\n        returns (bytes32)\n    {\n        return _claimWithResolver(addr, owner, address(0x0));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(address owner, address resolver)\n        public\n        returns (bytes32)\n    {\n        return _claimWithResolver(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record specified with the\n     *      address provided\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolverForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public authorised(addr) returns (bytes32) {\n        return _claimWithResolver(addr, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public returns (bytes32) {\n        bytes32 node = _claimWithResolver(\n            msg.sender,\n            address(this),\n            address(defaultResolver)\n        );\n        defaultResolver.setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        string memory name\n    ) public authorised(addr) returns (bytes32) {\n        bytes32 node = _claimWithResolver(\n            addr,\n            address(this),\n            address(defaultResolver)\n        );\n        defaultResolver.setName(node, name);\n        ens.setSubnodeOwner(ADDR_REVERSE_NODE, sha3HexAddress(addr), owner);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account's reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    /* Internal functions */\n\n    function _claimWithResolver(\n        address addr,\n        address owner,\n        address resolver\n    ) internal returns (bytes32) {\n        bytes32 label = sha3HexAddress(addr);\n        bytes32 node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\n        address currentResolver = ens.resolver(node);\n        bool shouldUpdateResolver = (resolver != address(0x0) &&\n            resolver != currentResolver);\n        address newResolver = shouldUpdateResolver ? resolver : currentResolver;\n\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, label, owner, newResolver, 0);\n\n        emit ReverseClaimed(addr, node);\n\n        return node;\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/root/Controllable.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Controllable is Ownable {\n    mapping(address => bool) public controllers;\n\n    event ControllerChanged(address indexed controller, bool enabled);\n\n    modifier onlyController {\n        require(\n            controllers[msg.sender],\n            \"Controllable: Caller is not a controller\"\n        );\n        _;\n    }\n\n    function setController(address controller, bool enabled) public onlyOwner {\n        controllers[controller] = enabled;\n        emit ControllerChanged(controller, enabled);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/StakingPoolData.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@cartesi/pos/contracts/IPoS.sol\";\n\nimport \"./utils/WadRayMath.sol\";\n\ncontract StakingPoolData is\n    Initializable,\n    PausableUpgradeable,\n    OwnableUpgradeable\n{\n    using WadRayMath for uint256;\n    uint256 public shares; // total number of shares\n    uint256 public amount; // amount of staked tokens (no matter where it is)\n    uint256 public requiredLiquidity; // amount of required tokens for withdraw requests\n\n    IPoS public pos;\n\n    struct UserBalance {\n        uint256 balance; // amount of free tokens belonging to this user\n        uint256 shares; // amount of shares belonging to this user\n        uint256 depositTimestamp; // timestamp of when user deposited for the last time\n    }\n    mapping(address => UserBalance) public userBalance;\n\n    function amountToShares(uint256 _amount) public view returns (uint256) {\n        if (amount == 0) {\n            // no shares yet, return 1 to 1 ratio\n            return _amount.wad2ray();\n        }\n        return _amount.wmul(shares).wdiv(amount);\n    }\n\n    function sharesToAmount(uint256 _shares) public view returns (uint256) {\n        if (shares == 0) {\n            // no shares yet, return 1 to 1 ratio\n            return _shares.ray2wad();\n        }\n        return _shares.rmul(amount).rdiv(shares);\n    }\n}\n"
    },
    "contracts/StakingPoolImpl.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/StakingPool.sol\";\nimport \"./StakingPoolData.sol\";\nimport \"./StakingPoolManagementImpl.sol\";\nimport \"./StakingPoolProducerImpl.sol\";\nimport \"./StakingPoolStakingImpl.sol\";\nimport \"./StakingPoolUserImpl.sol\";\nimport \"./StakingPoolWorkerImpl.sol\";\n\ncontract StakingPoolImpl is\n    StakingPool,\n    StakingPoolData,\n    StakingPoolManagementImpl,\n    StakingPoolProducerImpl,\n    StakingPoolStakingImpl,\n    StakingPoolUserImpl,\n    StakingPoolWorkerImpl\n{\n    constructor(\n        address _ctsi,\n        address _staking,\n        address _workerManager,\n        address _ens,\n        uint256 _stakeLock\n    )\n        StakingPoolManagementImpl(_ens)\n        StakingPoolProducerImpl(_ctsi)\n        StakingPoolStakingImpl(_ctsi, _staking)\n        StakingPoolUserImpl(_ctsi, _stakeLock)\n        StakingPoolWorkerImpl(_workerManager)\n    {}\n\n    function initialize(address _fee, address _pos)\n        external\n        override\n        initializer\n    {\n        __Pausable_init();\n        __Ownable_init();\n        __StakingPoolProducer_init(_fee, _pos);\n        __StakingPoolStaking_init();\n        __StakingPoolManagementImpl_init();\n    }\n\n    /// @notice updates the internal settings for important pieces of the Cartesi PoS system\n    function update() external override onlyOwner {\n        address _pos = factory.getPoS();\n        __StakingPoolWorkerImpl_update(_pos);\n    }\n\n    function transferOwnership(address newOwner)\n        public\n        override(StakingPool, OwnableUpgradeable)\n    {\n        OwnableUpgradeable.transferOwnership(newOwner);\n    }\n}\n"
    },
    "contracts/StakingPoolManagementImpl.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.8.0;\n\nimport \"@ensdomains/ens-contracts/contracts/registry/ReverseRegistrar.sol\";\nimport \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\n\nimport \"./interfaces/StakingPoolManagement.sol\";\nimport \"./interfaces/StakingPoolFactory.sol\";\nimport \"./StakingPoolData.sol\";\n\ncontract StakingPoolManagementImpl is StakingPoolManagement, StakingPoolData {\n    bytes32 private constant ADDR_REVERSE_NODE =\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    ENS public immutable ens;\n    StakingPoolFactory public factory;\n\n    // all immutable variables can stay at the constructor\n    constructor(address _ens) initializer {\n        require(_ens != address(0), \"parameter can not be zero address\");\n        ens = ENS(_ens);\n\n        // make sure reference code is pause so no one stake to it\n        _pause();\n    }\n\n    function __StakingPoolManagementImpl_init() internal {\n        factory = StakingPoolFactory(msg.sender);\n    }\n\n    /// @notice sets a name for the pool using ENS service\n    function setName(string memory name) external override onlyOwner {\n        ReverseRegistrar ensReverseRegistrar = ReverseRegistrar(\n            ens.owner(ADDR_REVERSE_NODE)\n        );\n\n        // call the ENS reverse registrar resolving pool address to name\n        ensReverseRegistrar.setName(name);\n\n        // emit event, for subgraph processing\n        emit StakingPoolRenamed(name);\n    }\n\n    /// @notice pauses new staking on the pool\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /// @notice unpauses new staking on the pool\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/StakingPoolProducerImpl.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@cartesi/pos/contracts/IPoS.sol\";\nimport \"@cartesi/pos/contracts/IRewardManager.sol\";\nimport \"./interfaces/Fee.sol\";\nimport \"./interfaces/StakingPoolProducer.sol\";\nimport \"./StakingPoolData.sol\";\n\ncontract StakingPoolProducerImpl is StakingPoolProducer, StakingPoolData {\n    IERC20 public immutable ctsi;\n    Fee public fee;\n\n    constructor(address _ctsi) {\n        ctsi = IERC20(_ctsi);\n    }\n\n    function __StakingPoolProducer_init(address _fee, address _pos) internal {\n        fee = Fee(_fee);\n        pos = IPoS(_pos);\n    }\n\n    /// @notice routes produceBlock to POS contract and\n    /// updates internal states of the pool\n    /// @return true when everything went fine\n    function produceBlock(uint256 _index) external override returns (bool) {\n        IRewardManager rewardManager = IRewardManager(\n            pos.getRewardManagerAddress(_index)\n        );\n\n        // get block reward\n        uint256 reward = rewardManager.getCurrentReward();\n\n        // produce block in the PoS\n        require(\n            pos.produceBlock(_index),\n            \"StakingPoolProducerImpl: failed to produce block\"\n        );\n\n        // calculate pool commission\n        uint256 commission = fee.getCommission(_index, reward);\n        require(\n            commission <= reward,\n            \"StakingPoolProducerImpl: commission is greater than block reward\"\n        );\n\n        uint256 remainingReward = reward - commission; // this is a safety check\n        // if commission is over the reward amount, it will underflow\n\n        // increase pool amount, this will change the pool exchange rate\n        amount += remainingReward;\n\n        // send commission directly to pool owner\n        if (commission > 0) {\n            require(\n                ctsi.transfer(owner(), commission),\n                \"StakingPoolProducerImpl: failed to transfer commission\"\n            );\n        }\n\n        // remainingReward is part of the balance, so it will automatically be staked by StakingPoolStakingImpl\n        emit BlockProduced(reward, commission);\n\n        return true;\n    }\n}\n"
    },
    "contracts/StakingPoolStakingImpl.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@cartesi/pos/contracts/IStaking.sol\";\nimport \"./interfaces/StakingPoolStaking.sol\";\nimport \"./StakingPoolData.sol\";\n\n/// @notice This contract takes care of the interaction between the pool and the staking contract\n/// It makes sure that there is enough liquidity in the pool to fullfil all unstake request from\n/// users, by requesting to withdraw or unstake from Staking contract.\n/// The remaining balance is staked.\ncontract StakingPoolStakingImpl is StakingPoolStaking, StakingPoolData {\n    IERC20 private immutable ctsi;\n    IStaking private immutable staking;\n\n    constructor(address _ctsi, address _staking) {\n        ctsi = IERC20(_ctsi);\n        staking = IStaking(_staking);\n    }\n\n    function __StakingPoolStaking_init() internal {\n        require(\n            ctsi.approve(address(staking), type(uint256).max),\n            \"Failed to approve CTSI for staking contract\"\n        );\n    }\n\n    function rebalance() external override {\n        // get amounts\n        (uint256 _stake, uint256 _unstake, uint256 _withdraw) = amounts();\n\n        if (_stake > 0) {\n            // we can stake\n            staking.stake(_stake);\n        }\n\n        if (_unstake > 0) {\n            // we need to provide liquidity\n            staking.unstake(_unstake);\n        }\n\n        if (_withdraw > 0) {\n            // we need to provide liquidity\n            staking.withdraw(_withdraw);\n        }\n    }\n\n    function amounts()\n        public\n        view\n        override\n        returns (\n            uint256 stake,\n            uint256 unstake,\n            uint256 withdraw\n        )\n    {\n        // get this contract balance first\n        uint256 balance = ctsi.balanceOf(address(this));\n\n        if (balance > requiredLiquidity) {\n            // we have spare tokens we can stake\n            // check if there is anything already maturing, to avoid reset the maturation clock\n            uint256 maturing = staking.getMaturingBalance(address(this));\n            if (maturing == 0) {\n                // nothing is maturing, we can stake the balance, preserving the liquidity\n                stake = balance - requiredLiquidity;\n            }\n        } else if (requiredLiquidity > balance) {\n            // we don't have enough tokens to provide liquidity\n            uint256 missingLiquidity = requiredLiquidity - balance;\n\n            // let's first check releasing balance\n            uint256 releasing = staking.getReleasingBalance(address(this));\n            if (releasing > 0) {\n                // some is already releasing\n\n                // let's check timestamp to see if we can withdrawn it\n                uint256 timestamp = staking.getReleasingTimestamp(\n                    address(this)\n                );\n                if (timestamp < block.timestamp) {\n                    // there it is, let's grab it\n                    withdraw = releasing;\n                }\n\n                // requiredLiquidity may be more than what is already releasing\n                // but we won't unstake more to not reset the clock\n            } else {\n                // no unstake maturing, let's queue some\n                unstake = missingLiquidity;\n            }\n        } else {\n            // balance is exactly required liquidity, we can't move any tokens around\n        }\n    }\n}\n"
    },
    "contracts/StakingPoolUserImpl.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/StakingPoolUser.sol\";\nimport \"./StakingPoolData.sol\";\n\ncontract StakingPoolUserImpl is StakingPoolUser, StakingPoolData {\n    IERC20 private immutable ctsi;\n    uint256 public immutable lockTime;\n\n    /// @dev Constructor\n    /// @param _ctsi The contract that provides the staking pool's token\n    /// @param _lockTime The user deposit lock period\n    constructor(address _ctsi, uint256 _lockTime) {\n        ctsi = IERC20(_ctsi);\n        lockTime = _lockTime;\n    }\n\n    function deposit(uint256 _amount) external override whenNotPaused {\n        // transfer tokens from caller to this contract\n        // user must have approved the transfer a priori\n        // tokens will be lying around, until actually staked by pool owner at a later time\n        require(\n            _amount > 0,\n            \"StakingPoolUserImpl: amount must be greater than 0\"\n        );\n\n        // add tokens to user's balance\n        UserBalance storage user = userBalance[msg.sender];\n        user.balance += _amount;\n\n        // reset deposit timestamp\n        user.depositTimestamp = block.timestamp;\n\n        // reserve the balance as required liquidity (don't stake to Staking)\n        requiredLiquidity += _amount;\n\n        require(\n            ctsi.transferFrom(msg.sender, address(this), _amount),\n            \"StakingPoolUserImpl: failed to transfer tokens\"\n        );\n\n        // emit event containing user and amount\n        emit Deposit(msg.sender, _amount, block.timestamp + lockTime);\n    }\n\n    /// @notice Stake an amount of tokens, immediately earning pool shares in returns\n    /// @param _amount amount of tokens to convert from user's balance\n    function stake(uint256 _amount) external override whenNotPaused {\n        // get user balance\n        UserBalance storage user = userBalance[msg.sender];\n\n        // transfer tokens from caller to this contract\n        // user must have approved the transfer a priori\n        // tokens will be lying around, until actually staked by pool owner at a later time\n        require(\n            _amount > 0,\n            \"StakingPoolUserImpl: amount must be greater than 0\"\n        );\n        require(\n            _amount <= user.balance,\n            \"StakingPoolUserImpl: not enough tokens available for staking\"\n        );\n\n        // check if user can already stake or if it's too early\n        require(\n            block.timestamp >= user.depositTimestamp + lockTime,\n            \"StakingPoolUserImpl: not enough time has passed since last deposit\"\n        );\n\n        // calculate amount of shares as of now\n        uint256 _shares = amountToShares(_amount);\n\n        // make sure he get at least one share (rounding errors)\n        require(\n            _shares > 0,\n            \"StakingPoolUserImpl: stake not enough to emit 1 share\"\n        );\n\n        // allocate new shares to user, immediately\n        user.shares += _shares;\n        user.balance -= _amount;\n\n        // increase total shares and amount (not changing share value)\n        amount += _amount;\n        shares += _shares;\n\n        // remove from required liquidity, as it's moving to Staking\n        requiredLiquidity -= _amount;\n\n        // emit event containing user, amount, shares and unlock time\n        emit Stake(msg.sender, _amount, _shares);\n    }\n\n    /// @notice allow for users to defined exactly how many shares they\n    /// want to unstake. Estimated value is then emitted on Unstake event\n    function unstake(uint256 _shares) external override {\n        UserBalance storage user = userBalance[msg.sender];\n\n        // check if shares is valid value\n        require(_shares > 0, \"StakingPoolUserImpl: invalid amount of shares\");\n\n        // check if user has enough shares to unstake\n        require(\n            user.shares >= _shares,\n            \"StakingPoolUserImpl: insufficient shares\"\n        );\n\n        // reduce user number of shares\n        user.shares -= _shares;\n\n        // calculate amount of tokens from shares\n        uint256 _amount = sharesToAmount(_shares);\n\n        // reduce total shares and amount\n        shares -= _shares;\n        amount -= _amount;\n\n        // add amount user can withdraw (if available)\n        user.balance += _amount;\n\n        // increase required liquidity\n        requiredLiquidity += _amount;\n\n        // emit event containing user, amount and shares\n        emit Unstake(msg.sender, _amount, _shares);\n    }\n\n    /// @notice Transfer tokens back to calling user wallet\n    /// @dev this will transfer all free tokens for the calling user\n    function withdraw(uint256 _amount) external override {\n        UserBalance storage user = userBalance[msg.sender];\n\n        // check user released value\n        require(\n            user.balance > 0,\n            \"StakingPoolUserImpl: no balance to withdraw\"\n        );\n\n        // clear user released value\n        user.balance -= _amount; // if _amount >  user.balance this will revert\n\n        // decrease required liquidity\n        requiredLiquidity -= _amount; // if _amount >  requiredLiquidity this will revert\n\n        // transfer token back to user\n        require(\n            ctsi.transfer(msg.sender, _amount),\n            \"StakingPoolUserImpl: failed to transfer tokens\"\n        );\n\n        // emit event containing user and token amount\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function getWithdrawBalance() external view override returns (uint256) {\n        UserBalance storage user = userBalance[msg.sender];\n\n        // get maximum amount user can withdraw (his balance)\n        uint256 _amount = user.balance;\n\n        // check contract balance\n        uint256 balance = ctsi.balanceOf(address(this));\n\n        // he can withdraw whatever is available at the contract, up to his balance\n        return balance >= _amount ? _amount : balance;\n    }\n}\n"
    },
    "contracts/StakingPoolWorkerImpl.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.8.0;\n\nimport \"@cartesi/pos/contracts/IWorkerManagerAuthManager.sol\";\nimport \"./interfaces/StakingPoolWorker.sol\";\nimport \"./StakingPoolData.sol\";\n\ncontract StakingPoolWorkerImpl is StakingPoolWorker, StakingPoolData {\n    IWorkerManagerAuthManager immutable workerManager;\n\n    // all immutable variables can stay at the constructor\n    constructor(address _workerManager) {\n        require(\n            _workerManager != address(0),\n            \"parameter can not be zero address\"\n        );\n        workerManager = IWorkerManagerAuthManager(_workerManager);\n    }\n\n    receive() external payable {}\n\n    function __StakingPoolWorkerImpl_update(address _pos) internal {\n        workerManager.authorize(address(this), _pos);\n        pos = IPoS(_pos);\n    }\n\n    /// @notice allows for the pool to act on its own behalf when producing blocks.\n    function selfhire() external payable override {\n        // pool needs to be both user and worker\n        workerManager.hire{value: msg.value}(payable(address(this)));\n        workerManager.authorize(address(this), address(pos));\n        workerManager.acceptJob();\n        payable(msg.sender).transfer(msg.value);\n    }\n\n    /// @notice Asks the worker to work for the sender. Sender needs to pay something.\n    /// @param workerAddress address of the worker\n    function hire(address payable workerAddress)\n        external\n        payable\n        override\n        onlyOwner\n    {\n        workerManager.hire{value: msg.value}(workerAddress);\n        workerManager.authorize(workerAddress, address(pos));\n    }\n\n    /// @notice Called by the user to cancel a job offer\n    /// @param workerAddress address of the worker node\n    function cancelHire(address workerAddress) external override onlyOwner {\n        workerManager.cancelHire(workerAddress);\n    }\n\n    /// @notice Called by the user to retire his worker.\n    /// @param workerAddress address of the worker to be retired\n    /// @dev this also removes all authorizations in place\n    function retire(address payable workerAddress) external override onlyOwner {\n        workerManager.retire(workerAddress);\n    }\n}\n"
    },
    "contracts/interfaces/Fee.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Calculator of pool owner commission for each block reward\n/// @author Danilo Tuler\n/// @notice This provides flexibility for different commission models\ninterface Fee {\n    /// @notice calculates the total amount of the reward that will be directed to the pool owner\n    /// @return amount of tokens taken by the pool owner as commission\n    function getCommission(uint256 posIndex, uint256 rewardAmount)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/StakingPool.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity >=0.7.0;\n\nimport \"./StakingPoolManagement.sol\";\nimport \"./StakingPoolProducer.sol\";\nimport \"./StakingPoolStaking.sol\";\nimport \"./StakingPoolUser.sol\";\nimport \"./StakingPoolWorker.sol\";\n\n/// @title Staking Pool interface\n/// @author Danilo Tuler\n/// @notice This interface aggregates all facets of a staking pool.\n/// It is broken down into the following sub-interfaces:\n/// - StakingPoolManagement: management operations on the pool, called by the owner\n/// - StakingPoolProducer: operations related to block production\n/// - StakingPoolStaking: interaction between the pool and the staking contract\n/// - StakingPoolUser: interaction between the pool users and the pool\n/// - StakingPoolWorker: interaction between the pool and the worker node\ninterface StakingPool is\n    StakingPoolManagement,\n    StakingPoolProducer,\n    StakingPoolStaking,\n    StakingPoolUser,\n    StakingPoolWorker\n{\n    /// @notice initialize pool (from reference)\n    function initialize(address fee, address _pos) external;\n\n    /// @notice Transfer ownership of pool to its deployer\n    function transferOwnership(address newOwner) external;\n\n    /// @notice updates the internal settings for important pieces of the Cartesi PoS system\n    function update() external;\n}\n"
    },
    "contracts/interfaces/StakingPoolFactory.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity >=0.7.0;\n\ninterface StakingPoolFactory {\n    /// @notice Creates a new staking pool using a flat commission model\n    /// emits NewFlatRateCommissionStakingPool with the parameters of the new pool\n    /// @return new pool address\n    function createFlatRateCommission(uint256 commission)\n        external\n        payable\n        returns (address);\n\n    /// @notice Creates a new staking pool using a gas tax commission model\n    /// emits NewGasTaxCommissionStakingPool with the parameters of the new pool\n    /// @return new pool address\n    function createGasTaxCommission(uint256 gas)\n        external\n        payable\n        returns (address);\n\n    /// @notice Returns configuration for the working pools of the current version\n    /// @return _pos address for the PoS contract\n    function getPoS() external view returns (address _pos);\n\n    /// @notice Event emmited when a pool is created\n    /// @param pool address of the new pool\n    /// @param fee address of the commission contract\n    event NewFlatRateCommissionStakingPool(address indexed pool, address fee);\n\n    /// @notice Event emmited when a pool is created\n    /// @param pool address of the new pool\n    /// @param fee address of thhe commission contract\n    event NewGasTaxCommissionStakingPool(address indexed pool, address fee);\n}\n"
    },
    "contracts/interfaces/StakingPoolManagement.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity >=0.7.0;\n\ninterface StakingPoolManagement {\n    /// @notice sets a name for the pool using ENS service\n    function setName(string memory name) external;\n\n    /// @notice pauses new staking on the pool\n    function pause() external;\n\n    /// @notice unpauses new staking on the pool\n    function unpause() external;\n\n    /// @notice Event emmited when a pool is rename\n    event StakingPoolRenamed(string name);\n}\n"
    },
    "contracts/interfaces/StakingPoolProducer.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity >=0.7.0;\n\n/// @title Interaction between a pool and the PoS block production.\n/// @author Danilo Tuler\n/// @notice This interface provides an opportunity to handle the necessary logic\n/// after a block is produced.\n/// A commission is taken from the block reward, and the remaining stays in the pool,\n/// raising the pool share value, and being further staked.\ninterface StakingPoolProducer {\n    /// @notice routes produceBlock to POS contract and\n    /// updates internal states of the pool\n    /// @return true when everything went fine\n    function produceBlock(uint256 _index) external returns (bool);\n\n    /// @notice this event is emitted at every produceBlock call\n    /// reward is the block reward\n    /// commission is how much CTSI is directed to the pool owner\n    event BlockProduced(uint256 reward, uint256 commission);\n}\n"
    },
    "contracts/interfaces/StakingPoolStaking.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity >=0.7.0;\n\n/// @title Interaction between a pool and the staking contract\n/// @author Danilo Tuler\n/// @notice This interface models all interactions between a pool and the staking contract,\n/// including staking, unstaking and withdrawing.\n/// Tokens staked by pool users will stay at the pool until the pool owner decides to\n/// stake them in the staking contract. On the other hand, tokens unstaked by pool users\n/// are added to a required liquidity accumulator, and must be unstaked and withdrawn from\n/// the staking contract.\ninterface StakingPoolStaking {\n    /// @notice Move tokens from pool to staking or vice-versa, according to required liquidity.\n    /// If the pool has more liquidity then necessary, it stakes tokens.\n    /// If the pool has less liquidity then necessary, and has not started an unstake, it unstakes.\n    /// If the pool has less liquity than necessary, and has started an unstake, it withdraws if possible.\n    function rebalance() external;\n\n    /// @notice provide information for offchain about the amount for each\n    /// staking operation on the main Staking contract\n    /// @return stake amount of tokens that can be staked\n    /// @return unstake amount of tokens that must be unstaked to add liquidity\n    /// @return withdraw amount of tokens that can be withdrawn to add liquidity\n    function amounts()\n        external\n        view\n        returns (\n            uint256 stake,\n            uint256 unstake,\n            uint256 withdraw\n        );\n}\n"
    },
    "contracts/interfaces/StakingPoolUser.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity >=0.7.0;\n\n/// @title Interaction between a pool user and a pool\n/// @author Danilo Tuler\n/// @notice This interface models all interactions between a pool user and a pool,\n/// including staking, unstaking and withdrawing. A pool user always holds pool shares.\n/// When a user stakes tokens, he immediately receive shares. When he unstakes shares\n/// he is asking to release tokens. Those tokens need to be withdrawn by an additional\n/// call to withdraw()\ninterface StakingPoolUser {\n    /// @notice Deposit tokens to user pool balance\n    /// @param amount amount of token deposited in the pool\n    function deposit(uint256 amount) external;\n\n    /// @notice Stake an amount of tokens, immediately earning pool shares in returns\n    /// @param amount amount of tokens to convert to shares\n    function stake(uint256 amount) external;\n\n    /// @notice Unstake an specified amount of shares of the calling user\n    /// @dev Shares are immediately converted to tokens, and added to the pool liquidity requirement\n    function unstake(uint256 shares) external;\n\n    /// @notice Transfer tokens back to calling user wallet\n    /// @dev this will transfer tokens from user pool account to user's wallet\n    function withdraw(uint256 amount) external;\n\n    /// @notice Returns the amount of tokens that can be immediately withdrawn by the calling user\n    /// @dev there is no way to know the exact time in the future the requested tokens will be available\n    /// @return the amount of tokens that can be immediately withdrawn by the calling user\n    function getWithdrawBalance() external returns (uint256);\n\n    /// @notice Tokens were deposited, available for staking or withdrawal\n    /// @param user address of msg.sender\n    /// @param amount amount of tokens deposited by the user\n    /// @param stakeTimestamp instant when the amount can be staked\n    event Deposit(address indexed user, uint256 amount, uint256 stakeTimestamp);\n\n    /// @notice Tokens were deposited, they count as shares immediatly\n    /// @param user address of msg.sender\n    /// @param amount amount deposited by the user\n    /// @param shares number of shares emitted for user\n    event Stake(address indexed user, uint256 amount, uint256 shares);\n\n    /// @notice Request to unstake tokens. Additional liquidity requested for the pool\n    /// @param user address of msg.sender\n    /// @param amount amount of tokens to be released\n    /// @param shares number of shares being liquidated\n    event Unstake(address indexed user, uint256 amount, uint256 shares);\n\n    /// @notice Withdraw performed by a user\n    /// @param user address of msg.sender\n    /// @param amount amount of tokens withdrawn\n    event Withdraw(address indexed user, uint256 amount);\n}\n"
    },
    "contracts/interfaces/StakingPoolWorker.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity >=0.7.0;\n\ninterface StakingPoolWorker {\n    /// @notice allows for the pool to act on its own behalf when producing blocks.\n    function selfhire() external payable;\n\n    /// @notice Asks the worker to work for the sender. Sender needs to pay something.\n    /// @param workerAddress address of the worker\n    function hire(address payable workerAddress) external payable;\n\n    /// @notice Called by the user to cancel a job offer\n    /// @param workerAddress address of the worker node\n    function cancelHire(address workerAddress) external;\n\n    /// @notice Called by the user to retire his worker.\n    /// @param workerAddress address of the worker to be retired\n    /// @dev this also removes all authorizations in place\n    function retire(address payable workerAddress) external;\n}\n"
    },
    "contracts/utils/WadRayMath.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Wad and Ray Math library\n/// @dev Math operations for wads (fixed point with 18 digits) and rays (fixed points with 27 digits)\npragma solidity ^0.8.0;\n\nlibrary WadRayMath {\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant RATIO = 1e9;\n\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ((WAD / 2) + (a * b)) / WAD;\n    }\n\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n        return (halfB + (a * WAD)) / b;\n    }\n\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ((RAY / 2) + (a * b)) / RAY;\n    }\n\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n        return (halfB + (a * RAY)) / b;\n    }\n\n    function ray2wad(uint256 a) internal pure returns (uint256) {\n        uint256 halfRatio = RATIO / 2;\n        return (halfRatio + a) / RATIO;\n    }\n\n    function wad2ray(uint256 a) internal pure returns (uint256) {\n        return a * RATIO;\n    }\n}\n"
    }
  }
}}