{{
  "language": "Solidity",
  "sources": {
    "contracts/OperatorStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IOperatorStore.sol\";\n\n/** \n  @notice\n  Addresses can give permissions to any other address to take specific actions \n  throughout the Juicebox ecosystem on their behalf. These addresses are called `operators`.\n  \n  @dev\n  Permissions are stored as a uint256, with each boolean bit representing whether or not\n  an oporator has the permission identified by that bit's index in the 256 bit uint256.\n  Indexes must be between 0 and 255.\n\n  The directory of permissions, along with how they uniquely mapp to indexes, are managed externally.\n  This contract doesn't know or care about specific permissions and their indexes.\n*/\ncontract OperatorStore is IOperatorStore {\n    // --- public stored properties --- //\n\n    /** \n      @notice\n      The permissions that an operator has to operate on a specific domain.\n      \n      @dev\n      An account can give an operator permissions that only pertain to a specific domain.\n      There is no domain with an ID of 0 -- accounts can use the 0 domain to give an operator\n      permissions to operator on their personal behalf.\n    */\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        public\n        override permissionsOf;\n\n    // --- public views --- //\n\n    /** \n      @notice \n      Whether or not an operator has the permission to take a certain action pertaining to the specified domain.\n\n      @param _operator The operator to check.\n      @param _account The account that has given out permission to the operator.\n      @param _domain The domain that the operator has been given permissions to operate.\n      @param _permissionIndex the permission to check for.\n\n      @return Whether the operator has the specified permission.\n    */\n    function hasPermission(\n        address _operator,\n        address _account,\n        uint256 _domain,\n        uint256 _permissionIndex\n    ) external view override returns (bool) {\n        require(\n            _permissionIndex <= 255,\n            \"OperatorStore::hasPermission: INDEX_OUT_OF_BOUNDS\"\n        );\n        return\n            ((permissionsOf[_operator][_account][_domain] >> _permissionIndex) &\n                1) == 1;\n    }\n\n    /** \n      @notice \n      Whether or not an operator has the permission to take certain actions pertaining to the specified domain.\n\n      @param _operator The operator to check.\n      @param _account The account that has given out permissions to the operator.\n      @param _domain The domain that the operator has been given permissions to operate.\n      @param _permissionIndexes An array of permission indexes to check for.\n\n      @return Whether the operator has all specified permissions.\n    */\n    function hasPermissions(\n        address _operator,\n        address _account,\n        uint256 _domain,\n        uint256[] calldata _permissionIndexes\n    ) external view override returns (bool) {\n        for (uint256 _i = 0; _i < _permissionIndexes.length; _i++) {\n            uint256 _permissionIndex = _permissionIndexes[_i];\n\n            require(\n                _permissionIndex <= 255,\n                \"OperatorStore::hasPermissions: INDEX_OUT_OF_BOUNDS\"\n            );\n\n            if (\n                ((permissionsOf[_operator][_account][_domain] >>\n                    _permissionIndex) & 1) == 0\n            ) return false;\n        }\n        return true;\n    }\n\n    // --- external transactions --- //\n\n    /** \n      @notice \n      Sets permissions for an operator.\n\n      @param _operator The operator to give permission to.\n      @param _domain The domain that the operator is being given permissions to operate.\n      @param _permissionIndexes An array of indexes of permissions to set.\n    */\n    function setOperator(\n        address _operator,\n        uint256 _domain,\n        uint256[] calldata _permissionIndexes\n    ) external override {\n        // Pack the indexes into a uint256.\n        uint256 _packed = _packedPermissions(_permissionIndexes);\n\n        // Store the new value.\n        permissionsOf[_operator][msg.sender][_domain] = _packed;\n\n        emit SetOperator(\n            _operator,\n            msg.sender,\n            _domain,\n            _permissionIndexes,\n            _packed\n        );\n    }\n\n    /** \n      @notice \n      Sets permissions for many operators.\n\n      @param _operators The operators to give permission to.\n      @param _domains The domains that can be operated. Set to 0 to allow operation of account level actions.\n      @param _permissionIndexes The level of power each operator should have.\n    */\n    function setOperators(\n        address[] calldata _operators,\n        uint256[] calldata _domains,\n        uint256[][] calldata _permissionIndexes\n    ) external override {\n        // There should be a level for each operator provided.\n        require(\n            _operators.length == _permissionIndexes.length &&\n                _operators.length == _domains.length,\n            \"OperatorStore::setOperators: BAD_ARGS\"\n        );\n        for (uint256 _i = 0; _i < _operators.length; _i++) {\n            // Pack the indexes into a uint256.\n            uint256 _packed = _packedPermissions(_permissionIndexes[_i]);\n            // Store the new value.\n            permissionsOf[_operators[_i]][msg.sender][_domains[_i]] = _packed;\n            emit SetOperator(\n                _operators[_i],\n                msg.sender,\n                _domains[_i],\n                _permissionIndexes[_i],\n                _packed\n            );\n        }\n    }\n\n    // --- private helper functions --- //\n\n    /** \n      @notice \n      Converts an array of permission indexes to a packed int.\n\n      @param _indexes The indexes of the permissions to pack.\n\n      @return packed The packed result.\n    */\n    function _packedPermissions(uint256[] calldata _indexes)\n        private\n        pure\n        returns (uint256 packed)\n    {\n        for (uint256 _i = 0; _i < _indexes.length; _i++) {\n            uint256 _permissionIndex = _indexes[_i];\n            require(\n                _permissionIndex <= 255,\n                \"OperatorStore::_packedPermissions: INDEX_OUT_OF_BOUNDS\"\n            );\n            // Turn the bit at the index on.\n            packed |= 1 << _permissionIndex;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOperatorStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IOperatorStore {\n    event SetOperator(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed domain,\n        uint256[] permissionIndexes,\n        uint256 packed\n    );\n\n    function permissionsOf(\n        address _operator,\n        address _account,\n        uint256 _domain\n    ) external view returns (uint256);\n\n    function hasPermission(\n        address _operator,\n        address _account,\n        uint256 _domain,\n        uint256 _permissionIndex\n    ) external view returns (bool);\n\n    function hasPermissions(\n        address _operator,\n        address _account,\n        uint256 _domain,\n        uint256[] calldata _permissionIndexes\n    ) external view returns (bool);\n\n    function setOperator(\n        address _operator,\n        uint256 _domain,\n        uint256[] calldata _permissionIndexes\n    ) external;\n\n    function setOperators(\n        address[] calldata _operators,\n        uint256[] calldata _domains,\n        uint256[][] calldata _permissionIndexes\n    ) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}