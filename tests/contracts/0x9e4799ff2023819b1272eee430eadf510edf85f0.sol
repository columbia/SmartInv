{{
  "language": "Solidity",
  "settings": {
    "remappings": [
      "ROOT=/home/achapman/augur/packages/augur-core/src/contracts//"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "reporting/ShareToken.sol": {
      "content": "pragma solidity 0.5.15;\n\ncontract IAugur {\n    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function isKnownUniverse(IUniverse _universe) public view returns (bool);\n    function trustedCashTransfer(address _from, address _to, uint256 _amount) public returns (bool);\n    function isTrustedSender(address _address) public returns (bool);\n    function onCategoricalMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, bytes32[] memory _outcomes) public returns (bool);\n    function onYesNoMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash) public returns (bool);\n    function onScalarMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, int256[] memory _prices, uint256 _numTicks)  public returns (bool);\n    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, address _initialReporter, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] memory _payoutNumerators, string memory _description, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime) public returns (bool);\n    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _size, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked, string memory description, uint256[] memory _payoutNumerators, uint256 _currentStake, uint256 _stakeRemaining, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime, bool _pacingOn, uint256 _totalRepStakedInPayout, uint256 _totalRepStakedInMarket, uint256 _disputeRound) public returns (bool);\n    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logMarketFinalized(IUniverse _universe, uint256[] memory _winningPayoutNumerators) public returns (bool);\n    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\n    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\n    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\n    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets, uint256 _fees) public returns (bool);\n    function logMarketOIChanged(IUniverse _universe, IMarket _market) public returns (bool);\n    function logTradingProceedsClaimed(IUniverse _universe, address _sender, address _market, uint256 _outcome, uint256 _numShares, uint256 _numPayoutTokens, uint256 _fees) public returns (bool);\n    function logUniverseForked(IMarket _forkingMarket) public returns (bool);\n    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logReputationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logReputationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logShareTokensBalanceChanged(address _account, IMarket _market, uint256 _outcome, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeWindowCreated(IDisputeWindow _disputeWindow, uint256 _id, bool _initial) public returns (bool);\n    function logParticipationTokensRedeemed(IUniverse universe, address _sender, uint256 _attoParticipationTokens, uint256 _feePayoutShare) public returns (bool);\n    function logTimestampSet(uint256 _newTimestamp) public returns (bool);\n    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\n    function logParticipationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logParticipationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logParticipationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logMarketRepBondTransferred(address _universe, address _from, address _to) public returns (bool);\n    function logWarpSyncDataUpdated(address _universe, uint256 _warpSyncHash, uint256 _marketEndTime) public returns (bool);\n    function isKnownFeeSender(address _feeSender) public view returns (bool);\n    function lookup(bytes32 _key) public view returns (address);\n    function getTimestamp() public view returns (uint256);\n    function getMaximumMarketEndDate() public returns (uint256);\n    function isKnownMarket(IMarket _market) public view returns (bool);\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators, uint256 _numTicks, uint256 numOutcomes) public view returns (bytes32);\n    function logValidityBondChanged(uint256 _validityBond) public returns (bool);\n    function logDesignatedReportStakeChanged(uint256 _designatedReportStake) public returns (bool);\n    function logNoShowBondChanged(uint256 _noShowBond) public returns (bool);\n    function logReportingFeeChanged(uint256 _reportingFee) public returns (bool);\n    function getUniverseForkIndex(IUniverse _universe) public view returns (uint256);\n}\n\nlibrary ContractExists {\n    function exists(address _address) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(_address) }\n        return size > 0;\n    }\n}\n\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\ncontract IOwnable {\n    function getOwner() public view returns (address);\n    function transferOwnership(address _newOwner) public returns (bool);\n}\n\ncontract ITyped {\n    function getTypeName() public view returns (bytes32);\n}\n\ncontract Initializable {\n    bool private initialized = false;\n\n    modifier beforeInitialized {\n        require(!initialized);\n        _;\n    }\n\n    function endInitialization() internal beforeInitialized {\n        initialized = true;\n    }\n\n    function getInitialized() public view returns (bool) {\n        return initialized;\n    }\n}\n\ncontract ReentrancyGuard {\n    /**\n     * @dev We use a single lock for the whole contract.\n     */\n    bool private rentrancyLock = false;\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * @notice If you mark a function `nonReentrant`, you should also mark it `external`. Calling one nonReentrant function from another is not supported. Instead, you can implement a `private` function doing the actual work, and a `external` wrapper marked as `nonReentrant`.\n     */\n    modifier nonReentrant() {\n        require(!rentrancyLock);\n        rentrancyLock = true;\n        _;\n        rentrancyLock = false;\n    }\n}\n\nlibrary TokenId {\n\n    function getTokenId(IMarket _market, uint256 _outcome) internal pure returns (uint256 _tokenId) {\n        bytes memory _tokenIdBytes = abi.encodePacked(_market, uint8(_outcome));\n        assembly {\n            _tokenId := mload(add(_tokenIdBytes, add(0x20, 0)))\n        }\n    }\n\n    function getTokenIds(IMarket _market, uint256[] memory _outcomes) internal pure returns (uint256[] memory _tokenIds) {\n        _tokenIds = new uint256[](_outcomes.length);\n        for (uint256 _i = 0; _i < _outcomes.length; _i++) {\n            _tokenIds[_i] = getTokenId(_market, _outcomes[_i]);\n        }\n    }\n\n    function unpackTokenId(uint256 _tokenId) internal pure returns (address _market, uint256 _outcome) {\n        assembly {\n            _market := shr(96,  and(_tokenId, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000))\n            _outcome := shr(88, and(_tokenId, 0x0000000000000000000000000000000000000000FF0000000000000000000000))\n        }\n    }\n}\n\nlibrary SafeMathUint256 {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            uint256 x = (y + 1) / 2;\n            z = y;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function getUint256Min() internal pure returns (uint256) {\n        return 0;\n    }\n\n    function getUint256Max() internal pure returns (uint256) {\n        // 2 ** 256 - 1\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    }\n\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n        return a % b == 0;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, base), b);\n    }\n}\n\ninterface IERC1155 {\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    /// Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define a token ID with no initial balance, the contract SHOULD emit the TransferSingle event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    ///Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /// @dev MUST emit when an approval is updated.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /// @dev MUST emit when the URI is updated for a token ID.\n    /// URIs are defined in RFC 3986.\n    /// The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\".\n    event URI(\n        string value,\n        uint256 indexed id\n    );\n\n    /// @notice Transfers value amount of an _id from the _from address to the _to address specified.\n    /// @dev MUST emit TransferSingle event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if balance of sender for token `_id` is lower than the `_value` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155Received` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`.\n    /// @param from    Source address\n    /// @param to      Target address\n    /// @param id      ID of the token type\n    /// @param value   Transfer amount\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Send multiple types of Tokens from a 3rd party in one transfer (with safety call).\n    /// @dev MUST emit TransferBatch event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if length of `_ids` is not the same as length of `_values`.\n    ///  MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_values` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`.\n    /// @param from    Source addresses\n    /// @param to      Target addresses\n    /// @param ids     IDs of each token type\n    /// @param values  Transfer amounts per token type\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n    /// @dev MUST emit the ApprovalForAll event on success.\n    /// @param operator  Address to add to the set of authorized operators\n    /// @param approved  True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @notice Queries the approval status of an operator for a given owner.\n    /// @param owner     The owner of the Tokens\n    /// @param operator  Address of authorized operator\n    /// @return           True if the operator is approved, false if not\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /// @notice Get the balance of an account's Tokens.\n    /// @param owner  The address of the token holder\n    /// @param id     ID of the Token\n    /// @return        The _owner's balance of the Token type requested\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /// @notice Get the total supply of a Token.\n    /// @param id     ID of the Token\n    /// @return        The total supply of the Token type requested\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /// @notice Get the balance of multiple account/token pairs\n    /// @param owners The addresses of the token holders\n    /// @param ids    ID of the Tokens\n    /// @return        The _owner's balance of the Token types requested\n    function balanceOfBatch(\n        address[] calldata owners,\n        uint256[] calldata ids\n    )\n        external\n        view\n        returns (uint256[] memory balances_);\n}\n\ncontract ERC1155 is ERC165, IERC1155 {\n    using SafeMathUint256 for uint256;\n    using ContractExists for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) public _balances;\n\n    // Mapping from token ID to total supply\n    mapping (uint256 => uint256) public _supplys;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) public _operatorApprovals;\n\n    constructor()\n        public\n    {\n        _registerInterface(\n            ERC1155(0).safeTransferFrom.selector ^\n            ERC1155(0).safeBatchTransferFrom.selector ^\n            ERC1155(0).balanceOf.selector ^\n            ERC1155(0).balanceOfBatch.selector ^\n            ERC1155(0).setApprovalForAll.selector ^\n            ERC1155(0).isApprovedForAll.selector\n        );\n    }\n\n    /**\n        @dev Get the specified address' balance for token with specified ID.\n\n        Attempting to query the zero account for a balance will result in a revert.\n\n        @param account The address of the token holder\n        @param id ID of the token\n        @return The account's balance of the token type requested\n     */\n    function balanceOf(address account, uint256 id) public view returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function totalSupply(uint256 id) public view returns (uint256) {\n        return _supplys[id];\n    }\n\n    /**\n        @dev Get the balance of multiple account/token pairs.\n\n        If any of the query accounts is the zero account, this query will revert.\n\n        @param accounts The addresses of the token holders\n        @param ids IDs of the tokens\n        @return Balances for each account and token id pair\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and IDs must have same lengths\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: some address in batch balance query is zero\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator.\n     *\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     *\n     * Because an account already has operator privileges for itself, this function will revert\n     * if the account attempts to set the approval status for itself.\n     *\n     * @param operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        require(msg.sender != operator, \"ERC1155: cannot set approval status for self\");\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n        @notice Queries the approval status of an operator for a given account.\n        @param account   The account of the Tokens\n        @param operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address account, address operator) public view returns (bool) {\n        return operator == address(this) || _operatorApprovals[account][operator];\n    }\n\n    /**\n        @dev Transfers `value` amount of an `id` from the `from` address to the `to` address specified.\n        Caller must be approved to manage the tokens being transferred out of the `from` account.\n        If `to` is a smart contract, will call `onERC1155Received` on `to` and act appropriately.\n        @param from Source address\n        @param to Target address\n        @param id ID of the token type\n        @param value Transfer amount\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n    {\n        _transferFrom(from, to, id, value, data, true);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data,\n        bool doAcceptanceCheck\n    )\n        internal\n    {\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender) == true,\n            \"ERC1155: need operator approval for 3rd party transfers\"\n        );\n\n        _internalTransferFrom(from, to, id, value, data, doAcceptanceCheck);\n    }\n\n    function _internalTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data,\n        bool doAcceptanceCheck\n    )\n        internal\n    {\n        _balances[id][from] = _balances[id][from].sub(value);\n        _balances[id][to] = _balances[id][to].add(value);\n\n        onTokenTransfer(id, from, to, value);\n        emit TransferSingle(msg.sender, from, to, id, value);\n\n        if (doAcceptanceCheck) {\n            _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, value, data);\n        }\n    }\n\n    /**\n        @dev Transfers `values` amount(s) of `ids` from the `from` address to the\n        `to` address specified. Caller must be approved to manage the tokens being\n        transferred out of the `from` account. If `to` is a smart contract, will\n        call `onERC1155BatchReceived` on `to` and act appropriately.\n        @param from Source address\n        @param to Target address\n        @param ids IDs of each token type\n        @param values Transfer amounts per token type\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n    {\n        _batchTransferFrom(from, to, ids, values, data, true);\n    }\n\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data,\n        bool doAcceptanceCheck\n    )\n        internal\n    {\n        require(ids.length == values.length, \"ERC1155: IDs and values must have same lengths\");\n        if (ids.length == 0) {\n            return;\n        }\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender) == true,\n            \"ERC1155: need operator approval for 3rd party transfers\"\n        );\n\n        _internalBatchTransferFrom(from, to, ids, values, data, doAcceptanceCheck);\n    }\n\n    function _internalBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data,\n        bool doAcceptanceCheck\n    )\n        internal\n    {\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n\n            _balances[id][from] = _balances[id][from].sub(value);\n            _balances[id][to] = _balances[id][to].add(value);\n            onTokenTransfer(id, from, to, value);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, values);\n\n        if (doAcceptanceCheck) {\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, ids, values, data);\n        }\n    }\n\n    /**\n     * @dev Internal function to mint an amount of a token with the given ID\n     * @param to The address that will own the minted token\n     * @param id ID of the token to be minted\n     * @param value Amount of the token to be minted\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data, bool doAcceptanceCheck) internal {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        _balances[id][to] = _balances[id][to].add(value);\n        _supplys[id] = _supplys[id].add(value);\n\n        onMint(id, to, value);\n        emit TransferSingle(msg.sender, address(0), to, id, value);\n\n        if (doAcceptanceCheck) {\n            _doSafeTransferAcceptanceCheck(msg.sender, address(0), to, id, value, data);\n        }\n    }\n\n    /**\n     * @dev Internal function to batch mint amounts of tokens with the given IDs\n     * @param to The address that will own the minted token\n     * @param ids IDs of the tokens to be minted\n     * @param values Amounts of the tokens to be minted\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data, bool doAcceptanceCheck) internal {\n        require(to != address(0), \"ERC1155: batch mint to the zero address\");\n        require(ids.length == values.length, \"ERC1155: minted IDs and values must have same lengths\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = values[i].add(_balances[ids[i]][to]);\n            _supplys[ids[i]] = _supplys[ids[i]].add(values[i]);\n            onMint(ids[i], to, values[i]);\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, values);\n\n        if (doAcceptanceCheck) {\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, address(0), to, ids, values, data);\n        }\n    }\n\n    /**\n     * @dev Internal function to burn an amount of a token with the given ID\n     * @param account Account which owns the token to be burnt\n     * @param id ID of the token to be burnt\n     * @param value Amount of the token to be burnt\n     */\n    function _burn(address account, uint256 id, uint256 value, bytes memory data, bool doAcceptanceCheck) internal {\n        require(account != address(0), \"ERC1155: attempting to burn tokens on zero account\");\n\n        _balances[id][account] = _balances[id][account].sub(value);\n        _supplys[id] = _supplys[id].sub(value);\n        onBurn(id, account, value);\n        emit TransferSingle(msg.sender, account, address(0), id, value);\n\n        if (doAcceptanceCheck) {\n            _doSafeTransferAcceptanceCheck(msg.sender, account, address(0), id, value, data);\n        }\n    }\n\n    /**\n     * @dev Internal function to batch burn an amounts of tokens with the given IDs\n     * @param account Account which owns the token to be burnt\n     * @param ids IDs of the tokens to be burnt\n     * @param values Amounts of the tokens to be burnt\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory values, bytes memory data, bool doAcceptanceCheck) internal {\n        require(account != address(0), \"ERC1155: attempting to burn batch of tokens on zero account\");\n        require(ids.length == values.length, \"ERC1155: burnt IDs and values must have same lengths\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(values[i]);\n            _supplys[ids[i]] = _supplys[ids[i]].sub(values[i]);\n            onBurn(ids[i], account, values[i]);\n        }\n\n        emit TransferBatch(msg.sender, account, address(0), ids, values);\n\n        if (doAcceptanceCheck) {\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, account, address(0), ids, values, data);\n        }\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n    {\n        if (to.exists()) {\n            require(\n                IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) ==\n                    IERC1155Receiver(to).onERC1155Received.selector,\n                \"ERC1155: got unknown value from onERC1155Received\"\n            );\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    )\n        internal\n    {\n        if (to.exists()) {\n            require(\n                IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) ==\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector,\n                \"ERC1155: got unknown value from onERC1155BatchReceived\"\n            );\n        }\n    }\n\n    // Subclasses of this token generally want to send additional logs through the centralized Augur log emitter contract\n    function onTokenTransfer(uint256 _tokenId, address _from, address _to, uint256 _value) internal;\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onMint(uint256 _tokenId, address _target, uint256 _amount) internal;\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onBurn(uint256 _tokenId, address _target, uint256 _amount) internal;\n}\n\ncontract IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n\ncontract IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) public view returns (uint256);\n    function transfer(address to, uint256 amount) public returns (bool);\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\n    function approve(address spender, uint256 amount) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ICash is IERC20 {\n}\n\ncontract IAffiliateValidator {\n    function validateReference(address _account, address _referrer) external view returns (bool);\n}\n\ncontract IDisputeWindow is ITyped, IERC20 {\n    function invalidMarketsTotal() external view returns (uint256);\n    function validityBondTotal() external view returns (uint256);\n\n    function incorrectDesignatedReportTotal() external view returns (uint256);\n    function initialReportBondTotal() external view returns (uint256);\n\n    function designatedReportNoShowsTotal() external view returns (uint256);\n    function designatedReporterNoShowBondTotal() external view returns (uint256);\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _disputeWindowId, bool _participationTokensEnabled, uint256 _duration, uint256 _startTime) public;\n    function trustedBuy(address _buyer, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getReputationToken() public view returns (IReputationToken);\n    function getStartTime() public view returns (uint256);\n    function getEndTime() public view returns (uint256);\n    function getWindowId() public view returns (uint256);\n    function isActive() public view returns (bool);\n    function isOver() public view returns (bool);\n    function onMarketFinalized() public;\n    function redeem(address _account) public returns (bool);\n}\n\ncontract IMarket is IOwnable {\n    enum MarketType {\n        YES_NO,\n        CATEGORICAL,\n        SCALAR\n    }\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public;\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators) public view returns (bytes32);\n    function doInitialReport(uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getDisputeWindow() public view returns (IDisputeWindow);\n    function getNumberOfOutcomes() public view returns (uint256);\n    function getNumTicks() public view returns (uint256);\n    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\n    function getForkingMarket() public view returns (IMarket _market);\n    function getEndTime() public view returns (uint256);\n    function getWinningPayoutDistributionHash() public view returns (bytes32);\n    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningReportingParticipant() public view returns (IReportingParticipant);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getFinalizationTime() public view returns (uint256);\n    function getInitialReporter() public view returns (IInitialReporter);\n    function getDesignatedReportingEndTime() public view returns (uint256);\n    function getValidityBondAttoCash() public view returns (uint256);\n    function affiliateFeeDivisor() external view returns (uint256);\n    function getNumParticipants() public view returns (uint256);\n    function getDisputePacingOn() public view returns (bool);\n    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\n    function recordMarketCreatorFees(uint256 _marketCreatorFees, address _sourceAccount, bytes32 _fingerprint) public returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function isFinalizedAsInvalid() public view returns (bool);\n    function finalize() public returns (bool);\n    function isFinalized() public view returns (bool);\n    function getOpenInterest() public view returns (uint256);\n}\n\ncontract IReportingParticipant {\n    function getStake() public view returns (uint256);\n    function getPayoutDistributionHash() public view returns (bytes32);\n    function liquidateLosing() public;\n    function redeem(address _redeemer) public returns (bool);\n    function isDisavowed() public view returns (bool);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getMarket() public view returns (IMarket);\n    function getSize() public view returns (uint256);\n}\n\ncontract IInitialReporter is IReportingParticipant, IOwnable {\n    function initialize(IAugur _augur, IMarket _market, address _designatedReporter) public;\n    function report(address _reporter, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _initialReportStake) public;\n    function designatedReporterShowed() public view returns (bool);\n    function initialReporterWasCorrect() public view returns (bool);\n    function getDesignatedReporter() public view returns (address);\n    function getReportTimestamp() public view returns (uint256);\n    function migrateToNewUniverse(address _designatedReporter) public;\n    function returnRepFromDisavow() public;\n}\n\ncontract IReputationToken is IERC20 {\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool);\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getTotalMigrated() public view returns (uint256);\n    function getTotalTheoreticalSupply() public view returns (uint256);\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\n}\n\ncontract IShareToken is ITyped, IERC1155 {\n    function initialize(IAugur _augur) external;\n    function initializeMarket(IMarket _market, uint256 _numOutcomes, uint256 _numTicks) public;\n    function unsafeTransferFrom(address _from, address _to, uint256 _id, uint256 _value) public;\n    function unsafeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;\n    function claimTradingProceeds(IMarket _market, address _shareHolder, bytes32 _fingerprint) external returns (uint256[] memory _outcomeFees);\n    function getMarket(uint256 _tokenId) external view returns (IMarket);\n    function getOutcome(uint256 _tokenId) external view returns (uint256);\n    function getTokenId(IMarket _market, uint256 _outcome) public pure returns (uint256 _tokenId);\n    function getTokenIds(IMarket _market, uint256[] memory _outcomes) public pure returns (uint256[] memory _tokenIds);\n    function buyCompleteSets(IMarket _market, address _account, uint256 _amount) external returns (bool);\n    function buyCompleteSetsForTrade(IMarket _market, uint256 _amount, uint256 _longOutcome, address _longRecipient, address _shortRecipient) external returns (bool);\n    function sellCompleteSets(IMarket _market, address _holder, address _recipient, uint256 _amount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function sellCompleteSetsForTrade(IMarket _market, uint256 _outcome, uint256 _amount, address _shortParticipant, address _longParticipant, address _shortRecipient, address _longRecipient, uint256 _price, address _sourceAccount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function totalSupplyForMarketOutcome(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function balanceOfMarketOutcome(IMarket _market, uint256 _outcome, address _account) public view returns (uint256);\n    function lowestBalanceOfMarketOutcomes(IMarket _market, uint256[] memory _outcomes, address _account) public view returns (uint256);\n}\n\ncontract IUniverse {\n    function creationTime() external view returns (uint256);\n    function marketBalance(address) external view returns (uint256);\n\n    function fork() public returns (bool);\n    function updateForkValues() public returns (bool);\n    function getParentUniverse() public view returns (IUniverse);\n    function createChildUniverse(uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getForkingMarket() public view returns (IMarket);\n    function getForkEndTime() public view returns (uint256);\n    function getForkReputationGoal() public view returns (uint256);\n    function getParentPayoutDistributionHash() public view returns (bytes32);\n    function getDisputeRoundDurationInSeconds(bool _initial) public view returns (uint256);\n    function getOrCreateDisputeWindowByTimestamp(uint256 _timestamp, bool _initial) public returns (IDisputeWindow);\n    function getOrCreateCurrentDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreateNextDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreatePreviousDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOpenInterestInAttoCash() public view returns (uint256);\n    function getTargetRepMarketCapInAttoCash() public view returns (uint256);\n    function getOrCacheValidityBond() public returns (uint256);\n    function getOrCacheDesignatedReportStake() public returns (uint256);\n    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\n    function getOrCacheMarketRepBond() public returns (uint256);\n    function getOrCacheReportingFeeDivisor() public returns (uint256);\n    function getDisputeThresholdForFork() public view returns (uint256);\n    function getDisputeThresholdForDisputePacing() public view returns (uint256);\n    function getInitialReportMinValue() public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getReportingFeeDivisor() public view returns (uint256);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningChildPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function isOpenInterestCash(address) public view returns (bool);\n    function isForkingMarket() public view returns (bool);\n    function getCurrentDisputeWindow(bool _initial) public view returns (IDisputeWindow);\n    function getDisputeWindowStartTimeAndDuration(uint256 _timestamp, bool _initial) public view returns (uint256, uint256);\n    function isParentOf(IUniverse _shadyChild) public view returns (bool);\n    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\n    function isContainerForDisputeWindow(IDisputeWindow _shadyTarget) public view returns (bool);\n    function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function migrateMarketOut(IUniverse _destinationUniverse) public returns (bool);\n    function migrateMarketIn(IMarket _market, uint256 _cashBalance, uint256 _marketOI) public returns (bool);\n    function decrementOpenInterest(uint256 _amount) public returns (bool);\n    function decrementOpenInterestFromMarket(IMarket _market) public returns (bool);\n    function incrementOpenInterest(uint256 _amount) public returns (bool);\n    function getWinningChildUniverse() public view returns (IUniverse);\n    function isForking() public view returns (bool);\n    function deposit(address _sender, uint256 _amount, address _market) public returns (bool);\n    function withdraw(address _recipient, uint256 _amount, address _market) public returns (bool);\n    function createScalarMarket(uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, int256[] memory _prices, uint256 _numTicks, string memory _extraInfo) public returns (IMarket _newMarket);\n}\n\ncontract IV2ReputationToken is IReputationToken {\n    function parentUniverse() external returns (IUniverse);\n    function burnForMarket(uint256 _amountToBurn) public returns (bool);\n    function mintForWarpSync(uint256 _amountToMint, address _target) public returns (bool);\n}\n\ncontract IAugurTrading {\n    function lookup(bytes32 _key) public view returns (address);\n    function logProfitLossChanged(IMarket _market, address _account, uint256 _outcome, int256 _netPosition, uint256 _avgPrice, int256 _realizedProfit, int256 _frozenFunds, int256 _realizedCost) public returns (bool);\n    function logOrderCreated(IUniverse _universe, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logOrderCanceled(IUniverse _universe, IMarket _market, address _creator, uint256 _tokenRefund, uint256 _sharesRefund, bytes32 _orderId) public returns (bool);\n    function logOrderFilled(IUniverse _universe, address _creator, address _filler, uint256 _price, uint256 _fees, uint256 _amountFilled, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logMarketVolumeChanged(IUniverse _universe, address _market, uint256 _volume, uint256[] memory _outcomeVolumes, uint256 _totalTrades) public returns (bool);\n    function logZeroXOrderFilled(IUniverse _universe, IMarket _market, bytes32 _orderHash, bytes32 _tradeGroupId, uint8 _orderType, address[] memory _addressData, uint256[] memory _uint256Data) public returns (bool);\n    function logZeroXOrderCanceled(address _universe, address _market, address _account, uint256 _outcome, uint256 _price, uint256 _amount, uint8 _type, bytes32 _orderHash) public;\n}\n\ncontract IOrders {\n    function saveOrder(uint256[] calldata _uints, bytes32[] calldata _bytes32s, Order.Types _type, IMarket _market, address _sender) external returns (bytes32 _orderId);\n    function removeOrder(bytes32 _orderId) external returns (bool);\n    function getMarket(bytes32 _orderId) public view returns (IMarket);\n    function getOrderType(bytes32 _orderId) public view returns (Order.Types);\n    function getOutcome(bytes32 _orderId) public view returns (uint256);\n    function getAmount(bytes32 _orderId) public view returns (uint256);\n    function getPrice(bytes32 _orderId) public view returns (uint256);\n    function getOrderCreator(bytes32 _orderId) public view returns (address);\n    function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderDataForCancel(bytes32 _orderId) public view returns (uint256, uint256, Order.Types, IMarket, uint256, address);\n    function getOrderDataForLogs(bytes32 _orderId) public view returns (Order.Types, address[] memory _addressData, uint256[] memory _uint256Data);\n    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function getOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\n    function getTotalEscrowed(IMarket _market) public view returns (uint256);\n    function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\n    function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\n    function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled, uint256 _fill) external returns (bool);\n    function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\n}\n\nlibrary Order {\n    using SafeMathUint256 for uint256;\n\n    enum Types {\n        Bid, Ask\n    }\n\n    enum TradeDirections {\n        Long, Short\n    }\n\n    struct Data {\n        // Contracts\n        IMarket market;\n        IAugur augur;\n        IAugurTrading augurTrading;\n        IShareToken shareToken;\n        ICash cash;\n\n        // Order\n        bytes32 id;\n        address creator;\n        uint256 outcome;\n        Order.Types orderType;\n        uint256 amount;\n        uint256 price;\n        uint256 sharesEscrowed;\n        uint256 moneyEscrowed;\n        bytes32 betterOrderId;\n        bytes32 worseOrderId;\n    }\n\n    function create(IAugur _augur, IAugurTrading _augurTrading, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data memory) {\n        require(_outcome < _market.getNumberOfOutcomes(), \"Order.create: Outcome is not within market range\");\n        require(_price != 0, \"Order.create: Price may not be 0\");\n        require(_price < _market.getNumTicks(), \"Order.create: Price is outside of market range\");\n        require(_attoshares > 0, \"Order.create: Cannot use amount of 0\");\n        require(_creator != address(0), \"Order.create: Creator is 0x0\");\n\n        IShareToken _shareToken = IShareToken(_augur.lookup(\"ShareToken\"));\n\n        return Data({\n            market: _market,\n            augur: _augur,\n            augurTrading: _augurTrading,\n            shareToken: _shareToken,\n            cash: ICash(_augur.lookup(\"Cash\")),\n            id: 0,\n            creator: _creator,\n            outcome: _outcome,\n            orderType: _type,\n            amount: _attoshares,\n            price: _price,\n            sharesEscrowed: 0,\n            moneyEscrowed: 0,\n            betterOrderId: _betterOrderId,\n            worseOrderId: _worseOrderId\n        });\n    }\n\n    //\n    // \"public\" functions\n    //\n\n    function getOrderId(Order.Data memory _orderData, IOrders _orders) internal view returns (bytes32) {\n        if (_orderData.id == bytes32(0)) {\n            bytes32 _orderId = calculateOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\n            require(_orders.getAmount(_orderId) == 0, \"Order.getOrderId: New order had amount. This should not be possible\");\n            _orderData.id = _orderId;\n        }\n        return _orderData.id;\n    }\n\n    function calculateOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(_type, _market, _amount, _price, _sender, _blockNumber, _outcome, _moneyEscrowed, _sharesEscrowed));\n    }\n\n    function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\n        return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\n    }\n\n    function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\n        return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\n    }\n\n    function saveOrder(Order.Data memory _orderData, bytes32 _tradeGroupId, IOrders _orders) internal returns (bytes32) {\n        getOrderId(_orderData, _orders);\n        uint256[] memory _uints = new uint256[](5);\n        _uints[0] = _orderData.amount;\n        _uints[1] = _orderData.price;\n        _uints[2] = _orderData.outcome;\n        _uints[3] = _orderData.moneyEscrowed;\n        _uints[4] = _orderData.sharesEscrowed;\n        bytes32[] memory _bytes32s = new bytes32[](4);\n        _bytes32s[0] = _orderData.betterOrderId;\n        _bytes32s[1] = _orderData.worseOrderId;\n        _bytes32s[2] = _tradeGroupId;\n        _bytes32s[3] = _orderData.id;\n        return _orders.saveOrder(_uints, _bytes32s, _orderData.orderType, _orderData.market, _orderData.creator);\n    }\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ncontract ShareToken is ITyped, Initializable, ERC1155, IShareToken, ReentrancyGuard {\n\n    string constant public name = \"Shares\";\n    string constant public symbol = \"SHARE\";\n\n    struct MarketData {\n        uint256 numOutcomes;\n        uint256 numTicks;\n    }\n\n    mapping(address => MarketData) markets;\n\n    IAugur public augur;\n    ICash public cash;\n\n    function initialize(IAugur _augur) external beforeInitialized {\n        endInitialization();\n        augur = _augur;\n        cash = ICash(_augur.lookup(\"Cash\"));\n\n        require(cash != ICash(0));\n    }\n\n    /**\n        @dev Transfers `value` amount of an `id` from the `from` address to the `to` address specified.\n        Caller must be approved to manage the tokens being transferred out of the `from` account.\n        Regardless of if the desintation is a contract or not this will not call `onERC1155Received` on `to`\n        @param _from Source address\n        @param _to Target address\n        @param _id ID of the token type\n        @param _value Transfer amount\n    */\n    function unsafeTransferFrom(address _from, address _to, uint256 _id, uint256 _value) public {\n        _transferFrom(_from, _to, _id, _value, bytes(\"\"), false);\n    }\n\n    /**\n        @dev Transfers `values` amount(s) of `ids` from the `from` address to the\n        `to` address specified. Caller must be approved to manage the tokens being\n        transferred out of the `from` account. Regardless of if the desintation is\n        a contract or not this will not call `onERC1155Received` on `to`\n        @param _from Source address\n        @param _to Target address\n        @param _ids IDs of each token type\n        @param _values Transfer amounts per token type\n    */\n    function unsafeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public {\n        _batchTransferFrom(_from, _to, _ids, _values, bytes(\"\"), false);\n    }\n\n    function initializeMarket(IMarket _market, uint256 _numOutcomes, uint256 _numTicks) public {\n        require (augur.isKnownUniverse(IUniverse(msg.sender)));\n        markets[address(_market)].numOutcomes = _numOutcomes;\n        markets[address(_market)].numTicks = _numTicks;\n    }\n\n    /**\n     * @notice Buy some amount of complete sets for a market\n     * @param _market The market to purchase complete sets in\n     * @param _amount The number of complete sets to purchase\n     * @return Bool True\n     */\n    function publicBuyCompleteSets(IMarket _market, uint256 _amount) external returns (bool) {\n        buyCompleteSetsInternal(_market, msg.sender, _amount);\n        augur.logCompleteSetsPurchased(_market.getUniverse(), _market, msg.sender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Buy some amount of complete sets for a market\n     * @param _market The market to purchase complete sets in\n     * @param _account The account receiving the complete sets\n     * @param _amount The number of complete sets to purchase\n     * @return Bool True\n     */\n    function buyCompleteSets(IMarket _market, address _account, uint256 _amount) external returns (bool) {\n        buyCompleteSetsInternal(_market, _account, _amount);\n        return true;\n    }\n\n    function buyCompleteSetsInternal(IMarket _market, address _account, uint256 _amount) internal returns (bool) {\n        uint256 _numOutcomes = markets[address(_market)].numOutcomes;\n        uint256 _numTicks = markets[address(_market)].numTicks;\n\n        require(_numOutcomes != 0, \"Invalid Market provided\");\n\n        IUniverse _universe = _market.getUniverse();\n\n        uint256 _cost = _amount.mul(_numTicks);\n        _universe.deposit(msg.sender, _cost, address(_market));\n\n        uint256[] memory _tokenIds = new uint256[](_numOutcomes);\n        uint256[] memory _values = new uint256[](_numOutcomes);\n\n        for (uint256 _i = 0; _i < _numOutcomes; _i++) {\n            _tokenIds[_i] = TokenId.getTokenId(_market, _i);\n            _values[_i] = _amount;\n        }\n\n        _mintBatch(_account, _tokenIds, _values, bytes(\"\"), false);\n\n        if (!_market.isFinalized()) {\n            _universe.incrementOpenInterest(_cost);\n        }\n\n        augur.logMarketOIChanged(_universe, _market);\n\n        assertBalances(_market);\n        return true;\n    }\n\n    /**\n     * @notice Buy some amount of complete sets for a market and distribute the shares according to the positions of two accounts\n     * @param _market The market to purchase complete sets in\n     * @param _amount The number of complete sets to purchase\n     * @param _longOutcome The outcome for the trade being fulfilled\n     * @param _longRecipient The account which should recieve the _longOutcome shares\n     * @param _shortRecipient The account which should recieve shares of every outcome other than _longOutcome\n     * @return Bool True\n     */\n    function buyCompleteSetsForTrade(IMarket _market, uint256 _amount, uint256 _longOutcome, address _longRecipient, address _shortRecipient) external returns (bool) {\n        uint256 _numOutcomes = markets[address(_market)].numOutcomes;\n\n        require(_numOutcomes != 0, \"Invalid Market provided\");\n        require(_longOutcome < _numOutcomes);\n\n        IUniverse _universe = _market.getUniverse();\n\n        {\n            uint256 _numTicks = markets[address(_market)].numTicks;\n            uint256 _cost = _amount.mul(_numTicks);\n            _universe.deposit(msg.sender, _cost, address(_market));\n\n            if (!_market.isFinalized()) {\n                _universe.incrementOpenInterest(_cost);\n            }\n        }\n\n        uint256[] memory _tokenIds = new uint256[](_numOutcomes - 1);\n        uint256[] memory _values = new uint256[](_numOutcomes - 1);\n        uint256 _outcome = 0;\n\n        for (uint256 _i = 0; _i < _numOutcomes - 1; _i++) {\n            if (_outcome == _longOutcome) {\n                _outcome++;\n            }\n            _tokenIds[_i] = TokenId.getTokenId(_market, _outcome);\n            _values[_i] = _amount;\n            _outcome++;\n        }\n\n        _mintBatch(_shortRecipient, _tokenIds, _values, bytes(\"\"), false);\n        _mint(_longRecipient, TokenId.getTokenId(_market, _longOutcome), _amount, bytes(\"\"), false);\n\n        augur.logMarketOIChanged(_universe, _market);\n\n        assertBalances(_market);\n        return true;\n    }\n\n    /**\n     * @notice Sell some amount of complete sets for a market\n     * @param _market The market to sell complete sets in\n     * @param _amount The number of complete sets to sell\n     * @return (uint256 _creatorFee, uint256 _reportingFee) The fees taken for the market creator and reporting respectively\n     */\n    function publicSellCompleteSets(IMarket _market, uint256 _amount) external returns (uint256 _creatorFee, uint256 _reportingFee) {\n        (uint256 _payout, uint256 _creatorFee, uint256 _reportingFee) = burnCompleteSets(_market, msg.sender, _amount, msg.sender, bytes32(0));\n\n        require(cash.transfer(msg.sender, _payout));\n\n        IUniverse _universe = _market.getUniverse();\n        augur.logCompleteSetsSold(_universe, _market, msg.sender, _amount, _creatorFee.add(_reportingFee));\n\n        assertBalances(_market);\n        return (_creatorFee, _reportingFee);\n    }\n\n    /**\n     * @notice Sell some amount of complete sets for a market\n     * @param _market The market to sell complete sets in\n     * @param _holder The holder of the complete sets\n     * @param _recipient The recipient of funds from the sale\n     * @param _amount The number of complete sets to sell\n     * @param _fingerprint Fingerprint of the filler used to naively restrict affiliate fee dispursement\n     * @return (uint256 _creatorFee, uint256 _reportingFee) The fees taken for the market creator and reporting respectively\n     */\n    function sellCompleteSets(IMarket _market, address _holder, address _recipient, uint256 _amount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee) {\n        require(_holder == msg.sender || isApprovedForAll(_holder, msg.sender) == true, \"ERC1155: need operator approval to sell complete sets\");\n        \n        (uint256 _payout, uint256 _creatorFee, uint256 _reportingFee) = burnCompleteSets(_market, _holder, _amount, _holder, _fingerprint);\n\n        require(cash.transfer(_recipient, _payout));\n\n        assertBalances(_market);\n        return (_creatorFee, _reportingFee);\n    }\n\n    /**\n     * @notice Sell some amount of complete sets for a market\n     * @param _market The market to sell complete sets in\n     * @param _amount The number of complete sets to sell\n     * @param _shortParticipant The account which should provide the short party portion of shares\n     * @param _longParticipant The account which should provide the long party portion of shares\n     * @param _longRecipient The account which should receive the remaining payout for providing the matching shares to the short recipients shares\n     * @param _shortRecipient The account which should recieve the (price * shares provided) payout for selling their side of the sale\n     * @param _price The price of the trade being done. This determines how much each recipient recieves from the sale proceeds\n     * @param _fingerprint Fingerprint of the filler used to naively restrict affiliate fee dispursement\n     * @return (uint256 _creatorFee, uint256 _reportingFee) The fees taken for the market creator and reporting respectively\n     */\n    function sellCompleteSetsForTrade(IMarket _market, uint256 _outcome, uint256 _amount, address _shortParticipant, address _longParticipant, address _shortRecipient, address _longRecipient, uint256 _price, address _sourceAccount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee) {\n        require(isApprovedForAll(_shortParticipant, msg.sender) == true, \"ERC1155: need operator approval to burn short account shares\");\n        require(isApprovedForAll(_longParticipant, msg.sender) == true, \"ERC1155: need operator approval to burn long account shares\");\n\n        _internalTransferFrom(_shortParticipant, _longParticipant, getTokenId(_market, _outcome), _amount, bytes(\"\"), false);\n\n        // NOTE: burnCompleteSets will validate the market provided is legitimate\n        (uint256 _payout, uint256 _creatorFee, uint256 _reportingFee) = burnCompleteSets(_market, _longParticipant, _amount, _sourceAccount, _fingerprint);\n\n        {\n            uint256 _longPayout = _payout.mul(_price) / _market.getNumTicks();\n            require(cash.transfer(_longRecipient, _longPayout));\n            require(cash.transfer(_shortRecipient, _payout.sub(_longPayout)));\n        }\n\n        assertBalances(_market);\n        return (_creatorFee, _reportingFee);\n    }\n\n    function burnCompleteSets(IMarket _market, address _account, uint256 _amount, address _sourceAccount, bytes32 _fingerprint) private returns (uint256 _payout, uint256 _creatorFee, uint256 _reportingFee) {\n        uint256 _numOutcomes = markets[address(_market)].numOutcomes;\n        uint256 _numTicks = markets[address(_market)].numTicks;\n\n        require(_numOutcomes != 0, \"Invalid Market provided\");\n\n        // solium-disable indentation\n        {\n            uint256[] memory _tokenIds = new uint256[](_numOutcomes);\n            uint256[] memory _values = new uint256[](_numOutcomes);\n\n            for (uint256 i = 0; i < _numOutcomes; i++) {\n                _tokenIds[i] = TokenId.getTokenId(_market, i);\n                _values[i] = _amount;\n            }\n\n            _burnBatch(_account, _tokenIds, _values, bytes(\"\"), false);\n        }\n        // solium-enable indentation\n\n        _payout = _amount.mul(_numTicks);\n        IUniverse _universe = _market.getUniverse();\n\n        if (!_market.isFinalized()) {\n            _universe.decrementOpenInterest(_payout);\n        }\n\n        _creatorFee = _market.deriveMarketCreatorFeeAmount(_payout);\n        uint256 _reportingFeeDivisor = _universe.getOrCacheReportingFeeDivisor();\n        _reportingFee = _payout.div(_reportingFeeDivisor);\n        _payout = _payout.sub(_creatorFee).sub(_reportingFee);\n\n        if (_creatorFee != 0) {\n            _market.recordMarketCreatorFees(_creatorFee, _sourceAccount, _fingerprint);\n        }\n\n        _universe.withdraw(address(this), _payout.add(_reportingFee), address(_market));\n\n        if (_reportingFee != 0) {\n            require(cash.transfer(address(_universe.getOrCreateNextDisputeWindow(false)), _reportingFee));\n        }\n\n        augur.logMarketOIChanged(_universe, _market);\n    }\n\n    /**\n     * @notice Claims winnings for a market and for a particular shareholder\n     * @param _market The market to claim winnings for\n     * @param _shareHolder The account to claim winnings for\n     * @param _fingerprint Fingerprint of the filler used to naively restrict affiliate fee dispursement\n     * @return Bool True\n     */\n    function claimTradingProceeds(IMarket _market, address _shareHolder, bytes32 _fingerprint) external nonReentrant returns (uint256[] memory _outcomeFees) {\n        return claimTradingProceedsInternal(_market, _shareHolder, _fingerprint);\n    }\n\n    function claimTradingProceedsInternal(IMarket _market, address _shareHolder, bytes32 _fingerprint) internal returns (uint256[] memory _outcomeFees) {\n        require(augur.isKnownMarket(_market));\n        if (!_market.isFinalized()) {\n            _market.finalize();\n        }\n        _outcomeFees = new uint256[](8);\n        for (uint256 _outcome = 0; _outcome < _market.getNumberOfOutcomes(); ++_outcome) {\n            uint256 _numberOfShares = balanceOfMarketOutcome(_market, _outcome, _shareHolder);\n\n            if (_numberOfShares > 0) {\n                uint256 _proceeds;\n                uint256 _shareHolderShare;\n                uint256 _creatorShare;\n                uint256 _reporterShare;\n                uint256 _tokenId = TokenId.getTokenId(_market, _outcome);\n                (_proceeds, _shareHolderShare, _creatorShare, _reporterShare) = divideUpWinnings(_market, _outcome, _numberOfShares);\n\n                // always destroy shares as it gives a minor gas refund and is good for the network\n                _burn(_shareHolder, _tokenId, _numberOfShares, bytes(\"\"), false);\n                logTradingProceedsClaimed(_market, _outcome, _shareHolder, _numberOfShares, _shareHolderShare, _creatorShare.add(_reporterShare));\n\n                if (_proceeds > 0) {\n                    _market.getUniverse().withdraw(address(this), _shareHolderShare.add(_reporterShare), address(_market));\n                    distributeProceeds(_market, _shareHolder, _shareHolderShare, _creatorShare, _reporterShare, _fingerprint);\n                }\n                _outcomeFees[_outcome] = _creatorShare.add(_reporterShare);\n            }\n        }\n\n        assertBalances(_market);\n        return _outcomeFees;\n    }\n\n    function distributeProceeds(IMarket _market, address _shareHolder, uint256 _shareHolderShare, uint256 _creatorShare, uint256 _reporterShare, bytes32 _fingerprint) private {\n        if (_shareHolderShare > 0) {\n            require(cash.transfer(_shareHolder, _shareHolderShare));\n        }\n        if (_creatorShare > 0) {\n            _market.recordMarketCreatorFees(_creatorShare, _shareHolder, _fingerprint);\n        }\n        if (_reporterShare > 0) {\n            require(cash.transfer(address(_market.getUniverse().getOrCreateNextDisputeWindow(false)), _reporterShare));\n        }\n    }\n\n    function logTradingProceedsClaimed(IMarket _market, uint256 _outcome, address _sender, uint256 _numShares, uint256 _numPayoutTokens, uint256 _fees) private {\n        augur.logTradingProceedsClaimed(_market.getUniverse(), _sender, address(_market), _outcome, _numShares, _numPayoutTokens, _fees);\n    }\n\n    function divideUpWinnings(IMarket _market, uint256 _outcome, uint256 _numberOfShares) public returns (uint256 _proceeds, uint256 _shareHolderShare, uint256 _creatorShare, uint256 _reporterShare) {\n        _proceeds = calculateProceeds(_market, _outcome, _numberOfShares);\n        _creatorShare = calculateCreatorFee(_market, _proceeds);\n        _reporterShare = calculateReportingFee(_market, _proceeds);\n        _shareHolderShare = _proceeds.sub(_creatorShare).sub(_reporterShare);\n        return (_proceeds, _shareHolderShare, _creatorShare, _reporterShare);\n    }\n\n    function calculateProceeds(IMarket _market, uint256 _outcome, uint256 _numberOfShares) public view returns (uint256) {\n        uint256 _payoutNumerator = _market.getWinningPayoutNumerator(_outcome);\n        return _numberOfShares.mul(_payoutNumerator);\n    }\n\n    function calculateReportingFee(IMarket _market, uint256 _amount) public returns (uint256) {\n        uint256 _reportingFeeDivisor = _market.getUniverse().getOrCacheReportingFeeDivisor();\n        return _amount.div(_reportingFeeDivisor);\n    }\n\n    function calculateCreatorFee(IMarket _market, uint256 _amount) public view returns (uint256) {\n        return _market.deriveMarketCreatorFeeAmount(_amount);\n    }\n\n    function getTypeName() public view returns(bytes32) {\n        return \"ShareToken\";\n    }\n\n    /**\n     * @return The market associated with this Share Token ID\n     */\n    function getMarket(uint256 _tokenId) external view returns(IMarket) {\n        (address _market, uint256 _outcome) = TokenId.unpackTokenId(_tokenId);\n        return IMarket(_market);\n    }\n\n    /**\n     * @return The outcome associated with this Share Token ID\n     */\n    function getOutcome(uint256 _tokenId) external view returns(uint256) {\n        (address _market, uint256 _outcome) = TokenId.unpackTokenId(_tokenId);\n        return _outcome;\n    }\n\n    function totalSupplyForMarketOutcome(IMarket _market, uint256 _outcome) public view returns (uint256) {\n        uint256 _tokenId = TokenId.getTokenId(_market, _outcome);\n        return totalSupply(_tokenId);\n    }\n\n    function balanceOfMarketOutcome(IMarket _market, uint256 _outcome, address _account) public view returns (uint256) {\n        uint256 _tokenId = TokenId.getTokenId(_market, _outcome);\n        return balanceOf(_account, _tokenId);\n    }\n\n    function lowestBalanceOfMarketOutcomes(IMarket _market, uint256[] memory _outcomes, address _account) public view returns (uint256) {\n        uint256 _lowest = SafeMathUint256.getUint256Max();\n        for (uint256 _i = 0; _i < _outcomes.length; ++_i) {\n            uint256 _tokenId = TokenId.getTokenId(_market, _outcomes[_i]);\n            _lowest = balanceOf(_account, _tokenId).min(_lowest);\n        }\n        return _lowest;\n    }\n\n    function assertBalances(IMarket _market) public view {\n        uint256 _expectedBalance = 0;\n        uint256 _numTicks = _market.getNumTicks();\n        uint256 _numOutcomes = _market.getNumberOfOutcomes();\n        // Market Open Interest. If we're finalized we need actually calculate the value\n        if (_market.isFinalized()) {\n            for (uint8 i = 0; i < _numOutcomes; i++) {\n                _expectedBalance = _expectedBalance.add(totalSupplyForMarketOutcome(_market, i).mul(_market.getWinningPayoutNumerator(i)));\n            }\n        } else {\n            _expectedBalance = totalSupplyForMarketOutcome(_market, 0).mul(_numTicks);\n        }\n\n        assert(_market.getUniverse().marketBalance(address(_market)) >= _expectedBalance);\n    }\n\n    function getTokenId(IMarket _market, uint256 _outcome) public pure returns (uint256 _tokenId) {\n        return TokenId.getTokenId(_market, _outcome);\n    }\n\n    function getTokenIds(IMarket _market, uint256[] memory _outcomes) public pure returns (uint256[] memory _tokenIds) {\n        return TokenId.getTokenIds(_market, _outcomes);\n    }\n\n    function unpackTokenId(uint256 _tokenId) public pure returns (address _market, uint256 _outcome) {\n        return TokenId.unpackTokenId(_tokenId);\n    }\n\n    function onTokenTransfer(uint256 _tokenId, address _from, address _to, uint256 _value) internal {\n        (address _marketAddress, uint256 _outcome) = TokenId.unpackTokenId(_tokenId);\n        augur.logShareTokensBalanceChanged(_from, IMarket(_marketAddress), _outcome, balanceOf(_from, _tokenId));\n        augur.logShareTokensBalanceChanged(_to, IMarket(_marketAddress), _outcome, balanceOf(_to, _tokenId));\n    }\n\n    function onMint(uint256 _tokenId, address _target, uint256 _amount) internal {\n        (address _marketAddress, uint256 _outcome) = TokenId.unpackTokenId(_tokenId);\n        augur.logShareTokensBalanceChanged(_target, IMarket(_marketAddress), _outcome, balanceOf(_target, _tokenId));\n    }\n\n    function onBurn(uint256 _tokenId, address _target, uint256 _amount) internal {\n        (address _marketAddress, uint256 _outcome) = TokenId.unpackTokenId(_tokenId);\n        augur.logShareTokensBalanceChanged(_target, IMarket(_marketAddress), _outcome, balanceOf(_target, _tokenId));\n    }\n}\n\n"
    }
  }
}}